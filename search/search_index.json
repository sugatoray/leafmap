{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to leafmap","text":"<p>A Python package for geospatial analysis and interactive mapping in a Jupyter environment.</p> <ul> <li>GitHub repo: https://github.com/opengeos/leafmap</li> <li>Documentation: https://leafmap.org</li> <li>PyPI: https://pypi.org/project/leafmap</li> <li>Conda-forge: https://anaconda.org/conda-forge/leafmap</li> <li>Leafmap tutorials on YouTube: https://youtube.com/@giswqs</li> <li>Free software: MIT license</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>Leafmap is a Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment. It is a spin-off project of the geemap Python package, which was designed specifically to work with Google Earth Engine (GEE). However, not everyone in the geospatial community has access to the GEE cloud computing platform. Leafmap is designed to fill this gap for non-GEE users. It is a free and open-source Python package that enables users to analyze and visualize geospatial data with minimal coding in a Jupyter environment, such as Google Colab, Jupyter Notebook, and JupyterLab. Leafmap is built upon several open-source packages, such as folium and ipyleaflet (for creating interactive maps), WhiteboxTools and whiteboxgui (for analyzing geospatial data), and ipywidgets (for designing interactive graphical user interfaces [GUIs]). Leafmap has a toolset with various interactive tools that allow users to load vector and raster data onto the map without coding. In addition, users can use the powerful analytical backend (i.e., WhiteboxTools) to perform geospatial analysis directly within the leafmap user interface without writing a single line of code. The WhiteboxTools library currently contains 500+ tools for advanced geospatial analysis, such as GIS Analysis, Geomorphometric Analysis, Hydrological Analysis, LiDAR Data Analysis, Mathematical and Statistical Analysis, and Stream Network Analysis.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project is supported by Amazon Web Services (AWS).</p>"},{"location":"#statement-of-need","title":"Statement of Need","text":"<p>There is a plethora of Python packages for geospatial analysis, such as geopandas for vector data analysis and xarray for raster data analysis. As listed at pyviz.org, there are also many options for plotting data on a map in Python, ranging from libraries focused specifically on maps like ipyleaflet and folium to general-purpose plotting tools that also support geospatial data types, such as hvPlot, bokeh, and plotly. While these tools provide powerful capabilities, displaying geospatial data from different file formats on an interactive map and performing basic analyses can be challenging, especially for users with limited coding skills. Furthermore, many tools lack bi-directional communication between the frontend (browser) and the backend (Python), limiting their interactivity and usability for exploring map data.</p> <p>Leafmap addresses these challenges by leveraging the bidirectional communication provided by ipyleaflet, enabling users to load and visualize geospatial datasets with just one line of code. Leafmap also provides an interactive graphical user interface (GUI) for loading geospatial datasets without any coding. It is designed for anyone who wants to analyze and visualize geospatial data interactively in a Jupyter environment, making it particularly accessible for novice users with limited programming skills. Advanced programmers can also benefit from leafmap for geospatial data analysis and building interactive web applications.</p>"},{"location":"#usage","title":"Usage","text":"<p>Launch the interactive notebook tutorial for the leafmap Python package with Amazon SageMaker Studio Lab, Microsoft Planetary Computer, Google Colab, or Binder:</p> <p> </p> <p>Check out this excellent article on Medium - Leafmap a new Python Package for Geospatial data science</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Leafmap offers a wide range of features and capabilities that empower geospatial data scientists, researchers, and developers to unlock the potential of their data. Some of the key features include:</p> <ul> <li> <p>Creating an interactive map with just one line of code: Leafmap makes it easy to create an interactive map by providing a simple API that allows you to load and visualize geospatial datasets with minimal coding.</p> </li> <li> <p>Switching between different mapping backends: Leafmap supports multiple mapping backends, including ipyleaflet, folium, kepler.gl, pydeck, and bokeh. You can switch between these backends to create maps with different visualization styles and capabilities.</p> </li> <li> <p>Changing basemaps interactively: Leafmap allows you to change basemaps interactively, providing a variety of options such as OpenStreetMap, Stamen Terrain, CartoDB Positron, and many more.</p> </li> <li> <p>Adding XYZ, WMS, and vector tile services: You can easily add XYZ, WMS, and vector tile services to your map, allowing you to overlay additional geospatial data from various sources.</p> </li> <li> <p>Displaying vector data: Leafmap supports various vector data formats, including Shapefile, GeoJSON, GeoPackage, and any vector format supported by GeoPandas. You can load and display vector data on the map, enabling you to visualize and analyze spatial features.</p> </li> <li> <p>Displaying raster data: Leafmap allows you to load and display raster data, such as GeoTIFFs, on the map. This feature is useful for visualizing satellite imagery, digital elevation models, and other gridded datasets.</p> </li> <li> <p>Creating custom legends and colorbars: Leafmap provides tools for customizing legends and colorbars on the map, allowing you to represent data values with different colors and corresponding labels.</p> </li> <li> <p>Creating split-panel maps and linked maps: With Leafmap, you can create split-panel maps to compare different datasets side by side. You can also create linked maps that synchronize interactions between multiple maps, providing a coordinated view of different spatial data.</p> </li> <li> <p>Downloading and visualizing OpenStreetMap data: Leafmap allows you to download and visualize OpenStreetMap data, providing access to detailed street maps, buildings, and other points of interest.</p> </li> <li> <p>Creating and editing vector data interactively: Leafmap includes tools for creating and editing vector data interactively on the map. You can draw points, lines, and polygons, and modify them as needed.</p> </li> <li> <p>Searching for geospatial data: Leafmap provides functionality for searching and accessing geospatial data from sources such as SpatialTemporal Asset Catalogs (STAC), Microsoft Planetary Computer, AWS Open Data Registry, and OpenAerialMap.</p> </li> <li> <p>Inspecting pixel values interactively: Leafmap allows you to interactively inspect pixel values in raster datasets, helping you analyze and understand the data at a more granular level.</p> </li> <li> <p>Creating choropleth maps and heat maps: Leafmap supports the creation of choropleth maps, where colors represent different data values for specific geographic areas. You can also create heat maps to visualize data density.</p> </li> <li> <p>Displaying data from a PostGIS database: Leafmap provides tools for connecting to a PostGIS database and displaying spatial data stored in the database on the map.</p> </li> <li> <p>Creating time series animations: Leafmap enables the creation of time series animations from both vector and raster data, allowing you to visualize temporal changes in your geospatial datasets.</p> </li> <li> <p>Analyzing geospatial data with whitebox: Leafmap integrates with WhiteboxTools and whiteboxgui, providing a suite of geospatial analyses, such as hydrological analysis, terrain analysis, and LiDAR processing.</p> </li> <li> <p>Segmenting and classifying remote sensing imagery: Leafmap integrates the segment-geospatial package, which provides tools for segmenting and classifying remote sensing imagery using deep learning algorithms.</p> </li> <li> <p>Building interactive web apps: Leafmap supports the development of interactive web applications using frameworks like Voila, Streamlit, and Solara. This allows you to share your geospatial analyses and visualizations with others in a user-friendly web interface.</p> </li> </ul> <p>These features and capabilities make leafmap a powerful tool for geospatial data exploration, analysis, and visualization. Whether you are a beginner or an experienced geospatial data scientist, leafmap provides an accessible and efficient way to work with geospatial data in Python.</p>"},{"location":"#citations","title":"Citations","text":"<p>If you find leafmap useful in your research, please consider citing the following paper to support my work. Thank you for your support.</p> <ul> <li>Wu, Q. (2021). Leafmap: A Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment. Journal of Open Source Software, 6(63), 3414. https://doi.org/10.21105/joss.03414</li> </ul>"},{"location":"#demo","title":"Demo","text":""},{"location":"#youtube-channel","title":"YouTube Channel","text":"<p>I have created a YouTube Channel for sharing geospatial tutorials. You can subscribe to my channel for regular updates. If there is any specific tutorial you would like to see, please submit a feature request here.</p> <p></p>"},{"location":"basemaps/","title":"basemaps module","text":"<p>Module for basemaps.</p> <p>Each basemap is defined as an item in the <code>basemaps</code> dictionary.</p> <p>For example, to access Google basemaps, users first need to get a Google Maps API key from https://bit.ly/3sw0THG.     Then, set the environment variable using geemap.set_api_key(). Then Google basemaps can be accessed using: <pre><code>* `basemaps['ROADMAP']`\n* `basemaps['SATELLITE']`\n* `basemaps['TERRAIN']`\n* `basemaps['HYBRID']`\n</code></pre> <p>More WMS basemaps can be found at the following websites:</p> <ol> <li>USGS National Map: https://viewer.nationalmap.gov/services/</li> <li>MRLC NLCD Land Cover data: https://viewer.nationalmap.gov/services/</li> <li>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</li> </ol>"},{"location":"basemaps/#leafmap.basemaps.get_xyz_dict","title":"<code>get_xyz_dict(free_only=True, france=False)</code>","text":"<p>Returns a dictionary of xyz services.</p> <p>Parameters:</p> Name Type Description Default <code>free_only</code> <code>bool</code> <p>Whether to return only free xyz tile services that do not require an access token. Defaults to True.</p> <code>True</code> <code>france</code> <code>bool</code> <p>Whether to include Geoportail France basemaps. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of xyz services.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def get_xyz_dict(free_only=True, france=False):\n    \"\"\"Returns a dictionary of xyz services.\n\n    Args:\n        free_only (bool, optional): Whether to return only free xyz tile\n            services that do not require an access token. Defaults to True.\n        france (bool, optional): Whether to include Geoportail France basemaps.\n            Defaults to False.\n\n    Returns:\n        dict: A dictionary of xyz services.\n    \"\"\"\n    xyz_bunch = xyzservices.providers\n\n    if free_only:\n        xyz_bunch = xyz_bunch.filter(requires_token=False)\n    if not france:\n        xyz_bunch = xyz_bunch.filter(\n            function=lambda tile: \"france\" not in dict(tile)[\"name\"].lower()\n        )\n\n    xyz_dict = xyz_bunch.flatten()\n\n    for key, value in xyz_dict.items():\n        tile = xyzservices.TileProvider(value)\n        if \"type\" not in tile:\n            tile[\"type\"] = \"xyz\"\n        xyz_dict[key] = tile\n\n    xyz_dict = collections.OrderedDict(sorted(xyz_dict.items()))\n    return xyz_dict\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.qms_to_geemap","title":"<code>qms_to_geemap(service_id)</code>","text":"<p>Convert a qms service to an ipyleaflet tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>service_id</code> <code>str</code> <p>Service ID.</p> required <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer</code> <p>An ipyleaflet tile layer.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def qms_to_geemap(service_id):\n    \"\"\"Convert a qms service to an ipyleaflet tile layer.\n\n    Args:\n        service_id (str): Service ID.\n\n    Returns:\n        ipyleaflet.TileLayer: An ipyleaflet tile layer.\n    \"\"\"\n    service_details = get_qms(service_id)\n    name = service_details[\"name\"]\n    url = service_details[\"url\"]\n    attribution = service_details[\"copyright_text\"]\n\n    layer = ipyleaflet.TileLayer(url=url, name=name, attribution=attribution)\n    return layer\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.search_qms","title":"<code>search_qms(keywords, limit=10)</code>","text":"<p>Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str</code> <p>Keywords to search for.</p> required <code>limit</code> <code>int</code> <p>Number of results to return.</p> <code>10</code> Source code in <code>leafmap/basemaps.py</code> <pre><code>def search_qms(keywords, limit=10):\n    \"\"\"Search qms files for keywords. Reference: https://github.com/geopandas/xyzservices/issues/65\n\n    Args:\n        keywords (str): Keywords to search for.\n        limit (int): Number of results to return.\n    \"\"\"\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n\n    services = requests.get(\n        f\"{QMS_API}/?search={keywords}&amp;type=tms&amp;epsg=3857&amp;limit={str(limit)}\"\n    )\n    services = services.json()\n    if services[\"count\"] == 0:\n        return None\n    elif services[\"count\"] &lt;= limit:\n        return services[\"results\"]\n    else:\n        return services[\"results\"][:limit]\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.xyz_to_bokeh","title":"<code>xyz_to_bokeh()</code>","text":"<p>Convert xyz tile services to bokeh tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of bokeh tile layers.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def xyz_to_bokeh():\n    \"\"\"Convert xyz tile services to bokeh tile layers.\n\n    Returns:\n        dict: A dictionary of bokeh tile layers.\n    \"\"\"\n    from bokeh.models import WMTSTileSource\n\n    bokeh_dict = {}\n\n    for key in XYZ_TILES:\n        url = XYZ_TILES[key][\"url\"]\n        attribution = XYZ_TILES[key][\"attribution\"]\n        tile_options = {\n            \"url\": url,\n            \"attribution\": attribution,\n        }\n        bokeh_dict[key] = WMTSTileSource(**tile_options)\n\n    xyz_dict = get_xyz_dict()\n    for item in xyz_dict:\n        url = xyz_dict[item].build_url()\n        attribution = xyz_dict[item].attribution\n        key = xyz_dict[item].name\n        tile_options = {\n            \"url\": url,\n            \"attribution\": attribution,\n        }\n        bokeh_dict[key] = WMTSTileSource(**tile_options)\n\n    return bokeh_dict\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.xyz_to_folium","title":"<code>xyz_to_folium()</code>","text":"<p>Convert xyz tile services to folium tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of folium tile layers.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def xyz_to_folium():\n    \"\"\"Convert xyz tile services to folium tile layers.\n\n    Returns:\n        dict: A dictionary of folium tile layers.\n    \"\"\"\n    folium_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        folium_dict[key] = folium.TileLayer(\n            tiles=tile[\"url\"],\n            attr=tile[\"attribution\"],\n            name=tile[\"name\"],\n            overlay=True,\n            control=True,\n            max_zoom=22,\n        )\n\n    for key, tile in custom_tiles[\"wms\"].items():\n        folium_dict[key] = folium.WmsTileLayer(\n            url=tile[\"url\"],\n            layers=tile[\"layers\"],\n            name=tile[\"name\"],\n            attr=tile[\"attribution\"],\n            fmt=tile[\"format\"],\n            transparent=tile[\"transparent\"],\n            overlay=True,\n            control=True,\n        )\n\n    for item in get_xyz_dict().values():\n        if item[\"name\"] in ignore_list:\n            continue\n        folium_dict[item.name] = folium.TileLayer(\n            tiles=item.build_url(),\n            attr=item.attribution,\n            name=item.name,\n            max_zoom=item.get(\"max_zoom\", 22),\n            overlay=True,\n            control=True,\n        )\n\n    if os.environ.get(\"PLANET_API_KEY\") is not None:\n        planet_dict = planet_tiles(tile_format=\"folium\")\n        folium_dict.update(planet_dict)\n\n    return folium_dict\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.xyz_to_leaflet","title":"<code>xyz_to_leaflet()</code>","text":"<p>Convert xyz tile services to ipyleaflet tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet tile layers.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def xyz_to_leaflet():\n    \"\"\"Convert xyz tile services to ipyleaflet tile layers.\n\n    Returns:\n        dict: A dictionary of ipyleaflet tile layers.\n    \"\"\"\n    leaflet_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    # Add custom tiles.\n    for tile_type, tile_dict in custom_tiles.items():\n        for tile_provider, tile_info in tile_dict.items():\n            tile_info[\"type\"] = tile_type\n            leaflet_dict[tile_info[\"name\"]] = tile_info\n\n    # Add xyzservices.provider tiles.\n    for tile_provider, tile_info in get_xyz_dict().items():\n        if tile_info[\"name\"] in ignore_list:\n            continue\n        tile_info[\"url\"] = tile_info.build_url()\n        leaflet_dict[tile_info[\"name\"]] = tile_info\n\n    return leaflet_dict\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.xyz_to_plotly","title":"<code>xyz_to_plotly()</code>","text":"<p>Convert xyz tile services to plotly tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of plotly tile layers.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def xyz_to_plotly():\n    \"\"\"Convert xyz tile services to plotly tile layers.\n\n    Returns:\n        dict: A dictionary of plotly tile layers.\n    \"\"\"\n    plotly_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        plotly_dict[key] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": tile[\"attribution\"],\n            \"source\": [tile[\"url\"]],\n            \"name\": key,\n        }\n\n    for item in get_xyz_dict().values():\n        if item[\"name\"] in ignore_list:\n            continue\n        plotly_dict[item.name] = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": item.attribution,\n            \"source\": [item.build_url()],\n            \"name\": item.name,\n        }\n\n    return plotly_dict\n</code></pre>"},{"location":"basemaps/#leafmap.basemaps.xyz_to_pydeck","title":"<code>xyz_to_pydeck()</code>","text":"<p>Convert xyz tile services to pydeck custom tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of pydeck tile layers.</p> Source code in <code>leafmap/basemaps.py</code> <pre><code>def xyz_to_pydeck():\n    \"\"\"Convert xyz tile services to pydeck custom tile layers.\n\n    Returns:\n        dict: A dictionary of pydeck tile layers.\n    \"\"\"\n\n    check_package(\"pydeck\", \"https://deckgl.readthedocs.io/en/latest/installation.html\")\n    import pydeck as pdk\n\n    pydeck_dict = {}\n    # Ignore Esri basemaps if they are already in the custom XYZ_TILES.\n    ignore_list = [XYZ_TILES[tile][\"name\"] for tile in XYZ_TILES]\n\n    for key, tile in custom_tiles[\"xyz\"].items():\n        url = tile[\"url\"]\n        pydeck_dict[key] = url\n\n    for key, item in get_xyz_dict().items():\n        if item[\"name\"] in ignore_list:\n            continue\n        url = item.build_url()\n        pydeck_dict[key] = url\n\n        if os.environ.get(\"PLANET_API_KEY\") is not None:\n            planet_dict = planet_tiles(tile_format=\"ipyleaflet\")\n            for id_, tile in planet_dict.items():\n                pydeck_dict[id_] = tile.url\n\n    pdk.settings.custom_libraries = [\n        {\n            \"libraryName\": \"MyTileLayerLibrary\",\n            \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n        }\n    ]\n\n    for key in pydeck_dict:\n        pydeck_dict[key] = pdk.Layer(\"MyTileLayer\", pydeck_dict[key], key)\n\n    return pydeck_dict\n</code></pre>"},{"location":"bokehmap/","title":"bokehmap module","text":""},{"location":"bokehmap/#leafmap.bokehmap.Map","title":"<code> Map        </code>","text":"Source code in <code>leafmap/bokehmap.py</code> <pre><code>class Map:\n    def __init__(\n        self,\n        center: List[float] = [10, 0],\n        zoom: float = 2,\n        width: float = 800,\n        height: float = 400,\n        basemap: Optional[str] = \"OpenStreetMap\",\n        grid_visible: bool = False,\n        output_notebook: bool = True,\n        **kwargs,\n    ):\n        if \"x_axis_type\" not in kwargs:\n            kwargs[\"x_axis_type\"] = \"mercator\"\n        if \"y_axis_type\" not in kwargs:\n            kwargs[\"y_axis_type\"] = \"mercator\"\n        if \"sizing_mode\" not in kwargs:\n            kwargs[\"sizing_mode\"] = \"scale_both\"\n        if \"width\" not in kwargs:\n            kwargs[\"width\"] = width\n        if \"height\" not in kwargs:\n            kwargs[\"height\"] = height\n\n        if \"x_range\" not in kwargs:\n            kwargs[\"x_range\"] = center_zoom_to_xy_range(center, zoom)[0]\n        if \"y_range\" not in kwargs:\n            kwargs[\"y_range\"] = center_zoom_to_xy_range(center, zoom)[1]\n\n        fig = figure(**kwargs)\n        self.figure = fig\n\n        if basemap is not None:\n            if basemap == \"OpenStreetMap\":\n                try:\n                    fig.add_tile(xyz.OpenStreetMap.Mapnik, retina=True)\n                except:\n                    from bokeh.tile_providers import get_provider\n\n                    fig.add_tile(get_provider(xyz.OpenStreetMap.Mapnik))\n            else:\n                self.add_basemap(basemap)\n        fig.toolbar.active_scroll = fig.select_one(WheelZoomTool)\n\n        if not grid_visible:\n            fig.grid.visible = False\n\n        self.output_notebook = output_notebook\n        self.output_notebook_done = False\n\n    def _repr_mimebundle_(self, **kwargs):\n        \"\"\"Display the bokeh map. Reference: https://ipython.readthedocs.io/en/stable/config/integrating.html#MyObject._repr_mimebundle_\"\"\"\n        if self.output_notebook and (os.environ[\"OUTPUT_NOTEBOOK\"] == \"False\"):\n            output_notebook()\n            os.environ[\"OUTPUT_NOTEBOOK\"] = \"True\"\n        show(self.figure)\n\n    def add_basemap(\n        self,\n        basemap: Optional[str] = \"OpenStreetMap\",\n        retina: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from basemaps. Defaults to 'OpenStreetMap'.\n            retina (bool, optional): Whether to use retina tiles. Defaults to True.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n        \"\"\"\n        import xyzservices\n\n        if isinstance(basemap, xyzservices.TileProvider):\n            url = basemap.build_url()\n            attribution = basemap.attribution\n            if \"max_zoom\" in basemap.keys():\n                max_zoom = basemap[\"max_zoom\"]\n            else:\n                max_zoom = 30\n            tile_options = {\n                \"url\": url,\n                \"attribution\": attribution,\n                \"max_zoom\": max_zoom,\n            }\n            tile_source = WMTSTileSource(**tile_options)\n            self.add_tile(tile_source, retina=retina, **kwargs)\n        elif isinstance(basemap, WMTSTileSource):\n            self.add_tile(basemap, retina=retina, **kwargs)\n        elif isinstance(basemap, str):\n            if basemap in basemaps.keys():\n                self.add_tile(basemaps[basemap], retina=retina, **kwargs)\n            else:\n                try:\n                    self.add_tile(basemap, retina=retina, **kwargs)\n                except Exception as e:\n                    print(e)\n                    raise ValueError(\n                        f\"Basemap {basemap} is not supported. Please choose one from {basemaps.keys()}\"\n                    )\n        elif basemap is None:\n            raise ValueError(\"Please specify a valid basemap\")\n\n    def add_tile(self, tile: str, **kwargs):\n        \"\"\"Adds a tile to the map.\n\n        Args:\n            tile (bokeh.models.tiles.WMTSTileSource): A bokeh tile.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n        \"\"\"\n        try:\n            self.figure.add_tile(tile, **kwargs)\n        except Exception as e:\n            if \"retina\" in kwargs.keys():\n                kwargs.pop(\"retina\")\n            self.figure.add_tile(tile, **kwargs)\n\n    def add_cog_layer(\n        self,\n        url: str,\n        attribution: str = \"\",\n        bands: Optional[List[str]] = None,\n        titiler_endpoint: Optional[str] = None,\n        cog_args: Dict = {},\n        fit_bounds: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            bands (list, optional): A list of bands to use for the layer. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n            cog_args: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n                color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n                apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **cog_args)\n        tile_options = {\n            \"url\": tile_url,\n            \"attribution\": attribution,\n        }\n        tile_source = WMTSTileSource(**tile_options)\n        self.figure.add_tile(tile_source, **kwargs)\n\n        if fit_bounds:\n            self.fit_bounds(cog_bounds(url, titiler_endpoint))\n\n    def add_raster(\n        self,\n        source: str,\n        indexes: Optional[List] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        attribution: Optional[str] = \"\",\n        fit_bounds: bool = True,\n        layer_name=\"Local COG\",\n        open_args={},\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n            if the raster does not render properly, try running the following code before calling this function:\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Local COG'.\n            fit_bounds (bool, optional): Whether to fit the map bounds to the raster bounds. Defaults to True.\n            open_args: Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n        \"\"\"\n\n        if source.startswith(\"http\"):\n            source = download_file(source)\n\n        tile_layer, client = get_local_tile_layer(\n            source,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            return_client=True,\n            **open_args,\n        )\n\n        tile_options = {\n            \"url\": tile_layer.url,\n            \"attribution\": attribution,\n        }\n        tile_source = WMTSTileSource(**tile_options)\n        self.figure.add_tile(tile_source, **kwargs)\n\n        if fit_bounds:\n            bounds = client.bounds()\n            bounds = [bounds[2], bounds[0], bounds[3], bounds[1]]\n            self.fit_bounds(bounds)\n\n    def add_stac_layer(\n        self,\n        url: str,\n        collection: Optional[str] = None,\n        item: Optional[str] = None,\n        assets: Optional[str] = None,\n        bands: Optional[List[str]] = None,\n        titiler_endpoint: Optional[str] = None,\n        attribution: Optional[str] = \"\",\n        fit_bounds: Optional[bool] = True,\n        open_args={},\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str | Optional): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): TiTiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            fit_bounds (bool, optional): Whether to fit the map bounds to the raster bounds. Defaults to True.\n            open_args: Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **open_args\n        )\n        tile_options = {\n            \"url\": tile_url,\n            \"attribution\": attribution,\n        }\n        tile_source = WMTSTileSource(**tile_options)\n        self.figure.add_tile(tile_source, **kwargs)\n\n        if fit_bounds:\n            self.fit_bounds(stac_bounds(url, collection, item, titiler_endpoint))\n\n    def add_gdf(\n        self, gdf, to_crs=\"epsg:3857\", tooltips=None, fit_bounds=True, **kwargs\n    ):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): The GeoDataFrame to add to the map.\n            to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n            tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n                https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n        \"\"\"\n        import geopandas as gpd\n\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise TypeError(\"gdf must be a GeoDataFrame\")\n\n        geom_type = gdf_geom_type(gdf)\n        gdf_new = gdf.to_crs(to_crs)\n\n        columns = gdf_new.columns.to_list()\n        if \"geometry\" in columns:\n            columns.remove(\"geometry\")\n\n        if tooltips is None:\n            tooltips = [(col, f\"@{col}\") for col in columns]\n\n        source = GeoJSONDataSource(geojson=gdf_new.to_json())\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            self.figure.circle(x=\"x\", y=\"y\", source=source, **kwargs)\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            self.figure.multi_line(xs=\"xs\", ys=\"ys\", source=source, **kwargs)\n        elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n            if \"fill_alpha\" not in kwargs:\n                kwargs[\"fill_alpha\"] = 0.5\n            self.figure.patches(xs=\"xs\", ys=\"ys\", source=source, **kwargs)\n\n        if len(tooltips) &gt; 0:\n            hover = HoverTool(tooltips=tooltips)\n            self.figure.add_tools(hover)\n\n        if fit_bounds:\n            self.fit_bounds(gdf.total_bounds.tolist())\n\n    def add_geojson(\n        self,\n        filename: str,\n        encoding: Optional[str] = \"utf-8\",\n        read_file_args: Dict = {},\n        to_crs: Optional[str] = \"epsg:3857\",\n        tooltips: Optional[List] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            filename (str): The path to the GeoJSON file. Can be a local file or a URL.\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n            read_file_args (Dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n            to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n            tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n            fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the GeoJSON. Defaults to True.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n                https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n        \"\"\"\n        import geopandas as gpd\n\n        if filename.startswith(\"http\"):\n            filename = github_raw_url(filename)\n\n        gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n        self.add_gdf(\n            gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n        )\n\n    def add_shp(\n        self,\n        filename: str,\n        encoding: Optional[str] = \"utf-8\",\n        read_file_args: Dict = {},\n        to_crs: Optional[str] = \"epsg:3857\",\n        tooltips: Optional[List] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            filename (str): The path to the shapefile.\n            encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n            read_file_args (dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n            to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n            tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n            fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the shapefile. Defaults to True.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n                https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n        \"\"\"\n        import geopandas as gpd\n\n        import glob\n\n        if filename.startswith(\"http\"):\n            filename = github_raw_url(filename)\n\n        if filename.startswith(\"http\") and filename.endswith(\".zip\"):\n            out_dir = os.path.abspath(\"./cache/shp\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            basename = os.path.basename(filename)\n            output = os.path.join(out_dir, basename)\n            download_file(filename, output)\n            files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n            if len(files) &gt; 0:\n                filename = files[0]\n            else:\n                raise FileNotFoundError(\n                    \"The downloaded zip file does not contain any shapefile in the root directory.\"\n                )\n        else:\n            filename = os.path.abspath(filename)\n            if not os.path.exists(filename):\n                raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n        self.add_gdf(\n            gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n        )\n\n    def add_vector(\n        self,\n        filename: str,\n        encoding: Optional[str] = \"utf-8\",\n        read_file_args: Dict = {},\n        to_crs: Optional[str] = \"epsg:3857\",\n        tooltips: Optional[List] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a vector dataset to the map.\n\n        Args:\n            filename (str): The path to the vector dataset. Can be a local file or a URL.\n            encoding (str, optional): The encoding of the vector dataset. Defaults to \"utf-8\".\n            read_file_args (Dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n            to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n            tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n            fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the vector dataset. Defaults to True.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n                https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n        \"\"\"\n        import geopandas as gpd\n\n        if filename.startswith(\"http\"):\n            filename = github_raw_url(filename)\n\n        if isinstance(filename, gpd.GeoDataFrame):\n            gdf = filename\n        else:\n            gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n\n        self.add_gdf(\n            gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n        )\n\n    def to_html(\n        self, filename: Optional[str] = None, title: Optional[str] = None, **kwargs\n    ):\n        \"\"\"Converts the map to HTML.\n\n        Args:\n            filename (str, optional): The filename to save the HTML to. Defaults to None.\n            title (str, optional): The title to use for the HTML. Defaults to None.\n            **kwargs: Arbitrary keyword arguments for bokeh.figure.save().\n        \"\"\"\n        save(self.figure, filename=filename, title=title, **kwargs)\n\n    def fit_bounds(self, bounds: List[float]):\n        \"\"\"Fits the map to the specified bounds in the form of [xmin, ymin, xmax, ymax].\n\n        Args:\n            bounds (list): A list of bounds in the form of [xmin, ymin, xmax, ymax].\n        \"\"\"\n\n        bounds = bounds_to_xy_range(bounds)\n\n        self.figure.x_range.start = bounds[0][0]\n        self.figure.x_range.end = bounds[0][1]\n        self.figure.y_range.start = bounds[1][0]\n        self.figure.y_range.end = bounds[1][1]\n\n    def to_streamlit(\n        self,\n        width: Optional[int] = 800,\n        height: Optional[int] = 600,\n        use_container_width: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Displays the map in a Streamlit app.\n\n        Args:\n            width (int, optional): The width of the map. Defaults to 800.\n            height (int, optional): The height of the map. Defaults to 600.\n            use_container_width (bool, optional): A flag indicating whether to use the full width of the container. Defaults to True.\n            **kwargs: Arbitrary keyword arguments for bokeh.plotting.show().\n        \"\"\"\n        import streamlit as st\n\n        self.figure.width = width\n        self.figure.height = height\n\n        st.bokeh_chart(\n            self.figure,\n            use_container_width=use_container_width,\n            **kwargs,\n        )\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', retina=True, **kwargs)</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from basemaps. Defaults to 'OpenStreetMap'.</p> <code>'OpenStreetMap'</code> <code>retina</code> <code>bool</code> <p>Whether to use retina tiles. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: Optional[str] = \"OpenStreetMap\",\n    retina: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from basemaps. Defaults to 'OpenStreetMap'.\n        retina (bool, optional): Whether to use retina tiles. Defaults to True.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n    \"\"\"\n    import xyzservices\n\n    if isinstance(basemap, xyzservices.TileProvider):\n        url = basemap.build_url()\n        attribution = basemap.attribution\n        if \"max_zoom\" in basemap.keys():\n            max_zoom = basemap[\"max_zoom\"]\n        else:\n            max_zoom = 30\n        tile_options = {\n            \"url\": url,\n            \"attribution\": attribution,\n            \"max_zoom\": max_zoom,\n        }\n        tile_source = WMTSTileSource(**tile_options)\n        self.add_tile(tile_source, retina=retina, **kwargs)\n    elif isinstance(basemap, WMTSTileSource):\n        self.add_tile(basemap, retina=retina, **kwargs)\n    elif isinstance(basemap, str):\n        if basemap in basemaps.keys():\n            self.add_tile(basemaps[basemap], retina=retina, **kwargs)\n        else:\n            try:\n                self.add_tile(basemap, retina=retina, **kwargs)\n            except Exception as e:\n                print(e)\n                raise ValueError(\n                    f\"Basemap {basemap} is not supported. Please choose one from {basemaps.keys()}\"\n                )\n    elif basemap is None:\n        raise ValueError(\"Please specify a valid basemap\")\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, attribution='', bands=None, titiler_endpoint=None, cog_args={}, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>bands</code> <code>list</code> <p>A list of bands to use for the layer. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>cog_args</code> <code>Dict</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    attribution: str = \"\",\n    bands: Optional[List[str]] = None,\n    titiler_endpoint: Optional[str] = None,\n    cog_args: Dict = {},\n    fit_bounds: bool = True,\n    **kwargs,\n):\n    \"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        bands (list, optional): A list of bands to use for the layer. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        cog_args: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n            color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n            apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **cog_args)\n    tile_options = {\n        \"url\": tile_url,\n        \"attribution\": attribution,\n    }\n    tile_source = WMTSTileSource(**tile_options)\n    self.figure.add_tile(tile_source, **kwargs)\n\n    if fit_bounds:\n        self.fit_bounds(cog_bounds(url, titiler_endpoint))\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_gdf","title":"<code>add_gdf(self, gdf, to_crs='epsg:3857', tooltips=None, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to add to the map.</p> required <code>to_crs</code> <code>str</code> <p>The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".</p> <code>'epsg:3857'</code> <code>tooltips</code> <code>list</code> <p>A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_gdf(\n    self, gdf, to_crs=\"epsg:3857\", tooltips=None, fit_bounds=True, **kwargs\n):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): The GeoDataFrame to add to the map.\n        to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n        tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n            https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n    \"\"\"\n    import geopandas as gpd\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"gdf must be a GeoDataFrame\")\n\n    geom_type = gdf_geom_type(gdf)\n    gdf_new = gdf.to_crs(to_crs)\n\n    columns = gdf_new.columns.to_list()\n    if \"geometry\" in columns:\n        columns.remove(\"geometry\")\n\n    if tooltips is None:\n        tooltips = [(col, f\"@{col}\") for col in columns]\n\n    source = GeoJSONDataSource(geojson=gdf_new.to_json())\n\n    if geom_type in [\"Point\", \"MultiPoint\"]:\n        self.figure.circle(x=\"x\", y=\"y\", source=source, **kwargs)\n    elif geom_type in [\"LineString\", \"MultiLineString\"]:\n        self.figure.multi_line(xs=\"xs\", ys=\"ys\", source=source, **kwargs)\n    elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n        if \"fill_alpha\" not in kwargs:\n            kwargs[\"fill_alpha\"] = 0.5\n        self.figure.patches(xs=\"xs\", ys=\"ys\", source=source, **kwargs)\n\n    if len(tooltips) &gt; 0:\n        hover = HoverTool(tooltips=tooltips)\n        self.figure.add_tools(hover)\n\n    if fit_bounds:\n        self.fit_bounds(gdf.total_bounds.tolist())\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_geojson","title":"<code>add_geojson(self, filename, encoding='utf-8', read_file_args={}, to_crs='epsg:3857', tooltips=None, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoJSON file. Can be a local file or a URL.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>read_file_args</code> <code>Dict</code> <p>A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.</p> <code>{}</code> <code>to_crs</code> <code>str</code> <p>The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".</p> <code>'epsg:3857'</code> <code>tooltips</code> <code>list</code> <p>A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether to fit the map bounds to the GeoJSON. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_geojson(\n    self,\n    filename: str,\n    encoding: Optional[str] = \"utf-8\",\n    read_file_args: Dict = {},\n    to_crs: Optional[str] = \"epsg:3857\",\n    tooltips: Optional[List] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        filename (str): The path to the GeoJSON file. Can be a local file or a URL.\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        read_file_args (Dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n        to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n        tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n        fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the GeoJSON. Defaults to True.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n            https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n    \"\"\"\n    import geopandas as gpd\n\n    if filename.startswith(\"http\"):\n        filename = github_raw_url(filename)\n\n    gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n    self.add_gdf(\n        gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n    )\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution='', fit_bounds=True, layer_name='Local COG', open_args={}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try running the following code before calling this function:</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file. Defaults to None.</p> <code>''</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Local COG'.</p> <code>'Local COG'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit the map bounds to the raster bounds. Defaults to True.</p> <code>True</code> <code>open_args</code> <p>Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    indexes: Optional[List] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    attribution: Optional[str] = \"\",\n    fit_bounds: bool = True,\n    layer_name=\"Local COG\",\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try running the following code before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Local COG'.\n        fit_bounds (bool, optional): Whether to fit the map bounds to the raster bounds. Defaults to True.\n        open_args: Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n    \"\"\"\n\n    if source.startswith(\"http\"):\n        source = download_file(source)\n\n    tile_layer, client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        return_client=True,\n        **open_args,\n    )\n\n    tile_options = {\n        \"url\": tile_layer.url,\n        \"attribution\": attribution,\n    }\n    tile_source = WMTSTileSource(**tile_options)\n    self.figure.add_tile(tile_source, **kwargs)\n\n    if fit_bounds:\n        bounds = client.bounds()\n        bounds = [bounds[2], bounds[0], bounds[3], bounds[1]]\n        self.fit_bounds(bounds)\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_shp","title":"<code>add_shp(self, filename, encoding='utf-8', read_file_args={}, to_crs='epsg:3857', tooltips=None, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the shapefile.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the shapefile. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>read_file_args</code> <code>dict</code> <p>A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.</p> <code>{}</code> <code>to_crs</code> <code>str</code> <p>The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".</p> <code>'epsg:3857'</code> <code>tooltips</code> <code>list</code> <p>A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether to fit the map bounds to the shapefile. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_shp(\n    self,\n    filename: str,\n    encoding: Optional[str] = \"utf-8\",\n    read_file_args: Dict = {},\n    to_crs: Optional[str] = \"epsg:3857\",\n    tooltips: Optional[List] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        filename (str): The path to the shapefile.\n        encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n        read_file_args (dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n        to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n        tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n        fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the shapefile. Defaults to True.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n            https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n    \"\"\"\n    import geopandas as gpd\n\n    import glob\n\n    if filename.startswith(\"http\"):\n        filename = github_raw_url(filename)\n\n    if filename.startswith(\"http\") and filename.endswith(\".zip\"):\n        out_dir = os.path.abspath(\"./cache/shp\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        basename = os.path.basename(filename)\n        output = os.path.join(out_dir, basename)\n        download_file(filename, output)\n        files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n        if len(files) &gt; 0:\n            filename = files[0]\n        else:\n            raise FileNotFoundError(\n                \"The downloaded zip file does not contain any shapefile in the root directory.\"\n            )\n    else:\n        filename = os.path.abspath(filename)\n        if not os.path.exists(filename):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n    self.add_gdf(\n        gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n    )\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, attribution='', fit_bounds=True, open_args={}, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> required <code>collection</code> <code>str | Optional</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit the map bounds to the raster bounds. Defaults to True.</p> <code>True</code> <code>open_args</code> <p>Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: str,\n    collection: Optional[str] = None,\n    item: Optional[str] = None,\n    assets: Optional[str] = None,\n    bands: Optional[List[str]] = None,\n    titiler_endpoint: Optional[str] = None,\n    attribution: Optional[str] = \"\",\n    fit_bounds: Optional[bool] = True,\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str | Optional): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): TiTiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        fit_bounds (bool, optional): Whether to fit the map bounds to the raster bounds. Defaults to True.\n        open_args: Arbitrary keyword arguments for get_local_tile_layer(). Defaults to {}.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **open_args\n    )\n    tile_options = {\n        \"url\": tile_url,\n        \"attribution\": attribution,\n    }\n    tile_source = WMTSTileSource(**tile_options)\n    self.figure.add_tile(tile_source, **kwargs)\n\n    if fit_bounds:\n        self.fit_bounds(stac_bounds(url, collection, item, titiler_endpoint))\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_tile","title":"<code>add_tile(self, tile, **kwargs)</code>","text":"<p>Adds a tile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>bokeh.models.tiles.WMTSTileSource</code> <p>A bokeh tile.</p> required <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_tile(self, tile: str, **kwargs):\n    \"\"\"Adds a tile to the map.\n\n    Args:\n        tile (bokeh.models.tiles.WMTSTileSource): A bokeh tile.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.add_tile() function, such as alpha, visible, etc.\n    \"\"\"\n    try:\n        self.figure.add_tile(tile, **kwargs)\n    except Exception as e:\n        if \"retina\" in kwargs.keys():\n            kwargs.pop(\"retina\")\n        self.figure.add_tile(tile, **kwargs)\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.add_vector","title":"<code>add_vector(self, filename, encoding='utf-8', read_file_args={}, to_crs='epsg:3857', tooltips=None, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the vector dataset. Can be a local file or a URL.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the vector dataset. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>read_file_args</code> <code>Dict</code> <p>A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.</p> <code>{}</code> <code>to_crs</code> <code>str</code> <p>The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".</p> <code>'epsg:3857'</code> <code>tooltips</code> <code>list</code> <p>A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether to fit the map bounds to the vector dataset. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def add_vector(\n    self,\n    filename: str,\n    encoding: Optional[str] = \"utf-8\",\n    read_file_args: Dict = {},\n    to_crs: Optional[str] = \"epsg:3857\",\n    tooltips: Optional[List] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n):\n    \"\"\"Adds a vector dataset to the map.\n\n    Args:\n        filename (str): The path to the vector dataset. Can be a local file or a URL.\n        encoding (str, optional): The encoding of the vector dataset. Defaults to \"utf-8\".\n        read_file_args (Dict, optional): A dictionary of arguments to pass to geopandas.read_file. Defaults to {}.\n        to_crs (str, optional): The CRS to use for the GeoDataFrame. Defaults to \"epsg:3857\".\n        tooltips (list, optional): A list of column names to use for tooltips in the form of [(name, @column_name), ...]. Defaults to None, which uses all columns.\n        fit_bounds (bool, optional): A flag indicating whether to fit the map bounds to the vector dataset. Defaults to True.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.circle, multi_line, and patches. For more info, see\n            https://docs.bokeh.org/en/latest/docs/reference/plotting/figure.html#bokeh.plotting.figure\n    \"\"\"\n    import geopandas as gpd\n\n    if filename.startswith(\"http\"):\n        filename = github_raw_url(filename)\n\n    if isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        gdf = gpd.read_file(filename, encoding=encoding, **read_file_args)\n\n    self.add_gdf(\n        gdf, to_crs=to_crs, tooltips=tooltips, fit_bounds=fit_bounds, **kwargs\n    )\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.fit_bounds","title":"<code>fit_bounds(self, bounds)</code>","text":"<p>Fits the map to the specified bounds in the form of [xmin, ymin, xmax, ymax].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of bounds in the form of [xmin, ymin, xmax, ymax].</p> required Source code in <code>leafmap/bokehmap.py</code> <pre><code>def fit_bounds(self, bounds: List[float]):\n    \"\"\"Fits the map to the specified bounds in the form of [xmin, ymin, xmax, ymax].\n\n    Args:\n        bounds (list): A list of bounds in the form of [xmin, ymin, xmax, ymax].\n    \"\"\"\n\n    bounds = bounds_to_xy_range(bounds)\n\n    self.figure.x_range.start = bounds[0][0]\n    self.figure.x_range.end = bounds[0][1]\n    self.figure.y_range.start = bounds[1][0]\n    self.figure.y_range.end = bounds[1][1]\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.to_html","title":"<code>to_html(self, filename=None, title=None, **kwargs)</code>","text":"<p>Converts the map to HTML.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to save the HTML to. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title to use for the HTML. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.figure.save().</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def to_html(\n    self, filename: Optional[str] = None, title: Optional[str] = None, **kwargs\n):\n    \"\"\"Converts the map to HTML.\n\n    Args:\n        filename (str, optional): The filename to save the HTML to. Defaults to None.\n        title (str, optional): The title to use for the HTML. Defaults to None.\n        **kwargs: Arbitrary keyword arguments for bokeh.figure.save().\n    \"\"\"\n    save(self.figure, filename=filename, title=title, **kwargs)\n</code></pre>"},{"location":"bokehmap/#leafmap.bokehmap.Map.to_streamlit","title":"<code>to_streamlit(self, width=800, height=600, use_container_width=True, **kwargs)</code>","text":"<p>Displays the map in a Streamlit app.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>The height of the map. Defaults to 600.</p> <code>600</code> <code>use_container_width</code> <code>bool</code> <p>A flag indicating whether to use the full width of the container. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for bokeh.plotting.show().</p> <code>{}</code> Source code in <code>leafmap/bokehmap.py</code> <pre><code>def to_streamlit(\n    self,\n    width: Optional[int] = 800,\n    height: Optional[int] = 600,\n    use_container_width: bool = True,\n    **kwargs,\n):\n    \"\"\"Displays the map in a Streamlit app.\n\n    Args:\n        width (int, optional): The width of the map. Defaults to 800.\n        height (int, optional): The height of the map. Defaults to 600.\n        use_container_width (bool, optional): A flag indicating whether to use the full width of the container. Defaults to True.\n        **kwargs: Arbitrary keyword arguments for bokeh.plotting.show().\n    \"\"\"\n    import streamlit as st\n\n    self.figure.width = width\n    self.figure.height = height\n\n    st.bokeh_chart(\n        self.figure,\n        use_container_width=use_container_width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0342-jun-21-2024","title":"v0.34.2 - Jun 21, 2024","text":"<p>What's Changed</p> <ul> <li>Add 3d terrain style by @giswqs in #779</li> </ul> <p>Full Changelog: v0.34.1...v0.34.2</p>"},{"location":"changelog/#v0341-jun-21-2024","title":"v0.34.1 - Jun 21, 2024","text":"<p>What's Changed</p> <ul> <li>Add to_streamlit and more examples by @giswqs in #777</li> </ul> <p>Full Changelog: v0.34.0...v0.34.1</p>"},{"location":"changelog/#v0340-jun-20-2024","title":"v0.34.0 - Jun 20, 2024","text":"<p>What's Changed</p> <ul> <li>Update changelog by @giswqs in #772</li> <li>Add more MapLibre example by @giswqs in #773</li> <li>Add more MapLibre examples by @giswqs in #774</li> <li>Add more MapLibre examples by @giswqs in #775</li> <li>Change MapLibre center from lat_lon to lon_lat by @giswqs in #776</li> </ul> <p>Full Changelog: v0.33.6...v0.34.0</p>"},{"location":"changelog/#v0336-jun-18-2024","title":"v0.33.6 - Jun 18, 2024","text":"<p>What's Changed</p> <ul> <li>Add color picker for changing layer color interactively by @giswqs in #771</li> </ul> <p>Full Changelog: v0.33.5...v0.33.6</p>"},{"location":"changelog/#v0335-jun-18-2024","title":"v0.33.5 - Jun 18, 2024","text":"<p>What's Changed</p> <ul> <li>Add support for MapLibre PMTiles by @giswqs in #770</li> </ul> <p>Full Changelog: v0.33.4...v0.33.5</p>"},{"location":"changelog/#v0334-jun-18-2024","title":"v0.33.4 - Jun 18, 2024","text":"<p>What's Changed</p> <ul> <li>Add basemap widget by @giswqs in #769</li> </ul> <p>Full Changelog: v0.33.3...v0.33.4</p>"},{"location":"changelog/#v0333-jun-17-2024","title":"v0.33.3 - Jun 17, 2024","text":"<p>What's Changed</p> <ul> <li>Update notebook badges by @giswqs in #765</li> <li>Bump docker/metadata-action from 4 to 5 by @dependabot in #768</li> <li>Bump docker/build-push-action from 5 to 6 by @dependabot in #767</li> <li>Add maplibre layer interact by @giswqs in #766</li> </ul> <p>Full Changelog: v0.33.2...v0.33.3</p>"},{"location":"changelog/#v0332-jun-17-2024","title":"v0.33.2 - Jun 17, 2024","text":"<p>What's Changed</p> <ul> <li>Bump actions/dependency-review-action from 2 to 4 by @dependabot in #763</li> <li>Bump nwtgck/actions-netlify from 2.1 to 3.0 by @dependabot in #761</li> <li>Bump github/codeql-action from 2 to 3 by @dependabot in #759</li> <li>Bump docker/build-push-action from 4 to 5 by @dependabot in #760</li> <li>Bump docker/login-action from 2 to 3 by @dependabot in #762</li> <li>Improve the maplibre module by @giswqs in #764</li> </ul> <p>New Contributors</p> <ul> <li>@dependabot made their first contribution in #763</li> </ul> <p>Full Changelog: v0.33.1...v0.33.2</p>"},{"location":"changelog/#v0331-jun-13-2024","title":"v0.33.1 - Jun 13, 2024","text":"<p>What's Changed</p> <ul> <li>Fix pydeck basemap issue by @giswqs in #757</li> <li>Improve add_vector for the deck module by @giswqs in #758</li> </ul> <p>Full Changelog: v0.33.0...v0.33.1</p>"},{"location":"changelog/#v0330-jun-10-2024","title":"v0.33.0 - Jun 10, 2024","text":"<p>What's Changed</p> <ul> <li>Fix typos and update plt.get_cmap by @giswqs in #742</li> <li>Fix netcdf_to_tif bug by @giswqs in #743</li> <li>[pre-commit.ci] pre-commit autoupdate by @pre-commit-ci in #744</li> <li>Fix new typos discovered by codespell by @giswqs in #745</li> <li>Fix transform bug for array to image by @giswqs in #749</li> <li>Add GUI for raster data visualization by @giswqs in #750</li> </ul> <p>Full Changelog: v0.32.1...v0.33.0</p>"},{"location":"changelog/#v0321-may-12-2024","title":"v0.32.1 - May 12, 2024","text":"<p>What's Changed</p> <ul> <li>Fix AWS checking for localtileserver by @giswqs in #740</li> </ul> <p>Full Changelog: v0.32.0...v0.32.1</p>"},{"location":"changelog/#v0320-may-12-2024","title":"v0.32.0 - May 12, 2024","text":"<p>What's Changed</p> <ul> <li>Fix custom stac bug by @giswqs in #725</li> <li>Fix docs build error by @giswqs in #727</li> <li>[pre-commit.ci] pre-commit autoupdate by @pre-commit-ci in #731</li> <li>Add maplibregl module by @giswqs in #719</li> <li>Improve s3 functions by @giswqs in #734</li> <li>Fix docs date issue by @giswqs in #735</li> <li>Add tile name prefix option to split_raster by @giswqs in #736</li> <li>Fix checking studio lab bug by @giswqs in #739</li> </ul> <p>Full Changelog: v0.31.9...v0.32.0</p>"},{"location":"changelog/#v0319-apr-15-2024","title":"v0.31.9 - Apr 15, 2024","text":"<p>What's Changed</p> <ul> <li>ignore url parameters when checking if file ends with \".pmtiles\" by @james-willis in #722</li> <li>[pre-commit.ci] pre-commit autoupdate by @pre-commit-ci in #721</li> <li>Improve NASA Earth Data search by @giswqs in #723</li> </ul> <p>New Contributors</p> <ul> <li>@james-willis made their first contribution in #722</li> </ul> <p>Full Changelog: v0.31.8...v0.31.9</p>"},{"location":"changelog/#v0318-apr-14-2024","title":"v0.31.8 - Apr 14, 2024","text":"<p>What's Changed</p> <ul> <li>[pre-commit.ci] pre-commit autoupdate by @pre-commit-ci in #712</li> <li>Fix split-map bug by @giswqs in #717</li> </ul> <p>Full Changelog: v0.31.7...v0.31.8</p>"},{"location":"changelog/#v0317-apr-2-2024","title":"v0.31.7 - Apr 2, 2024","text":"<p>What's Changed</p> <ul> <li>Update changelog by @giswqs in #710</li> <li>Add tile layer params for split map by @giswqs in #711</li> </ul> <p>Full Changelog: v0.31.6...v0.31.7</p>"},{"location":"changelog/#v0316-mar-29-2024","title":"v0.31.6 - Mar 29, 2024","text":"<p>What's Changed</p> <ul> <li>Allow to send options directly as str by @lopezvoliver in #702</li> <li>Vector tile layer arguments by @lopezvoliver in #703</li> <li>Fix docs build error by @giswqs in #704</li> <li>[pre-commit.ci] pre-commit autoupdate by @pre-commit-ci in #705</li> <li>Add functions for extracting multi-part archive by @giswqs in #709</li> </ul> <p>New Contributors</p> <ul> <li>@pre-commit-ci made their first contribution in #705</li> </ul> <p>Full Changelog: v0.31.5...v0.31.6</p>"},{"location":"changelog/#v0315-mar-4-2024","title":"v0.31.5 - Mar 4, 2024","text":"<p>What's Changed</p> <ul> <li>Fix lonboard zoom to layer bug by @giswqs in #700</li> </ul> <p>Full Changelog: v0.31.4...v0.31.5</p>"},{"location":"changelog/#v0314-mar-4-2024","title":"v0.31.4 - Mar 4, 2024","text":"<p>What's Changed</p> <ul> <li>Fix deckgl compute_view bug by @giswqs in #693</li> <li>Add more badges and update notebook by @giswqs in #694</li> <li>Fix notebook 88 error by @giswqs in #696</li> <li>Add testing for Python 3.12 by @giswqs in #698</li> </ul> <p>Full Changelog: v0.31.3...v0.31.4</p>"},{"location":"changelog/#v0313-feb-21-2024","title":"v0.31.3 - Feb 21, 2024","text":"<p>What's Changed</p> <ul> <li>Update changelog by @giswqs in #683</li> <li>Add split map example by @giswqs in #684</li> <li>Add pre-commit hooks by @giswqs in #686</li> <li>Fix raster pixel inspector bug by @giswqs in #689</li> <li>Update notebook examples by @giswqs in #690</li> </ul> <p>Full Changelog: v0.31.2...v0.31.3</p>"},{"location":"changelog/#v0312-feb-14-2024","title":"v0.31.2 - Feb 14, 2024","text":"<p>What's Changed</p> <ul> <li>Improve the add_raster method by @giswqs in #675</li> <li>Add xarray support for add_raster by @giswqs in #678</li> <li>Get crs and transform from xarray rio accessor in <code>array_to_memory_file</code> by @lopezvoliver in #679</li> <li>Layers as xarray.DataArray in split_map (ipyleaflet Map) by @lopezvoliver in #681</li> </ul> <p>New Contributors</p> <ul> <li>@lopezvoliver made their first contribution in #679</li> </ul> <p>Full Changelog: v0.31.1...v0.31.2</p>"},{"location":"changelog/#v0311-feb-7-2024","title":"v0.31.1 - Feb 7, 2024","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.31.0 by @giswqs in #672</li> <li>Fix add raster colormap bug by @giswqs in #674</li> </ul> <p>Full Changelog: v0.31.0...v0.31.1</p>"},{"location":"changelog/#v0310-feb-6-2024","title":"v0.31.0 - Feb 6, 2024","text":"<p>What's Changed</p> <ul> <li>Update notebooks by @giswqs in #657</li> <li>Fix array_to_image bug by @giswqs in #660</li> <li>Update GitHub Action versions by @giswqs in #669</li> <li>Bump localtileserver&gt;=0.10.0 by @banesullivan in #666</li> <li>Add get_root param to stac_client by @giswqs in #564</li> <li>Remove support for JupyterLite by @giswqs in #671</li> </ul> <p>New Contributors</p> <ul> <li>@banesullivan made their first contribution in #666</li> </ul> <p>Full Changelog: v0.30.1...v0.31.0</p>"},{"location":"changelog/#v0301-jan-11-2024","title":"v0.30.1 - Jan 11, 2024","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.30.0 by @giswqs in #652</li> <li>Improve array_to_image function by @giswqs in #653</li> <li>87_actinia.ipynb: simplify installation of actinia_python_client by @neteler in #655</li> <li>Modified add_velocity in leafmap.py to support custom color list by @shailesh-stha in #654</li> </ul> <p>New Contributors</p> <ul> <li>@shailesh-stha made their first contribution in #654</li> </ul> <p>Full Changelog: v0.30.0...v0.30.1</p>"},{"location":"changelog/#v0300-dec-23-2023","title":"v0.30.0 - Dec 23, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.29.8 by @giswqs in #646</li> <li>Improve folium legend position docstring by @giswqs in #647</li> <li>Add support for downloading NASA Earth data by @giswqs in #648</li> <li>Add support for searching NASA data interactively by @giswqs in #649</li> <li>Add support for visualizing in-memory raster by @giswqs in #651</li> </ul> <p>Full Changelog: v0.29.8...v0.30.0</p>"},{"location":"changelog/#v0298-dec-20-2023","title":"v0.29.8 - Dec 20, 2023","text":"<p>What's Changed</p> <ul> <li>Fix PMTiles metadata bug by @giswqs in #643</li> <li>fixed namespace and event handling issue with PMTiles by @prusswan in #645</li> </ul> <p>New Contributors</p> <ul> <li>@prusswan made their first contribution in #645</li> </ul> <p>Full Changelog: v0.29.7...v0.29.8</p>"},{"location":"changelog/#v0297-dec-15-2023","title":"v0.29.7 - Dec 15, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog by @giswqs in #634</li> <li>Update Colab badge link by @giswqs in #635</li> <li>Update GEDI notebook example by @giswqs in #637</li> <li>Add actinia notebook by @neteler in #573</li> <li>Fix folium pmtiles bug by @giswqs in #641</li> </ul> <p>New Contributors</p> <ul> <li>@neteler made their first contribution in #573</li> </ul> <p>Full Changelog: v0.29.6...v0.29.7</p>"},{"location":"changelog/#v0296-dec-7-2023","title":"v0.29.6 - Dec 7, 2023","text":"<p>What's Changed</p> <ul> <li>Add font size option for circle marker by @giswqs in #628</li> <li>Add GEDI subsetting and add_markers functions by @giswqs in #630</li> </ul> <p>Full Changelog: v0.29.5...v0.29.6</p>"},{"location":"changelog/#v0295-nov-30-2023","title":"v0.29.5 - Nov 30, 2023","text":"<p>What's Changed</p> <ul> <li>Fix basemap visibility bug by @giswqs in #622</li> <li>Add support for visualizing GEDI data by @giswqs in #624</li> </ul> <p>Full Changelog: v0.29.4...v0.29.5</p>"},{"location":"changelog/#v0294-nov-28-2023","title":"v0.29.4 - Nov 28, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.29.3 by @giswqs in #618</li> <li>Add functions for searching and downloading GEDI data by @giswqs in #619</li> </ul> <p>Full Changelog: v0.29.3...v0.29.4</p>"},{"location":"changelog/#v0293-nov-26-2023","title":"v0.29.3 - Nov 26, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.29.2 by @giswqs in #614</li> <li>Add default style for rendering PMTiles by @giswqs in #617</li> </ul> <p>Full Changelog: v0.29.2...v0.29.3</p>"},{"location":"changelog/#v0292-nov-21-2023","title":"v0.29.2 - Nov 21, 2023","text":"<p>What's Changed</p> <ul> <li>Add wms legend method to Map class by @JJFlorian in #608</li> <li>Update GitHub Actions to Python 3.11 by @giswqs in #612</li> <li>Add tooltip for PMTiles by @giswqs in #613</li> </ul> <p>New Contributors</p> <ul> <li>@JJFlorian made their first contribution in #608</li> </ul> <p>Full Changelog: v0.29.1...v0.29.2</p>"},{"location":"changelog/#v0291-nov-6-2023","title":"v0.29.1 - Nov 6, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.29.0 by @giswqs in #602</li> <li>Update notebook 84 by @giswqs in #603</li> <li>Update NWI legend by @giswqs in #604</li> <li>Add plot functions by @giswqs in #609</li> </ul> <p>Full Changelog: v0.29.0...v0.29.1</p>"},{"location":"changelog/#v0290-nov-12-2023","title":"v0.29.0 - Nov 12, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.28.1 by @giswqs in #593</li> <li>Add vector_to_parquet function by @giswqs in #598</li> <li>Add support for reading parquet files by @giswqs in #599</li> <li>Add streamlit support for lonboard by @giswqs in #600</li> <li>Add color schemes for visualizing vector data by @giswqs in #601</li> </ul> <p>Full Changelog: v0.28.1...v0.29.0</p>"},{"location":"changelog/#v0281-nov-7-2023","title":"v0.28.1 - Nov 7, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog for v0.28.0 by @giswqs in #589</li> <li>Update notebook 83 by @giswqs in #590</li> <li>Fix gdal driver error by @giswqs in #591</li> <li>Fix folium notebook error by @giswqs in #592</li> </ul> <p>Full Changelog: v0.28.0...v0.28.1</p>"},{"location":"changelog/#v0280-nov-5-2023","title":"v0.28.0 - Nov 5, 2023","text":"<p>What's Changed</p> <ul> <li>Update gradio example by @giswqs in #584</li> <li>Add GDAL and OpenFileGDB functions by @giswqs in #585</li> <li>Add df_to_gdf function by @giswqs in #586</li> <li>Add mbtiles and pmtiles functions by @giswqs in #587</li> <li>Add support for lonboard by @giswqs in #588</li> </ul> <p>Full Changelog: v0.27.2...v0.28.0</p>"},{"location":"changelog/#v0272-nov-3-2023","title":"v0.27.2 - Nov 3, 2023","text":"<p>What's Changed</p> <ul> <li>Update changelog by @giswqs in #579</li> <li>Add some vector functions by @giswqs in #582</li> </ul> <p>Full Changelog: v0.27.1...v0.27.2</p>"},{"location":"changelog/#v0271-oct-17-2023","title":"v0.27.1 - Oct 17, 2023","text":"<p>What's Changed</p> <ul> <li>Add global buildings example by @giswqs in #569</li> <li>Add ipyleaflet support for PMTiles by @giswqs in #575</li> <li>fix numpy.ndarray.interp error #577 by @kongdd in #578</li> </ul> <p>New Contributors</p> <ul> <li>@kongdd made their first contribution in #578</li> </ul> <p>Full Changelog: v0.27.0...v0.27.1</p>"},{"location":"changelog/#v0270-sep-25-2023","title":"v0.27.0 - Sep 25, 2023","text":"<p>What's Changed</p> <ul> <li>Add start_server function for pmtiles by @giswqs in #563</li> <li>Add support for PMTiles by @giswqs in #566</li> <li>Improve PMTiles functions by @giswqs in #567</li> </ul> <p>Full Changelog: v0.26.0...v0.27.0</p>"},{"location":"changelog/#v0260-sep-20-2023","title":"v0.26.0 - Sep 20, 2023","text":"<p>What's Changed</p> <ul> <li>Add support for PMTiles by @giswqs in #560</li> <li>Add example for visualizing overture pmtiles by @giswqs in #561</li> </ul> <p>Full Changelog: v0.25.3...v0.26.0</p>"},{"location":"changelog/#v0253-sep-19-2023","title":"v0.25.3 - Sep 19, 2023","text":"<p>What's Changed</p> <ul> <li>Add widget template by @giswqs in #557</li> <li>Update EE dataset link by @giswqs in #558</li> </ul> <p>Full Changelog: v0.25.2...v0.25.3</p>"},{"location":"changelog/#v0252-sep-16-2023","title":"v0.25.2 - Sep 16, 2023","text":"<p>What's Changed</p> <ul> <li>Update Google Buildings notebook by @giswqs in #551</li> <li>Add function for convert building csv to vector by @giswqs in #552</li> <li>Add add_ee_layer function by @giswqs in #553</li> </ul> <p>Full Changelog: v0.25.1...v0.25.2</p>"},{"location":"changelog/#v0251-sep-14-2023","title":"v0.25.1 - Sep 14, 2023","text":"<p>What's Changed</p> <ul> <li>Add support for downloading google buildings by @giswqs in #550</li> </ul> <p>Full Changelog: v0.25.0...v0.25.1</p>"},{"location":"changelog/#v0250-sep-14-2023","title":"v0.25.0 - Sep 14, 2023","text":"<p>What's Changed</p> <ul> <li>Add support for downloading MS building footprints by @giswqs in #549</li> </ul> <p>Full Changelog: v0.24.4...v0.25.0</p>"},{"location":"changelog/#v0244-sep-12-2023","title":"v0.24.4 - Sep 12, 2023","text":"<p>What's Changed</p> <ul> <li>Fix basemap issue by @giswqs in #545</li> </ul> <p>Full Changelog: v0.24.3...v0.24.4</p>"},{"location":"changelog/#v0243-sep-12-2023","title":"v0.24.3 - Sep 12, 2023","text":"<p>What's Changed</p> <ul> <li>Add session header to map tiles download by @giswqs in #541</li> <li>Update opengeos url by @giswqs in #542</li> <li>Add changelog script by @giswqs in #544</li> </ul> <p>Full Changelog: v0.24.2...v0.24.3</p>"},{"location":"changelog/#v0242-sep-10-2023","title":"v0.24.2 - Sep 10, 2023","text":"<p>What's Changed</p> <ul> <li>Change tms_to_geotiff to map_tiles_to_geotiff by @giswqs in #536</li> <li>Fix MosaicJSON bug in add_stac_layer by @giswqs in #538</li> </ul> <p>Full Changelog: v0.24.1...v0.24.2</p>"},{"location":"changelog/#v0241-sep-6-2023","title":"v0.24.1 - Sep 6, 2023","text":"<p>What's Changed</p> <ul> <li>Update GitHub Actions by @giswqs in #532</li> <li>Add support for Google Solar API by @giswqs in #534</li> </ul> <p>Full Changelog: v0.24.0...v0.24.1</p>"},{"location":"changelog/#v0240-sep-4-2023","title":"v0.24.0 - Sep 4, 2023","text":"<p>What's Changed</p> <ul> <li>Fix netcdf_to_tif to correctly shift longitude with custom variable name by @jovanovski in #529</li> <li>Add array_to_image function by @giswqs in #530</li> <li>Add images_to_tiles function by @giswqs in #531</li> </ul> <p>New Contributors</p> <ul> <li>@jovanovski made their first contribution in #529</li> </ul>"},{"location":"changelog/#v0234-aug-31-2023","title":"v0.23.4 - Aug 31, 2023","text":"<p>What's Changed</p> <ul> <li>Update docs by @giswqs in #513</li> <li>Update logo by @giswqs in #517</li> <li>Add get_geometry_type and NLCD 2021 by @giswqs in #521</li> <li>Add Google Maps API key requirement by @giswqs in #522</li> <li>Remove unused control by @giswqs in #523</li> <li>Improve split_map function by @giswqs in #524</li> <li>Enable xarray dataset in add_raster_legacy by @giswqs in #528</li> </ul>"},{"location":"changelog/#v0233-aug-19-2023","title":"v0.23.3 - Aug 19, 2023","text":"<p>Improvement</p> <ul> <li>Added leafmap book link (#512)</li> <li>Updated pepy badge (#511)</li> <li>Fixed docker image error (#510)</li> <li>Added zoom_to_layer param for folium add_cog_layer (#508)</li> <li>Improved download function for tar file unzip (#505)</li> <li>Added installation CI (#504)</li> </ul>"},{"location":"changelog/#v0232-aug-8-2023","title":"v0.23.2 - Aug 8, 2023","text":"<p>Improvement</p> <ul> <li>Removed shapely import from osm module (#503)</li> </ul>"},{"location":"changelog/#v0231-aug-8-2023","title":"v0.23.1 - Aug 8, 2023","text":"<p>Improvement</p> <ul> <li>Added typing (#494)</li> </ul>"},{"location":"changelog/#v0230-jul-19-2023","title":"v0.23.0 - Jul 19, 2023","text":"<p>New Features</p> <ul> <li>Added S3 get objects and read raster functions (#495)</li> <li>Added folium add_markers_from_xy method (#486)</li> </ul> <p>Improvement</p> <ul> <li>Changed palette to cmap for add_raster (#491)</li> <li>Fixed stac layer expression bug (#490)</li> <li>Updated SAM notebook (#489)</li> <li>Fixed ipywidget Output widget bug (#487)</li> <li>Improved add_gdf error handling (#485)</li> <li>Fixed add_gdf bug (#484)</li> </ul>"},{"location":"changelog/#v0220-jun-21-2023","title":"v0.22.0 - Jun 21, 2023","text":"<p>New Features</p> <ul> <li>Added several GUI methods to Map class (#481)</li> <li>Add EarthCube workshop notebook</li> </ul>"},{"location":"changelog/#v0214-jun-20-2023","title":"v0.21.4 - Jun 20, 2023","text":"<p>New Features</p> <ul> <li>Added split_raster and merge_rasters functions (#478)</li> </ul> <p>Improvement</p> <ul> <li>Suppress gdal open raster warming (#477)</li> <li>Used sorted function instead of if statements (#476)</li> <li>Added bounds warning for numpy_to_cog (#473)</li> <li>Added zoom_to_layer to add_vector (#470)</li> <li>Improved add_html for supporting local image (#467)</li> <li>Updated ICRW notebook (#462)</li> </ul>"},{"location":"changelog/#v0213-jun-4-2023","title":"v0.21.3 - Jun 4, 2023","text":"<p>New Features</p> <ul> <li>Added layer manager GUI (#461)</li> </ul>"},{"location":"changelog/#v0212-jun-4-2023","title":"v0.21.2 - Jun 4, 2023","text":"<p>New Features</p> <ul> <li>Added NHD and 3DEP functions (#457)</li> <li>Added vector processing functions (#458)</li> <li>Added ICRW workshop notebook (#459)</li> </ul> <p>Improvement</p> <ul> <li>Fixed typos (#460)</li> </ul>"},{"location":"changelog/#v0211-jun-1-2023","title":"v0.21.1 - Jun 1, 2023","text":"<p>Improvement</p> <ul> <li>Fixed split control bug (#454)</li> <li>Added tool template (#453)</li> </ul>"},{"location":"changelog/#v0210-may-28-2023","title":"v0.21.0 - May 28, 2023","text":"<p>New Features</p> <ul> <li>Added support for Solara web apps (#450)</li> </ul> <p>Improvement</p> <ul> <li>Improved support for stac GUI (#436)</li> </ul>"},{"location":"changelog/#v0204-may-25-2023","title":"v0.20.4 - May 25, 2023","text":"<p>Improvement</p> <ul> <li>Improved handling of crs conversion (#449)</li> </ul>"},{"location":"changelog/#v0203-may-20-2023","title":"v0.20.3 - May 20, 2023","text":"<p>Improvement</p> <ul> <li>Added arc_zoom_to_bounds function (#447)</li> </ul>"},{"location":"changelog/#v0202-may-10-2023","title":"v0.20.2 - May 10, 2023","text":"<p>Improvement</p> <ul> <li>Added repeat mode for draw control (#443)</li> <li>Changed show_html to display_html</li> </ul>"},{"location":"changelog/#v0201-may-7-2023","title":"v0.20.1 - May 7, 2023","text":"<p>New Features</p> <ul> <li>Added <code>image_comparison</code> for comparing images with a slider (#441)</li> <li>Added <code>show_html</code> function (#441)</li> </ul>"},{"location":"changelog/#v0200-apr-24-2023","title":"v0.20.0 - Apr 24, 2023","text":"<p>New Features</p> <ul> <li>Added map_tiles_to_geotiff function (#420)</li> <li>Added tif_to_jp2 function and fixed build errors (#425)</li> <li>Added Segment Anything Model (SAM) (#426)</li> </ul> <p>Improvement</p> <ul> <li>Fixed custom STAC GUI bug (#414)</li> <li>Added marker cluster radius option (#417)</li> <li>Added request_modifier param to stac_client (#421)</li> <li>Added bbox parameter for create_timelapse function (#427)</li> <li>Improved map_tiles_to_geotiff and tif_to_jp2 (#430)</li> <li>Fixed ArcGIS add layer bug (#434)</li> </ul>"},{"location":"changelog/#v0191-apr-21-2023","title":"v0.19.1 - Apr 21, 2023","text":"<p>New Features</p> <ul> <li>Added map_tiles_to_geotiff function (#420)</li> <li>Added tif_to_jp2 function (#424)</li> </ul> <p>Improvement</p> <ul> <li>Add request_modifier param to stac_client (#421)</li> <li>Added marker cluster radius option (#417)</li> <li>Fixed custom STAC GUI bug (#414)</li> </ul>"},{"location":"changelog/#v0190-apr-10-2023","title":"v0.19.0 - Apr 10, 2023","text":"<p>New Features</p> <ul> <li>Added GUI for custom STAC catalogs (#413)</li> </ul>"},{"location":"changelog/#v01810-apr-6-2023","title":"v0.18.10 - Apr 6, 2023","text":"<p>Improvement</p> <ul> <li>Dropped support for Python 3.7 (#410)</li> <li>Fixed create_timelapse bug (#410)</li> </ul>"},{"location":"changelog/#v0189-apr-6-2023","title":"v0.18.9 - Apr 6, 2023","text":"<p>Improvement</p> <ul> <li>Set toolbar widget visibility with env variables (#407)</li> <li>Moved repo to opengeos org and updated repo URL (#408)</li> <li>Removed ipykernel</li> <li>Updated docker image url</li> </ul>"},{"location":"changelog/#v0188-mar-26-2023","title":"v0.18.8 - Mar 26, 2023","text":"<p>Improvement</p> <ul> <li>Removed ipykernel import (#402)</li> </ul>"},{"location":"changelog/#v0187-mar-24-2023","title":"v0.18.7 - Mar 24, 2023","text":"<p>New Features</p> <ul> <li>Added support for creating satellite timelapse animations (#398)</li> </ul>"},{"location":"changelog/#v0186-mar-22-2023","title":"v0.18.6 - Mar 22, 2023","text":"<p>Improvement</p> <ul> <li>Fixed ipywidgets comm error (#396)</li> </ul>"},{"location":"changelog/#v0185-mar-19-2023","title":"v0.18.5 - Mar 19, 2023","text":"<p>Improvement</p> <ul> <li>Updated mkdocs-jupyter execute_ignore</li> <li>Removed Google Search from menu</li> <li>Set mkdocs material version lower bound (#394)</li> <li>Added mkdocs built-in search (#393)</li> <li>Fixed CodeQL warnings (#392)</li> <li>Fixed notebook 71 error</li> </ul>"},{"location":"changelog/#v0184-mar-15-2023","title":"v0.18.4 - Mar 15, 2023","text":"<p>New Features</p> <ul> <li>Added support for loading raster datasets from AWS S3 buckets (#391)</li> <li>Added <code>zonal_stats</code> function (#389)</li> <li>Added <code>disjoint</code> function for filtering vector data (#388)</li> </ul> <p>Improvement</p> <ul> <li>Updated installation instructions</li> <li>Updated Dockerfile</li> </ul>"},{"location":"changelog/#v0183-mar-6-2023","title":"v0.18.3 - Mar 6, 2023","text":"<p>New Features</p> <ul> <li>Added docker image (#387)</li> </ul> <p>Improvement</p> <ul> <li>Cleaned up notebooks (#386)</li> </ul>"},{"location":"changelog/#v0182-mar-5-2023","title":"v0.18.2 - Mar 5, 2023","text":"<p>New Features</p> <ul> <li>Added filter_date and filter_bounds functions (#385)</li> <li>Added Google Search for docs (#383)</li> <li>Added SageMaker Studio Lab and Planetary Computer badges (#380)</li> </ul> <p>Improvement</p> <ul> <li>Cleaned up notebooks (#384)</li> <li>Added missing dependencies to notebook (#382)</li> <li>Added default_vis option to cog_tile (#378)</li> </ul>"},{"location":"changelog/#v0181-mar-1-2023","title":"v0.18.1 - Mar 1, 2023","text":"<p>Improvement</p> <ul> <li>Deprecated ipyleaflet add_layer and add_control methods (#377)</li> <li>Fixed add geojson style bug (#376)</li> </ul>"},{"location":"changelog/#v0180-mar-1-2023","title":"v0.18.0 - Mar 1, 2023","text":"<p>New Features</p> <ul> <li>Added support for searching OpenAerialMap imagery (#375)</li> <li>Added Google Search for docs (#374)</li> <li>Added leafmap logo (#372)</li> </ul> <p>Improvement</p> <ul> <li>Fixed datapane bug (#373)</li> <li>Pin osmnx version lower bound (#369)</li> </ul>"},{"location":"changelog/#v0171-feb-16-2023","title":"v0.17.1 - Feb 16, 2023","text":"<p>New Features</p> <ul> <li>Added support for visualizing Maxar Open Data (#367)</li> </ul>"},{"location":"changelog/#v0170-feb-15-2023","title":"v0.17.0 - Feb 15, 2023","text":"<p>New Features</p> <ul> <li>Added support for gradio for developing interactive web apps (#364)</li> </ul>"},{"location":"changelog/#v0161-feb-7-2023","title":"v0.16.1 - Feb 7, 2023","text":"<p>New Features</p> <ul> <li>Added support for visualizing raster datasets in AWS SageMaker (#359)</li> </ul>"},{"location":"changelog/#v0160-feb-3-2023","title":"v0.16.0 - Feb 3, 2023","text":"<p>New Features</p> <ul> <li>Added STAC API Browser GUI (#347, #354)</li> <li>Added support for vector tiles (#352)</li> <li>Added support for editing an empty vector dataset interactively (#353)</li> <li>Added vector-to-raster function (#343)</li> </ul> <p>Improvement</p> <ul> <li>Updated 04_cog_mosaic.ipynb (#342)</li> <li>Fixed tar file bug CVE-2007-4559 (#350)</li> <li>Fixed folium add basemap bug</li> </ul>"},{"location":"changelog/#v0150-dec-23-2022","title":"v0.15.0 - Dec 23, 2022","text":"<p>New Features</p> <ul> <li>Added support for ArcGIS Pro (#334)</li> </ul>"},{"location":"changelog/#v0142-dec-22-2022","title":"v0.14.2 - Dec 22, 2022","text":"<p>New Features</p> <ul> <li>Added colorbar support for folium (#330)</li> </ul> <p>Improvement</p> <ul> <li>Updated vector_to_gif notebook</li> </ul>"},{"location":"changelog/#v0141-dec-11-2022","title":"v0.14.1 - Dec 11, 2022","text":"<p>New Features</p> <ul> <li>Added support for vector_to_gif (#323)</li> </ul> <p>Improvement</p> <ul> <li>Updated TiTiler endpoint (#325)</li> <li>Fixed <code>stac_pixel_value()</code> bug</li> </ul>"},{"location":"changelog/#v0140-nov-27-2022","title":"v0.14.0 - Nov 27, 2022","text":"<p>New Features</p> <ul> <li>Added functions for creating legends and adding widgets to the map (#321)</li> <li>New functions include <code>create_legend()</code>, <code>add_legend()</code>, <code>add_text()</code>, <code>add_image()</code>, <code>add_html()</code>, and <code>add_widget()</code></li> <li>Added two notebook examples for using newly added functions</li> <li>Split-map now supports adding multiple legends</li> <li>Added ESA World Cover 2021 basemaps</li> </ul>"},{"location":"changelog/#v0133-nov-25-2022","title":"v0.13.3 - Nov 25, 2022","text":"<p>New Features</p> <ul> <li>Added function for downloading files using pyodide (#320)</li> <li>Added JupyterLite badge to notebook examples (#319)</li> <li>Added gdown and JupyterLite badge to docs (#318)</li> </ul>"},{"location":"changelog/#v0131-nov-24-2022","title":"v0.13.1 - Nov 24, 2022","text":"<p>New Features</p> <ul> <li>Added support for JupyterLite (#317)</li> </ul>"},{"location":"changelog/#v0130-nov-23-2022","title":"v0.13.0 - Nov 23, 2022","text":"<p>New Features</p> <ul> <li>Added support for JupyterLite (#316)</li> <li>Added choropleth map legend position option #305 (#315)</li> <li>Added dark mode and fix bugs (#312)</li> <li>Added vector_area and image_filesize functions (#309)</li> <li>Added bbox to gdf and polygon func</li> <li>Added raster support for SageMaker AWS (#307)</li> </ul> <p>Improvement</p> <ul> <li>Fixed kml bug (#308)</li> </ul>"},{"location":"changelog/#v0121-nov-10-2022","title":"v0.12.1 - Nov 10, 2022","text":"<p>New Features</p> <ul> <li>Added add_mask_to_image() function (#306)</li> </ul>"},{"location":"changelog/#v0120-nov-8-2022","title":"v0.12.0 - Nov 8, 2022","text":"<p>New Features</p> <ul> <li>Added bokeh as a new plotting backend #298 #301</li> <li>The bokeh backend supports loading COG, STAC, local rasters, GeoJSON, Shapefile, etc.</li> <li>Added GeoJSON support for split-view map #291 #300</li> </ul> <p>Improvement</p> <ul> <li>Fixed numpy to cog crs bug</li> <li>Improved cog rescale param and docs #284 #299</li> </ul>"},{"location":"changelog/#v0113-nov-3-2022","title":"v0.11.3 - Nov 3, 2022","text":"<p>Improvement</p> <ul> <li>Fixed split map bug (layer visualization args)</li> <li>Improved linked maps to support COG and local GeoTIFFs</li> </ul>"},{"location":"changelog/#v0112-nov-2-2022","title":"v0.11.2 - Nov 2, 2022","text":"<p>Improvement</p> <ul> <li>Improved the mosaic() function to support creating COG</li> <li>Improved the download_file() function to support downloading and extracting files</li> </ul>"},{"location":"changelog/#v0111-nov-2-2022","title":"v0.11.1 - Nov 2, 2022","text":"<p>New Features:</p> <ul> <li>Added find_files() function for searching files recursively in a directory</li> </ul> <p>Improvement</p> <ul> <li>Improved the mosaic() function</li> </ul>"},{"location":"changelog/#v0110-nov-2-2022","title":"v0.11.0 - Nov 2, 2022","text":"<p>New Features:</p> <ul> <li>Improved support for creating split-panel map #297</li> <li>Split-panel map supports any local or remote raster datasets</li> <li>Added several image functions:</li> <li><code>image_center()</code></li> <li><code>image_bounds()</code></li> <li><code>image_size()</code></li> <li><code>image_resolution()</code></li> <li><code>image_metadata()</code></li> <li><code>image_projection()</code></li> <li><code>image_geotransform()</code></li> </ul>"},{"location":"changelog/#v0106-oct-31-2022","title":"v0.10.6 - Oct 31, 2022","text":"<p>New Features:</p> <ul> <li>Added reproject image function</li> <li>Added download ned notebook tutorial #285</li> <li>Added download ned by huc and bbox #287 #289</li> <li>Added USGS The national map API wrapper #290</li> </ul> <p>Improvement</p> <ul> <li>Added codeql.yml</li> <li>Improved Colab import error message</li> <li>Added Python 3.11 to CI</li> <li>Fixed max zoom bug</li> <li>Improved split control</li> </ul>"},{"location":"changelog/#v0105-sep-7-2022","title":"v0.10.5 - Sep 7, 2022","text":"<p>New Features:</p> <ul> <li>Added geometry_bounds() function</li> <li>Added Map.user_roi_bounds() method</li> </ul> <p>Improvement</p> <ul> <li>Fixed download NED bug</li> </ul>"},{"location":"changelog/#v0104-sep-7-2022","title":"v0.10.4 - Sep 7, 2022","text":"<p>New Features:</p> <ul> <li>Added download_ned and mosaic image functions</li> <li>Added html_to_streamlit function</li> </ul> <p>Improvement</p> <ul> <li>Updated Map.to_streamlit()</li> </ul>"},{"location":"changelog/#v0103-jul-22-2022","title":"v0.10.3 - Jul 22, 2022","text":"<p>New Features:</p> <ul> <li>Added lidar tutorial #276</li> <li>Added add_crs function #275</li> <li>Added more lidar functions</li> <li>Added get_direct_url function</li> </ul> <p>Improvement</p> <ul> <li>Improved add_raster function #275</li> </ul>"},{"location":"changelog/#v0102-jul-15-2022","title":"v0.10.2 - Jul 15, 2022","text":"<p>New Features:</p> <ul> <li>Added csv_to_vector function #270</li> </ul> <p>Improvement</p> <ul> <li>Pin ipyleaflet version &gt; 0.17.0</li> <li>Updated sample datasets</li> <li>Fixed json import error</li> </ul>"},{"location":"changelog/#v0101-jul-11-2022","title":"v0.10.1 - Jul 11, 2022","text":"<p>New Features:</p> <ul> <li>Added github_raw_url function #267</li> </ul> <p>Improvement</p> <ul> <li>Pin ipyleaflet version for Colab #269</li> <li>Improved add data methods to accept HTTP URL #262</li> <li>Changed parameter name to layer_name #262</li> <li>Improved download_file function</li> </ul>"},{"location":"changelog/#v0100-jul-8-2022","title":"v0.10.0 - Jul 8, 2022","text":"<p>New Features:</p> <ul> <li>Added support for changing geojson layer opacity #265</li> </ul> <p>Improvement</p> <ul> <li>Updated plot raster 3d function #264</li> <li>Fixed clip image bug</li> </ul>"},{"location":"changelog/#v095-jun-26-2022","title":"v0.9.5 - Jun 26, 2022","text":"<p>Improvement</p> <ul> <li>Made mapclassify optional #257</li> </ul>"},{"location":"changelog/#v096-jul-1-2022","title":"v0.9.6 - Jul 1, 2022","text":"<p>New Features:</p> <ul> <li>Added plotting raster in 3D #259</li> <li>Added scooby report for reporting issues #260</li> </ul>"},{"location":"changelog/#v095-jun-26-2022_1","title":"v0.9.5 - Jun 26, 2022","text":"<p>Improvement</p> <ul> <li>Made mapclassify optional #257</li> <li>Improved wording on the home page #256</li> <li>Fixed typos #251</li> </ul>"},{"location":"changelog/#v094-jun-7-2022","title":"v0.9.4 - Jun 7, 2022","text":"<p>Improvement</p> <ul> <li>Added ESA WorldCover and USGS NAIP basemaps #250</li> <li>Fixed bugs in add_points_from_xy functions #249</li> <li>Fixed link redirects #247</li> <li>Added check_cmap function</li> </ul>"},{"location":"changelog/#v093-apr-27-2022","title":"v0.9.3 - Apr 27, 2022","text":"<p>Improvement</p> <ul> <li>Fixed stac stats bug #245</li> </ul>"},{"location":"changelog/#v092-apr-27-2022","title":"v0.9.2 - Apr 27, 2022","text":"<p>New Features:</p> <ul> <li>Added support for creating interactive choropleth maps with a variety of classification schemes #235 #239 #240</li> <li>Added tooltip and popup for GeoJSON</li> <li>Added examples module #238</li> </ul> <p>Improvement</p> <ul> <li>Fixed add velocity bug #234</li> <li>Added ability to handle levels and times in netCDF files #232</li> </ul>"},{"location":"changelog/#v091-apr-2-2022","title":"v0.9.1 - Apr 2, 2022","text":"<p>Improvement</p> <ul> <li>Fixed heremap import error</li> </ul>"},{"location":"changelog/#v090-apr-2-2022","title":"v0.9.0 - Apr 2, 2022","text":"<p>Improvement</p> <ul> <li>Reduced number of dependencies, making plotting backends optional except ipyleaflet and folium #230</li> <li>Updated clip image notebook</li> <li>Updated docs</li> </ul>"},{"location":"changelog/#v086-mar-22-2022","title":"v0.8.6 - Mar 22, 2022","text":"<p>Improvement</p> <ul> <li>Renamed basemaps and updated notebooks #228</li> </ul>"},{"location":"changelog/#v085-mar-19-2022","title":"v0.8.5 - Mar 19, 2022","text":"<p>New Features:</p> <ul> <li>Added support for NetCDF data #127 #226</li> <li>Converting NetCDF to GeoTIFF</li> <li>Adding velocity map</li> <li>Added clip_image function #108 #225</li> </ul> <p>Improvement</p> <ul> <li>Added optional dependencies (netcdf4 and rioxarray) to setup.py</li> </ul>"},{"location":"changelog/#v084-mar-15-2022","title":"v0.8.4 - Mar 15, 2022","text":"<p>New Features:</p> <ul> <li>Added streamlit folium bidirectional functionality #223</li> <li>Added marker icon options for marker cluster #222</li> <li>Added folium search control</li> </ul> <p>Improvement</p> <ul> <li>Renamed data files #221</li> <li>Fixed circle marker bug</li> </ul>"},{"location":"changelog/#v083-mar-12-2022","title":"v0.8.3 - Mar 12, 2022","text":"<p>New Features:</p> <ul> <li>Added split map for folium and streamlit #218</li> <li>Added eye dome lighting for lidar data #212</li> <li>Added ipygany and panel 3D plotting backends for LiDAR data #212</li> </ul> <p>Improvement</p> <ul> <li>Updated binder env</li> </ul>"},{"location":"changelog/#v082-mar-2-2022","title":"v0.8.2 - Mar 2, 2022","text":"<p>Improvement</p> <ul> <li>Added missing requirements.txt to MANIFEST</li> </ul>"},{"location":"changelog/#v081-mar-2-2022","title":"v0.8.1 - Mar 2, 2022","text":"<p>New Features:</p> <ul> <li>Added support for visualizing LiDAR data in 3D #212</li> <li>Added support for downloading Googld Drive folder #212</li> </ul> <p>Improvement</p> <ul> <li>Improved COG STAC palette</li> <li>Fixed getattr bug #207</li> </ul>"},{"location":"changelog/#v080-feb-25-2022","title":"v0.8.0 - Feb 25, 2022","text":"<p>New Features:</p> <ul> <li>Added STAC search and visualization GUI #181</li> <li>Added support for STAC MosaicJSON #206</li> <li>Added encoding param for reading vector #208</li> </ul> <p>Improvement</p> <ul> <li>Use getattr instead of eval #207</li> </ul>"},{"location":"changelog/#v078-feb-22-2022","title":"v0.7.8 - Feb 22, 2022","text":"<p>New Features:</p> <ul> <li>Added numpy to cog #200</li> </ul> <p>Improvement</p> <ul> <li>Fixed LGTM alerts</li> </ul>"},{"location":"changelog/#v077-feb-15-2022","title":"v0.7.7 - Feb 15, 2022","text":"<p>New Features:</p> <ul> <li>Added raster support for JupyterHub</li> <li>Added new function add_raster</li> </ul> <p>Improvement</p> <ul> <li>Fixed Colab plotly bug #199</li> </ul>"},{"location":"changelog/#v076-feb-4-2022","title":"v0.7.6 - Feb 4, 2022","text":"<p>New Features:</p> <ul> <li>Added support for editing vector data #178 #179</li> </ul> <p>Improvement</p> <ul> <li>Fixed Colab widgets.jslink bug</li> <li>Updated STAC notebooks</li> <li>Changed STAC items to item</li> <li>Added sample vector data</li> </ul>"},{"location":"changelog/#v075-jan-27-2022","title":"v0.7.5 - Jan 27, 2022","text":"<p>New Features:</p> <ul> <li>Added vector creation GUI #179 #194</li> </ul>"},{"location":"changelog/#v074-jan-24-2022","title":"v0.7.4 - Jan 24, 2022","text":"<p>New Features:</p> <ul> <li>Added attribute table GUI #179</li> </ul> <p>Improvement</p> <ul> <li>Improved add_labels function #188</li> <li>Improved GitHub workflows #192</li> <li>Improved add_raster function #191</li> <li>Removed nominatim URL from Search Control #182</li> <li>Fixed search control bug #183</li> </ul>"},{"location":"changelog/#v073-jan-21-2022","title":"v0.7.3 - Jan 21, 2022","text":"<p>New Features:</p> <ul> <li>Added search control GUI #182 #183</li> <li>Added COG creation #176</li> </ul> <p>Improvement</p> <ul> <li>Removed COG mosaic function #180</li> <li>Updated binder env</li> </ul>"},{"location":"changelog/#v072-jan-11-2022","title":"v0.7.2 - Jan 11, 2022","text":"<p>New Features:</p> <ul> <li>Added GUI for loading COG/STAC #164</li> <li>Added ROI to GeoJSON function #170</li> <li>Added add_geojson for plotly #163 #167</li> </ul>"},{"location":"changelog/#v071-jan-3-2022","title":"v0.7.1 - Jan 3, 2022","text":"<p>New Features:</p> <ul> <li>Added plotly toolbar GUI #160</li> <li>Added layer control #160</li> <li>Added Inspector support for local tile #162</li> <li>Added add_gdf for plotly #163</li> </ul> <p>Improvement</p> <ul> <li>Improved COG visualization #161</li> <li>Fixed citation bug #165</li> </ul>"},{"location":"changelog/#v070-dec-29-2021","title":"v0.7.0 - Dec 29, 2021","text":"<p>New Features:</p> <ul> <li>Added Planetary Computer STAC support #137</li> <li>Added plotly backend #109</li> <li>Added Inspector tool #158</li> <li>Added plotly COG STAC support #109</li> <li>Added plotly planet imagery support #109</li> <li>Added plotly toolbar #160</li> <li>Added geojson_to_df and geom_type functions</li> </ul> <p>Improvement</p> <ul> <li>Removed pangeo broken binder links</li> <li>Improved kepler config options #150</li> <li>Improved stac tile function #137</li> <li>Updated STAC notebook example #156</li> </ul>"},{"location":"changelog/#v061-dec-23-2021","title":"v0.6.1 - Dec 23, 2021","text":"<p>New Features:</p> <ul> <li>Added image overlay functionality #136</li> <li>Added marker cluster function #138</li> <li>Added locate control to folium</li> <li>Added cesium_to_streamlit function #139</li> <li>Added add_points_from_xy function #138</li> <li>Added circle markers function #140</li> </ul> <p>Improvement</p> <ul> <li>Added localtileserver to env.yml</li> <li>Fixed gdf style callback bug #119</li> <li>Added ts_inspector docstring #147</li> <li>Improved streamlit download button</li> </ul>"},{"location":"changelog/#v060-nov-27-2021","title":"v0.6.0 - Nov 27, 2021","text":"<p>New Features:</p> <ul> <li>Added add_marker function</li> <li>Added save_data function</li> <li>Added support for local tile #129</li> <li>Added open raster GUI #129</li> <li>Added zoom to tile #129</li> </ul>"},{"location":"changelog/#v055-nov-9-2021","title":"v0.5.5 - Nov 9, 2021","text":"<p>New Features:</p> <ul> <li>Added YouthMappers workshop notebook</li> </ul> <p>Improvement</p> <ul> <li>Fixed <code>add_legend</code> bug</li> <li>Changed default <code>max_zoom</code> to 24</li> </ul>"},{"location":"changelog/#v054-nov-2-2021","title":"v0.5.4 - Nov 2, 2021","text":"<p>New Features:</p> <ul> <li>Added search basemaps GUI #93</li> <li>Added get wms layers function</li> <li>Made streamlit map width responsive #126</li> <li>Added function read file from url</li> <li>Added streamlit download button</li> <li>Added SIGSPATIAL workshop notebook</li> </ul> <p>Improvement</p> <ul> <li>Fixed layer attribution error #93</li> <li>Fixed open vector bug #124</li> <li>Improved streamlit support</li> </ul>"},{"location":"changelog/#v053-oct-17-2021","title":"v0.5.3 - Oct 17, 2021","text":"<p>New Features:</p> <ul> <li>Added support for US Census data with hundreds of WMS layers #123</li> </ul>"},{"location":"changelog/#v052-oct-17-2021","title":"v0.5.2 - Oct 17, 2021","text":"<p>Improvement</p> <ul> <li>Fixed pydeck import error</li> </ul>"},{"location":"changelog/#v051-oct-17-2021","title":"v0.5.1 - Oct 17, 2021","text":"<p>New Features:</p> <ul> <li>Added support for pydeck #122</li> <li>Added streamlit support for heremap #118</li> <li>Added create_colormap function</li> </ul> <p>Improvement</p> <ul> <li>Added optional postgis port param #144</li> <li>Added STAC time slider example to notebook #177</li> <li>Fixed geojson style callback bug #119</li> <li>Updated foss4g notebook</li> <li>Fixed planet imagery bug</li> <li>Improved vector to geojson</li> <li>Added streamlit app link to docs</li> </ul>"},{"location":"changelog/#v043-sep-17-2021","title":"v0.4.3 - Sep 17, 2021","text":"<p>New Features:</p> <ul> <li>Added <code>sandbox_path</code> option allowing users to restrict Voila app access to system directories #113</li> </ul>"},{"location":"changelog/#v042-sep-10-2021","title":"v0.4.2 - Sep 10, 2021","text":"<p>New Features:</p> <ul> <li>Changed default plotting backend on Colab from folium to ipyleaflet #112</li> <li>Added streamlit support #96</li> <li>Added support for xyzservices provider #92</li> <li>Added a basemap gallery #91</li> </ul> <p>Improvement</p> <ul> <li>Fixed linked maps bug</li> <li>Improved folium basemaps #91</li> </ul>"},{"location":"changelog/#v041-aug-4-2021","title":"v0.4.1 - Aug 4, 2021","text":"<p>New Features:</p> <ul> <li>Added 200+ basemaps from xyzservices #91</li> </ul> <p>Improvement</p> <ul> <li>Fixed typo #90</li> <li>Added kepler module to mkdocs</li> <li>Removed support for Python 3.6 due to xyzservices</li> </ul>"},{"location":"changelog/#v040-jul-28-2021","title":"v0.4.0 - Jul 28, 2021","text":"<p>New Features:</p> <ul> <li>Added kepler.gl plotting backend #88</li> <li>Added keplergl sample data #88</li> <li>Added keplergl sample html #88</li> </ul> <p>Improvement</p> <ul> <li>Added CITATIONS.cff</li> </ul>"},{"location":"changelog/#v035-jul-26-2021","title":"v0.3.5 - Jul 26, 2021","text":"<p>New Features:</p> <ul> <li>Added kepler.gl plotting backend #88</li> </ul> <p>Improvement</p> <ul> <li>Added unittest for toolbar module #83</li> <li>Updated paper.md</li> </ul>"},{"location":"changelog/#v034-jul-21-2021","title":"v0.3.4 - Jul 21, 2021","text":"<p>New Features:</p> <ul> <li>Added map title function #84</li> </ul> <p>Improvement</p> <ul> <li>Improved add_ahp and add_kml for http</li> <li>Added codespell to docs.yml</li> <li>Made XYZ tiles attribution required #83</li> <li>Changed some functions to be private #83</li> <li>Added more info about plotting backends #83</li> <li>Added text description to notebooks #83</li> <li>Added NotImplementedError for foliumap #83</li> <li>Fixed typos using codespell #83</li> <li>Added Code of Conduct #83</li> <li>Made usage page interactive #83</li> <li>Added key features notebook #83</li> <li>Added plotting backend comparison #83</li> <li>Added leafmap and foliumap unittest #83</li> <li>Improved JOSS paper #83</li> </ul>"},{"location":"changelog/#v033-jul-8-2021","title":"v0.3.3 - Jul 8, 2021","text":"<p>New Features:</p> <ul> <li>Added troubleshooting section #76</li> <li>Added df_to_geojson function #75</li> <li>Added creating heat map from csv #64</li> <li>Added cog mosaic from file #61</li> <li>Added colormap notebook #60</li> </ul> <p>Improvement</p> <ul> <li>Changed COG and STAC function names #61</li> <li>Updated colormap example #60</li> </ul>"},{"location":"changelog/#v032-jun-22-2021","title":"v0.3.2 - Jun 22, 2021","text":"<p>New Features:</p> <ul> <li>Added time slider #42</li> <li>Added JOSS manuscript</li> <li>Added unittests</li> </ul>"},{"location":"changelog/#v031-jun-20-2021","title":"v0.3.1 - Jun 20, 2021","text":"<p>New Features:</p> <ul> <li>Added GUI for loading COG #50</li> <li>Added methods to add vector data on heremap #43 </li> <li>Added Planet imagery GUI #9</li> </ul> <p>Improvement</p> <ul> <li>Improved support for folium styles #47</li> <li>Improved save map to image #37</li> <li>Updated toolbar icons #9</li> <li>Added LGTM</li> <li>Updated installation docs</li> </ul>"},{"location":"changelog/#v030-jun-14-2021","title":"v0.3.0 - Jun 14, 2021","text":"<p>New Features:</p> <ul> <li>Added Planet basemaps GUI #9</li> <li>Added open point layer GUI #29</li> <li>Improved GUI for opening vector data from http #33</li> <li>Added map to html function #32</li> <li>Added point layer with popup #27</li> <li>Added vector tile layer support #26</li> <li>Added HERE map plotting backend #20</li> </ul> <p>Improvement</p> <ul> <li>Allow json file in open data widget</li> <li>Added five notebook tutorials</li> <li>Fixed folium map custom size bug #21</li> </ul>"},{"location":"changelog/#v020-jun-5-2021","title":"v0.2.0 - Jun 5, 2021","text":"<p>New Features:</p> <ul> <li>Added handle-draw function #2</li> <li>Added split-panel map #7</li> <li>Added GeoPandas support #16</li> <li>Added support for PostGIS #15</li> <li>Added support for downloading OpenStreetMap data #10 #12</li> </ul> <p>Improvement</p> <ul> <li>Fixed basemap bug #5</li> <li>Fixed output scroll bug #11</li> <li>Changed COG and STAC functions to snake_case</li> <li>Added binder badge to notebooks</li> <li>Added binder env</li> <li>Added 15 tutorials</li> <li>Added domain name leafmap.org</li> </ul>"},{"location":"changelog/#v010-may-25-2021","title":"v0.1.0 - May 25, 2021","text":"<p>New Features:</p> <ul> <li>Create an interactive map with only one-line of code.</li> <li>Select from a variety of basemaps interactively without coding.</li> <li>Add XYZ and WMS tile services to the map.</li> <li>Convert CSV to points and display points as a marker cluster.</li> <li>Add local vector data (e.g., shapefile, GeoJSON, KML) to the map without coding.</li> <li>Add local raster data (e.g., GeoTIFF) to the map without coding.</li> <li>Add Cloud Optimized GeoTIFF (COG) and SpatialTemporal Asset Catalog (STAC) to the map.</li> <li>Add custom legends and colorbars to the map.</li> <li>Perform geospatial analysis using WhiteboxTools and whiteboxgui.</li> <li>Publish interactive maps with only one line of code.</li> </ul>"},{"location":"changelog_update/","title":"Changelog update","text":"In\u00a0[1]: Copied! <pre>import re\n</pre> import re In\u00a0[2]: Copied! <pre># Copy the release notes from the GitHub release page\nmarkdown_text = \"\"\"\n## What's Changed\n* Add 3d terrain style by @giswqs in https://github.com/opengeos/leafmap/pull/779\n\n\n**Full Changelog**: https://github.com/opengeos/leafmap/compare/v0.34.1...v0.34.2\n\"\"\"\n</pre> # Copy the release notes from the GitHub release page markdown_text = \"\"\" ## What's Changed * Add 3d terrain style by @giswqs in https://github.com/opengeos/leafmap/pull/779   **Full Changelog**: https://github.com/opengeos/leafmap/compare/v0.34.1...v0.34.2 \"\"\" In\u00a0[3]: Copied! <pre># Regular expression pattern to match the Markdown hyperlinks\npattern = r\"https://github\\.com/opengeos/leafmap/pull/(\\d+)\"\n</pre> # Regular expression pattern to match the Markdown hyperlinks pattern = r\"https://github\\.com/opengeos/leafmap/pull/(\\d+)\" In\u00a0[4]: Copied! <pre># Function to replace matched URLs with the desired format\ndef replace_url(match):\n    pr_number = match.group(1)\n    return f\"[#{pr_number}](https://github.com/opengeos/leafmap/pull/{pr_number})\"\n</pre> # Function to replace matched URLs with the desired format def replace_url(match):     pr_number = match.group(1)     return f\"[#{pr_number}](https://github.com/opengeos/leafmap/pull/{pr_number})\" In\u00a0[5]: Copied! <pre># Use re.sub to replace URLs with the desired format\nformatted_text = re.sub(pattern, replace_url, markdown_text)\n</pre> # Use re.sub to replace URLs with the desired format formatted_text = re.sub(pattern, replace_url, markdown_text) In\u00a0[6]: Copied! <pre>for line in formatted_text.splitlines():\n    if \"Full Changelog\" in line:\n        prefix = line.split(\": \")[0]\n        link = line.split(\": \")[1]\n        version = line.split(\"/\")[-1]\n        formatted_text = (\n            formatted_text.replace(line, f\"{prefix}: [{version}]({link})\")\n            .replace(\"## What's Changed\", \"**What's Changed**\")\n            .replace(\"## New Contributors\", \"**New Contributors**\")\n        )\n</pre> for line in formatted_text.splitlines():     if \"Full Changelog\" in line:         prefix = line.split(\": \")[0]         link = line.split(\": \")[1]         version = line.split(\"/\")[-1]         formatted_text = (             formatted_text.replace(line, f\"{prefix}: [{version}]({link})\")             .replace(\"## What's Changed\", \"**What's Changed**\")             .replace(\"## New Contributors\", \"**New Contributors**\")         ) In\u00a0[7]: Copied! <pre>with open(\"docs/changelog_update.md\", \"w\") as f:\n    f.write(formatted_text)\n</pre> with open(\"docs/changelog_update.md\", \"w\") as f:     f.write(formatted_text) In\u00a0[8]: Copied! <pre># Print the formatted text\nprint(formatted_text)\n</pre> # Print the formatted text print(formatted_text) <pre>\n**What's Changed**\n* Add 3d terrain style by @giswqs in [#779](https://github.com/opengeos/leafmap/pull/779)\n\n\n**Full Changelog**: [v0.34.1...v0.34.2](https://github.com/opengeos/leafmap/compare/v0.34.1...v0.34.2)\n\n</pre> <p>Copy the formatted text and paste it to the CHANGELOG.md file</p>"},{"location":"colormaps/","title":"colormaps module","text":"<p>Module for commonly used colormaps and palettes for visualizing geospatial data.</p>"},{"location":"colormaps/#leafmap.colormaps.create_colormap","title":"<code>create_colormap(cmap='gray', colors=None, discrete=False, label=None, width=8.0, height=0.4, orientation='horizontal', vmin=0, vmax=1.0, axis_off=False, show_name=False, font_size=12, **kwargs)</code>","text":"<p>Plot a matplotlib colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>colors</code> <code>list</code> <p>A list of custom colors to create a colormap. Defaults to None.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 8.0.</p> <code>8.0</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1.0</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn axis off. Defaults to False.</p> <code>False</code> <code>show_name</code> <code>bool</code> <p>Whether to show the colormap name. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size of the text. Defaults to 12.</p> <code>12</code> Source code in <code>leafmap/colormaps.py</code> <pre><code>def create_colormap(\n    cmap: Optional[str] = \"gray\",\n    colors: Optional[List] = None,\n    discrete: Optional[bool] = False,\n    label: Optional[str] = None,\n    width: Optional[float] = 8.0,\n    height: Optional[float] = 0.4,\n    orientation: Optional[str] = \"horizontal\",\n    vmin: Optional[float] = 0,\n    vmax: Optional[float] = 1.0,\n    axis_off: Optional[bool] = False,\n    show_name: Optional[bool] = False,\n    font_size: Optional[int] = 12,\n    **kwargs\n):\n    \"\"\"Plot a matplotlib colormap.\n\n    Args:\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        colors (list, optional): A list of custom colors to create a colormap. Defaults to None.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        width (float, optional): The width of the colormap. Defaults to 8.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        axis_off (bool, optional): Whether to turn axis off. Defaults to False.\n        show_name (bool, optional): Whether to show the colormap name. Defaults to False.\n        font_size (int, optional): Font size of the text. Defaults to 12.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(width, height))\n\n    if colors is not None and (isinstance(colors, list) or isinstance(colors, tuple)):\n        hexcodes = to_hex_colors(list(colors))\n        if discrete:\n            col_map = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, col_map.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, col_map.N)\n\n        else:\n            col_map = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n    else:\n        col_map = mpl.colormaps[cmap]\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, cmap=col_map, orientation=orientation, **kwargs\n    )\n\n    if label is not None and isinstance(label, str):\n        cb.set_label(label, fontsize=font_size)\n\n    if axis_off:\n        ax.set_axis_off()\n    ax.tick_params(labelsize=font_size)\n\n    if show_name:\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, cmap, va=\"center\", ha=\"right\", fontsize=font_size)\n\n    return fig\n</code></pre>"},{"location":"colormaps/#leafmap.colormaps.get_colorbar","title":"<code>get_colorbar(colors, vmin=0, vmax=1, width=6.0, height=0.4, orientation='horizontal', discrete=False)</code>","text":"<p>Creates a colorbar based on custom colors.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex colors.</p> required <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1</code> <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 6.0.</p> <code>6.0</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colormap.</p> <code>False</code> Source code in <code>leafmap/colormaps.py</code> <pre><code>def get_colorbar(\n    colors: List,\n    vmin: Optional[float] = 0,\n    vmax: Optional[float] = 1,\n    width: Optional[float] = 6.0,\n    height: Optional[float] = 0.4,\n    orientation: Optional[str] = \"horizontal\",\n    discrete: Optional[bool] = False,\n):\n    \"\"\"Creates a colorbar based on custom colors.\n\n    Args:\n        colors (list): A list of hex colors.\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        width (float, optional): The width of the colormap. Defaults to 6.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        discrete (bool, optional): Whether to create a discrete colormap.\n    \"\"\"\n    hexcodes = [i if i[0] == \"#\" else \"#\" + i for i in colors]\n    _, ax = plt.subplots(figsize=(width, height))\n    if discrete:\n        cmap = mpl.colors.ListedColormap(hexcodes)\n        vals = np.linspace(vmin, vmax, cmap.N + 1)\n        norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n    else:\n        cmap = mpl.colors.LinearSegmentedColormap.from_list(\"custom\", hexcodes, N=256)\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n    mpl.colorbar.ColorbarBase(ax, norm=norm, cmap=cmap, orientation=orientation)\n    plt.show()\n</code></pre>"},{"location":"colormaps/#leafmap.colormaps.get_palette","title":"<code>get_palette(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>leafmap/colormaps.py</code> <pre><code>def get_palette(\n    cmap_name: Optional[str] = None,\n    n_class: Optional[int] = None,\n    hashtag: Optional[bool] = False,\n) -&gt; List:\n    \"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n\n    if cmap_name in [\"dem\", \"ndvi\", \"ndwi\"]:\n        colors = _palette_dict[cmap_name]\n    else:\n        cmap = mpl.colormaps[cmap_name]  # Retrieve colormap\n        if n_class:\n            colors = [\n                mpl.colors.rgb2hex(cmap(i / (n_class - 1)))[1:] for i in range(n_class)\n            ]\n        else:\n            colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n    return colors\n</code></pre>"},{"location":"colormaps/#leafmap.colormaps.list_colormaps","title":"<code>list_colormaps(add_extra=False, lowercase=False)</code>","text":"<p>List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of colormap names.</p> Source code in <code>leafmap/colormaps.py</code> <pre><code>def list_colormaps(add_extra: bool = False, lowercase: bool = False) -&gt; List:\n    \"\"\"List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Returns:\n        list: The list of colormap names.\n    \"\"\"\n    result = plt.colormaps()\n    if add_extra:\n        result += [\"dem\", \"ndvi\", \"ndwi\"]\n    if lowercase:\n        result = [i.lower() for i in result]\n    result.sort()\n    return result\n</code></pre>"},{"location":"colormaps/#leafmap.colormaps.plot_colormap","title":"<code>plot_colormap(cmap='gray', colors=None, discrete=False, label=None, width=8.0, height=0.4, orientation='horizontal', vmin=0, vmax=1.0, axis_off=False, show_name=False, font_size=12, **kwargs)</code>","text":"<p>Plot a matplotlib colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>colors</code> <code>list</code> <p>A list of custom colors to create a colormap. Defaults to None.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 8.0.</p> <code>8.0</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1.0</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn axis off. Defaults to False.</p> <code>False</code> <code>show_name</code> <code>bool</code> <p>Whether to show the colormap name. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size of the text. Defaults to 12.</p> <code>12</code> Source code in <code>leafmap/colormaps.py</code> <pre><code>def plot_colormap(\n    cmap: Optional[str] = \"gray\",\n    colors: Optional[List] = None,\n    discrete: Optional[bool] = False,\n    label: Optional[str] = None,\n    width: Optional[float] = 8.0,\n    height: Optional[float] = 0.4,\n    orientation: Optional[str] = \"horizontal\",\n    vmin: Optional[float] = 0,\n    vmax: Optional[float] = 1.0,\n    axis_off: Optional[bool] = False,\n    show_name: Optional[bool] = False,\n    font_size: Optional[int] = 12,\n    **kwargs\n):\n    \"\"\"Plot a matplotlib colormap.\n\n    Args:\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        colors (list, optional): A list of custom colors to create a colormap. Defaults to None.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        width (float, optional): The width of the colormap. Defaults to 8.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        axis_off (bool, optional): Whether to turn axis off. Defaults to False.\n        show_name (bool, optional): Whether to show the colormap name. Defaults to False.\n        font_size (int, optional): Font size of the text. Defaults to 12.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(width, height))\n\n    if colors is not None and (isinstance(colors, list) or isinstance(colors, tuple)):\n        hexcodes = to_hex_colors(list(colors))\n        if discrete:\n            col_map = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, col_map.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, col_map.N)\n\n        else:\n            col_map = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n    else:\n        col_map = mpl.colormaps[cmap]\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, cmap=col_map, orientation=orientation, **kwargs\n    )\n\n    if label is not None and isinstance(label, str):\n        cb.set_label(label, fontsize=font_size)\n\n    if axis_off:\n        ax.set_axis_off()\n    ax.tick_params(labelsize=font_size)\n\n    if show_name:\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, cmap, va=\"center\", ha=\"right\", fontsize=font_size)\n\n    plt.show()\n</code></pre>"},{"location":"colormaps/#leafmap.colormaps.plot_colormaps","title":"<code>plot_colormaps(width=8.0, height=0.4, return_fig=False, **kwargs)</code>","text":"<p>Plot all available colormaps.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the colormap. Defaults to 8.0.</p> <code>8.0</code> <code>height</code> <code>float</code> <p>Height of the colormap. Defaults to 0.4.</p> <code>0.4</code> <code>return_fig</code> <code>bool</code> <p>Whether to return the figure. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/colormaps.py</code> <pre><code>def plot_colormaps(\n    width: Optional[float] = 8.0,\n    height: Optional[float] = 0.4,\n    return_fig: Optional[bool] = False,\n    **kwargs\n):\n    \"\"\"Plot all available colormaps.\n\n    Args:\n        width (float, optional): Width of the colormap. Defaults to 8.0.\n        height (float, optional): Height of the colormap. Defaults to 0.4.\n        return_fig (bool, optional): Whether to return the figure. Defaults to False.\n    \"\"\"\n    cmap_list = list_colormaps()\n    nrows = len(cmap_list)\n    fig, axes = plt.subplots(nrows=nrows, figsize=(width, height * nrows))\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)\n\n    gradient = np.linspace(0, 1, 256)\n    gradient = np.vstack((gradient, gradient))\n\n    for ax, name in zip(axes, cmap_list):\n        ax.imshow(gradient, aspect=\"auto\", cmap=mpl.colormaps[name])\n        ax.set_axis_off()\n        pos = list(ax.get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2.0\n        fig.text(x_text, y_text, name, va=\"center\", ha=\"right\", fontsize=12)\n\n    # Turn off *all* ticks &amp; spines, not just the ones with colormaps.\n    for ax in axes:\n        ax.set_axis_off()\n\n    if return_fig:\n        return fig\n    else:\n        plt.show()\n</code></pre>"},{"location":"common/","title":"common module","text":"<p>This module contains some common functions for both folium and ipyleaflet.</p>"},{"location":"common/#leafmap.common.The_national_map_USGS","title":"<code> The_national_map_USGS        </code>","text":"<p>The national map is a collection of topological datasets, maintained by the USGS.</p> <p>It provides an API endpoint which can be used to find downloadable links for the products offered.     - Full description of datasets available can retrieved.       This consists of metadata such as detail description and publication dates.     - A wide range of dataformats are available</p> <p>This class is a tiny wrapper to find and download files using the API.</p> <p>More complete documentation for the API can be found at     https://apps.nationalmap.gov/tnmaccess/#/</p> Source code in <code>leafmap/common.py</code> <pre><code>class The_national_map_USGS:\n    \"\"\"\n    The national map is a collection of topological datasets, maintained by the USGS.\n\n    It provides an API endpoint which can be used to find downloadable links for the products offered.\n        - Full description of datasets available can retrieved.\n          This consists of metadata such as detail description and publication dates.\n        - A wide range of dataformats are available\n\n    This class is a tiny wrapper to find and download files using the API.\n\n    More complete documentation for the API can be found at\n        https://apps.nationalmap.gov/tnmaccess/#/\n    \"\"\"\n\n    def __init__(self):\n        self.api_endpoint = r\"https://tnmaccess.nationalmap.gov/api/v1/\"\n        self.DS = self.datasets_full\n\n    @property\n    def datasets_full(self) -&gt; list:\n        \"\"\"\n        Full description of datasets provided.\n        Returns a JSON or empty list.\n        \"\"\"\n        link = f\"{self.api_endpoint}datasets?\"\n        try:\n            return requests.get(link).json()\n        except Exception:\n            print(f\"Failed to load metadata from The National Map API endpoint\\n{link}\")\n            return []\n\n    @property\n    def prodFormats(self) -&gt; list:\n        \"\"\"\n        Return all datatypes available in any of the collections.\n        Note that \"All\" is only peculiar to one dataset.\n        \"\"\"\n        return set(i[\"displayName\"] for ds in self.DS for i in ds[\"formats\"])\n\n    @property\n    def datasets(self) -&gt; list:\n        \"\"\"\n        Returns a list of dataset tags (most common human readable self description for specific datasets).\n        \"\"\"\n        return set(y[\"sbDatasetTag\"] for x in self.DS for y in x[\"tags\"])\n\n    def parse_region(self, region, geopandas_args={}) -&gt; list:\n        \"\"\"\n\n        Translate a Vector dataset to its bounding box.\n\n        Args:\n            region (str | list): an URL|filepath to a vector dataset to a polygon\n            geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(region, str):\n            if region.startswith(\"http\"):\n                region = github_raw_url(region)\n                region = download_file(region)\n            elif not os.path.exists(region):\n                raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n            roi = gpd.read_file(region, **geopandas_args)\n            roi = roi.to_crs(epsg=4326)\n            return roi.total_bounds\n        return region\n\n    def download_tiles(\n        self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n    ) -&gt; None:\n        \"\"\"\n\n        Download the US National Elevation Datasets (NED) for a region.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API. Defaults to {}.\n\n        Returns:\n            None\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        if out_dir is None:\n            out_dir = os.getcwd()\n        else:\n            out_dir = os.path.abspath(out_dir)\n\n        tiles = self.find_tiles(\n            region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n        )\n        T = len(tiles)\n        errors = 0\n        done = 0\n\n        for i, link in enumerate(tiles):\n            file_name = os.path.basename(link)\n            out_name = os.path.join(out_dir, file_name)\n            if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n                print(f\"Downloading {i+1} of {T}: {file_name}\")\n            try:\n                download_file(link, out_name, **download_args)\n                done += 1\n            except KeyboardInterrupt:\n                print(\"Cancelled download\")\n                break\n            except Exception:\n                errors += 1\n                print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n        print(\n            f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n        )\n        return\n\n    def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n        \"\"\"\n        Find a list of downloadable files.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API parameters. Defaults to {}.\n\n        Returns:\n            list: A list of download_urls.\n            dict: A dictionary with urls and related metadata\n        \"\"\"\n        assert region or API, \"Provide a region or use the API\"\n\n        if region:\n            API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n        results = self.find_details(**API)\n        if return_type == \"list\":\n            return [i[\"downloadURL\"] for i in results.get(\"items\")]\n        return results\n\n    def find_details(\n        self,\n        bbox: List[float] = None,\n        polygon: List[Tuple[float, float]] = None,\n        datasets: str = None,\n        prodFormats: str = None,\n        prodExtents: str = None,\n        q: str = None,\n        dateType: str = None,\n        start: str = None,\n        end: str = None,\n        offset: int = 0,\n        max: int = None,\n        outputFormat: str = \"JSON\",\n        polyType: str = None,\n        polyCode: str = None,\n        extentQuery: int = None,\n    ) -&gt; Dict:\n        \"\"\"\n        Possible search parameters (kwargs) support by API\n\n        Parameter               Values\n            Description\n        ---------------------------------------------------------------------------------------------------\n        bbox                    'minx, miny, maxx, maxy'\n            Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n        polygon                 '[x,y x,y x,y x,y x,y]'\n            Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n        datasets                See: Datasets (Optional)\n            Dataset tag name (sbDatasetTag)\n            From https://apps.nationalmap.gov/tnmaccess/#/product\n        prodFormats             See: Product Formats (Optional)\n            Dataset-specific format\n\n        prodExtents             See: Product Extents (Optional)\n            Dataset-specific extent\n        q                       free text\n            Text input which can be used to filter by product titles and text descriptions.\n        dateType                dateCreated | lastUpdated | Publication\n            Type of date to search by.\n        start                   'YYYY-MM-DD'\n            Start date\n        end                     'YYYY-MM-DD'\n            End date (required if start date is provided)\n        offset                  integer\n            Offset into paginated results - default=0\n        max                     integer\n            Number of results returned\n        outputFormat            JSON | CSV | pjson\n            Default=JSON\n        polyType                state | huc2 | huc4 | huc8\n            Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n            (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n        polyCode                state FIPS code or huc number\n            Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n        extentQuery             integer\n            A Polygon code in the science base system, typically from an uploaded shapefile\n        \"\"\"\n\n        try:\n            # call locals before creating new locals\n            used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n            # Parsing\n            if polygon:\n                used_locals[\"polygon\"] = \",\".join(\n                    \" \".join(map(str, point)) for point in polygon\n                )\n            if bbox:\n                used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n            if max:\n                max += 2\n\n            # Fetch response\n            response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n            if response.status_code // 100 == 2:\n                return response.json()\n            else:\n                # Parameter validation handled by API endpoint error responses\n                print(response.json())\n            return {}\n        except Exception as e:\n            print(e)\n            return {}\n</code></pre>"},{"location":"common/#leafmap.common.The_national_map_USGS.datasets","title":"<code>datasets: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns a list of dataset tags (most common human readable self description for specific datasets).</p>"},{"location":"common/#leafmap.common.The_national_map_USGS.datasets_full","title":"<code>datasets_full: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Full description of datasets provided. Returns a JSON or empty list.</p>"},{"location":"common/#leafmap.common.The_national_map_USGS.prodFormats","title":"<code>prodFormats: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Return all datatypes available in any of the collections. Note that \"All\" is only peculiar to one dataset.</p>"},{"location":"common/#leafmap.common.The_national_map_USGS.download_tiles","title":"<code>download_tiles(self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_tiles(\n    self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n) -&gt; None:\n    \"\"\"\n\n    Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API. Defaults to {}.\n\n    Returns:\n        None\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    tiles = self.find_tiles(\n        region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n    )\n    T = len(tiles)\n    errors = 0\n    done = 0\n\n    for i, link in enumerate(tiles):\n        file_name = os.path.basename(link)\n        out_name = os.path.join(out_dir, file_name)\n        if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n            print(f\"Downloading {i+1} of {T}: {file_name}\")\n        try:\n            download_file(link, out_name, **download_args)\n            done += 1\n        except KeyboardInterrupt:\n            print(\"Cancelled download\")\n            break\n        except Exception:\n            errors += 1\n            print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n    print(\n        f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n    )\n    return\n</code></pre>"},{"location":"common/#leafmap.common.The_national_map_USGS.find_details","title":"<code>find_details(self, bbox=None, polygon=None, datasets=None, prodFormats=None, prodExtents=None, q=None, dateType=None, start=None, end=None, offset=0, max=None, outputFormat='JSON', polyType=None, polyCode=None, extentQuery=None)</code>","text":"<p>Possible search parameters (kwargs) support by API</p> <p>Parameter               Values     Description</p> <p>bbox                    'minx, miny, maxx, maxy'     Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list. polygon                 '[x,y x,y x,y x,y x,y]'     Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list. datasets                See: Datasets (Optional)     Dataset tag name (sbDatasetTag)     From https://apps.nationalmap.gov/tnmaccess/#/product prodFormats             See: Product Formats (Optional)     Dataset-specific format</p> <p>prodExtents             See: Product Extents (Optional)     Dataset-specific extent q                       free text     Text input which can be used to filter by product titles and text descriptions. dateType                dateCreated | lastUpdated | Publication     Type of date to search by. start                   'YYYY-MM-DD'     Start date end                     'YYYY-MM-DD'     End date (required if start date is provided) offset                  integer     Offset into paginated results - default=0 max                     integer     Number of results returned outputFormat            JSON | CSV | pjson     Default=JSON polyType                state | huc2 | huc4 | huc8     Well Known Polygon Type. Use this parameter to deliver data by state or HUC     (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD) polyCode                state FIPS code or huc number     Well Known Polygon Code. This value needs to coordinate with the polyType parameter. extentQuery             integer     A Polygon code in the science base system, typically from an uploaded shapefile</p> Source code in <code>leafmap/common.py</code> <pre><code>def find_details(\n    self,\n    bbox: List[float] = None,\n    polygon: List[Tuple[float, float]] = None,\n    datasets: str = None,\n    prodFormats: str = None,\n    prodExtents: str = None,\n    q: str = None,\n    dateType: str = None,\n    start: str = None,\n    end: str = None,\n    offset: int = 0,\n    max: int = None,\n    outputFormat: str = \"JSON\",\n    polyType: str = None,\n    polyCode: str = None,\n    extentQuery: int = None,\n) -&gt; Dict:\n    \"\"\"\n    Possible search parameters (kwargs) support by API\n\n    Parameter               Values\n        Description\n    ---------------------------------------------------------------------------------------------------\n    bbox                    'minx, miny, maxx, maxy'\n        Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n    polygon                 '[x,y x,y x,y x,y x,y]'\n        Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n    datasets                See: Datasets (Optional)\n        Dataset tag name (sbDatasetTag)\n        From https://apps.nationalmap.gov/tnmaccess/#/product\n    prodFormats             See: Product Formats (Optional)\n        Dataset-specific format\n\n    prodExtents             See: Product Extents (Optional)\n        Dataset-specific extent\n    q                       free text\n        Text input which can be used to filter by product titles and text descriptions.\n    dateType                dateCreated | lastUpdated | Publication\n        Type of date to search by.\n    start                   'YYYY-MM-DD'\n        Start date\n    end                     'YYYY-MM-DD'\n        End date (required if start date is provided)\n    offset                  integer\n        Offset into paginated results - default=0\n    max                     integer\n        Number of results returned\n    outputFormat            JSON | CSV | pjson\n        Default=JSON\n    polyType                state | huc2 | huc4 | huc8\n        Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n        (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n    polyCode                state FIPS code or huc number\n        Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n    extentQuery             integer\n        A Polygon code in the science base system, typically from an uploaded shapefile\n    \"\"\"\n\n    try:\n        # call locals before creating new locals\n        used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n        # Parsing\n        if polygon:\n            used_locals[\"polygon\"] = \",\".join(\n                \" \".join(map(str, point)) for point in polygon\n            )\n        if bbox:\n            used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n        if max:\n            max += 2\n\n        # Fetch response\n        response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n        if response.status_code // 100 == 2:\n            return response.json()\n        else:\n            # Parameter validation handled by API endpoint error responses\n            print(response.json())\n        return {}\n    except Exception as e:\n        print(e)\n        return {}\n</code></pre>"},{"location":"common/#leafmap.common.The_national_map_USGS.find_tiles","title":"<code>find_tiles(self, region=None, return_type='list', geopandas_args={}, API={})</code>","text":"<p>Find a list of downloadable files.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> required <code>return_type</code> <code>str</code> <p>list | dict. Defaults to list. Changes the return output type and content.</p> <code>'list'</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API parameters. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of download_urls. dict: A dictionary with urls and related metadata</p> Source code in <code>leafmap/common.py</code> <pre><code>def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n    \"\"\"\n    Find a list of downloadable files.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API parameters. Defaults to {}.\n\n    Returns:\n        list: A list of download_urls.\n        dict: A dictionary with urls and related metadata\n    \"\"\"\n    assert region or API, \"Provide a region or use the API\"\n\n    if region:\n        API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n    results = self.find_details(**API)\n    if return_type == \"list\":\n        return [i[\"downloadURL\"] for i in results.get(\"items\")]\n    return results\n</code></pre>"},{"location":"common/#leafmap.common.The_national_map_USGS.parse_region","title":"<code>parse_region(self, region, geopandas_args={})</code>","text":"<p>Translate a Vector dataset to its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>an URL|filepath to a vector dataset to a polygon</p> required <code>geopandas_reader_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def parse_region(self, region, geopandas_args={}) -&gt; list:\n    \"\"\"\n\n    Translate a Vector dataset to its bounding box.\n\n    Args:\n        region (str | list): an URL|filepath to a vector dataset to a polygon\n        geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(region, str):\n        if region.startswith(\"http\"):\n            region = github_raw_url(region)\n            region = download_file(region)\n        elif not os.path.exists(region):\n            raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n        roi = gpd.read_file(region, **geopandas_args)\n        roi = roi.to_crs(epsg=4326)\n        return roi.total_bounds\n    return region\n</code></pre>"},{"location":"common/#leafmap.common.WhiteboxTools","title":"<code> WhiteboxTools            (WhiteboxTools)         </code>","text":"<p>This class inherits the whitebox WhiteboxTools class.</p> Source code in <code>leafmap/common.py</code> <pre><code>class WhiteboxTools(whitebox.WhiteboxTools):\n    \"\"\"This class inherits the whitebox WhiteboxTools class.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.__install_from_github","title":"<code>__install_from_github(url)</code>","text":"<p>Install a package from a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the GitHub repository.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def __install_from_github(url: str):\n    \"\"\"Install a package from a GitHub repository.\n\n    Args:\n        url (str): The URL of the GitHub repository.\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n\n        repo_name = os.path.basename(url)\n        zip_url = os.path.join(url, \"archive/master.zip\")\n        filename = repo_name + \"-master.zip\"\n        download_from_url(\n            url=zip_url, out_file_name=filename, out_dir=download_dir, unzip=True\n        )\n\n        pkg_dir = os.path.join(download_dir, repo_name + \"-master\")\n        pkg_name = os.path.basename(url)\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n        print(\"Installing {}...\".format(pkg_name))\n        cmd = \"pip install .\"\n        os.system(cmd)\n        os.chdir(work_dir)\n        print(\"{} has been installed successfully.\".format(pkg_name))\n        # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\")\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.add_crs","title":"<code>add_crs(filename, epsg)</code>","text":"<p>Add a CRS to a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the raster dataset.</p> required <code>epsg</code> <code>int | str</code> <p>The EPSG code of the CRS.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def add_crs(filename, epsg):\n    \"\"\"Add a CRS to a raster dataset.\n\n    Args:\n        filename (str): The filename of the raster dataset.\n        epsg (int | str): The EPSG code of the CRS.\n\n    \"\"\"\n    try:\n        import rasterio\n    except ImportError:\n        raise ImportError(\n            \"rasterio is required for adding a CRS to a raster. Please install it using 'pip install rasterio'.\"\n        )\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    if isinstance(epsg, int):\n        epsg = f\"EPSG:{epsg}\"\n    elif isinstance(epsg, str):\n        epsg = \"EPSG:\" + epsg\n    else:\n        raise ValueError(\"epsg must be an integer or string.\")\n\n    crs = rasterio.crs.CRS({\"init\": epsg})\n    with rasterio.open(filename, mode=\"r+\") as src:\n        src.crs = crs\n</code></pre>"},{"location":"common/#leafmap.common.add_image_to_gif","title":"<code>add_image_to_gif(in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False)</code>","text":"<p>Adds an image logo to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>Input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>Output file path to the GIF image.</p> required <code>in_image</code> <code>str</code> <p>Input file path to the image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>image_size</code> <code>tuple</code> <p>Resize image. Defaults to (80, 80).</p> <code>(80, 80)</code> <code>circle_mask</code> <code>bool</code> <p>Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/common.py</code> <pre><code>def add_image_to_gif(\n    in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False\n):\n    \"\"\"Adds an image logo to a GIF image.\n\n    Args:\n        in_gif (str): Input file path to the GIF image.\n        out_gif (str): Output file path to the GIF image.\n        in_image (str): Input file path to the image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        image_size (tuple, optional): Resize image. Defaults to (80, 80).\n        circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n\n    is_url = False\n    if in_image.startswith(\"http\"):\n        is_url = True\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if (not is_url) and (not os.path.exists(in_image)):\n        print(\"The provided logo file does not exist.\")\n        return\n\n    out_dir = check_dir((os.path.dirname(out_gif)))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        gif = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the image.\")\n        print(e)\n        return\n\n    logo_raw_image = None\n    try:\n        if in_image.startswith(\"http\"):\n            logo_raw_image = open_image_from_url(in_image)\n        else:\n            in_image = os.path.abspath(in_image)\n            logo_raw_image = Image.open(in_image)\n    except Exception as e:\n        print(e)\n\n    logo_raw_size = logo_raw_image.size\n\n    ratio = max(\n        logo_raw_size[0] / image_size[0],\n        logo_raw_size[1] / image_size[1],\n    )\n    image_resize = (int(logo_raw_size[0] / ratio), int(logo_raw_size[1] / ratio))\n    image_size = min(logo_raw_size[0], image_size[0]), min(\n        logo_raw_size[1], image_size[1]\n    )\n\n    logo_image = logo_raw_image.convert(\"RGBA\")\n    logo_image.thumbnail(image_size, Image.ANTIALIAS)\n\n    gif_width, gif_height = gif.size\n    mask_im = None\n\n    if circle_mask:\n        mask_im = Image.new(\"L\", image_size, 0)\n        draw = ImageDraw.Draw(mask_im)\n        draw.ellipse((0, 0, image_size[0], image_size[1]), fill=255)\n\n    if has_transparency(logo_raw_image):\n        mask_im = logo_image.copy()\n\n    if xy is None:\n        # default logo location is 5% width and 5% height of the image.\n        delta = 10\n        xy = (gif_width - image_resize[0] - delta, gif_height - image_resize[1] - delta)\n        # xy = (int(0.05 * gif_width), int(0.05 * gif_height))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; gif_width) and (y &gt; 0) and (y &lt; gif_height):\n            pass\n        else:\n            print(\n                \"xy is out of bounds. x must be within [0, {}], and y must be within [0, {}]\".format(\n                    gif_width, gif_height\n                )\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * gif_width)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * gif_height)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    try:\n        frames = []\n        for _, frame in enumerate(ImageSequence.Iterator(gif)):\n            frame = frame.convert(\"RGBA\")\n            frame.paste(logo_image, xy, mask_im)\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n            frames.append(frame)\n\n        frames[0].save(out_gif, save_all=True, append_images=frames[1:])\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.add_mask_to_image","title":"<code>add_mask_to_image(image, mask, output, color='red')</code>","text":"<p>Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A local path or HTTP URL to an image.</p> required <code>mask</code> <code>str</code> <p>A local path or HTTP URL to a binary mask.</p> required <code>output</code> <code>str</code> <p>A local path to the output image.</p> required <code>color</code> <code>str</code> <p>Color of the mask. Defaults to 'red'.</p> <code>'red'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rasterio and detectron2 are not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def add_mask_to_image(image, mask, output, color=\"red\"):\n    \"\"\"Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.\n\n    Args:\n        image (str): A local path or HTTP URL to an image.\n        mask (str): A local path or HTTP URL to a binary mask.\n        output (str): A local path to the output image.\n        color (str, optional): Color of the mask. Defaults to 'red'.\n\n    Raises:\n        ImportError: If rasterio and detectron2 are not installed.\n    \"\"\"\n    try:\n        import rasterio\n        from detectron2.utils.visualizer import Visualizer\n        from PIL import Image\n    except ImportError:\n        raise ImportError(\n            \"Please install rasterio and detectron2 to use this function. See https://detectron2.readthedocs.io/en/latest/tutorials/install.html\"\n        )\n\n    ds = rasterio.open(image)\n    image_arr = ds.read()\n\n    mask_arr = rasterio.open(mask).read()\n\n    vis = Visualizer(image_arr.transpose((1, 2, 0)))\n    vis.draw_binary_mask(mask_arr[0] &gt; 0, color=color)\n\n    out_arr = Image.fromarray(vis.get_output().get_image())\n\n    out_arr.save(output)\n\n    if ds.crs is not None:\n        numpy_to_cog(output, output, profile=image)\n</code></pre>"},{"location":"common/#leafmap.common.add_progress_bar_to_gif","title":"<code>add_progress_bar_to_gif(in_gif, out_gif, progress_bar_color='blue', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds a progress bar to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>leafmap/common.py</code> <pre><code>def add_progress_bar_to_gif(\n    in_gif,\n    out_gif,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds a progress bar to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        raise Exception(\"An error occurred while opening the gif.\")\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.add_text_to_gif","title":"<code>add_text_to_gif(in_gif, out_gif, xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#000000', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds animated text to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#000000'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>leafmap/common.py</code> <pre><code>def add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=None,\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#000000\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds animated text to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    import pkg_resources\n    from PIL import Image, ImageDraw, ImageFont, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    default_font = os.path.join(pkg_dir, \"data/fonts/arial.ttf\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if font_type == \"arial.ttf\":\n        font = ImageFont.truetype(default_font, font_size)\n    elif font_type == \"alibaba.otf\":\n        default_font = os.path.join(pkg_dir, \"data/fonts/alibaba.otf\")\n        font = ImageFont.truetype(default_font, font_size)\n    else:\n        try:\n            font_list = system_fonts(show_full_path=True)\n            font_names = [os.path.basename(f) for f in font_list]\n            if (font_type in font_list) or (font_type in font_names):\n                font = ImageFont.truetype(font_type, font_size)\n            else:\n                print(\n                    \"The specified font type could not be found on your system. Using the default font instead.\"\n                )\n                font = ImageFont.truetype(default_font, font_size)\n        except Exception as e:\n            print(e)\n            font = ImageFont.truetype(default_font, font_size)\n\n    color = check_color(font_color)\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the gif.\")\n        print(e)\n        return\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * W)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * H)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        print(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n        return\n\n    if text_sequence is None:\n        text = [str(x) for x in range(1, count + 1)]\n    elif isinstance(text_sequence, int):\n        text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n    elif isinstance(text_sequence, str):\n        try:\n            text_sequence = int(text_sequence)\n            text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n        except Exception:\n            text = [text_sequence] * count\n    elif isinstance(text_sequence, list) and len(text_sequence) != count:\n        print(\n            f\"The length of the text sequence must be equal to the number ({count}) of frames in the gif.\"\n        )\n        return\n    else:\n        text = [str(x) for x in text_sequence]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.text(xy, text[index], font=font, fill=color)\n            if add_progress_bar:\n                draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.adjust_longitude","title":"<code>adjust_longitude(in_fc)</code>","text":"<p>Adjusts longitude if it is less than -180 or greater than 180.</p> <p>Parameters:</p> Name Type Description Default <code>in_fc</code> <code>dict</code> <p>The input dictionary containing coordinates.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the converted longitudes</p> Source code in <code>leafmap/common.py</code> <pre><code>def adjust_longitude(in_fc):\n    \"\"\"Adjusts longitude if it is less than -180 or greater than 180.\n\n    Args:\n        in_fc (dict): The input dictionary containing coordinates.\n\n    Returns:\n        dict: A dictionary containing the converted longitudes\n    \"\"\"\n    try:\n        keys = in_fc.keys()\n\n        if \"geometry\" in keys:\n            coordinates = in_fc[\"geometry\"][\"coordinates\"]\n\n            if in_fc[\"geometry\"][\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"geometry\"][\"coordinates\"][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"geometry\"][\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"geometry\"][\"coordinates\"][index][0] = longitude\n\n        elif \"type\" in keys:\n            coordinates = in_fc[\"coordinates\"]\n\n            if in_fc[\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"coordinates\"][0] = longitude\n\n            elif in_fc[\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"coordinates\"][index][0] = longitude\n\n        return in_fc\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#leafmap.common.arc_active_map","title":"<code>arc_active_map()</code>","text":"<p>Get the active map in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.Map</code> <p>The active map in ArcGIS Pro.</p> Source code in <code>leafmap/common.py</code> <pre><code>def arc_active_map():\n    \"\"\"Get the active map in ArcGIS Pro.\n\n    Returns:\n        arcpy.Map: The active map in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        m = aprx.activeMap\n        return m\n    else:\n        return None\n</code></pre>"},{"location":"common/#leafmap.common.arc_active_view","title":"<code>arc_active_view()</code>","text":"<p>Get the active view in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.MapView</code> <p>The active view in ArcGIS Pro.</p> Source code in <code>leafmap/common.py</code> <pre><code>def arc_active_view():\n    \"\"\"Get the active view in ArcGIS Pro.\n\n    Returns:\n        arcpy.MapView: The active view in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        view = aprx.activeView\n        return view\n    else:\n        return None\n</code></pre>"},{"location":"common/#leafmap.common.arc_add_layer","title":"<code>arc_add_layer(url, name=None, shown=True, opacity=1.0)</code>","text":"<p>Add a layer to the active map in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer to add.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>Whether the layer is shown. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>leafmap/common.py</code> <pre><code>def arc_add_layer(url, name=None, shown=True, opacity=1.0):\n    \"\"\"Add a layer to the active map in ArcGIS Pro.\n\n    Args:\n        url (str): The URL of the tile layer to add.\n        name (str, optional): The name of the layer. Defaults to None.\n        shown (bool, optional): Whether the layer is shown. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n    \"\"\"\n    if is_arcpy():\n        m = arc_active_map()\n        if m is not None:\n            m.addDataFromPath(url)\n            if isinstance(name, str):\n                layers = m.listLayers(\"Tiled service layer\")\n                if len(layers) &gt; 0:\n                    layer = layers[0]\n                    layer.name = name\n                    layer.visible = shown\n                    layer.transparency = 100 - (opacity * 100)\n</code></pre>"},{"location":"common/#leafmap.common.arc_zoom_to_bounds","title":"<code>arc_zoom_to_bounds(bounds)</code>","text":"<p>Zoom to a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>leafmap/common.py</code> <pre><code>def arc_zoom_to_bounds(bounds):\n    \"\"\"Zoom to a bounding box.\n\n    Args:\n        bounds (list): The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n\n    if len(bounds) == 4:\n        xmin, ymin, xmax, ymax = bounds\n    elif len(bounds) == 2:\n        (ymin, xmin), (ymax, xmax) = bounds\n    else:\n        raise ValueError(\"bounds must be a tuple of length 2 or 4.\")\n\n    arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"common/#leafmap.common.arc_zoom_to_extent","title":"<code>arc_zoom_to_extent(xmin, ymin, xmax, ymax)</code>","text":"<p>Zoom to an extent in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimum x value of the extent.</p> required <code>ymin</code> <code>float</code> <p>The minimum y value of the extent.</p> required <code>xmax</code> <code>float</code> <p>The maximum x value of the extent.</p> required <code>ymax</code> <code>float</code> <p>The maximum y value of the extent.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def arc_zoom_to_extent(xmin, ymin, xmax, ymax):\n    \"\"\"Zoom to an extent in ArcGIS Pro.\n\n    Args:\n        xmin (float): The minimum x value of the extent.\n        ymin (float): The minimum y value of the extent.\n        xmax (float): The maximum x value of the extent.\n        ymax (float): The maximum y value of the extent.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        view = arc_active_view()\n        if view is not None:\n            view.camera.setExtent(\n                arcpy.Extent(\n                    xmin,\n                    ymin,\n                    xmax,\n                    ymax,\n                    spatial_reference=arcpy.SpatialReference(4326),\n                )\n            )\n\n        # if isinstance(zoom, int):\n        #     scale = 156543.04 * math.cos(0) / math.pow(2, zoom)\n        #     view.camera.scale = scale  # Not working properly\n</code></pre>"},{"location":"common/#leafmap.common.array_to_image","title":"<code>array_to_image(array, output=None, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', **kwargs)</code>","text":"<p>Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The NumPy array to be saved as a GeoTIFF.</p> required <code>output</code> <code>str</code> <p>The path to the output image. If None, a temporary file will be created. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The path to an existing GeoTIFF file with map projection information. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The resolution of the output image in meters. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the output image. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None.</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def array_to_image(\n    array,\n    output: str = None,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver: str = \"COG\",\n    **kwargs,\n) -&gt; str:\n    \"\"\"Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.\n\n    Args:\n        array (np.ndarray): The NumPy array to be saved as a GeoTIFF.\n        output (str): The path to the output image. If None, a temporary file will be created. Defaults to None.\n        source (str, optional): The path to an existing GeoTIFF file with map projection information. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output array. Defaults to None.\n        compress (str, optional): The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The resolution of the output image in meters. Defaults to None.\n        crs (str, optional): The CRS of the output image. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361).\n            Defaults to None.\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    import xarray as xr\n    from rasterio.transform import Affine\n\n    if output is None:\n        return array_to_memory_file(\n            array,\n            source,\n            dtype,\n            compress,\n            transpose,\n            cellsize,\n            crs=crs,\n            transform=transform,\n            driver=driver,\n            **kwargs,\n        )\n\n    if isinstance(array, xr.DataArray):\n        coords = [coord for coord in array.coords]\n        if coords[0] == \"time\":\n            x_dim = coords[1]\n            y_dim = coords[2]\n            array = (\n                array.isel(time=0).rename({y_dim: \"y\", x_dim: \"x\"}).transpose(\"y\", \"x\")\n            )\n        array = array.values\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not output.endswith(\".tif\"):\n        output += \".tif\"\n\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if cellsize is None:\n            raise ValueError(\"resolution must be provided if source is not provided\")\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None:\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n\n    # Create a new GeoTIFF file and write the array to it\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:\n            dst.write(array, 1)\n        elif array.ndim == 3:\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n</code></pre>"},{"location":"common/#leafmap.common.array_to_memory_file","title":"<code>array_to_memory_file(array, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', **kwargs)</code>","text":"<p>Convert a NumPy array to a memory file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>numpy.ndarray</code> <p>The input NumPy array.</p> required <code>source</code> <code>str</code> <p>Path to the source file to extract metadata from. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The desired data type of the array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method for the output file. Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The cell size of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix if source is not provided. Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The rasterio dataset reader object for the converted array.</p> Source code in <code>leafmap/common.py</code> <pre><code>def array_to_memory_file(\n    array,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver=\"COG\",\n    **kwargs,\n):\n    \"\"\"Convert a NumPy array to a memory file.\n\n    Args:\n        array (numpy.ndarray): The input NumPy array.\n        source (str, optional): Path to the source file to extract metadata from. Defaults to None.\n        dtype (str, optional): The desired data type of the array. Defaults to None.\n        compress (str, optional): The compression method for the output file. Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The cell size of the array if source is not provided. Defaults to None.\n        crs (str, optional): The coordinate reference system of the array if source is not provided. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix if source is not provided.\n            Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n\n    Returns:\n        rasterio.DatasetReader: The rasterio dataset reader object for the converted array.\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import xarray as xr\n    from rasterio.transform import Affine\n\n    if isinstance(array, xr.DataArray):\n        coords = [coord for coord in array.coords]\n        if coords[0] == \"time\":\n            x_dim = coords[1]\n            y_dim = coords[2]\n            array = (\n                array.isel(time=0).rename({y_dim: \"y\", x_dim: \"x\"}).transpose(\"y\", \"x\")\n            )\n        if hasattr(array, \"rio\"):\n            if hasattr(array.rio, \"crs\"):\n                crs = array.rio.crs\n            if transform is None and hasattr(array.rio, \"transform\"):\n                transform = array.rio.transform()\n        elif source is None:\n            if hasattr(array, \"encoding\"):\n                if \"source\" in array.encoding:\n                    source = array.encoding[\"source\"]\n        array = array.values\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            if cellsize is None:\n                raise ValueError(\"cellsize must be provided if source is not provided\")\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            # (west, south, east, north, width, height)\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None:\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n\n    # Create a new memory file and write the array to it\n    memory_file = rasterio.MemoryFile()\n    dst = memory_file.open(**metadata)\n\n    if array.ndim == 2:\n        dst.write(array, 1)\n    elif array.ndim == 3:\n        for i in range(array.shape[2]):\n            dst.write(array[:, :, i], i + 1)\n\n    dst.close()\n\n    # Read the dataset from memory\n    dataset_reader = rasterio.open(dst.name, mode=\"r\")\n\n    return dataset_reader\n</code></pre>"},{"location":"common/#leafmap.common.assign_continuous_colors","title":"<code>assign_continuous_colors(df, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None, to_rgb=True, return_type='array', return_legend=False)</code>","text":"<p>Assigns continuous colors to a DataFrame column based on a specified scheme.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>A pandas DataFrame.</p> required <code>column</code> <code>str</code> <p>The name of the column to assign colors.</p> required <code>cmap</code> <code>str</code> <p>The name of the colormap to use.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of custom colors.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of custom labels for the legend.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>The scheme for classifying the data. Default is 'Quantiles'.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>The number of classes for classification.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the classification.</p> <code>None</code> <code>to_rgb</code> <code>bool</code> <p>Whether to convert colors to RGB values. Default is True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Default is 'array'.</p> <code>'array'</code> <code>return_legend</code> <code>bool</code> <p>Whether to return the legend. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <p>The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.</p> Source code in <code>leafmap/common.py</code> <pre><code>def assign_continuous_colors(\n    df,\n    column: str,\n    cmap: str = None,\n    colors: list = None,\n    labels: list = None,\n    scheme: str = \"Quantiles\",\n    k: int = 5,\n    legend_kwds: dict = None,\n    classification_kwds: dict = None,\n    to_rgb: bool = True,\n    return_type: str = \"array\",\n    return_legend: bool = False,\n):\n    \"\"\"Assigns continuous colors to a DataFrame column based on a specified scheme.\n\n    Args:\n        df: A pandas DataFrame.\n        column: The name of the column to assign colors.\n        cmap: The name of the colormap to use.\n        colors: A list of custom colors.\n        labels: A list of custom labels for the legend.\n        scheme: The scheme for classifying the data. Default is 'Quantiles'.\n        k: The number of classes for classification.\n        legend_kwds: Additional keyword arguments for configuring the legend.\n        classification_kwds: Additional keyword arguments for configuring the classification.\n        to_rgb: Whether to convert colors to RGB values. Default is True.\n        return_type: The type of the returned values. Default is 'array'.\n        return_legend: Whether to return the legend. Default is False.\n\n    Returns:\n        The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.\n    \"\"\"\n    import numpy as np\n\n    data = df[[column]].copy()\n    new_df, legend = classify(\n        data, column, cmap, colors, labels, scheme, k, legend_kwds, classification_kwds\n    )\n    values = new_df[\"color\"].values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    if return_legend:\n        return values, legend\n    else:\n        return values\n</code></pre>"},{"location":"common/#leafmap.common.assign_discrete_colors","title":"<code>assign_discrete_colors(df, column, cmap, to_rgb=True, return_type='array')</code>","text":"<p>Assigns unique colors to each category in a categorical column of a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input dataframe.</p> required <code>column</code> <code>str</code> <p>The name of the categorical column.</p> required <code>cmap</code> <code>dict</code> <p>A dictionary mapping categories to colors.</p> required <code>to_rgb</code> <code>bool</code> <p>Whether to convert the colors to RGB values. Defaults to True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.</p> <code>'array'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of colors for each category in the categorical column.</p> Source code in <code>leafmap/common.py</code> <pre><code>def assign_discrete_colors(df, column, cmap, to_rgb=True, return_type=\"array\"):\n    \"\"\"\n    Assigns unique colors to each category in a categorical column of a dataframe.\n\n    Args:\n        df (pandas.DataFrame): The input dataframe.\n        column (str): The name of the categorical column.\n        cmap (dict): A dictionary mapping categories to colors.\n        to_rgb (bool): Whether to convert the colors to RGB values. Defaults to True.\n        return_type (str): The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.\n\n    Returns:\n        list: A list of colors for each category in the categorical column.\n    \"\"\"\n    import numpy as np\n\n    # Copy the categorical column from the original dataframe\n    category_column = df[column].copy()\n\n    # Map colors to the categorical values\n    category_column = category_column.map(cmap)\n\n    values = category_column.values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    return values\n</code></pre>"},{"location":"common/#leafmap.common.basemap_xyz_tiles","title":"<code>basemap_xyz_tiles()</code>","text":"<p>Returns a dictionary containing a set of basemaps that are XYZ tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of XYZ tile layers.</p> Source code in <code>leafmap/common.py</code> <pre><code>def basemap_xyz_tiles():\n    \"\"\"Returns a dictionary containing a set of basemaps that are XYZ tile layers.\n\n    Returns:\n        dict: A dictionary of XYZ tile layers.\n    \"\"\"\n    from .leafmap import basemaps\n\n    layers_dict = {}\n    keys = dict(basemaps).keys()\n    for key in keys:\n        if isinstance(basemaps[key], ipyleaflet.WMSLayer):\n            pass\n        else:\n            layers_dict[key] = basemaps[key]\n    return layers_dict\n</code></pre>"},{"location":"common/#leafmap.common.bbox_to_gdf","title":"<code>bbox_to_gdf(bbox, crs='epsg:4326')</code>","text":"<p>Convert a bounding box to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>crs</code> <code>str</code> <p>The CRS of the bounding box. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with a single polygon.</p> Source code in <code>leafmap/common.py</code> <pre><code>def bbox_to_gdf(bbox, crs=\"epsg:4326\"):\n    \"\"\"Convert a bounding box to a GeoPandas GeoDataFrame.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        crs (str, optional): The CRS of the bounding box. Defaults to 'epsg:4326'.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame with a single polygon.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    return gpd.GeoDataFrame(\n        geometry=[Polygon.from_bounds(*bbox)],\n        crs=crs,\n    )\n</code></pre>"},{"location":"common/#leafmap.common.bbox_to_geojson","title":"<code>bbox_to_geojson(bounds)</code>","text":"<p>Convert coordinates of a bounding box to a geojson.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list of coordinates representing [left, bottom, right, top] or m.bounds.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson feature.</p> Source code in <code>leafmap/common.py</code> <pre><code>def bbox_to_geojson(bounds):\n    \"\"\"Convert coordinates of a bounding box to a geojson.\n\n    Args:\n        bounds (list | tuple): A list of coordinates representing [left, bottom, right, top] or m.bounds.\n\n    Returns:\n        dict: A geojson feature.\n    \"\"\"\n\n    if isinstance(bounds, tuple) and len(bounds) == 2:\n        bounds = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    return {\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        },\n        \"type\": \"Feature\",\n    }\n</code></pre>"},{"location":"common/#leafmap.common.bbox_to_polygon","title":"<code>bbox_to_polygon(bbox)</code>","text":"<p>Convert a bounding box to a shapely Polygon.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>A shapely Polygon.</p> Source code in <code>leafmap/common.py</code> <pre><code>def bbox_to_polygon(bbox):\n    \"\"\"Convert a bounding box to a shapely Polygon.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n\n    Returns:\n        Polygon: A shapely Polygon.\n    \"\"\"\n    from shapely.geometry import Polygon\n\n    return Polygon.from_bounds(*bbox)\n</code></pre>"},{"location":"common/#leafmap.common.blend_images","title":"<code>blend_images(img1, img2, alpha=0.5, output=False, show=True, figsize=(12, 10), axis='off', **kwargs)</code>","text":"<p>Blends two images together using the addWeighted function from the OpenCV library.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>numpy.ndarray</code> <p>The first input image on top represented as a NumPy array.</p> required <code>img2</code> <code>numpy.ndarray</code> <p>The second input image at the bottom represented as a NumPy array.</p> required <code>alpha</code> <code>float</code> <p>The weighting factor for the first image in the blend. By default, this is set to 0.5.</p> <code>0.5</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display the blended image. Defaults to True.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>axis</code> <code>str</code> <p>The axis of the figure. Defaults to \"off\".</p> <code>'off'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the cv2.addWeighted() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>The blended image as a NumPy array.</p> Source code in <code>leafmap/common.py</code> <pre><code>def blend_images(\n    img1,\n    img2,\n    alpha=0.5,\n    output=False,\n    show=True,\n    figsize=(12, 10),\n    axis=\"off\",\n    **kwargs,\n):\n    \"\"\"\n    Blends two images together using the addWeighted function from the OpenCV library.\n\n    Args:\n        img1 (numpy.ndarray): The first input image on top represented as a NumPy array.\n        img2 (numpy.ndarray): The second input image at the bottom represented as a NumPy array.\n        alpha (float): The weighting factor for the first image in the blend. By default, this is set to 0.5.\n        output (str, optional): The path to the output image. Defaults to False.\n        show (bool, optional): Whether to display the blended image. Defaults to True.\n        figsize (tuple, optional): The size of the figure. Defaults to (12, 10).\n        axis (str, optional): The axis of the figure. Defaults to \"off\".\n        **kwargs: Additional keyword arguments to pass to the cv2.addWeighted() function.\n\n    Returns:\n        numpy.ndarray: The blended image as a NumPy array.\n    \"\"\"\n    import cv2\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # Resize the images to have the same dimensions\n    if isinstance(img1, str):\n        if img1.startswith(\"http\"):\n            img1 = download_file(img1)\n\n        if not os.path.exists(img1):\n            raise ValueError(f\"Input path {img1} does not exist.\")\n\n        img1 = cv2.imread(img1)\n\n    if isinstance(img2, str):\n        if img2.startswith(\"http\"):\n            img2 = download_file(img2)\n\n        if not os.path.exists(img2):\n            raise ValueError(f\"Input path {img2} does not exist.\")\n\n        img2 = cv2.imread(img2)\n\n    if img1.dtype == np.float32:\n        img1 = (img1 * 255).astype(np.uint8)\n\n    if img2.dtype == np.float32:\n        img2 = (img2 * 255).astype(np.uint8)\n\n    if img1.dtype != img2.dtype:\n        img2 = img2.astype(img1.dtype)\n\n    img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))\n\n    # Blend the images using the addWeighted function\n    beta = 1 - alpha\n    blend_img = cv2.addWeighted(img1, alpha, img2, beta, 0, **kwargs)\n\n    if output:\n        array_to_image(blend_img, output, img2)\n\n    if show:\n        plt.figure(figsize=figsize)\n        plt.imshow(blend_img)\n        plt.axis(axis)\n        plt.show()\n    else:\n        return blend_img\n</code></pre>"},{"location":"common/#leafmap.common.bounds_to_xy_range","title":"<code>bounds_to_xy_range(bounds)</code>","text":"<p>Convert bounds to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>leafmap/common.py</code> <pre><code>def bounds_to_xy_range(bounds):\n    \"\"\"Convert bounds to x and y range to be used as input to bokeh map.\n\n    Args:\n        bounds (list): A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(bounds, tuple):\n        bounds = list(bounds)\n    elif not isinstance(bounds, list):\n        raise TypeError(\"bounds must be a list\")\n\n    if len(bounds) == 4:\n        west, south, east, north = bounds\n    elif len(bounds) == 2:\n        south, west = bounds[0]\n        north, east = bounds[1]\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n    return x_range, y_range\n</code></pre>"},{"location":"common/#leafmap.common.center_zoom_to_xy_range","title":"<code>center_zoom_to_xy_range(center, zoom)</code>","text":"<p>Convert center and zoom to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>A tuple of (latitude, longitude).</p> required <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>leafmap/common.py</code> <pre><code>def center_zoom_to_xy_range(center, zoom):\n    \"\"\"Convert center and zoom to x and y range to be used as input to bokeh map.\n\n    Args:\n        center (tuple): A tuple of (latitude, longitude).\n        zoom (int): The zoom level.\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(center, tuple) or isinstance(center, list):\n        pass\n    else:\n        raise TypeError(\"center must be a tuple or list\")\n\n    if not isinstance(zoom, int):\n        raise TypeError(\"zoom must be an integer\")\n\n    latitude, longitude = center\n    x_range = (-179, 179)\n    y_range = (-70, 70)\n    x_full_length = x_range[1] - x_range[0]\n    y_full_length = y_range[1] - y_range[0]\n\n    x_length = x_full_length / 2 ** (zoom - 2)\n    y_length = y_full_length / 2 ** (zoom - 2)\n\n    south = latitude - y_length / 2\n    north = latitude + y_length / 2\n    west = longitude - x_length / 2\n    east = longitude + x_length / 2\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n\n    return x_range, y_range\n</code></pre>"},{"location":"common/#leafmap.common.cesium_to_streamlit","title":"<code>cesium_to_streamlit(html, width=800, height=600, responsive=True, scrolling=False, token_name=None, token_value=None, **kwargs)</code>","text":"<p>Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML file to render. It can a local file path or a URL.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>token_name</code> <code>str</code> <p>The name of the token in the HTML file to be replaced. Defaults to None.</p> <code>None</code> <code>token_value</code> <code>str</code> <p>The value of the token to pass to the HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def cesium_to_streamlit(\n    html,\n    width=800,\n    height=600,\n    responsive=True,\n    scrolling=False,\n    token_name=None,\n    token_value=None,\n    **kwargs,\n):\n    \"\"\"Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        html (str): The HTML file to render. It can a local file path or a URL.\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        token_name (str, optional): The name of the token in the HTML file to be replaced. Defaults to None.\n        token_value (str, optional): The value of the token to pass to the HTML file. Defaults to None.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n    if token_name is None:\n        token_name = \"your_access_token\"\n\n    if token_value is None:\n        token_value = os.environ.get(\"CESIUM_TOKEN\")\n\n    html_to_streamlit(\n        html, width, height, responsive, scrolling, token_name, token_value\n    )\n</code></pre>"},{"location":"common/#leafmap.common.check_cmap","title":"<code>check_cmap(cmap)</code>","text":"<p>Check the colormap and return a list of colors.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | list | Box</code> <p>The colormap to check.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of colors.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_cmap(cmap):\n    \"\"\"Check the colormap and return a list of colors.\n\n    Args:\n        cmap (str | list | Box): The colormap to check.\n\n    Returns:\n        list: A list of colors.\n    \"\"\"\n\n    from box import Box\n    from .colormaps import get_palette\n\n    if isinstance(cmap, str):\n        try:\n            return get_palette(cmap)\n        except Exception as e:\n            raise Exception(f\"{cmap} is not a valid colormap.\")\n    elif isinstance(cmap, Box):\n        return list(cmap[\"default\"])\n    elif isinstance(cmap, list) or isinstance(cmap, tuple):\n        return cmap\n    else:\n        raise Exception(f\"{cmap} is not a valid colormap.\")\n</code></pre>"},{"location":"common/#leafmap.common.check_color","title":"<code>check_color(in_color)</code>","text":"<p>Checks the input color and returns the corresponding hex color code.</p> <p>Parameters:</p> Name Type Description Default <code>in_color</code> <code>str or tuple or list</code> <p>It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex color code.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_color(in_color: Union[str, Tuple]) -&gt; str:\n    \"\"\"Checks the input color and returns the corresponding hex color code.\n\n    Args:\n            in_color (str or tuple or list): It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).\n\n    Returns:\n        str: A hex color code.\n    \"\"\"\n    import colour\n\n    out_color = \"#000000\"  # default black color\n    if (isinstance(in_color, tuple) or isinstance(in_color, list)) and len(\n        in_color\n    ) == 3:\n        # rescale color if necessary\n        if all(isinstance(item, int) for item in in_color):\n            in_color = [c / 255.0 for c in in_color]\n\n        return colour.Color(rgb=tuple(in_color)).hex_l\n\n    else:\n        # try to guess the color system\n        try:\n            return colour.Color(in_color).hex_l\n\n        except Exception as e:\n            pass\n\n        # try again by adding an extra # (GEE handle hex codes without #)\n        try:\n            return colour.Color(f\"#{in_color}\").hex_l\n\n        except Exception as e:\n            print(\n                f\"The provided color ({in_color}) is invalid. Using the default black color.\"\n            )\n            print(e)\n\n        return out_color\n</code></pre>"},{"location":"common/#leafmap.common.check_dir","title":"<code>check_dir(dir_path, make_dirs=True)</code>","text":"<p>Checks if a directory exists and creates it if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>[str</code> <p>The path to the directory.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the directory.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_dir(dir_path, make_dirs=True):\n    \"\"\"Checks if a directory exists and creates it if it does not.\n\n    Args:\n        dir_path ([str): The path to the directory.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The path to the directory.\n    \"\"\"\n\n    if isinstance(dir_path, str):\n        if dir_path.startswith(\"~\"):\n            dir_path = os.path.expanduser(dir_path)\n        else:\n            dir_path = os.path.abspath(dir_path)\n\n        if not os.path.exists(dir_path) and make_dirs:\n            os.makedirs(dir_path)\n\n        if os.path.exists(dir_path):\n            return dir_path\n        else:\n            raise FileNotFoundError(\"The provided directory could not be found.\")\n    else:\n        raise TypeError(\"The provided directory path must be a string.\")\n</code></pre>"},{"location":"common/#leafmap.common.check_file_path","title":"<code>check_file_path(file_path, make_dirs=True)</code>","text":"<p>Gets the absolute file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The absolute path to the file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_file_path(file_path, make_dirs=True):\n    \"\"\"Gets the absolute file path.\n\n    Args:\n        file_path (str): The path to the file.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The absolute path to the file.\n    \"\"\"\n    if isinstance(file_path, str):\n        if file_path.startswith(\"~\"):\n            file_path = os.path.expanduser(file_path)\n        else:\n            file_path = os.path.abspath(file_path)\n\n        file_dir = os.path.dirname(file_path)\n        if not os.path.exists(file_dir) and make_dirs:\n            os.makedirs(file_dir)\n\n        return file_path\n\n    else:\n        raise TypeError(\"The provided file path must be a string.\")\n</code></pre>"},{"location":"common/#leafmap.common.check_html_string","title":"<code>check_html_string(html_string)</code>","text":"<p>Check if an HTML string contains local images and convert them to base64.</p> <p>Parameters:</p> Name Type Description Default <code>html_string</code> <code>str</code> <p>The HTML string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML string with local images converted to base64.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_html_string(html_string):\n    \"\"\"Check if an HTML string contains local images and convert them to base64.\n\n    Args:\n        html_string (str): The HTML string.\n\n    Returns:\n        str: The HTML string with local images converted to base64.\n    \"\"\"\n    import re\n    import base64\n\n    # Search for img tags with src attribute\n    img_regex = r'&lt;img[^&gt;]+src\\s*=\\s*[\"\\']([^\"\\':]+)[\"\\'][^&gt;]*&gt;'\n\n    for match in re.findall(img_regex, html_string):\n        with open(match, \"rb\") as img_file:\n            img_data = img_file.read()\n            base64_data = base64.b64encode(img_data).decode(\"utf-8\")\n            html_string = html_string.replace(\n                'src=\"{}\"'.format(match),\n                'src=\"data:image/png;base64,' + base64_data + '\"',\n            )\n\n    return html_string\n</code></pre>"},{"location":"common/#leafmap.common.check_url","title":"<code>check_url(url)</code>","text":"<p>Check if an HTTP URL is working.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the URL is working (returns a 200 status code), False otherwise.</p> Source code in <code>leafmap/common.py</code> <pre><code>def check_url(url: str) -&gt; bool:\n    \"\"\"Check if an HTTP URL is working.\n\n    Args:\n        url (str): The URL to check.\n\n    Returns:\n        bool: True if the URL is working (returns a 200 status code), False otherwise.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except requests.exceptions.RequestException:\n        return False\n</code></pre>"},{"location":"common/#leafmap.common.classify","title":"<code>classify(data, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None)</code>","text":"<p>Classify a dataframe column using a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame, dict</code> <p>A pandas dataframe with the classification applied and a legend dictionary.</p> Source code in <code>leafmap/common.py</code> <pre><code>def classify(\n    data,\n    column,\n    cmap=None,\n    colors=None,\n    labels=None,\n    scheme=\"Quantiles\",\n    k=5,\n    legend_kwds=None,\n    classification_kwds=None,\n):\n    \"\"\"Classify a dataframe column using a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n\n    Returns:\n        pd.DataFrame, dict: A pandas dataframe with the classification applied and a legend dictionary.\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        import mapclassify\n    except ImportError:\n        raise ImportError(\n            \"mapclassify is required for this function. Install with `pip install mapclassify`.\"\n        )\n\n    if (\n        isinstance(data, gpd.GeoDataFrame)\n        or isinstance(data, pd.DataFrame)\n        or isinstance(data, pd.Series)\n    ):\n        df = data\n    else:\n        try:\n            df = gpd.read_file(data)\n        except Exception:\n            raise TypeError(\n                \"Data must be a GeoDataFrame or a path to a file that can be read by geopandas.read_file().\"\n            )\n\n    if df.empty:\n        warnings.warn(\n            \"The GeoDataFrame you are attempting to plot is \"\n            \"empty. Nothing has been displayed.\",\n            UserWarning,\n        )\n        return\n\n    columns = df.columns.values.tolist()\n    if column not in columns:\n        raise ValueError(\n            f\"{column} is not a column in the GeoDataFrame. It must be one of {columns}.\"\n        )\n\n    # Convert categorical data to numeric\n    init_column = None\n    value_list = None\n    if np.issubdtype(df[column].dtype, np.object0):\n        value_list = df[column].unique().tolist()\n        value_list.sort()\n        df[\"category\"] = df[column].replace(value_list, range(0, len(value_list)))\n        init_column = column\n        column = \"category\"\n        k = len(value_list)\n\n    if legend_kwds is not None:\n        legend_kwds = legend_kwds.copy()\n\n    # To accept pd.Series and np.arrays as column\n    if isinstance(column, (np.ndarray, pd.Series)):\n        if column.shape[0] != df.shape[0]:\n            raise ValueError(\n                \"The dataframe and given column have different number of rows.\"\n            )\n        else:\n            values = column\n\n            # Make sure index of a Series matches index of df\n            if isinstance(values, pd.Series):\n                values = values.reindex(df.index)\n    else:\n        values = df[column]\n\n    values = df[column]\n    nan_idx = np.asarray(pd.isna(values), dtype=\"bool\")\n\n    if cmap is None:\n        cmap = \"Blues\"\n    try:\n        cmap = plt.get_cmap(cmap, k)\n    except:\n        cmap = plt.cm.get_cmap(cmap, k)\n    if colors is None:\n        colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n        colors = [\"#\" + i for i in colors]\n    elif isinstance(colors, list):\n        colors = [check_color(i) for i in colors]\n    elif isinstance(colors, str):\n        colors = [check_color(colors)] * k\n\n    allowed_schemes = [\n        \"BoxPlot\",\n        \"EqualInterval\",\n        \"FisherJenks\",\n        \"FisherJenksSampled\",\n        \"HeadTailBreaks\",\n        \"JenksCaspall\",\n        \"JenksCaspallForced\",\n        \"JenksCaspallSampled\",\n        \"MaxP\",\n        \"MaximumBreaks\",\n        \"NaturalBreaks\",\n        \"Quantiles\",\n        \"Percentiles\",\n        \"StdMean\",\n        \"UserDefined\",\n    ]\n\n    if scheme.lower() not in [s.lower() for s in allowed_schemes]:\n        raise ValueError(\n            f\"{scheme} is not a valid scheme. It must be one of {allowed_schemes}.\"\n        )\n\n    if classification_kwds is None:\n        classification_kwds = {}\n    if \"k\" not in classification_kwds:\n        classification_kwds[\"k\"] = k\n\n    binning = mapclassify.classify(\n        np.asarray(values[~nan_idx]), scheme, **classification_kwds\n    )\n    df[\"category\"] = binning.yb\n    df[\"color\"] = [colors[i] for i in df[\"category\"]]\n\n    if legend_kwds is None:\n        legend_kwds = {}\n\n    if \"interval\" not in legend_kwds:\n        legend_kwds[\"interval\"] = True\n\n    if \"fmt\" not in legend_kwds:\n        if np.issubdtype(df[column].dtype, np.floating):\n            legend_kwds[\"fmt\"] = \"{:.2f}\"\n        else:\n            legend_kwds[\"fmt\"] = \"{:.0f}\"\n\n    if labels is None:\n        # set categorical to True for creating the legend\n        if legend_kwds is not None and \"labels\" in legend_kwds:\n            if len(legend_kwds[\"labels\"]) != binning.k:\n                raise ValueError(\n                    \"Number of labels must match number of bins, \"\n                    \"received {} labels for {} bins\".format(\n                        len(legend_kwds[\"labels\"]), binning.k\n                    )\n                )\n            else:\n                labels = list(legend_kwds.pop(\"labels\"))\n        else:\n            # fmt = \"{:.2f}\"\n            if legend_kwds is not None and \"fmt\" in legend_kwds:\n                fmt = legend_kwds.pop(\"fmt\")\n\n            labels = binning.get_legend_classes(fmt)\n            if legend_kwds is not None:\n                show_interval = legend_kwds.pop(\"interval\", False)\n            else:\n                show_interval = False\n            if not show_interval:\n                labels = [c[1:-1] for c in labels]\n\n        if init_column is not None:\n            labels = value_list\n    elif isinstance(labels, list):\n        if len(labels) != len(colors):\n            raise ValueError(\"The number of labels must match the number of colors.\")\n    else:\n        raise ValueError(\"labels must be a list or None.\")\n\n    legend_dict = dict(zip(labels, colors))\n    df[\"category\"] = df[\"category\"] + 1\n    return df, legend_dict\n</code></pre>"},{"location":"common/#leafmap.common.clip_image","title":"<code>clip_image(image, mask, output, to_cog=True)</code>","text":"<p>Clip an image by mask.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file in GeoTIFF format.</p> required <code>mask</code> <code>str | list | dict</code> <p>The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>to_cog</code> <code>bool</code> <p>Flags to indicate if you want to convert the output to COG. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the fiona or rasterio package is not installed.</p> <code>FileNotFoundError</code> <p>If the image is not found.</p> <code>ValueError</code> <p>If the mask is not a valid GeoJSON or raster file.</p> <code>FileNotFoundError</code> <p>If the mask file is not found.</p> Source code in <code>leafmap/common.py</code> <pre><code>def clip_image(image, mask, output, to_cog=True):\n    \"\"\"Clip an image by mask.\n\n    Args:\n        image (str): Path to the image file in GeoTIFF format.\n        mask (str | list | dict): The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.\n        output (str): Path to the output file.\n        to_cog (bool, optional): Flags to indicate if you want to convert the output to COG. Defaults to True.\n\n    Raises:\n        ImportError: If the fiona or rasterio package is not installed.\n        FileNotFoundError: If the image is not found.\n        ValueError: If the mask is not a valid GeoJSON or raster file.\n        FileNotFoundError: If the mask file is not found.\n    \"\"\"\n    try:\n        import json\n        import fiona\n        import rasterio\n        import rasterio.mask\n    except ImportError as e:\n        raise ImportError(e)\n\n    if not os.path.exists(image):\n        raise FileNotFoundError(f\"{image} does not exist.\")\n\n    if not output.endswith(\".tif\"):\n        raise ValueError(\"Output must be a tif file.\")\n\n    output = check_file_path(output)\n\n    if isinstance(mask, str):\n        if mask.startswith(\"http\"):\n            mask = download_file(mask, output)\n        if not os.path.exists(mask):\n            raise FileNotFoundError(f\"{mask} does not exist.\")\n    elif isinstance(mask, list) or isinstance(mask, dict):\n        if isinstance(mask, list):\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [mask]},\n                    }\n                ],\n            }\n        else:\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [mask],\n            }\n        mask = temp_file_path(\".geojson\")\n        with open(mask, \"w\") as f:\n            json.dump(geojson, f)\n\n    with fiona.open(mask, \"r\") as shapefile:\n        shapes = [feature[\"geometry\"] for feature in shapefile]\n\n    with rasterio.open(image) as src:\n        out_image, out_transform = rasterio.mask.mask(src, shapes, crop=True)\n        out_meta = src.meta\n\n    out_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform,\n        }\n    )\n\n    with rasterio.open(output, \"w\", **out_meta) as dest:\n        dest.write(out_image)\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#leafmap.common.cog_validate","title":"<code>cog_validate(source, verbose=False)</code>","text":"<p>Validate Cloud Optimized Geotiff.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path or URL. Will be opened in \"r\" mode.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print the output of the validation. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the rio-cogeo package is not installed.</p> <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).</p> Source code in <code>leafmap/common.py</code> <pre><code>def cog_validate(source, verbose=False):\n    \"\"\"Validate Cloud Optimized Geotiff.\n\n    Args:\n        source (str): A dataset path or URL. Will be opened in \"r\" mode.\n        verbose (bool, optional): Whether to print the output of the validation. Defaults to False.\n\n    Raises:\n        ImportError: If the rio-cogeo package is not installed.\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        tuple: A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_validate, cog_info\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if verbose:\n        return cog_info(source)\n    else:\n        return cog_validate(source)\n</code></pre>"},{"location":"common/#leafmap.common.connect_postgis","title":"<code>connect_postgis(database, host='localhost', user=None, password=None, port=5432, use_env_var=False)</code>","text":"<p>Connects to a PostGIS database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Name of the database</p> required <code>host</code> <code>str</code> <p>Hosting server for the database. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>user</code> <code>str</code> <p>User name to access the database. Defaults to None.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password to access the database. Defaults to None.</p> <code>None</code> <code>port</code> <code>int</code> <p>Port number to connect to at the server host. Defaults to 5432.</p> <code>5432</code> <code>use_env_var</code> <code>bool</code> <p>Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If user is not specified.</p> <code>ValueError</code> <p>If password is not specified.</p> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>leafmap/common.py</code> <pre><code>def connect_postgis(\n    database, host=\"localhost\", user=None, password=None, port=5432, use_env_var=False\n):\n    \"\"\"Connects to a PostGIS database.\n\n    Args:\n        database (str): Name of the database\n        host (str, optional): Hosting server for the database. Defaults to \"localhost\".\n        user (str, optional): User name to access the database. Defaults to None.\n        password (str, optional): Password to access the database. Defaults to None.\n        port (int, optional): Port number to connect to at the server host. Defaults to 5432.\n        use_env_var (bool, optional): Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.\n\n    Raises:\n        ValueError: If user is not specified.\n        ValueError: If password is not specified.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    check_package(\n        name=\"sqlalchemy\",\n        URL=\"https://docs.sqlalchemy.org/en/14/intro.html#installation\",\n    )\n\n    from sqlalchemy import create_engine\n\n    if use_env_var:\n        if user is not None:\n            user = os.getenv(user)\n        else:\n            user = os.getenv(\"SQL_USER\")\n\n        if password is not None:\n            password = os.getenv(password)\n        else:\n            password = os.getenv(\"SQL_PASSWORD\")\n\n        if user is None:\n            raise ValueError(\"user is not specified.\")\n        if password is None:\n            raise ValueError(\"password is not specified.\")\n\n    connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n    engine = create_engine(connection_string)\n\n    return engine\n</code></pre>"},{"location":"common/#leafmap.common.convert_coordinates","title":"<code>convert_coordinates(x, y, source_crs, target_crs='epsg:4326')</code>","text":"<p>Convert coordinates from the source EPSG code to the target EPSG code.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p> required <code>source_crs</code> <code>str</code> <p>The EPSG code of the source coordinate system.</p> required <code>target_crs</code> <code>str</code> <p>The EPSG code of the target coordinate system. Defaults to '4326' (EPSG code for WGS84).</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the converted longitude and latitude.</p> Source code in <code>leafmap/common.py</code> <pre><code>def convert_coordinates(x, y, source_crs, target_crs=\"epsg:4326\"):\n    \"\"\"Convert coordinates from the source EPSG code to the target EPSG code.\n\n    Args:\n        x (float): The x-coordinate of the point.\n        y (float): The y-coordinate of the point.\n        source_crs (str): The EPSG code of the source coordinate system.\n        target_crs (str, optional): The EPSG code of the target coordinate system.\n            Defaults to '4326' (EPSG code for WGS84).\n\n    Returns:\n        tuple: A tuple containing the converted longitude and latitude.\n    \"\"\"\n    import pyproj\n\n    # Create the transformer\n    transformer = pyproj.Transformer.from_crs(source_crs, target_crs, always_xy=True)\n\n    # Perform the transformation\n    lon, lat = transformer.transform(x, y)\n\n    # Return the converted coordinates\n    return lon, lat\n</code></pre>"},{"location":"common/#leafmap.common.convert_lidar","title":"<code>convert_lidar(source, destination=None, point_format_id=None, file_version=None, **kwargs)</code>","text":"<p>Converts a Las from one point format to another Automatically upgrades the file version if source file version     is not compatible with the new point_format_id</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be converted.</p> required <code>destination</code> <code>str</code> <p>The destination file path. Defaults to None.</p> <code>None</code> <code>point_format_id</code> <code>int</code> <p>The new point format id (the default is None, which won't change the source format id).</p> <code>None</code> <code>file_version</code> <code>str</code> <p>The new file version. None by default which means that the file_version may be upgraded for compatibility with the new point_format. The file version will not be downgraded.</p> <code>None</code> <p>Returns:</p> Type Description <code>aspy.lasdatas.base.LasBase</code> <p>The converted LasData object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def convert_lidar(\n    source, destination=None, point_format_id=None, file_version=None, **kwargs\n):\n    \"\"\"Converts a Las from one point format to another Automatically upgrades the file version if source file version\n        is not compatible with the new point_format_id\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be converted.\n        destination (str, optional): The destination file path. Defaults to None.\n        point_format_id (int, optional): The new point format id (the default is None, which won't change the source format id).\n        file_version (str, optional): The new file version. None by default which means that the file_version may be upgraded\n            for compatibility with the new point_format. The file version will not be downgraded.\n\n    Returns:\n        aspy.lasdatas.base.LasBase: The converted LasData object.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    las = laspy.convert(\n        source, point_format_id=point_format_id, file_version=file_version\n    )\n\n    if destination is None:\n        return las\n    else:\n        destination = check_file_path(destination)\n        write_lidar(las, destination, **kwargs)\n        return destination\n</code></pre>"},{"location":"common/#leafmap.common.coords_to_geojson","title":"<code>coords_to_geojson(coords)</code>","text":"<p>Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of bbox coordinates representing [left, bottom, right, top].</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson FeatureCollection.</p> Source code in <code>leafmap/common.py</code> <pre><code>def coords_to_geojson(coords):\n    \"\"\"Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.\n\n    Args:\n        coords (list): A list of bbox coordinates representing [left, bottom, right, top].\n\n    Returns:\n        dict: A geojson FeatureCollection.\n    \"\"\"\n\n    features = []\n    for bbox in coords:\n        features.append(bbox_to_geojson(bbox))\n    return {\"type\": \"FeatureCollection\", \"features\": features}\n</code></pre>"},{"location":"common/#leafmap.common.coords_to_vector","title":"<code>coords_to_vector(coords, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Convert a list of coordinates to a GeoDataFrame or a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [(x1, y1), (x2, y2), ...].</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the coordinates. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFraem</code> <p>A GeoDataFrame of the coordinates.</p> Source code in <code>leafmap/common.py</code> <pre><code>def coords_to_vector(coords, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Convert a list of coordinates to a GeoDataFrame or a vector file.\n\n    Args:\n        coords (list): A list of coordinates in the format of [(x1, y1), (x2, y2), ...].\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS of the coordinates. Defaults to \"EPSG:4326\".\n\n    Returns:\n        gpd.GeoDataFraem: A GeoDataFrame of the coordinates.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    if not isinstance(coords, list):\n        raise TypeError(\"coords must be a list of coordinates\")\n\n    if isinstance(coords[0], int) or isinstance(coords[0], float):\n        coords = [(coords[0], coords[1])]\n\n    # convert the points to a GeoDataFrame\n    geometry = [Point(xy) for xy in coords]\n    gdf = gpd.GeoDataFrame(geometry=geometry, crs=\"EPSG:4326\")\n    gdf.to_crs(crs, inplace=True)\n\n    if output is not None:\n        gdf.to_file(output, **kwargs)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#leafmap.common.coords_to_xy","title":"<code>coords_to_xy(src_fp, coords, coord_crs='epsg:4326', request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2], ...]</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>request_payer</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <p>Additional keyword arguments to pass to rasterio.Env.</p> <code>{}</code> <code>open_args</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.transform.rowcol.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>leafmap/common.py</code> <pre><code>def coords_to_xy(\n    src_fp: str,\n    coords: list,\n    coord_crs: str = \"epsg:4326\",\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n) -&gt; list:\n    \"\"\"Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.\n\n    Args:\n        src_fp: The source raster file path.\n        coords: A list of coordinates in the format of [[x1, y1], [x2, y2], ...]\n        coord_crs: The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n        request_payer: Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args: Additional keyword arguments to pass to rasterio.Env.\n        open_args: Additional keyword arguments to pass to rasterio.open.\n        **kwargs: Additional keyword arguments to pass to rasterio.transform.rowcol.\n\n    Returns:\n        A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n    import numpy as np\n    import rasterio\n\n    if isinstance(coords, np.ndarray):\n        coords = coords.tolist()\n\n    if len(coords) == 4 and all([isinstance(c, (int, float)) for c in coords]):\n        coords = [[coords[0], coords[1]], [coords[2], coords[3]]]\n\n    xs, ys = zip(*coords)\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        with rasterio.open(src_fp, **open_args) as src:\n            width = src.width\n            height = src.height\n            if coord_crs != src.crs:\n                xs, ys = transform_coords(xs, ys, coord_crs, src.crs, **kwargs)\n            rows, cols = rasterio.transform.rowcol(src.transform, xs, ys, **kwargs)\n        result = [[col, row] for col, row in zip(cols, rows)]\n\n        result = [\n            [x, y] for x, y in result if x &gt;= 0 and y &gt;= 0 and x &lt; width and y &lt; height\n        ]\n        if len(result) == 0:\n            print(\"No valid pixel coordinates found.\")\n        elif len(result) &lt; len(coords):\n            print(\"Some coordinates are out of the image boundary.\")\n\n        return result\n</code></pre>"},{"location":"common/#leafmap.common.create_code_cell","title":"<code>create_code_cell(code='', where='below')</code>","text":"<p>Creates a code cell in the IPython Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to fill the new code cell with. Defaults to ''.</p> <code>''</code> <code>where</code> <code>str</code> <p>Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.</p> <code>'below'</code> Source code in <code>leafmap/common.py</code> <pre><code>def create_code_cell(code=\"\", where=\"below\"):\n    \"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n\n    # try:\n    #     import pyperclip\n    # except ImportError:\n    #     install_package(\"pyperclip\")\n    #     import pyperclip\n\n    from IPython.display import Javascript, display\n\n    # try:\n    #     pyperclip.copy(str(code))\n    # except Exception as e:\n    #     pass\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n            \"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )\n</code></pre>"},{"location":"common/#leafmap.common.create_download_link","title":"<code>create_download_link(filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path to the file to download</p> required <code>title</code> <code>str</code> <p>str. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML download URL.</p> Source code in <code>leafmap/common.py</code> <pre><code>def create_download_link(filename, title=\"Click here to download: \"):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578\n\n    Args:\n        filename (str): The file path to the file to download\n        title (str, optional): str. Defaults to \"Click here to download: \".\n\n    Returns:\n        str: HTML download URL.\n    \"\"\"\n    import base64\n    from IPython.display import HTML\n\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n    basename = os.path.basename(filename)\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" style=\"color:#0000FF;\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    html = html.format(payload=payload, title=title + f\" {basename}\", filename=basename)\n    return HTML(html)\n</code></pre>"},{"location":"common/#leafmap.common.create_legend","title":"<code>create_legend(title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, output=None, style={})</code>","text":"<p>Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output file path (*.html) to save the legend. Defaults to None.</p> <code>None</code> <code>style</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of the legend.</p> Source code in <code>leafmap/common.py</code> <pre><code>def create_legend(\n    title=\"Legend\",\n    labels=None,\n    colors=None,\n    legend_dict=None,\n    builtin_legend=None,\n    opacity=1.0,\n    position=\"bottomright\",\n    draggable=True,\n    output=None,\n    style={},\n):\n    \"\"\"Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        output (str, optional): The output file path (*.html) to save the legend. Defaults to None.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    Returns:\n        str: The HTML code of the legend.\n    \"\"\"\n\n    import pkg_resources\n    from .legends import builtin_legends\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    legend_template = os.path.join(pkg_dir, \"data/template/legend_style.html\")\n\n    if draggable:\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.txt\")\n\n    if not os.path.exists(legend_template):\n        raise FileNotFoundError(\"The legend template does not exist.\")\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        raise ValueError(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n\n    if position == \"bottomright\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"20px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"bottomleft\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"topright\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n    elif position == \"topleft\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n\n    if \"position\" not in style:\n        style[\"position\"] = \"fixed\"\n    if \"z-index\" not in style:\n        style[\"z-index\"] = \"9999\"\n    if \"background-color\" not in style:\n        style[\"background-color\"] = \"rgba(255, 255, 255, 0.8)\"\n    if \"padding\" not in style:\n        style[\"padding\"] = \"10px\"\n    if \"border-radius\" not in style:\n        style[\"border-radius\"] = \"5px\"\n    if \"font-size\" not in style:\n        style[\"font-size\"] = \"14px\"\n\n    content = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n\n    if draggable:\n        for index, line in enumerate(lines):\n            if index &lt; 36:\n                content.append(line)\n            elif index == 36:\n                line = lines[index].replace(\"Legend\", title)\n                content.append(line)\n            elif index &lt; 39:\n                content.append(line)\n            elif index == 39:\n                for i, color in enumerate(colors):\n                    item = f\"    &lt;li&gt;&lt;span style='background:{check_color(color)};opacity:{opacity};'&gt;&lt;/span&gt;{labels[i]}&lt;/li&gt;\\n\"\n                    content.append(item)\n            elif index &gt; 41:\n                content.append(line)\n        content = content[3:-1]\n\n    else:\n        for index, line in enumerate(lines):\n            if index &lt; 8:\n                content.append(line)\n            elif index == 8:\n                for key, value in style.items():\n                    content.append(\n                        \"              {}: {};\\n\".format(key.replace(\"_\", \"-\"), value)\n                    )\n            elif index &lt; 17:\n                pass\n            elif index &lt; 19:\n                content.append(line)\n            elif index == 19:\n                content.append(line.replace(\"Legend\", title))\n            elif index &lt; 22:\n                content.append(line)\n            elif index == 22:\n                for index, key in enumerate(labels):\n                    color = colors[index]\n                    if not color.startswith(\"#\"):\n                        color = \"#\" + color\n                    item = \"                    &lt;li&gt;&lt;span style='background:{};opacity:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                        color, opacity, key\n                    )\n                    content.append(item)\n            elif index &lt; 33:\n                pass\n            else:\n                content.append(line)\n\n    legend_text = \"\".join(content)\n\n    if output is not None:\n        with open(output, \"w\") as f:\n            f.write(legend_text)\n    else:\n        return legend_text\n</code></pre>"},{"location":"common/#leafmap.common.create_timelapse","title":"<code>create_timelapse(images, out_gif, ext='.tif', bands=None, size=None, bbox=None, fps=5, loop=0, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, add_text=False, text_xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='black', mp4=False, quiet=True, reduce_size=False, clean_up=True, **kwargs)</code>","text":"<p>Creates a timelapse gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from. For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to '.tif'.</p> <code>'.tif'</code> <code>bands</code> <code>list</code> <p>The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.</p> <code>None</code> <code>size</code> <code>tuple</code> <p>The size of the gif. For example, (500, 500). Defaults to None, using the original size.</p> <code>None</code> <code>bbox</code> <code>list</code> <p>The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.</p> <code>None</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0, looping forever.</p> <code>0</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the gif. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar, can be color name or hex code. Defaults to 'blue'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the gif. Defaults to False.</p> <code>False</code> <code>text_xy</code> <code>tuple</code> <p>The x, y coordinates of the text. For example, ('10%', '10%'). Defaults to None, using the bottom left corner.</p> <code>None</code> <code>text_sequence</code> <code>list</code> <p>The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].</p> <code>None</code> <code>font_type</code> <code>str</code> <p>The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>The color of the text, can be color name or hex code. Defaults to 'black'.</p> <code>'black'</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to print the progress. Defaults to False.</p> <code>True</code> <code>reduce_size</code> <code>bool</code> <p>Whether to reduce the size of the gif using ffmpeg. Defaults to False.</p> <code>False</code> <code>clean_up</code> <code>bool</code> <p>Whether to clean up the temporary files. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/common.py</code> <pre><code>def create_timelapse(\n    images: Union[List, str],\n    out_gif: str,\n    ext: str = \".tif\",\n    bands: Optional[List] = None,\n    size: Optional[Tuple] = None,\n    bbox: Optional[List] = None,\n    fps: int = 5,\n    loop: int = 0,\n    add_progress_bar: bool = True,\n    progress_bar_color: str = \"blue\",\n    progress_bar_height: int = 5,\n    add_text: bool = False,\n    text_xy: Optional[Tuple] = None,\n    text_sequence: Optional[List] = None,\n    font_type: str = \"arial.ttf\",\n    font_size: int = 20,\n    font_color: str = \"black\",\n    mp4: bool = False,\n    quiet: bool = True,\n    reduce_size: bool = False,\n    clean_up: bool = True,\n    **kwargs,\n):\n    \"\"\"Creates a timelapse gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n            For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to '.tif'.\n        bands (list, optional): The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.\n        size (tuple, optional): The size of the gif. For example, (500, 500). Defaults to None, using the original size.\n        bbox (list, optional): The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.\n        fps (int, optional): The frames per second of the gif. Defaults to 5.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0, looping forever.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the gif. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar, can be color name or hex code. Defaults to 'blue'.\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        add_text (bool, optional): Whether to add text to the gif. Defaults to False.\n        text_xy (tuple, optional): The x, y coordinates of the text. For example, ('10%', '10%').\n            Defaults to None, using the bottom left corner.\n        text_sequence (list, optional): The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].\n        font_type (str, optional): The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.\n        font_size (int, optional): The font size of the text. Defaults to 20.\n        font_color (str, optional): The color of the text, can be color name or hex code. Defaults to 'black'.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        quiet (bool, optional): Whether to print the progress. Defaults to False.\n        reduce_size (bool, optional): Whether to reduce the size of the gif using ffmpeg. Defaults to False.\n        clean_up (bool, optional): Whether to clean up the temporary files. Defaults to True.\n\n    \"\"\"\n\n    import glob\n    import tempfile\n\n    if isinstance(images, str):\n        if not images.endswith(ext):\n            images = os.path.join(images, f\"*{ext}\")\n        images = list(glob.glob(images))\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    temp_dir = os.path.join(tempfile.gettempdir(), \"timelapse\")\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    if bbox is not None:\n        clip_dir = os.path.join(tempfile.gettempdir(), \"clip\")\n        if not os.path.exists(clip_dir):\n            os.makedirs(clip_dir)\n\n        if len(bbox) == 4:\n            bbox = bbox_to_geojson(bbox)\n\n    else:\n        clip_dir = None\n\n    output = widgets.Output()\n\n    if \"out_ext\" in kwargs:\n        out_ext = kwargs[\"out_ext\"].lower()\n    else:\n        out_ext = \".jpg\"\n\n    try:\n        for index, image in enumerate(images):\n            if bbox is not None:\n                clip_file = os.path.join(clip_dir, os.path.basename(image))\n                with output:\n                    clip_image(image, mask=bbox, output=clip_file, to_cog=False)\n                image = clip_file\n\n            if \"add_prefix\" in kwargs:\n                basename = (\n                    str(f\"{index + 1}\").zfill(len(str(len(images))))\n                    + \"-\"\n                    + os.path.basename(image).replace(ext, out_ext)\n                )\n            else:\n                basename = os.path.basename(image).replace(ext, out_ext)\n            if not quiet:\n                print(f\"Processing {index+1}/{len(images)}: {basename} ...\")\n\n            # ignore GDAL warnings\n            with output:\n                numpy_to_image(\n                    image, os.path.join(temp_dir, basename), bands=bands, size=size\n                )\n        make_gif(\n            temp_dir,\n            out_gif,\n            ext=out_ext,\n            fps=fps,\n            loop=loop,\n            mp4=mp4,\n            clean_up=clean_up,\n        )\n\n        if clip_dir is not None:\n            shutil.rmtree(clip_dir)\n\n        if add_text:\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                text_xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n        elif add_progress_bar:\n            add_progress_bar_to_gif(\n                out_gif,\n                out_gif,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n\n        if reduce_size:\n            reduce_gif_size(out_gif)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.csv_points_to_shp","title":"<code>csv_points_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude')</code>","text":"<p>Converts a csv file containing points (latitude, longitude) into a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv</p> required <code>out_shp</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>leafmap/common.py</code> <pre><code>def csv_points_to_shp(in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\"):\n    \"\"\"Converts a csv file containing points (latitude, longitude) into a shapefile.\n\n    Args:\n        in_csv (str): File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\n        out_shp (str): File path to the output shapefile.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    \"\"\"\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        out_name = os.path.basename(in_csv)\n\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_csv, out_dir=out_dir)\n        in_csv = os.path.join(out_dir, out_name)\n\n    wbt = whitebox.WhiteboxTools()\n    in_csv = os.path.abspath(in_csv)\n    out_shp = os.path.abspath(out_shp)\n\n    if not os.path.exists(in_csv):\n        raise Exception(\"The provided csv file does not exist.\")\n\n    with open(in_csv, encoding=\"utf-8\") as csv_file:\n        reader = csv.DictReader(csv_file)\n        fields = reader.fieldnames\n        xfield = fields.index(longitude)\n        yfield = fields.index(latitude)\n\n    wbt.csv_points_to_vector(in_csv, out_shp, xfield=xfield, yfield=yfield, epsg=4326)\n</code></pre>"},{"location":"common/#leafmap.common.csv_to_df","title":"<code>csv_to_df(in_csv, **kwargs)</code>","text":"<p>Converts a CSV file to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>leafmap/common.py</code> <pre><code>def csv_to_df(in_csv, **kwargs):\n    \"\"\"Converts a CSV file to pandas dataframe.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    try:\n        return pd.read_csv(in_csv, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.csv_to_gdf","title":"<code>csv_to_gdf(in_csv, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and converts them to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>object</code> <p>GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def csv_to_gdf(in_csv, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"):\n    \"\"\"Creates points for a CSV file and converts them to a GeoDataFrame.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    Returns:\n        object: GeoDataFrame.\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    out_dir = os.getcwd()\n\n    out_geojson = os.path.join(out_dir, random_string() + \".geojson\")\n    csv_to_geojson(in_csv, out_geojson, latitude, longitude, encoding)\n\n    gdf = gpd.read_file(out_geojson)\n    os.remove(out_geojson)\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.csv_to_geojson","title":"<code>csv_to_geojson(in_csv, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>leafmap/common.py</code> <pre><code>def csv_to_geojson(\n    in_csv,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a CSV file and exports data as a GeoJSON.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import pandas as pd\n\n    in_csv = github_raw_url(in_csv)\n\n    if out_geojson is not None:\n        out_geojson = check_file_path(out_geojson)\n\n    df = pd.read_csv(in_csv)\n    geojson = df_to_geojson(\n        df, latitude=latitude, longitude=longitude, encoding=encoding\n    )\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#leafmap.common.csv_to_shp","title":"<code>csv_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Converts a csv file with latlon info to a point shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The input csv file containing longitude and latitude columns.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>The column name of the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>leafmap/common.py</code> <pre><code>def csv_to_shp(\n    in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"\n):\n    \"\"\"Converts a csv file with latlon info to a point shapefile.\n\n    Args:\n        in_csv (str): The input csv file containing longitude and latitude columns.\n        out_shp (str): The file path to the output shapefile.\n        latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'.\n    \"\"\"\n    import shapefile as shp\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        in_csv = github_raw_url(in_csv)\n        in_csv = download_file(in_csv, quiet=True, overwrite=True)\n\n    try:\n        points = shp.Writer(out_shp, shapeType=shp.POINT)\n        with open(in_csv, encoding=encoding) as csvfile:\n            csvreader = csv.DictReader(csvfile)\n            header = csvreader.fieldnames\n            [points.field(field) for field in header]\n            for row in csvreader:\n                points.point((float(row[longitude])), (float(row[latitude])))\n                points.record(*tuple([row[f] for f in header]))\n\n        out_prj = out_shp.replace(\".shp\", \".prj\")\n        with open(out_prj, \"w\") as f:\n            prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] '\n            f.write(prj_str)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.csv_to_vector","title":"<code>csv_to_vector(in_csv, output, latitude='latitude', longitude='longitude', encoding='utf-8', **kwargs)</code>","text":"<p>Creates points for a CSV file and converts them to a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The file path to the output vector dataset.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>leafmap/common.py</code> <pre><code>def csv_to_vector(\n    in_csv,\n    output,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Creates points for a CSV file and converts them to a vector dataset.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        output (str): The file path to the output vector dataset.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n    gdf = csv_to_gdf(in_csv, latitude, longitude, encoding)\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.delete_shp","title":"<code>delete_shp(in_shp, verbose=False)</code>","text":"<p>Deletes a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input shapefile to delete.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to True.</p> <code>False</code> Source code in <code>leafmap/common.py</code> <pre><code>def delete_shp(in_shp, verbose=False):\n    \"\"\"Deletes a shapefile.\n\n    Args:\n        in_shp (str): The input shapefile to delete.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to True.\n    \"\"\"\n    from pathlib import Path\n\n    in_shp = os.path.abspath(in_shp)\n    in_dir = os.path.dirname(in_shp)\n    basename = os.path.basename(in_shp).replace(\".shp\", \"\")\n\n    files = Path(in_dir).rglob(basename + \".*\")\n\n    for file in files:\n        filepath = os.path.join(in_dir, str(file))\n        os.remove(filepath)\n        if verbose:\n            print(f\"Deleted {filepath}\")\n</code></pre>"},{"location":"common/#leafmap.common.df_to_gdf","title":"<code>df_to_gdf(df, geometry='geometry', src_crs='EPSG:4326', dst_crs=None, **kwargs)</code>","text":"<p>Converts a pandas DataFrame to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The pandas DataFrame to convert.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column in the DataFrame.</p> <code>'geometry'</code> <code>src_crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>dst_crs</code> <code>str</code> <p>The target CRS of the GeoDataFrame. Default is None</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>The converted GeoPandas GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def df_to_gdf(df, geometry=\"geometry\", src_crs=\"EPSG:4326\", dst_crs=None, **kwargs):\n    \"\"\"\n    Converts a pandas DataFrame to a GeoPandas GeoDataFrame.\n\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame to convert.\n        geometry (str): The name of the geometry column in the DataFrame.\n        src_crs (str): The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".\n        dst_crs (str): The target CRS of the GeoDataFrame. Default is None\n\n    Returns:\n        geopandas.GeoDataFrame: The converted GeoPandas GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n    from shapely import wkt\n\n    # Convert the geometry column to Shapely geometry objects\n    df[geometry] = df[geometry].apply(lambda x: wkt.loads(x))\n\n    # Convert the pandas DataFrame to a GeoPandas GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=src_crs, **kwargs)\n    if dst_crs is not None and dst_crs != src_crs:\n        gdf = gdf.to_crs(dst_crs)\n\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.df_to_geojson","title":"<code>df_to_geojson(df, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a Pandas DataFrame and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input Pandas DataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>leafmap/common.py</code> <pre><code>def df_to_geojson(\n    df,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a Pandas DataFrame and exports data as a GeoJSON.\n\n    Args:\n        df (pandas.DataFrame): The input Pandas DataFrame.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import json\n    from geojson import Feature, FeatureCollection, Point\n\n    if out_geojson is not None:\n        out_dir = os.path.dirname(os.path.abspath(out_geojson))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    features = df.apply(\n        lambda row: Feature(\n            geometry=Point((float(row[longitude]), float(row[latitude]))),\n            properties=dict(row),\n        ),\n        axis=1,\n    ).tolist()\n\n    geojson = FeatureCollection(features=features)\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#leafmap.common.dict_to_json","title":"<code>dict_to_json(data, file_path, indent=4)</code>","text":"<p>Writes a dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary.</p> required <code>file_path</code> <code>str</code> <p>The path to the JSON file.</p> required <code>indent</code> <code>int</code> <p>The indentation of the JSON file. Defaults to 4.</p> <code>4</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the input data is not a dictionary.</p> Source code in <code>leafmap/common.py</code> <pre><code>def dict_to_json(data, file_path, indent=4):\n    \"\"\"Writes a dictionary to a JSON file.\n\n    Args:\n        data (dict): A dictionary.\n        file_path (str): The path to the JSON file.\n        indent (int, optional): The indentation of the JSON file. Defaults to 4.\n\n    Raises:\n        TypeError: If the input data is not a dictionary.\n    \"\"\"\n    import json\n\n    file_path = check_file_path(file_path)\n\n    if isinstance(data, dict):\n        with open(file_path, \"w\") as f:\n            json.dump(data, f, indent=indent)\n    else:\n        raise TypeError(\"The provided data must be a dictionary.\")\n</code></pre>"},{"location":"common/#leafmap.common.disjoint","title":"<code>disjoint(input_features, selecting_features, output=None, **kwargs)</code>","text":"<p>Find the features in the input_features that do not intersect the selecting_features.</p> <p>Parameters:</p> Name Type Description Default <code>input_features</code> <code>str | GeoDataFrame</code> <p>The input features to select from. Can be a file path or a GeoDataFrame.</p> required <code>selecting_features</code> <code>str | GeoDataFrame</code> <p>The features in the Input Features parameter will be selected based on their relationship to the features from this layer.</p> required <code>output</code> <code>are</code> <p>The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | GeoDataFrame</code> <p>The path to the output file or the GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def disjoint(input_features, selecting_features, output=None, **kwargs):\n    \"\"\"Find the features in the input_features that do not intersect the selecting_features.\n\n    Args:\n        input_features (str | GeoDataFrame): The input features to select from. Can be a file path or a GeoDataFrame.\n        selecting_features (str | GeoDataFrame): The features in the Input Features parameter will be selected based\n            on their relationship to the features from this layer.\n        output (are, optional): The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.\n\n    Returns:\n        str | GeoDataFrame: The path to the output file or the GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(input_features, str):\n        input_features = gpd.read_file(input_features, **kwargs)\n    elif not isinstance(input_features, gpd.GeoDataFrame):\n        raise TypeError(\"input_features must be a file path or a GeoDataFrame\")\n\n    if isinstance(selecting_features, str):\n        selecting_features = gpd.read_file(selecting_features, **kwargs)\n    elif not isinstance(selecting_features, gpd.GeoDataFrame):\n        raise TypeError(\"selecting_features must be a file path or a GeoDataFrame\")\n\n    selecting_features = selecting_features.to_crs(input_features.crs)\n\n    input_features[\"savedindex\"] = input_features.index\n    intersecting = selecting_features.sjoin(input_features, how=\"inner\")[\"savedindex\"]\n    results = input_features[~input_features.savedindex.isin(intersecting)].drop(\n        columns=[\"savedindex\"], axis=1\n    )\n\n    if output is not None:\n        results.to_file(output, **kwargs)\n    else:\n        return results\n</code></pre>"},{"location":"common/#leafmap.common.display_html","title":"<code>display_html(filename, width='100%', height='600px', **kwargs)</code>","text":"<p>Show an HTML file in a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HTML file.</p> required <code>width</code> <code>str</code> <p>The width of the HTML file. Defaults to \"100%\".</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the HTML file. Defaults to \"600px\".</p> <code>'600px'</code> <p>Returns:</p> Type Description <code>IFrame</code> <p>An IFrame object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def display_html(filename, width=\"100%\", height=\"600px\", **kwargs):\n    \"\"\"Show an HTML file in a Jupyter notebook.\n\n    Args:\n        filename (str): The path to the HTML file.\n        width (str, optional): The width of the HTML file. Defaults to \"100%\".\n        height (str, optional): The height of the HTML file. Defaults to \"600px\".\n\n    Returns:\n        IFrame: An IFrame object.\n    \"\"\"\n\n    from IPython.display import IFrame\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    return IFrame(filename, width=width, height=height, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n    \"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    out_dir = os.path.abspath(os.path.dirname(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip:\n        if output.endswith(\".zip\"):\n            with zipfile.ZipFile(output, \"r\") as zip_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    zip_ref.extractall(output)\n                else:\n                    zip_ref.extractall(os.path.dirname(output))\n        elif output.endswith(\".tar.gz\") or output.endswith(\".tar\"):\n            if output.endswith(\".tar.gz\"):\n                mode = \"r:gz\"\n            else:\n                mode = \"r\"\n\n            with tarfile.open(output, mode) as tar_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    tar_ref.extractall(output)\n                else:\n                    tar_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#leafmap.common.download_file_lite","title":"<code>download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs)</code>  <code>async</code>","text":"<p>Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>output</code> <code>str</code> <p>The local path to save the file. Defaults to None.</p> <code>None</code> <code>binary</code> <code>bool</code> <p>Whether the file is binary. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it exists. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/common.py</code> <pre><code>async def download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs):\n    \"\"\"Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).\n\n    Args:\n        url (str): The URL of the file.\n        output (str, optional): The local path to save the file. Defaults to None.\n        binary (bool, optional): Whether the file is binary. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the file if it exists. Defaults to False.\n    \"\"\"\n    import sys\n    import pyodide\n\n    if \"pyodide\" not in sys.modules:\n        raise ValueError(\"Pyodide is not available.\")\n\n    if output is None:\n        output = os.path.basename(url)\n\n    output = os.path.abspath(output)\n\n    ext = os.path.splitext(output)[1]\n\n    if ext in [\".png\", \"jpg\", \".tif\", \".tiff\", \"zip\", \"gz\", \"bz2\", \"xz\"]:\n        binary = True\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"{output} already exists, skip downloading.\")\n        return output\n\n    if binary:\n        response = await pyodide.http.pyfetch(url)\n        with open(output, \"wb\") as f:\n            f.write(await response.bytes())\n\n    else:\n        obj = pyodide.http.open_url(url)\n        with open(output, \"w\") as fd:\n            shutil.copyfileobj(obj, fd)\n\n    return output\n</code></pre>"},{"location":"common/#leafmap.common.download_files","title":"<code>download_files(urls, out_dir=None, filenames=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False, multi_part=False)</code>","text":"<p>Download files from URLs, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>The list of urls to download. Google Drive URL is also supported.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>list</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <code>multi_part</code> <code>bool</code> <p>If the file is a multi-part file. Defaults to False.</p> <code>False</code> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_files(\n    urls,\n    out_dir=None,\n    filenames=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n    multi_part=False,\n):\n    \"\"\"Download files from URLs, including Google Drive shared URL.\n\n    Args:\n        urls (list): The list of urls to download. Google Drive URL is also supported.\n        out_dir (str, optional): The output directory. Defaults to None.\n        filenames (list, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n        multi_part (bool, optional): If the file is a multi-part file. Defaults to False.\n\n    Examples:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n    \"\"\"\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if filenames is None:\n        filenames = [None] * len(urls)\n\n    filepaths = []\n    for url, output in zip(urls, filenames):\n        if output is None:\n            filename = os.path.join(out_dir, os.path.basename(url))\n        else:\n            filename = os.path.join(out_dir, output)\n\n        filepaths.append(filename)\n        if multi_part:\n            unzip = False\n\n        download_file(\n            url,\n            filename,\n            quiet,\n            proxy,\n            speed,\n            use_cookies,\n            verify,\n            id,\n            fuzzy,\n            resume,\n            unzip,\n            overwrite,\n            subfolder,\n        )\n\n    if multi_part:\n        archive = os.path.splitext(filename)[0] + \".zip\"\n        out_dir = os.path.dirname(filename)\n        extract_archive(archive, out_dir)\n\n        for file in filepaths:\n            os.remove(file)\n</code></pre>"},{"location":"common/#leafmap.common.download_folder","title":"<code>download_folder(url=None, id=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, remaining_ok=False)</code>","text":"<p>Downloads the entire folder from URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.</p> <code>None</code> <code>id</code> <code>str</code> <p>Google Drive's folder ID. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>String containing the path of the output folder. Defaults to current working directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Defaults to False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of files downloaded, or None if failed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_folder(\n    url=None,\n    id=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    remaining_ok=False,\n):\n    \"\"\"Downloads the entire folder from URL.\n\n    Args:\n        url (str, optional): URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.\n        id (str, optional): Google Drive's folder ID. Defaults to None.\n        output (str, optional):  String containing the path of the output folder. Defaults to current working directory.\n        quiet (bool, optional): Suppress terminal output. Defaults to False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n\n    Returns:\n        list: List of files downloaded, or None if failed.\n    \"\"\"\n\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    files = gdown.download_folder(\n        url, id, output, quiet, proxy, speed, use_cookies, remaining_ok\n    )\n    return files\n</code></pre>"},{"location":"common/#leafmap.common.download_from_gdrive","title":"<code>download_from_gdrive(gfile_url, file_name, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file shared via Google Drive    (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)</p> <p>Parameters:</p> Name Type Description Default <code>gfile_url</code> <code>str</code> <p>The Google Drive shared file URL</p> required <code>file_name</code> <code>str</code> <p>The output file name to use.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the output file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>leafmap/common.py</code> <pre><code>def download_from_gdrive(gfile_url, file_name, out_dir=\".\", unzip=True, verbose=True):\n    \"\"\"Download a file shared via Google Drive\n       (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)\n\n    Args:\n        gfile_url (str): The Google Drive shared file URL\n        file_name (str): The output file name to use.\n        out_dir (str, optional): The output directory. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the output file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    try:\n        from google_drive_downloader import GoogleDriveDownloader as gdd\n    except ImportError:\n        raise ImportError(\n            'Please install googledrivedownloader using \"pip install googledrivedownloader\"'\n        )\n\n    file_id = gfile_url.split(\"/\")[5]\n    if verbose:\n        print(\"Google Drive file id: {}\".format(file_id))\n\n    out_dir = check_dir(out_dir)\n    dest_path = os.path.join(out_dir, file_name)\n    gdd.download_file_from_google_drive(file_id, dest_path, True, unzip)\n</code></pre>"},{"location":"common/#leafmap.common.download_from_url","title":"<code>download_from_url(url, out_file_name=None, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The HTTP URL to download.</p> required <code>out_file_name</code> <code>str</code> <p>The output file name to use. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The output directory to use. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>leafmap/common.py</code> <pre><code>def download_from_url(\n    url: str,\n    out_file_name: Optional[str] = None,\n    out_dir: Optional[str] = \".\",\n    unzip: Optional[bool] = True,\n    verbose: Optional[bool] = True,\n):\n    \"\"\"Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)\n\n    Args:\n        url (str): The HTTP URL to download.\n        out_file_name (str, optional): The output file name to use. Defaults to None.\n        out_dir (str, optional): The output directory to use. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    in_file_name = os.path.basename(url)\n    out_dir = check_dir(out_dir)\n\n    if out_file_name is None:\n        out_file_name = in_file_name\n    out_file_path = os.path.join(out_dir, out_file_name)\n\n    if verbose:\n        print(\"Downloading {} ...\".format(url))\n\n    try:\n        urllib.request.urlretrieve(url, out_file_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    final_path = out_file_path\n\n    if unzip:\n        # if it is a zip file\n        if \".zip\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n                zip_ref.extractall(out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".zip\", \"\")\n            )\n\n        # if it is a tar file\n        if \".tar\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with tarfile.open(out_file_path, \"r\") as tar_ref:\n                with tarfile.open(out_file_path, \"r\") as tar_ref:\n\n                    def is_within_directory(directory, target):\n                        abs_directory = os.path.abspath(directory)\n                        abs_target = os.path.abspath(target)\n\n                        prefix = os.path.commonprefix([abs_directory, abs_target])\n\n                        return prefix == abs_directory\n\n                    def safe_extract(\n                        tar, path=\".\", members=None, *, numeric_owner=False\n                    ):\n                        for member in tar.getmembers():\n                            member_path = os.path.join(path, member.name)\n                            if not is_within_directory(path, member_path):\n                                raise Exception(\"Attempted Path Traversal in Tar File\")\n\n                        tar.extractall(path, members, numeric_owner=numeric_owner)\n\n                    safe_extract(tar_ref, out_dir)\n\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".tart\", \"\")\n            )\n\n    if verbose:\n        print(\"Data downloaded to: {}\".format(final_path))\n</code></pre>"},{"location":"common/#leafmap.common.download_google_buildings","title":"<code>download_google_buildings(location, out_dir=None, merge_output=None, head=None, keep_geojson=False, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Download Google Open Building dataset for a specific location. Check the dataset links from     https://sites.research.google/open-buildings.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <code>Optional[int]</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>keep_geojson</code> <code>bool</code> <p>Optional. If True, the GeoJSON files will be kept after converting them to CSV files.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Optional. If True, overwrite the existing files.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_google_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head: Optional[int] = None,\n    keep_geojson: bool = False,\n    overwrite: bool = False,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Google Open Building dataset for a specific location. Check the dataset links from\n        https://sites.research.google/open-buildings.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        keep_geojson: Optional. If True, the GeoJSON files will be kept after converting them to CSV files.\n        overwrite: Optional. If True, overwrite the existing files.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    building_url = \"https://sites.research.google/open-buildings/tiles.geojson\"\n    country_url = (\n        \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n    )\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    building_gdf = gpd.read_file(building_url)\n    country_gdf = gpd.read_file(country_url)\n\n    country = country_gdf[country_gdf[\"NAME\"] == location]\n\n    if len(country) == 0:\n        country = country_gdf[country_gdf[\"NAME_LONG\"] == location]\n        if len(country) == 0:\n            raise ValueError(f\"Could not find {location} in the Natural Earth dataset.\")\n\n    gdf = building_gdf[building_gdf.intersects(country.geometry.iloc[0])]\n    gdf.sort_values(by=\"size_mb\", inplace=True)\n\n    print(f\"Found {len(gdf)} links for {location}.\")\n    if head is not None:\n        gdf = gdf.head(head)\n\n    if len(gdf) &gt; 0:\n        links = gdf[\"tile_url\"].tolist()\n        download_files(links, out_dir=out_dir, quiet=quiet, **kwargs)\n        filenames = [os.path.join(out_dir, os.path.basename(link)) for link in links]\n\n        gdfs = []\n        for filename in filenames:\n            # Read the CSV file into a pandas DataFrame\n            df = pd.read_csv(filename)\n\n            # Create a geometry column from the \"geometry\" column in the DataFrame\n            df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n            # Convert the pandas DataFrame to a GeoDataFrame\n            gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n            gdf.crs = \"EPSG:4326\"\n            if keep_geojson:\n                gdf.to_file(\n                    filename.replace(\".csv.gz\", \".geojson\"), driver=\"GeoJSON\", **kwargs\n                )\n            gdfs.append(gdf)\n\n        if merge_output:\n            if os.path.exists(merge_output) and not overwrite:\n                print(f\"File {merge_output} already exists, skip merging...\")\n            else:\n                if not quiet:\n                    print(\"Merging GeoDataFrames ...\")\n                gdf = gpd.GeoDataFrame(\n                    pd.concat(gdfs, ignore_index=True), crs=\"EPSG:4326\"\n                )\n                gdf.to_file(merge_output, **kwargs)\n\n    else:\n        print(f\"No buildings found for {location}.\")\n</code></pre>"},{"location":"common/#leafmap.common.download_ms_buildings","title":"<code>download_ms_buildings(location, out_dir=None, merge_output=None, head=None, quiet=False, **kwargs)</code>","text":"<p>Download Microsoft Buildings dataset for a specific location. Check the dataset links from     https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_ms_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head=None,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Microsoft Buildings dataset for a specific location. Check the dataset links from\n        https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import shape\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    dataset_links = pd.read_csv(\n        \"https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv\"\n    )\n    country_links = dataset_links[dataset_links.Location == location]\n\n    if not quiet:\n        print(f\"Found {len(country_links)} links for {location}\")\n    if head is not None:\n        country_links = country_links.head(head)\n\n    filenames = []\n    i = 1\n\n    for _, row in country_links.iterrows():\n        if not quiet:\n            print(f\"Downloading {i} of {len(country_links)}: {row.QuadKey}.geojson\")\n        i += 1\n        filename = os.path.join(out_dir, f\"{row.QuadKey}.geojson\")\n        filenames.append(filename)\n        if os.path.exists(filename):\n            print(f\"File {filename} already exists, skipping...\")\n            continue\n        df = pd.read_json(row.Url, lines=True)\n        df[\"geometry\"] = df[\"geometry\"].apply(shape)\n        gdf = gpd.GeoDataFrame(df, crs=4326)\n        gdf.to_file(filename, driver=\"GeoJSON\", **kwargs)\n\n    if merge_output is not None:\n        if os.path.exists(merge_output):\n            print(f\"File {merge_output} already exists, skip merging...\")\n            return filenames\n        merge_vector(filenames, merge_output, quiet=quiet)\n\n    return filenames\n</code></pre>"},{"location":"common/#leafmap.common.download_ned","title":"<code>download_ned(region, out_dir=None, return_url=False, download_args={}, geopandas_args={}, query={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].</p> required <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>query</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. See https://apps.nationalmap.gov/tnmaccess/#/product for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_ned(\n    region,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    query={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list): A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        query (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            See https://apps.nationalmap.gov/tnmaccess/#/product for more information.\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if not query:\n        query = {\n            \"datasets\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n            \"prodFormats\": \"GeoTIFF\",\n        }\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=query)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=query,\n    )\n</code></pre>"},{"location":"common/#leafmap.common.download_tnm","title":"<code>download_tnm(region=None, out_dir=None, return_url=False, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. Exposes most of the documented API. Defaults to {}</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>leafmap/common.py</code> <pre><code>def download_tnm(\n    region=None,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    API={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            Exposes most of the documented API. Defaults to {}\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=API)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=API,\n    )\n</code></pre>"},{"location":"common/#leafmap.common.edit_download_html","title":"<code>edit_download_html(htmlWidget, filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058</p> <p>Parameters:</p> Name Type Description Default <code>htmlWidget</code> <code>object</code> <p>The HTML widget to display the URL.</p> required <code>filename</code> <code>str</code> <p>File path to download.</p> required <code>title</code> <code>str</code> <p>Download description. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> Source code in <code>leafmap/common.py</code> <pre><code>def edit_download_html(htmlWidget, filename, title=\"Click here to download: \"):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058\n\n    Args:\n        htmlWidget (object): The HTML widget to display the URL.\n        filename (str): File path to download.\n        title (str, optional): Download description. Defaults to \"Click here to download: \".\n    \"\"\"\n\n    # from IPython.display import HTML\n    # import ipywidgets as widgets\n    import base64\n\n    # Change widget html temporarily to a font-awesome spinner\n    htmlWidget.value = '&lt;i class=\"fa fa-spinner fa-spin fa-2x fa-fw\"&gt;&lt;/i&gt;&lt;span class=\"sr-only\"&gt;Loading...&lt;/span&gt;'\n\n    # Process raw data\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n\n    basename = os.path.basename(filename)\n\n    # Create and assign html to widget\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    htmlWidget.value = html.format(\n        payload=payload, title=title + basename, filename=basename\n    )\n</code></pre>"},{"location":"common/#leafmap.common.explode","title":"<code>explode(coords)</code>","text":"<p>Explode a GeoJSON geometry's coordinates object and yield coordinate tuples. As long as the input is conforming, the type of the geometry doesn't matter.  From Fiona 1.4.8</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates.</p> required <p>Yields:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>leafmap/common.py</code> <pre><code>def explode(coords):\n    \"\"\"Explode a GeoJSON geometry's coordinates object and yield\n    coordinate tuples. As long as the input is conforming, the type of\n    the geometry doesn't matter.  From Fiona 1.4.8\n\n    Args:\n        coords (list): A list of coordinates.\n\n    Yields:\n        [type]: [description]\n    \"\"\"\n\n    for e in coords:\n        if isinstance(e, (float, int)):\n            yield coords\n            break\n        else:\n            for f in explode(e):\n                yield f\n</code></pre>"},{"location":"common/#leafmap.common.extract_archive","title":"<code>extract_archive(archive, outdir=None, **kwargs)</code>","text":"<p>Extracts a multipart archive.</p> <p>This function uses the patoolib library to extract a multipart archive. If the patoolib library is not installed, it attempts to install it. If the archive does not end with \".zip\", it appends \".zip\" to the archive name. If the extraction fails (for example, if the files already exist), it skips the extraction.</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <code>str</code> <p>The path to the archive file.</p> required <code>outdir</code> <code>str</code> <p>The directory where the archive should be extracted.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for the patoolib.extract_archive function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>An exception is raised if the extraction fails for reasons other than the files already existing.</p> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>leafmap/common.py</code> <pre><code>def extract_archive(archive, outdir=None, **kwargs):\n    \"\"\"\n    Extracts a multipart archive.\n\n    This function uses the patoolib library to extract a multipart archive.\n    If the patoolib library is not installed, it attempts to install it.\n    If the archive does not end with \".zip\", it appends \".zip\" to the archive name.\n    If the extraction fails (for example, if the files already exist), it skips the extraction.\n\n    Args:\n        archive (str): The path to the archive file.\n        outdir (str): The directory where the archive should be extracted.\n        **kwargs: Arbitrary keyword arguments for the patoolib.extract_archive function.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: An exception is raised if the extraction fails for reasons other than the files already existing.\n\n    Example:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n\n    \"\"\"\n    try:\n        import patoolib\n    except ImportError:\n        install_package(\"patool\")\n        import patoolib\n\n    if not archive.endswith(\".zip\"):\n        archive = archive + \".zip\"\n\n    if outdir is None:\n        outdir = os.path.dirname(archive)\n\n    try:\n        patoolib.extract_archive(archive, outdir=outdir, **kwargs)\n    except Exception as e:\n        print(\"The unzipped files might already exist. Skipping extraction.\")\n        return\n</code></pre>"},{"location":"common/#leafmap.common.filter_bounds","title":"<code>filter_bounds(data, bbox, within=False, align=True, **kwargs)</code>","text":"<p>Filters a GeoDataFrame or GeoSeries by a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a GeoDataFrame.</p> required <code>bbox</code> <code>list | GeoDataFrame</code> <p>The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.</p> required <code>within</code> <code>bool</code> <p>Whether to filter by the bounding box or the bounding box's interior. Defaults to False.</p> <code>False</code> <code>align</code> <code>bool</code> <p>If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>The filtered data.</p> Source code in <code>leafmap/common.py</code> <pre><code>def filter_bounds(data, bbox, within=False, align=True, **kwargs):\n    \"\"\"Filters a GeoDataFrame or GeoSeries by a bounding box.\n\n    Args:\n        data (str | GeoDataFrame): The input data to filter. Can be a file path or a GeoDataFrame.\n        bbox (list | GeoDataFrame): The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.\n        within (bool, optional): Whether to filter by the bounding box or the bounding box's interior. Defaults to False.\n        align (bool, optional): If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.\n\n    Returns:\n        GeoDataFrame: The filtered data.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(data, (gpd.GeoDataFrame, gpd.GeoSeries)):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if isinstance(bbox, list):\n        if len(bbox) != 4:\n            raise ValueError(\"bbox must be a list of 4 coordinates\")\n        bbox = bbox_to_gdf(bbox)\n    elif isinstance(bbox, str):\n        bbox = gpd.read_file(bbox, **kwargs)\n\n    if within:\n        result = data[data.within(bbox.unary_union, align=align)]\n    else:\n        result = data[data.intersects(bbox.unary_union, align=align)]\n\n    return result\n</code></pre>"},{"location":"common/#leafmap.common.filter_date","title":"<code>filter_date(data, start_date=None, end_date=None, date_field='date', date_args={}, **kwargs)</code>","text":"<p>Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | DataFrame | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.</p> required <code>start_date</code> <code>str</code> <p>The start date, e.g., 2023-01-01. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date, e.g., 2023-12-31. Defaults to None.</p> <code>None</code> <code>date_field</code> <code>str</code> <p>The name of the date field. Defaults to \"date\".</p> <code>'date'</code> <code>date_args</code> <code>dict</code> <p>Additional arguments for pd.to_datetime. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The filtered data.</p> Source code in <code>leafmap/common.py</code> <pre><code>def filter_date(\n    data, start_date=None, end_date=None, date_field=\"date\", date_args={}, **kwargs\n):\n    \"\"\"Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.\n\n    Args:\n        data (str | DataFrame | GeoDataFrame): The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.\n        start_date (str, optional): The start date, e.g., 2023-01-01. Defaults to None.\n        end_date (str, optional): The end date, e.g., 2023-12-31. Defaults to None.\n        date_field (str, optional): The name of the date field. Defaults to \"date\".\n        date_args (dict, optional): Additional arguments for pd.to_datetime. Defaults to {}.\n\n    Returns:\n        DataFrame: The filtered data.\n    \"\"\"\n\n    import datetime\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(\n        data, (gpd.GeoDataFrame, gpd.GeoSeries, pd.DataFrame, pd.Series)\n    ):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if date_field not in data.columns:\n        raise ValueError(f\"date_field must be one of {data.columns}\")\n\n    new_field = f\"{date_field}_temp\"\n    data[new_field] = pd.to_datetime(data[date_field], **date_args)\n\n    if end_date is None:\n        end_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    if start_date is None:\n        start_date = data[new_field].min()\n\n    mask = (data[new_field] &gt;= start_date) &amp; (data[new_field] &lt;= end_date)\n    result = data.loc[mask]\n    return result.drop(columns=[new_field], axis=1)\n</code></pre>"},{"location":"common/#leafmap.common.find_files","title":"<code>find_files(input_dir, ext=None, fullpath=True, recursive=True)</code>","text":"<p>Find files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The input directory.</p> required <code>ext</code> <code>str</code> <p>The file extension to match. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Whether to return the full path. Defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of matching files.</p> Source code in <code>leafmap/common.py</code> <pre><code>def find_files(input_dir, ext=None, fullpath=True, recursive=True):\n    \"\"\"Find files in a directory.\n\n    Args:\n        input_dir (str): The input directory.\n        ext (str, optional): The file extension to match. Defaults to None.\n        fullpath (bool, optional): Whether to return the full path. Defaults to True.\n        recursive (bool, optional): Whether to search recursively. Defaults to True.\n\n    Returns:\n        list: A list of matching files.\n    \"\"\"\n\n    from pathlib import Path\n\n    files = []\n\n    if ext is None:\n        ext = \"*\"\n    else:\n        ext = ext.replace(\".\", \"\")\n\n    ext = f\"*.{ext}\"\n\n    if recursive:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).rglob(ext)]\n        else:\n            files = [str(path.name) for path in Path(input_dir).rglob(ext)]\n    else:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).glob(ext)]\n        else:\n            files = [path.name for path in Path(input_dir).glob(ext)]\n\n    files.sort()\n    return files\n</code></pre>"},{"location":"common/#leafmap.common.gdb_layer_names","title":"<code>gdb_layer_names(gdb_path)</code>","text":"<p>Get a list of layer names in a File Geodatabase (GDB).</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of layer names in the GDB.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdb_layer_names(gdb_path: str) -&gt; List[str]:\n    \"\"\"Get a list of layer names in a File Geodatabase (GDB).\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n\n    Returns:\n        List[str]: A list of layer names in the GDB.\n    \"\"\"\n\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n    # Iterate over the layers\n    layer_names = []\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n        layer_names.append(feature_class_name)\n\n    # Close the GDB dataset\n    gdb_dataset = None\n    return layer_names\n</code></pre>"},{"location":"common/#leafmap.common.gdb_to_vector","title":"<code>gdb_to_vector(gdb_path, out_dir, layers=None, filenames=None, gdal_driver='GPKG', file_extension=None, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Converts layers from a File Geodatabase (GDB) to a vector format.</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <code>out_dir</code> <code>str</code> <p>The output directory to save the converted files.</p> required <code>layers</code> <code>Optional[List[str]]</code> <p>A list of layer names to convert. If None, all layers will be converted. Default is None.</p> <code>None</code> <code>filenames</code> <code>Optional[List[str]]</code> <p>A list of output file names. If None, the layer names will be used as the file names. Default is None.</p> <code>None</code> <code>gdal_driver</code> <code>str</code> <p>The GDAL driver name for the output vector format. Default is \"GPKG\".</p> <code>'GPKG'</code> <code>file_extension</code> <code>Optional[str]</code> <p>The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdb_to_vector(\n    gdb_path: str,\n    out_dir: str,\n    layers: Optional[List[str]] = None,\n    filenames: Optional[List[str]] = None,\n    gdal_driver: str = \"GPKG\",\n    file_extension: Optional[str] = None,\n    overwrite: bool = False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Converts layers from a File Geodatabase (GDB) to a vector format.\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n        out_dir (str): The output directory to save the converted files.\n        layers (Optional[List[str]]): A list of layer names to convert. If None, all layers will be converted. Default is None.\n        filenames (Optional[List[str]]): A list of output file names. If None, the layer names will be used as the file names. Default is None.\n        gdal_driver (str): The GDAL driver name for the output vector format. Default is \"GPKG\".\n        file_extension (Optional[str]): The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n\n    if isinstance(layers, str):\n        layers = [layers]\n\n    if isinstance(filenames, str):\n        filenames = [filenames]\n\n    if filenames is not None:\n        if len(filenames) != len(layers):\n            raise ValueError(\"The length of filenames must match the length of layers.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    ii = 0\n    # Iterate over the layers\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n\n        if layers is not None:\n            if feature_class_name not in layers:\n                continue\n\n        if file_extension is None:\n            file_extension = get_gdal_file_extension(gdal_driver)\n\n        # Create the output file path\n        if filenames is not None:\n            output_file = os.path.join(out_dir, filenames[ii] + \".\" + file_extension)\n            ii += 1\n        else:\n            output_file = os.path.join(\n                out_dir, feature_class_name + \".\" + file_extension\n            )\n\n        if os.path.exists(output_file) and not overwrite:\n            print(f\"File {output_file} already exists. Skipping...\")\n            continue\n        else:\n            if not quiet:\n                print(f\"Converting layer {feature_class_name} to {output_file}...\")\n\n        # Create the output driver\n        output_driver = ogr.GetDriverByName(gdal_driver)\n        output_dataset = output_driver.CreateDataSource(output_file)\n\n        # Copy the input layer to the output format\n        output_dataset.CopyLayer(layer, feature_class_name)\n\n        output_dataset = None\n\n    # Close the GDB dataset\n    gdb_dataset = None\n</code></pre>"},{"location":"common/#leafmap.common.gdf_bounds","title":"<code>gdf_bounds(gdf, return_geom=False)</code>","text":"<p>Returns the bounding box of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_bounds(gdf, return_geom=False):\n    \"\"\"Returns the bounding box of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    if return_geom:\n        return bbox_to_gdf(bbox=bounds)\n    else:\n        return bounds\n</code></pre>"},{"location":"common/#leafmap.common.gdf_centroid","title":"<code>gdf_centroid(gdf, return_geom=False)</code>","text":"<p>Returns the centroid of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (lon, lat) or GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_centroid(gdf, return_geom=False):\n    \"\"\"Returns the centroid of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (lon, lat) or GeoDataFrame.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    centroid = gdf_bounds(gdf, return_geom=True).centroid\n    if return_geom:\n        return centroid\n    else:\n        return centroid.x[0], centroid.y[0]\n</code></pre>"},{"location":"common/#leafmap.common.gdf_geom_type","title":"<code>gdf_geom_type(gdf, first_only=True)</code>","text":"<p>Returns the geometry type of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the f irst feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame, such as Point, LineString,     Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_geom_type(gdf, first_only=True):\n    \"\"\"Returns the geometry type of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the f\n            irst feature in the GeoDataFrame. Defaults to True.\n\n    Returns:\n        str: The geometry type of the GeoDataFrame, such as Point, LineString,\n            Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import geopandas as gpd\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#leafmap.common.gdf_to_bokeh","title":"<code>gdf_to_bokeh(gdf)</code>","text":"<p>Function to convert a GeoPandas GeoDataFrame to a Bokeh ColumnDataSource object.</p> <p>:param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under                             the column name 'geometry.'</p> <p>:return: ColumnDataSource for Bokeh.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_to_bokeh(gdf):\n    \"\"\"\n    Function to convert a GeoPandas GeoDataFrame to a Bokeh\n    ColumnDataSource object.\n\n    :param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under\n                                the column name 'geometry.'\n\n    :return: ColumnDataSource for Bokeh.\n    \"\"\"\n    from bokeh.plotting import ColumnDataSource\n\n    shape_type = gdf_geom_type(gdf)\n\n    gdf_new = gdf.drop(\"geometry\", axis=1).copy()\n    gdf_new[\"x\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"x\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    gdf_new[\"y\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"y\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    return ColumnDataSource(gdf_new)\n</code></pre>"},{"location":"common/#leafmap.common.gdf_to_df","title":"<code>gdf_to_df(gdf, drop_geom=True)</code>","text":"<p>Converts a GeoDataFrame to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>drop_geom</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_to_df(gdf, drop_geom=True):\n    \"\"\"Converts a GeoDataFrame to a pandas DataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        drop_geom (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if drop_geom:\n        df = pd.DataFrame(gdf.drop(columns=[\"geometry\"]))\n    else:\n        df = pd.DataFrame(gdf)\n\n    return df\n</code></pre>"},{"location":"common/#leafmap.common.gdf_to_geojson","title":"<code>gdf_to_geojson(gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding='utf-8')</code>","text":"<p>Converts a GeoDataFame to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>File path to he output GeoJSON. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>An EPSG string, e.g., \"4326\". Defaults to None.</p> <code>None</code> <code>tuple_to_list</code> <code>bool</code> <p>Whether to convert tuples to lists. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the GeoJSON. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>When the output file extension is incorrect.</p> <code>Exception</code> <p>When the conversion fails.</p> <p>Returns:</p> Type Description <code>dict</code> <p>When the out_json is None returns a dict.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gdf_to_geojson(\n    gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding=\"utf-8\"\n):\n    \"\"\"Converts a GeoDataFame to GeoJSON.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        out_geojson (str, optional): File path to he output GeoJSON. Defaults to None.\n        epsg (str, optional): An EPSG string, e.g., \"4326\". Defaults to None.\n        tuple_to_list (bool, optional): Whether to convert tuples to lists. Defaults to False.\n        encoding (str, optional): The encoding to use for the GeoJSON. Defaults to \"utf-8\".\n\n    Raises:\n        TypeError: When the output file extension is incorrect.\n        Exception: When the conversion fails.\n\n    Returns:\n        dict: When the out_json is None returns a dict.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    def listit(t):\n        return list(map(listit, t)) if isinstance(t, (list, tuple)) else t\n\n    try:\n        if epsg is not None:\n            if gdf.crs is not None and gdf.crs.to_epsg() != epsg:\n                gdf = gdf.to_crs(epsg=epsg)\n        geojson = gdf.__geo_interface__\n\n        if tuple_to_list:\n            for feature in geojson[\"features\"]:\n                feature[\"geometry\"][\"coordinates\"] = listit(\n                    feature[\"geometry\"][\"coordinates\"]\n                )\n\n        if out_geojson is None:\n            return geojson\n        else:\n            ext = os.path.splitext(out_geojson)[1]\n            if ext.lower() not in [\".json\", \".geojson\"]:\n                raise TypeError(\n                    \"The output file extension must be either .json or .geojson\"\n                )\n            out_dir = os.path.dirname(out_geojson)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            gdf.to_file(out_geojson, driver=\"GeoJSON\", encoding=encoding)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.gedi_download_file","title":"<code>gedi_download_file(url, filename=None, username=None, password=None)</code>","text":"<p>Downloads a file from the given URL and saves it to the specified filename. If no filename is provided, the name of the file from the URL will be used.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download. e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5</p> required <code>filename</code> <code>str</code> <p>The name of the file to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def gedi_download_file(\n    url: str, filename: str = None, username: str = None, password: str = None\n) -&gt; None:\n    \"\"\"\n    Downloads a file from the given URL and saves it to the specified filename.\n    If no filename is provided, the name of the file from the URL will be used.\n\n    Args:\n        url (str): The URL of the file to download.\n            e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5\n        filename (str, optional): The name of the file to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\n            \"Username and password must be provided. Create an account at https://urs.earthdata.nasa.gov.\"\n        )\n\n    with requests.Session() as session:\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n        print(r.status_code)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            # Use the filename from the URL if not provided\n            if not filename:\n                parsed_url = urlparse(url)\n                filename = parsed_url.path.split(\"/\")[-1]\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filename, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n</code></pre>"},{"location":"common/#leafmap.common.gedi_download_files","title":"<code>gedi_download_files(urls, outdir=None, filenames=None, username=None, password=None, overwrite=False)</code>","text":"<p>Downloads files from the given URLs and saves them to the specified directory. If no directory is provided, the current directory will be used. If no filenames are provided, the names of the files from the URLs will be used.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[str]</code> <p>The URLs of the files to download. e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]</p> required <code>outdir</code> <code>str</code> <p>The directory to save the downloaded files to. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>str</code> <p>The names of the files to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def gedi_download_files(\n    urls: List[str],\n    outdir: str = None,\n    filenames: str = None,\n    username: str = None,\n    password: str = None,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Downloads files from the given URLs and saves them to the specified directory.\n    If no directory is provided, the current directory will be used.\n    If no filenames are provided, the names of the files from the URLs will be used.\n\n    Args:\n        urls (List[str]): The URLs of the files to download.\n            e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]\n        outdir (str, optional): The directory to save the downloaded files to. Defaults to None.\n        filenames (str, optional): The names of the files to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n\n    Returns:\n        None\n    \"\"\"\n\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n    import geopandas as gpd\n\n    if isinstance(urls, gpd.GeoDataFrame):\n        urls = urls[\"granule_url\"].tolist()\n\n    session = requests.Session()\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        print(\"Username and password must be provided.\")\n        return\n\n    if outdir is None:\n        outdir = os.getcwd()\n\n    if not os.path.exists(outdir):\n        os.makedirs(outdir)\n\n    for index, url in enumerate(urls):\n        print(f\"Downloading file {index+1} of {len(urls)}...\")\n\n        if url is None:\n            continue\n\n        # Use the filename from the URL if not provided\n        if not filenames:\n            parsed_url = urlparse(url)\n            filename = parsed_url.path.split(\"/\")[-1]\n        else:\n            filename = filenames.pop(0)\n\n        filepath = os.path.join(outdir, filename)\n        if os.path.exists(filepath) and not overwrite:\n            print(f\"File {filepath} already exists. Skipping...\")\n            continue\n\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filepath, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n\n    session.close()\n</code></pre>"},{"location":"common/#leafmap.common.gedi_search","title":"<code>gedi_search(roi, start_date=None, end_date=None, add_roi=False, return_type='gdf', output=None, sort_filesize=False, **kwargs)</code>","text":"<p>Searches for GEDI data using the Common Metadata Repository (CMR) API. The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials. Credits to ORNL DAAC and Rupesh Shrestha.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <p>A list, tuple, or file path representing the bounding box coordinates in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame containing the region of interest geometry.</p> required <code>start_date</code> <code>Optional[str]</code> <p>The start date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>The end date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>add_roi</code> <code>bool</code> <p>A boolean value indicating whether to include the region of interest as a granule in the search results. Default is False.</p> <code>False</code> <code>return_type</code> <code>str</code> <p>The type of the search results to return. Must be one of 'df' (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.</p> <code>'gdf'</code> <code>output</code> <code>Optional[str]</code> <p>The file path to save the CSV output when return_type is 'csv'. Optional and only applicable when return_type is 'csv'.</p> <code>None</code> <code>sort_filesize</code> <code>bool</code> <p>A boolean value indicating whether to sort the search results.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the CMR API.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame (return_type='gdf'), or a CSV file (return_type='csv').</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If roi is not a list, tuple, or file path.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gedi_search(\n    roi,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    add_roi: bool = False,\n    return_type: str = \"gdf\",\n    output: Optional[str] = None,\n    sort_filesize: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Searches for GEDI data using the Common Metadata Repository (CMR) API.\n    The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials.\n    Credits to ORNL DAAC and Rupesh Shrestha.\n\n    Args:\n        roi: A list, tuple, or file path representing the bounding box coordinates\n            in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame\n            containing the region of interest geometry.\n        start_date: The start date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        end_date: The end date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        add_roi: A boolean value indicating whether to include the region of interest\n            as a granule in the search results. Default is False.\n        return_type: The type of the search results to return. Must be one of 'df'\n            (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.\n        output: The file path to save the CSV output when return_type is 'csv'.\n            Optional and only applicable when return_type is 'csv'.\n        sort_filesize: A boolean value indicating whether to sort the search results.\n        **kwargs: Additional keyword arguments to be passed to the CMR API.\n\n    Returns:\n        The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame\n        (return_type='gdf'), or a CSV file (return_type='csv').\n\n    Raises:\n        ValueError: If roi is not a list, tuple, or file path.\n\n    \"\"\"\n\n    import requests\n    import datetime as dt\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import MultiPolygon, Polygon, box\n    from shapely.ops import orient\n\n    # CMR API base url\n    cmrurl = \"https://cmr.earthdata.nasa.gov/search/\"\n\n    doi = \"10.3334/ORNLDAAC/2056\"  # GEDI L4A DOI\n\n    # Construct the DOI search URL\n    doisearch = cmrurl + \"collections.json?doi=\" + doi\n\n    # Send a request to the CMR API to get the concept ID\n    response = requests.get(doisearch)\n    response.raise_for_status()\n    concept_id = response.json()[\"feed\"][\"entry\"][0][\"id\"]\n\n    # CMR formatted start and end times\n    if start_date is not None and end_date is not None:\n        dt_format = \"%Y-%m-%dT%H:%M:%SZ\"\n        start_date = dt.datetime.strptime(start_date, \"%Y-%m-%d\")\n        end_date = dt.datetime.strptime(end_date, \"%Y-%m-%d\")\n        temporal_str = (\n            start_date.strftime(dt_format) + \",\" + end_date.strftime(dt_format)\n        )\n    else:\n        temporal_str = None\n\n    # CMR formatted bounding box\n    if isinstance(roi, list) or isinstance(roi, tuple):\n        bound_str = \",\".join(map(str, roi))\n    elif isinstance(roi, str):\n        roi = gpd.read_file(roi)\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    elif isinstance(roi, gpd.GeoDataFrame):\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    else:\n        raise ValueError(\"roi must be a list, tuple, or a file path.\")\n\n    page_num = 1\n    page_size = 2000  # CMR page size limit\n\n    granule_arr = []\n\n    while True:\n        # Define CMR search parameters\n        cmr_param = {\n            \"collection_concept_id\": concept_id,\n            \"page_size\": page_size,\n            \"page_num\": page_num,\n        }\n\n        if temporal_str is not None:\n            cmr_param[\"temporal\"] = temporal_str\n\n        if kwargs:\n            cmr_param.update(kwargs)\n\n        granulesearch = cmrurl + \"granules.json\"\n\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            cmr_param[\"bounding_box[]\"] = bound_str\n            response = requests.get(granulesearch, params=cmr_param)\n            response.raise_for_status()\n        else:\n            cmr_param[\"simplify-shapefile\"] = \"true\"\n            geojson = {\n                \"shapefile\": (\n                    \"region.geojson\",\n                    roi.geometry.to_json(),\n                    \"application/geo+json\",\n                )\n            }\n            response = requests.post(granulesearch, data=cmr_param, files=geojson)\n\n        # Send a request to the CMR API to get the granules\n        granules = response.json()[\"feed\"][\"entry\"]\n\n        if granules:\n            for index, g in enumerate(granules):\n                granule_url = \"\"\n                granule_poly = \"\"\n\n                # Read file size\n                granule_size = float(g[\"granule_size\"])\n\n                # Read bounding geometries\n                if \"polygons\" in g:\n                    polygons = g[\"polygons\"]\n                    multipolygons = []\n                    for poly in polygons:\n                        i = iter(poly[0].split(\" \"))\n                        ltln = list(map(\" \".join, zip(i, i)))\n                        multipolygons.append(\n                            Polygon(\n                                [\n                                    [float(p.split(\" \")[1]), float(p.split(\" \")[0])]\n                                    for p in ltln\n                                ]\n                            )\n                        )\n                    granule_poly = MultiPolygon(multipolygons)\n\n                # Get URL to HDF5 files\n                for links in g[\"links\"]:\n                    if (\n                        \"title\" in links\n                        and links[\"title\"].startswith(\"Download\")\n                        and links[\"title\"].endswith(\".h5\")\n                    ):\n                        granule_url = links[\"href\"]\n\n                granule_id = g[\"id\"]\n                title = g[\"title\"]\n                time_start = g[\"time_start\"]\n                time_end = g[\"time_end\"]\n\n                granule_arr.append(\n                    [\n                        granule_id,\n                        title,\n                        time_start,\n                        time_end,\n                        granule_size,\n                        granule_url,\n                        granule_poly,\n                    ]\n                )\n\n            page_num += 1\n        else:\n            break\n\n    # Add bound as the last row into the dataframe\n    if add_roi:\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            b = list(roi)\n            granule_arr.append(\n                [\"roi\", None, None, None, 0, None, box(b[0], b[1], b[2], b[3])]\n            )\n        else:\n            granule_arr.append([\"roi\", None, None, None, 0, None, roi.geometry.item()])\n\n    # Create a pandas dataframe\n    columns = [\n        \"id\",\n        \"title\",\n        \"time_start\",\n        \"time_end\",\n        \"granule_size\",\n        \"granule_url\",\n        \"granule_poly\",\n    ]\n    l4adf = pd.DataFrame(granule_arr, columns=columns)\n\n    # Drop granules with empty geometry\n    l4adf = l4adf[l4adf[\"granule_poly\"] != \"\"]\n\n    if sort_filesize:\n        l4adf = l4adf.sort_values(by=[\"granule_size\"], ascending=True)\n\n    if return_type == \"df\":\n        return l4adf\n    elif return_type == \"gdf\":\n        gdf = gpd.GeoDataFrame(l4adf, geometry=\"granule_poly\")\n        gdf.crs = \"EPSG:4326\"\n        return gdf\n    elif return_type == \"csv\":\n        columns.remove(\"granule_poly\")\n        return l4adf.to_csv(output, index=False, columns=columns)\n    else:\n        raise ValueError(\"return_type must be one of 'df', 'gdf', or 'csv'.\")\n</code></pre>"},{"location":"common/#leafmap.common.gedi_subset","title":"<code>gedi_subset(spatial=None, start_date=None, end_date=None, out_dir=None, collection=None, variables=['all'], max_results=None, username=None, password=None, overwrite=False, **kwargs)</code>","text":"<p>Subsets GEDI data using the Harmony API.</p> <p>Parameters:</p> Name Type Description Default <code>spatial</code> <code>Union[str, gpd.GeoDataFrame, List[float]]</code> <p>Spatial extent for subsetting. Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy]. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Start date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Output directory to save the subsetted files. Defaults to None, which will use the current working directory.</p> <code>None</code> <code>collection</code> <code>Collection</code> <p>GEDI data collection. If not provided, the default collection with DOI '10.3334/ORNLDAAC/2056' will be used. Defaults to None.</p> <code>None</code> <code>variables</code> <code>List[str]</code> <p>List of variable names to subset. Defaults to ['all'], which subsets all available variables.</p> <code>['all']</code> <code>max_results</code> <code>int</code> <p>Maximum number of results to return. Defaults to None, which returns all results.</p> <code>None</code> <code>username</code> <code>str</code> <p>Earthdata username. Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.</p> <code>None</code> <code>password</code> <code>str</code> <p>Earthdata password. Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files in the output directory. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Harmony API request.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the 'harmony' package is not installed.</p> <code>ValueError</code> <p>If the 'spatial', 'start_date', or 'end_date' arguments are not valid.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any value.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gedi_subset(\n    spatial=None,\n    start_date=None,\n    end_date=None,\n    out_dir=None,\n    collection=None,\n    variables=[\"all\"],\n    max_results=None,\n    username=None,\n    password=None,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"\n    Subsets GEDI data using the Harmony API.\n\n    Args:\n        spatial (Union[str, gpd.GeoDataFrame, List[float]], optional): Spatial extent for subsetting.\n            Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy].\n            Defaults to None.\n        start_date (str, optional): Start date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        end_date (str, optional): End date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        out_dir (str, optional): Output directory to save the subsetted files.\n            Defaults to None, which will use the current working directory.\n        collection (Collection, optional): GEDI data collection. If not provided,\n            the default collection with DOI '10.3334/ORNLDAAC/2056' will be used.\n            Defaults to None.\n        variables (List[str], optional): List of variable names to subset.\n            Defaults to ['all'], which subsets all available variables.\n        max_results (int, optional): Maximum number of results to return.\n            Defaults to None, which returns all results.\n        username (str, optional): Earthdata username.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.\n        password (str, optional): Earthdata password.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.\n        overwrite (bool, optional): Whether to overwrite existing files in the output directory.\n            Defaults to False.\n        **kwargs: Additional keyword arguments to pass to the Harmony API request.\n\n    Raises:\n        ImportError: If the 'harmony' package is not installed.\n        ValueError: If the 'spatial', 'start_date', or 'end_date' arguments are not valid.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n\n    try:\n        import harmony\n    except ImportError:\n        install_package(\"harmony-py\")\n\n    import requests as re\n    import geopandas as gpd\n    from datetime import datetime\n    from harmony import BBox, Client, Collection, Environment, Request\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if collection is None:\n        # GEDI L4A DOI\n        doi = \"10.3334/ORNLDAAC/2056\"\n\n        # CMR API base url\n        doisearch = f\"https://cmr.earthdata.nasa.gov/search/collections.json?doi={doi}\"\n        concept_id = re.get(doisearch).json()[\"feed\"][\"entry\"][0][\"id\"]\n        concept_id\n        collection = Collection(id=concept_id)\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\"username and password must be provided.\")\n\n    harmony_client = Client(auth=(username, password))\n\n    if isinstance(spatial, str):\n        spatial = gpd.read_file(spatial)\n\n    if isinstance(spatial, gpd.GeoDataFrame):\n        spatial = spatial.total_bounds.tolist()\n\n    if isinstance(spatial, list) and len(spatial) == 4:\n        bounding_box = BBox(spatial[0], spatial[1], spatial[2], spatial[3])\n    else:\n        raise ValueError(\n            \"spatial must be a list of bounding box coordinates or a GeoDataFrame, or a file path.\"\n        )\n\n    if isinstance(start_date, str):\n        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n    if isinstance(end_date, str):\n        end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    if start_date is None or end_date is None:\n        print(\"start_date and end_date must be provided.\")\n        temporal_range = None\n    else:\n        temporal_range = {\"start\": start_date, \"end\": end_date}\n\n    request = Request(\n        collection=collection,\n        variables=variables,\n        temporal=temporal_range,\n        spatial=bounding_box,\n        ignore_errors=True,\n        max_results=max_results,\n        **kwargs,\n    )\n\n    # submit harmony request, will return job id\n    subset_job_id = harmony_client.submit(request)\n\n    print(f\"Processing job: {subset_job_id}\")\n\n    print(f\"Waiting for the job to finish\")\n    results = harmony_client.result_json(subset_job_id, show_progress=True)\n\n    print(f\"Downloading subset files...\")\n    futures = harmony_client.download_all(\n        subset_job_id, directory=out_dir, overwrite=overwrite\n    )\n    for f in futures:\n        # all subsetted files have this suffix\n        if f.result().endswith(\"subsetted.h5\"):\n            print(f\"Downloaded: {f.result()}\")\n\n    print(f\"Done downloading files.\")\n</code></pre>"},{"location":"common/#leafmap.common.geojson_bounds","title":"<code>geojson_bounds(geojson)</code>","text":"<p>Calculate the bounds of a GeoJSON object.</p> <p>This function uses the shapely library to calculate the bounds of a GeoJSON object. If the shapely library is not installed, it will print a message and return None.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A dictionary representing a GeoJSON object.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds (minx, miny, maxx, maxy) if shapely is installed, None otherwise.</p> Source code in <code>leafmap/common.py</code> <pre><code>def geojson_bounds(geojson: dict) -&gt; Optional[list]:\n    \"\"\"\n    Calculate the bounds of a GeoJSON object.\n\n    This function uses the shapely library to calculate the bounds of a GeoJSON object.\n    If the shapely library is not installed, it will print a message and return None.\n\n    Args:\n        geojson (dict): A dictionary representing a GeoJSON object.\n\n    Returns:\n        list: A list of bounds (minx, miny, maxx, maxy) if shapely is installed, None otherwise.\n    \"\"\"\n    try:\n        import shapely\n    except ImportError:\n        print(\"shapely is not installed\")\n        return\n\n    if isinstance(geojson, str):\n        geojson = json.loads(geojson)\n\n    return list(shapely.bounds(shapely.from_geojson(json.dumps(geojson))))\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_df","title":"<code>geojson_to_df(in_geojson, encoding='utf-8', drop_geometry=True)</code>","text":"<p>Converts a GeoJSON object to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>drop_geometry</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the input GeoJSON file could not be found.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoJSON object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_df(in_geojson, encoding=\"utf-8\", drop_geometry=True):\n    \"\"\"Converts a GeoJSON object to a pandas DataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n        drop_geometry (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the input GeoJSON file could not be found.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import json\n    import pandas as pd\n    from urllib.request import urlopen\n\n    if isinstance(in_geojson, str):\n        if in_geojson.startswith(\"http\"):\n            with urlopen(in_geojson) as f:\n                data = json.load(f)\n        else:\n            in_geojson = os.path.abspath(in_geojson)\n            if not os.path.exists(in_geojson):\n                raise FileNotFoundError(\"The provided GeoJSON file could not be found.\")\n\n            with open(in_geojson, encoding=encoding) as f:\n                data = json.load(f)\n\n    elif isinstance(in_geojson, dict):\n        data = in_geojson\n\n    df = pd.json_normalize(data[\"features\"])\n    df.columns = [col.replace(\"properties.\", \"\") for col in df.columns]\n    if drop_geometry:\n        df = df[df.columns.drop(list(df.filter(regex=\"geometry\")))]\n    return df\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_gdf","title":"<code>geojson_to_gdf(in_geojson, encoding='utf-8', **kwargs)</code>","text":"<p>Converts a GeoJSON object to a geopandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or GeoJSON object as a dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A geopandas GeoDataFrame containing the GeoJSON object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_gdf(in_geojson, encoding=\"utf-8\", **kwargs):\n    \"\"\"Converts a GeoJSON object to a geopandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or GeoJSON object as a dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        geopandas.GeoDataFrame: A geopandas GeoDataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, encoding=encoding, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_gpkg","title":"<code>geojson_to_gpkg(in_geojson, out_gpkg, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPackage.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_gpkg</code> <code>str</code> <p>The output GeoPackage path.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_gpkg(in_geojson, out_gpkg, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPackage.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_gpkg (str): The output GeoPackage path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_gpkg)[1]\n    if ext.lower() != \".gpkg\":\n        out_gpkg = out_gpkg + \".gpkg\"\n    out_gpkg = check_file_path(out_gpkg)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    name = os.path.splitext(os.path.basename(out_gpkg))[0]\n    gdf.to_file(out_gpkg, layer=name, driver=\"GPKG\")\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_mbtiles","title":"<code>geojson_to_mbtiles(input_file, output_file, layer_name=None, options=None, quiet=False)</code>","text":"<p>Converts vector data to .mbtiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> required <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_mbtiles(\n    input_file: str,\n    output_file: str,\n    layer_name: Optional[str] = None,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to .mbtiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_pmtiles","title":"<code>geojson_to_pmtiles(input_file, output_file=None, layer_name=None, projection='EPSG:4326', overwrite=False, options=None, quiet=False)</code>","text":"<p>Converts vector data to PMTiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> <code>None</code> <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>projection</code> <code>Optional[str]</code> <p>Projection for the output PMTiles file. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the existing output file. Defaults to False.</p> <code>False</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. Defaults to None. To reduce the size of the output file, use '-zg' or '-z max-zoom'.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_pmtiles(\n    input_file: str,\n    output_file: Optional[str] = None,\n    layer_name: Optional[str] = None,\n    projection: Optional[str] = \"EPSG:4326\",\n    overwrite: bool = False,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to PMTiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        projection (Optional[str]): Projection for the output PMTiles file. Defaults to \"EPSG:4326\".\n        overwrite (bool): If True, overwrite the existing output file. Defaults to False.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. Defaults to None.\n            To reduce the size of the output file, use '-zg' or '-z max-zoom'.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    if output_file is None:\n        output_file = os.path.splitext(input_file)[0] + \".pmtiles\"\n\n    if not output_file.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: output file must be a .pmtiles file.\")\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    command.extend([\"--projection\", projection])\n\n    if options is None:\n        options = []\n\n    if overwrite:\n        command.append(\"--force\")\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#leafmap.common.geojson_to_shp","title":"<code>geojson_to_shp(in_geojson, out_shp, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_shp</code> <code>str</code> <p>The output shapefile path.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def geojson_to_shp(in_geojson, out_shp, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_shp (str): The output shapefile path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_shp)[1]\n    if ext != \".shp\":\n        out_shp = out_shp + \".shp\"\n    out_shp = check_file_path(out_shp)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    gdf.to_file(out_shp)\n</code></pre>"},{"location":"common/#leafmap.common.geom_type","title":"<code>geom_type(in_geojson, encoding='utf-8')</code>","text":"<p>Returns the geometry type of a GeoJSON object.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>dict</code> <p>A GeoJSON object.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>leafmap/common.py</code> <pre><code>def geom_type(in_geojson, encoding=\"utf-8\"):\n    \"\"\"Returns the geometry type of a GeoJSON object.\n\n    Args:\n        in_geojson (dict): A GeoJSON object.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        str: The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import json\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n\n        return data[\"features\"][0][\"geometry\"][\"type\"]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.geometry_bounds","title":"<code>geometry_bounds(geometry, decimals=4)</code>","text":"<p>Returns the bounds of a geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON geometry.</p> required <code>decimals</code> <code>int</code> <p>The number of decimal places to round the bounds to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [minx, miny, maxx, maxy].</p> Source code in <code>leafmap/common.py</code> <pre><code>def geometry_bounds(geometry, decimals=4):\n    \"\"\"Returns the bounds of a geometry.\n\n    Args:\n        geometry (dict): A GeoJSON geometry.\n        decimals (int, optional): The number of decimal places to round the bounds to. Defaults to 4.\n\n    Returns:\n        list: A list of bounds in the form of [minx, miny, maxx, maxy].\n    \"\"\"\n    if isinstance(geometry, dict):\n        if \"geometry\" in geometry:\n            coords = geometry[\"geometry\"][\"coordinates\"][0]\n        else:\n            coords = geometry[\"coordinates\"][0]\n\n    else:\n        raise ValueError(\"geometry must be a GeoJSON-like dictionary.\")\n\n    x = [p[0] for p in coords]\n    y = [p[1] for p in coords]\n    west = round(min(x), decimals)\n    east = round(max(x), decimals)\n    south = round(min(y), decimals)\n    north = round(max(y), decimals)\n    return [west, south, east, north]\n</code></pre>"},{"location":"common/#leafmap.common.get_3dep_dem","title":"<code>get_3dep_dem(geometry, resolution=30, src_crs='EPSG:4326', output=None, dst_crs='EPSG:5070', to_cog=False, overwrite=False, **kwargs)</code>","text":"<p>Get DEM data at any resolution from 3DEP.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Polygon | MultiPolygon | tuple</code> <p>It can be a polygon or a bounding box of form (xmin, ymin, xmax, ymax).</p> required <code>resolution</code> <code>int</code> <p>arget DEM source resolution in meters. Defaults to 30.</p> <code>30</code> <code>src_crs</code> <code>str</code> <p>The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>The output GeoTIFF file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".</p> <code>'EPSG:5070'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the output file if it exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>DEM at the specified resolution in meters and CRS.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_3dep_dem(\n    geometry,\n    resolution=30,\n    src_crs=\"EPSG:4326\",\n    output=None,\n    dst_crs=\"EPSG:5070\",\n    to_cog=False,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"Get DEM data at any resolution from 3DEP.\n\n    Args:\n        geometry (Polygon | MultiPolygon | tuple): It can be a polygon or a bounding\n            box of form (xmin, ymin, xmax, ymax).\n        resolution (int): arget DEM source resolution in meters. Defaults to 30.\n        src_crs (str, optional): The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".\n        output (str, optional): The output GeoTIFF file. Defaults to None.\n        dst_crs (str, optional): The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the output file if it exists. Defaults to False.\n\n    Returns:\n        xarray.DataArray: DEM at the specified resolution in meters and CRS.\n    \"\"\"\n\n    try:\n        import py3dep\n    except ImportError:\n        raise ImportError(\"py3dep is not installed. Install it with pip install py3dep\")\n\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is not installed. Install it with pip install geopandas\"\n        )\n\n    if output is not None and os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Set overwrite=True to overwrite it\")\n        return\n\n    if isinstance(geometry, gpd.GeoDataFrame):\n        geometry = geometry.geometry.unary_union\n\n    dem = py3dep.get_dem(geometry, resolution=resolution, crs=src_crs)\n    dem = dem.rio.reproject(dst_crs)\n\n    if output is not None:\n        if not output.endswith(\".tif\"):\n            output += \".tif\"\n        print(output)\n        dem.rio.to_raster(output, **kwargs)\n\n        if to_cog:\n            image_to_cog(output, output)\n\n    else:\n        return dem\n</code></pre>"},{"location":"common/#leafmap.common.get_api_key","title":"<code>get_api_key(name=None, key=None)</code>","text":"<p>Retrieves an API key. If a key is provided, it is returned directly. If a name is provided, the function attempts to retrieve the key from user data (if running in Google Colab) or from environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the key to retrieve. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>The key to return directly. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The retrieved key, or None if no key was found.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_api_key(name: Optional[str] = None, key: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"\n    Retrieves an API key. If a key is provided, it is returned directly. If a\n    name is provided, the function attempts to retrieve the key from user data\n    (if running in Google Colab) or from environment variables.\n\n    Args:\n        name (Optional[str], optional): The name of the key to retrieve. Defaults to None.\n        key (Optional[str], optional): The key to return directly. Defaults to None.\n\n    Returns:\n        Optional[str]: The retrieved key, or None if no key was found.\n    \"\"\"\n\n    if key is not None:\n        return key\n    elif name is not None:\n        if _in_colab_shell():\n            from google.colab import userdata\n\n            try:\n                return userdata.get(name)\n            except:\n                return os.environ.get(name)\n        else:\n            return os.environ.get(name)\n</code></pre>"},{"location":"common/#leafmap.common.get_bounds","title":"<code>get_bounds(geometry, north_up=True, transform=None)</code>","text":"<p>Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection. left, bottom, right, top not xmin, ymin, xmax, ymax If not north_up, y will be switched to guarantee the above. Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of coordinates representing [left, bottom, right, top]</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_bounds(geometry, north_up=True, transform=None):\n    \"\"\"Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection.\n    left, bottom, right, top\n    *not* xmin, ymin, xmax, ymax\n    If not north_up, y will be switched to guarantee the above.\n    Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: A list of coordinates representing [left, bottom, right, top]\n    \"\"\"\n\n    if \"bbox\" in geometry:\n        return tuple(geometry[\"bbox\"])\n\n    geometry = geometry.get(\"geometry\") or geometry\n\n    # geometry must be a geometry, GeometryCollection, or FeatureCollection\n    if not (\n        \"coordinates\" in geometry or \"geometries\" in geometry or \"features\" in geometry\n    ):\n        raise ValueError(\n            \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n            \"or FeatureCollection\"\n        )\n\n    if \"features\" in geometry:\n        # Input is a FeatureCollection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for feature in geometry[\"features\"]:\n            xmin, ymin, xmax, ymax = get_bounds(feature[\"geometry\"])\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"geometries\" in geometry:\n        # Input is a geometry collection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for geometry in geometry[\"geometries\"]:\n            xmin, ymin, xmax, ymax = get_bounds(geometry)\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"coordinates\" in geometry:\n        # Input is a singular geometry object\n        if transform is not None:\n            xyz = list(explode(geometry[\"coordinates\"]))\n            xyz_px = [transform * point for point in xyz]\n            xyz = tuple(zip(*xyz_px))\n            return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n        else:\n            xyz = tuple(zip(*list(explode(geometry[\"coordinates\"]))))\n            if north_up:\n                return min(xyz[0]), min(xyz[1]), max(xyz[0]), max(xyz[1])\n            else:\n                return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n\n    # all valid inputs returned above, so whatever falls through is an error\n    raise ValueError(\n        \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n        \"or FeatureCollection\"\n    )\n</code></pre>"},{"location":"common/#leafmap.common.get_census_dict","title":"<code>get_census_dict(reset=False)</code>","text":"<p>Returns a dictionary of Census data.</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Reset the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of Census data.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_census_dict(reset=False):\n    \"\"\"Returns a dictionary of Census data.\n\n    Args:\n        reset (bool, optional): Reset the dictionary. Defaults to False.\n\n    Returns:\n        dict: A dictionary of Census data.\n    \"\"\"\n    import json\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    census_data = os.path.join(pkg_dir, \"data/census_data.json\")\n\n    if reset:\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n        census_dict = {}\n\n        names = [\n            \"Current\",\n            \"ACS 2021\",\n            \"ACS 2019\",\n            \"ACS 2018\",\n            \"ACS 2017\",\n            \"ACS 2016\",\n            \"ACS 2015\",\n            \"ACS 2014\",\n            \"ACS 2013\",\n            \"ACS 2012\",\n            \"ECON 2012\",\n            \"Census 2020\",\n            \"Census 2010\",\n            \"Physical Features\",\n            \"Decennial Census 2020\",\n            \"Decennial Census 2010\",\n            \"Decennial Census 2000\",\n            \"Decennial Physical Features\",\n        ]\n\n        links = {}\n\n        print(\"Retrieving data. Please wait ...\")\n        for name in names:\n            if \"Decennial\" not in name:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/TIGERweb/tigerWMS_{name.replace(' ', '')}/MapServer/WMSServer\"\n                )\n            else:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/Census2020/tigerWMS_{name.replace('Decennial', '').replace(' ', '')}/MapServer/WMSServer\"\n                )\n\n            wms = WebMapService(links[name], timeout=300)\n            layers = list(wms.contents)\n            layers.sort()\n            census_dict[name] = {\n                \"url\": links[name],\n                \"layers\": layers,\n                # \"title\": wms.identification.title,\n                # \"abstract\": wms.identification.abstract,\n            }\n\n        with open(census_data, \"w\") as f:\n            json.dump(census_dict, f, indent=4)\n\n    else:\n        with open(census_data, \"r\") as f:\n            census_dict = json.load(f)\n\n    return census_dict\n</code></pre>"},{"location":"common/#leafmap.common.get_center","title":"<code>get_center(geometry, north_up=True, transform=None)</code>","text":"<p>Get the centroid of a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>[lon, lat]</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_center(geometry, north_up=True, transform=None):\n    \"\"\"Get the centroid of a GeoJSON.\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: [lon, lat]\n    \"\"\"\n    bounds = get_bounds(geometry, north_up, transform)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"common/#leafmap.common.get_direct_url","title":"<code>get_direct_url(url)</code>","text":"<p>Get the direct URL for a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to get the direct URL for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The direct URL.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_direct_url(url):\n    \"\"\"Get the direct URL for a given URL.\n\n    Args:\n        url (str): The URL to get the direct URL for.\n\n    Returns:\n        str: The direct URL.\n    \"\"\"\n\n    if not isinstance(url, str):\n        raise ValueError(\"url must be a string.\")\n\n    if not url.startswith(\"http\"):\n        raise ValueError(\"url must start with http.\")\n\n    r = requests.head(url, allow_redirects=True)\n    return r.url\n</code></pre>"},{"location":"common/#leafmap.common.get_gdal_drivers","title":"<code>get_gdal_drivers()</code>","text":"<p>Get a list of available driver names in the GDAL library.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of available driver names.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_gdal_drivers() -&gt; List[str]:\n    \"\"\"Get a list of available driver names in the GDAL library.\n\n    Returns:\n        List[str]: A list of available driver names.\n    \"\"\"\n    from osgeo import ogr\n\n    driver_list = []\n\n    # Iterate over all registered drivers\n    for i in range(ogr.GetDriverCount()):\n        driver = ogr.GetDriver(i)\n        driver_name = driver.GetName()\n        driver_list.append(driver_name)\n\n    return driver_list\n</code></pre>"},{"location":"common/#leafmap.common.get_gdal_file_extension","title":"<code>get_gdal_file_extension(driver_name)</code>","text":"<p>Get the file extension corresponding to a driver name in the GDAL library.</p> <p>Parameters:</p> Name Type Description Default <code>driver_name</code> <code>str</code> <p>The name of the driver.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_gdal_file_extension(driver_name: str) -&gt; Optional[str]:\n    \"\"\"Get the file extension corresponding to a driver name in the GDAL library.\n\n    Args:\n        driver_name (str): The name of the driver.\n\n    Returns:\n        Optional[str]: The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.\n    \"\"\"\n    from osgeo import ogr\n\n    driver = ogr.GetDriverByName(driver_name)\n    if driver is None:\n        drivers = get_gdal_drivers()\n        raise ValueError(\n            f\"Driver {driver_name} not found. Available drivers: {drivers}\"\n        )\n\n    metadata = driver.GetMetadata()\n    if \"DMD_EXTENSION\" in metadata:\n        file_extension = driver.GetMetadataItem(\"DMD_EXTENSION\")\n    else:\n        file_extensions = driver.GetMetadataItem(\"DMD_EXTENSIONS\")\n        if file_extensions == \"json geojson\":\n            file_extension = \"geojson\"\n        else:\n            file_extension = file_extensions.split()[0].lower()\n\n    return file_extension\n</code></pre>"},{"location":"common/#leafmap.common.get_geometry_coords","title":"<code>get_geometry_coords(row, geom, coord_type, shape_type, mercator=False)</code>","text":"<p>Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.</p> <p>:param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame. :param: (str) geom : The column name. :param: (str) coord_type : Whether it's 'x' or 'y' coordinate. :param: (str) shape_type</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_geometry_coords(row, geom, coord_type, shape_type, mercator=False):\n    \"\"\"\n    Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.\n\n    :param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame.\n    :param: (str) geom : The column name.\n    :param: (str) coord_type : Whether it's 'x' or 'y' coordinate.\n    :param: (str) shape_type\n    \"\"\"\n\n    # Parse the exterior of the coordinate\n    if shape_type.lower() in [\"polygon\", \"multipolygon\"]:\n        exterior = row[geom].geoms[0].exterior\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = list(exterior.coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = list(exterior.coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"linestring\", \"multilinestring\"]:\n        if coord_type == \"x\":\n            coords = list(row[geom].coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n        elif coord_type == \"y\":\n            coords = list(row[geom].coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"point\", \"multipoint\"]:\n        exterior = row[geom]\n\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = exterior.coords.xy[0][0]\n            if mercator:\n                coords = lnglat_to_meters(coords, 0)[0]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = exterior.coords.xy[1][0]\n            if mercator:\n                coords = lnglat_to_meters(0, coords)[1]\n            return coords\n</code></pre>"},{"location":"common/#leafmap.common.get_geometry_type","title":"<code>get_geometry_type(in_geojson)</code>","text":"<p>Get the geometry type of a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The path to the GeoJSON file or a GeoJSON dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",     \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_geometry_type(in_geojson: Union[str, Dict]) -&gt; str:\n    \"\"\"Get the geometry type of a GeoJSON file.\n\n    Args:\n        in_geojson (str | dict): The path to the GeoJSON file or a GeoJSON dictionary.\n\n    Returns:\n        str: The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",\n            \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".\n    \"\"\"\n\n    import geojson\n\n    try:\n        if isinstance(in_geojson, str):  # If input is a file path\n            with open(in_geojson, \"r\") as geojson_file:\n                geojson_data = geojson.load(geojson_file)\n        elif isinstance(in_geojson, dict):  # If input is a GeoJSON dictionary\n            geojson_data = in_geojson\n        else:\n            return \"Invalid input type. Expected file path or dictionary.\"\n\n        if \"type\" in geojson_data:\n            if geojson_data[\"type\"] == \"FeatureCollection\":\n                features = geojson_data.get(\"features\", [])\n                if features:\n                    first_feature = features[0]\n                    geometry = first_feature.get(\"geometry\")\n                    if geometry and \"type\" in geometry:\n                        return geometry[\"type\"]\n                    else:\n                        return \"No geometry type found in the first feature.\"\n                else:\n                    return \"No features found in the FeatureCollection.\"\n            elif geojson_data[\"type\"] == \"Feature\":\n                geometry = geojson_data.get(\"geometry\")\n                if geometry and \"type\" in geometry:\n                    return geometry[\"type\"]\n                else:\n                    return \"No geometry type found in the Feature.\"\n            else:\n                return \"Unsupported GeoJSON type.\"\n        else:\n            return \"No 'type' field found in the GeoJSON data.\"\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"common/#leafmap.common.get_google_map","title":"<code>get_google_map(map_type='HYBRID', show=True, api_key=None, backend='ipyleaflet', **kwargs)</code>","text":"<p>Gets Google basemap tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>show</code> <code>bool</code> <p>Whether to add the layer to the map. Defaults to True.</p> <code>True</code> <code>api_key</code> <code>str</code> <p>The Google Maps API key. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to ipyleaflet.TileLayer().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def get_google_map(\n    map_type=\"HYBRID\", show=True, api_key=None, backend=\"ipyleaflet\", **kwargs\n):\n    \"\"\"Gets Google basemap tile layer.\n\n    Args:\n        map_type (str, optional): Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.\n        show (bool, optional): Whether to add the layer to the map. Defaults to True.\n        api_key (str, optional): The Google Maps API key. Defaults to None.\n        **kwargs: Additional arguments to pass to ipyleaflet.TileLayer().\n    \"\"\"\n\n    allow_types = [\"ROADMAP\", \"SATELLITE\", \"HYBRID\", \"TERRAIN\"]\n    if map_type not in allow_types:\n        print(\"map_type must be one of the following: {}\".format(allow_types))\n        return\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_MAPS_API_KEY\", \"YOUR-API-KEY\")\n\n    if api_key == \"\":\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldStreetMap\",\n            },\n            \"SATELLITE\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n            \"TERRAIN\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldTopoMap\",\n            },\n            \"HYBRID\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n        }\n\n        print(\n            \"Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\"\n        )\n\n    else:\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=m&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Maps\",\n            },\n            \"SATELLITE\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=s&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Satellite\",\n            },\n            \"TERRAIN\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=p&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Terrain\",\n            },\n            \"HYBRID\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=y&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Hybrid\",\n            },\n        }\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 24\n\n    if backend == \"ipyleaflet\":\n        import ipyleaflet\n\n        layer = ipyleaflet.TileLayer(\n            url=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attribution=MAP_TILES[map_type][\"attribution\"],\n            visible=show,\n            **kwargs,\n        )\n    elif backend == \"folium\":\n        import folium\n\n        layer = folium.TileLayer(\n            tiles=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attr=MAP_TILES[map_type][\"attribution\"],\n            overlay=True,\n            control=True,\n            show=show,\n            **kwargs,\n        )\n    else:\n        raise ValueError(\"backend must be either 'ipyleaflet' or 'folium'\")\n\n    return layer\n</code></pre>"},{"location":"common/#leafmap.common.get_local_tile_layer","title":"<code>get_local_tile_layer(source, port='default', debug=False, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, tile_format='ipyleaflet', layer_name='Local COG', client_args={'cors_all': False}, return_client=False, quiet=False, **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).     If you are using this function in JupyterHub on a remote server and the raster does not render properly, try     running the following two lines before calling this function:</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>'Local COG'</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to the TileClient. Defaults to {}.</p> <code>{'cors_all': False}</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, the error messages will be suppressed. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_local_tile_layer(\n    source,\n    port=\"default\",\n    debug=False,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"Local COG\",\n    client_args={\"cors_all\": False},\n    return_client=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        client_args (dict, optional): Additional arguments to pass to the TileClient. Defaults to {}.\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        quiet (bool, optional): If True, the error messages will be suppressed. Defaults to False.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n    import rasterio\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    # Handle legacy localtileserver kwargs\n    if \"cmap\" in kwargs:\n        warnings.warn(\n            \"`cmap` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"palette\" in kwargs:\n        warnings.warn(\n            \"`palette` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"band\" in kwargs or \"bands\" in kwargs:\n        warnings.warn(\n            \"`band` and `bands` are deprecated keyword arguments for get_local_tile_layer. Please use `indexes`.\"\n        )\n    if \"projection\" in kwargs:\n        warnings.warn(\n            \"`projection` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n    if \"style\" in kwargs:\n        warnings.warn(\n            \"`style` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 30\n    if \"cmap\" in kwargs:\n        colormap = kwargs.pop(\"cmap\")\n    if \"palette\" in kwargs:\n        colormap = kwargs.pop(\"palette\")\n    if \"band\" in kwargs:\n        indexes = kwargs.pop(\"band\")\n    if \"bands\" in kwargs:\n        indexes = kwargs.pop(\"bands\")\n\n    # Make it compatible with binder and JupyterHub\n    if os.environ.get(\"JUPYTERHUB_SERVICE_PREFIX\") is not None:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}\"\n        )\n\n    if is_studio_lab():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"studiolab/default/jupyter/proxy/{{port}}\"\n        )\n    elif is_on_aws():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = \"proxy/{port}\"\n    elif \"prefix\" in kwargs:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = kwargs[\"prefix\"]\n        kwargs.pop(\"prefix\")\n\n    from localtileserver import (\n        get_leaflet_tile_layer,\n        get_folium_tile_layer,\n        TileClient,\n    )\n\n    # if \"show_loading\" not in kwargs:\n    #     kwargs[\"show_loading\"] = False\n\n    if isinstance(source, str):\n        if not source.startswith(\"http\"):\n            if source.startswith(\"~\"):\n                source = os.path.expanduser(source)\n            # else:\n            #     source = os.path.abspath(source)\n            # if not os.path.exists(source):\n            #     raise ValueError(\"The source path does not exist.\")\n        else:\n            source = github_raw_url(source)\n    elif isinstance(source, TileClient) or isinstance(\n        source, rasterio.io.DatasetReader\n    ):\n        pass\n\n    else:\n        raise ValueError(\"The source must either be a string or TileClient\")\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    if layer_name is None:\n        if source.startswith(\"http\"):\n            layer_name = \"RemoteTile_\" + random_string(3)\n        else:\n            layer_name = \"LocalTile_\" + random_string(3)\n\n    if isinstance(source, str) or isinstance(source, rasterio.io.DatasetReader):\n        tile_client = TileClient(source, port=port, debug=debug, **client_args)\n    else:\n        tile_client = source\n\n    if quiet:\n        output = widgets.Output()\n        with output:\n            if tile_format == \"ipyleaflet\":\n                tile_layer = get_leaflet_tile_layer(\n                    tile_client,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attribution=attribution,\n                    name=layer_name,\n                    **kwargs,\n                )\n            else:\n                tile_layer = get_folium_tile_layer(\n                    tile_client,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attr=attribution,\n                    overlay=True,\n                    name=layer_name,\n                    **kwargs,\n                )\n    else:\n        if tile_format == \"ipyleaflet\":\n            tile_layer = get_leaflet_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                name=layer_name,\n                **kwargs,\n            )\n        else:\n            tile_layer = get_folium_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attr=attribution,\n                overlay=True,\n                name=layer_name,\n                **kwargs,\n            )\n\n    if return_client:\n        return tile_layer, tile_client\n    else:\n        return tile_layer\n\n    # center = tile_client.center()\n    # bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    # bounds = (bounds[2], bounds[0], bounds[3], bounds[1])  # [minx, miny, maxx, maxy]\n\n    # if get_center and get_bounds:\n    #     return tile_layer, center, bounds\n    # elif get_center:\n    #     return tile_layer, center\n    # elif get_bounds:\n    #     return tile_layer, bounds\n    # else:\n    #     return tile_layer\n</code></pre>"},{"location":"common/#leafmap.common.get_nhd_basins","title":"<code>get_nhd_basins(feature_ids, fsource='nwissite', split_catchment=False, simplified=True, **kwargs)</code>","text":"<p>Get NHD basins for a list of station IDs.</p> <p>Parameters:</p> Name Type Description Default <code>feature_ids</code> <code>str | list</code> <p>Target feature ID(s).</p> required <code>fsource</code> <code>str</code> <p>The name of feature(s) source, defaults to <code>nwissite</code>. The valid sources are: * 'comid' for NHDPlus comid. * 'ca_gages' for Streamgage catalog for CA SB19 * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest * 'huc12pp' for HUC12 Pour Points * 'nmwdi-st' for New Mexico Water Data Initiative Sites * 'nwisgw' for NWIS Groundwater Sites * 'nwissite' for NWIS Surface Water Sites * 'ref_gage' for geoconnex.us reference gauges * 'vigil' for Vigil Network Data * 'wade' for Water Data Exchange 2.0 Sites * 'WQP' for Water Quality Portal</p> <code>'nwissite'</code> <code>split_catchment</code> <code>bool</code> <p>If True, split basins at their outlet locations</p> <code>False</code> <code>simplified</code> <code>bool</code> <p>If True, return a simplified version of basin geometries. Default to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If pynhd is not installed.</p> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>NLDI indexed basins in EPSG:4326. If some IDs don't return any features     a list of missing ID(s) are returned as well.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_nhd_basins(\n    feature_ids,\n    fsource=\"nwissite\",\n    split_catchment=False,\n    simplified=True,\n    **kwargs,\n):\n    \"\"\"Get NHD basins for a list of station IDs.\n\n    Args:\n        feature_ids (str | list): Target feature ID(s).\n        fsource (str, optional): The name of feature(s) source, defaults to ``nwissite``.\n            The valid sources are:\n            * 'comid' for NHDPlus comid.\n            * 'ca_gages' for Streamgage catalog for CA SB19\n            * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest\n            * 'huc12pp' for HUC12 Pour Points\n            * 'nmwdi-st' for New Mexico Water Data Initiative Sites\n            * 'nwisgw' for NWIS Groundwater Sites\n            * 'nwissite' for NWIS Surface Water Sites\n            * 'ref_gage' for geoconnex.us reference gauges\n            * 'vigil' for Vigil Network Data\n            * 'wade' for Water Data Exchange 2.0 Sites\n            * 'WQP' for Water Quality Portal\n        split_catchment (bool, optional): If True, split basins at their outlet locations\n        simplified (bool, optional): If True, return a simplified version of basin geometries.\n            Default to True.\n\n    Raises:\n        ImportError: If pynhd is not installed.\n\n    Returns:\n        geopandas.GeoDataFrame: NLDI indexed basins in EPSG:4326. If some IDs don't return any features\n            a list of missing ID(s) are returned as well.\n    \"\"\"\n\n    try:\n        from pynhd import NLDI\n    except ImportError:\n        raise ImportError(\"pynhd is not installed. Install it with pip install pynhd\")\n\n    return NLDI().get_basins(\n        feature_ids, fsource, split_catchment, simplified, **kwargs\n    )\n</code></pre>"},{"location":"common/#leafmap.common.get_overlap","title":"<code>get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True)</code>","text":"<p>Get overlapping area of two images.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image.</p> required <code>img2</code> <code>str</code> <p>Path to the second image.</p> required <code>overlap</code> <code>str</code> <p>Path to the output overlap area in GeoJSON format.</p> required <code>out_img1</code> <code>str</code> <p>Path to the cropped image of the first image.</p> <code>None</code> <code>out_img2</code> <code>str</code> <p>Path to the cropped image of the second image.</p> <code>None</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output images to COG.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the overlap area in GeoJSON format.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True):\n    \"\"\"Get overlapping area of two images.\n\n    Args:\n        img1 (str): Path to the first image.\n        img2 (str): Path to the second image.\n        overlap (str): Path to the output overlap area in GeoJSON format.\n        out_img1 (str, optional): Path to the cropped image of the first image.\n        out_img2 (str, optional): Path to the cropped image of the second image.\n        to_cog (bool, optional): Whether to convert the output images to COG.\n\n    Returns:\n        str: Path to the overlap area in GeoJSON format.\n    \"\"\"\n    import json\n    from osgeo import gdal, ogr, osr\n    import geopandas as gpd\n\n    extent = gdal.Info(img1, format=\"json\")[\"wgs84Extent\"]\n    poly1 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    extent = gdal.Info(img2, format=\"json\")[\"wgs84Extent\"]\n    poly2 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    intersection = poly1.Intersection(poly2)\n    gg = gdal.OpenEx(intersection.ExportToJson())\n    ds = gdal.VectorTranslate(\n        overlap,\n        srcDS=gg,\n        format=\"GeoJSON\",\n        layerCreationOptions=[\"RFC7946=YES\", \"WRITE_BBOX=YES\"],\n    )\n    ds = None\n\n    d = gdal.Open(img1)\n    proj = osr.SpatialReference(wkt=d.GetProjection())\n    epsg = proj.GetAttrValue(\"AUTHORITY\", 1)\n\n    gdf = gpd.read_file(overlap)\n    gdf.to_crs(epsg=epsg, inplace=True)\n    gdf.to_file(overlap)\n\n    if out_img1 is not None:\n        clip_image(img1, overlap, out_img1, to_cog=to_cog)\n\n    if out_img2 is not None:\n        clip_image(img2, overlap, out_img2, to_cog=to_cog)\n\n    return overlap\n</code></pre>"},{"location":"common/#leafmap.common.get_palettable","title":"<code>get_palettable(types=None)</code>","text":"<p>Get a list of palettable color palettes.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>list</code> <p>A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of palettable color palettes.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_palettable(types=None):\n    \"\"\"Get a list of palettable color palettes.\n\n    Args:\n        types (list, optional): A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.\n\n    Returns:\n        list: A list of palettable color palettes.\n    \"\"\"\n    try:\n        import palettable\n    except ImportError:\n        raise ImportError(\n            \"Please install the palettable package using 'pip install palettable'.\"\n        )\n\n    if types is not None and (not isinstance(types, list)):\n        raise ValueError(\"The types must be a list.\")\n\n    allowed_palettes = [\n        \"cartocolors\",\n        \"cmocean\",\n        \"colorbrewer\",\n        \"cubehelix\",\n        \"lightbartlein\",\n        \"matplotlib\",\n        \"mycarta\",\n        \"scientific\",\n        \"tableau\",\n        \"wesanderson\",\n    ]\n\n    if types is None:\n        types = allowed_palettes[:]\n\n    if all(x in allowed_palettes for x in types):\n        pass\n    else:\n        raise ValueError(\n            \"The types must be one of the following: \" + \", \".join(allowed_palettes)\n        )\n\n    palettes = []\n\n    if \"cartocolors\" in types:\n        cartocolors_diverging = [\n            f\"cartocolors.diverging.{c}\"\n            for c in dir(palettable.cartocolors.diverging)[:-19]\n        ]\n        cartocolors_qualitative = [\n            f\"cartocolors.qualitative.{c}\"\n            for c in dir(palettable.cartocolors.qualitative)[:-19]\n        ]\n        cartocolors_sequential = [\n            f\"cartocolors.sequential.{c}\"\n            for c in dir(palettable.cartocolors.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + cartocolors_diverging\n            + cartocolors_qualitative\n            + cartocolors_sequential\n        )\n\n    if \"cmocean\" in types:\n        cmocean_diverging = [\n            f\"cmocean.diverging.{c}\" for c in dir(palettable.cmocean.diverging)[:-19]\n        ]\n        cmocean_sequential = [\n            f\"cmocean.sequential.{c}\" for c in dir(palettable.cmocean.sequential)[:-19]\n        ]\n\n        palettes = palettes + cmocean_diverging + cmocean_sequential\n\n    if \"colorbrewer\" in types:\n        colorbrewer_diverging = [\n            f\"colorbrewer.diverging.{c}\"\n            for c in dir(palettable.colorbrewer.diverging)[:-19]\n        ]\n        colorbrewer_qualitative = [\n            f\"colorbrewer.qualitative.{c}\"\n            for c in dir(palettable.colorbrewer.qualitative)[:-19]\n        ]\n        colorbrewer_sequential = [\n            f\"colorbrewer.sequential.{c}\"\n            for c in dir(palettable.colorbrewer.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + colorbrewer_diverging\n            + colorbrewer_qualitative\n            + colorbrewer_sequential\n        )\n\n    if \"cubehelix\" in types:\n        cubehelix = [\n            \"classic_16\",\n            \"cubehelix1_16\",\n            \"cubehelix2_16\",\n            \"cubehelix3_16\",\n            \"jim_special_16\",\n            \"perceptual_rainbow_16\",\n            \"purple_16\",\n            \"red_16\",\n        ]\n        cubehelix = [f\"cubehelix.{c}\" for c in cubehelix]\n        palettes = palettes + cubehelix\n\n    if \"lightbartlein\" in types:\n        lightbartlein_diverging = [\n            f\"lightbartlein.diverging.{c}\"\n            for c in dir(palettable.lightbartlein.diverging)[:-19]\n        ]\n        lightbartlein_sequential = [\n            f\"lightbartlein.sequential.{c}\"\n            for c in dir(palettable.lightbartlein.sequential)[:-19]\n        ]\n\n        palettes = palettes + lightbartlein_diverging + lightbartlein_sequential\n\n    if \"matplotlib\" in types:\n        matplotlib_colors = [\n            f\"matplotlib.{c}\" for c in dir(palettable.matplotlib)[:-16]\n        ]\n        palettes = palettes + matplotlib_colors\n\n    if \"mycarta\" in types:\n        mycarta = [f\"mycarta.{c}\" for c in dir(palettable.mycarta)[:-16]]\n        palettes = palettes + mycarta\n\n    if \"scientific\" in types:\n        scientific_diverging = [\n            f\"scientific.diverging.{c}\"\n            for c in dir(palettable.scientific.diverging)[:-19]\n        ]\n        scientific_sequential = [\n            f\"scientific.sequential.{c}\"\n            for c in dir(palettable.scientific.sequential)[:-19]\n        ]\n\n        palettes = palettes + scientific_diverging + scientific_sequential\n\n    if \"tableau\" in types:\n        tableau = [f\"tableau.{c}\" for c in dir(palettable.tableau)[:-14]]\n        palettes = palettes + tableau\n\n    return palettes\n</code></pre>"},{"location":"common/#leafmap.common.get_palette_colors","title":"<code>get_palette_colors(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_palette_colors(cmap_name=None, n_class=None, hashtag=False):\n    \"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        cmap = plt.get_cmap(cmap_name, n_class)\n    except:\n        cmap = plt.cm.get_cmap(cmap_name, n_class)\n    colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n    return colors\n</code></pre>"},{"location":"common/#leafmap.common.get_solar_data","title":"<code>get_solar_data(lat, lon, radiusMeters=50, view='FULL_LAYERS', requiredQuality='HIGH', pixelSizeMeters=0.1, api_key=None, header=None, out_dir=None, basename=None, quiet=False, **kwargs)</code>","text":"<p>Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar. You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the location.</p> required <code>lon</code> <code>float</code> <p>Longitude of the location.</p> required <code>radiusMeters</code> <code>int</code> <p>Radius in meters for the data retrieval (default is 50).</p> <code>50</code> <code>view</code> <code>str</code> <p>View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.</p> <code>'FULL_LAYERS'</code> <code>requiredQuality</code> <code>str</code> <p>Required quality level (default is \"HIGH\").</p> <code>'HIGH'</code> <code>pixelSizeMeters</code> <code>float</code> <p>Pixel size in meters (default is 0.1).</p> <code>0.1</code> <code>api_key</code> <code>str</code> <p>Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).</p> <code>None</code> <code>header</code> <code>dict</code> <p>Additional HTTP headers to include in the request.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Directory where downloaded files will be saved.</p> <code>None</code> <code>basename</code> <code>str</code> <p>Base name for the downloaded files (default is generated from imagery date).</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress progress messages during file downloads (default is False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the download_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A dictionary mapping file names to their corresponding paths.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_solar_data(\n    lat: float,\n    lon: float,\n    radiusMeters: int = 50,\n    view: str = \"FULL_LAYERS\",\n    requiredQuality: str = \"HIGH\",\n    pixelSizeMeters: float = 0.1,\n    api_key: Optional[str] = None,\n    header: Optional[Dict[str, str]] = None,\n    out_dir: Optional[str] = None,\n    basename: Optional[str] = None,\n    quiet: bool = False,\n    **kwargs: Any,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar.\n    You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.\n\n    Args:\n        lat (float): Latitude of the location.\n        lon (float): Longitude of the location.\n        radiusMeters (int, optional): Radius in meters for the data retrieval (default is 50).\n        view (str, optional): View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.\n        requiredQuality (str, optional): Required quality level (default is \"HIGH\").\n        pixelSizeMeters (float, optional): Pixel size in meters (default is 0.1).\n        api_key (str, optional): Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).\n        header (dict, optional): Additional HTTP headers to include in the request.\n        out_dir (str, optional): Directory where downloaded files will be saved.\n        basename (str, optional): Base name for the downloaded files (default is generated from imagery date).\n        quiet (bool, optional): If True, suppress progress messages during file downloads (default is False).\n        **kwargs: Additional keyword arguments to be passed to the download_file function.\n\n    Returns:\n        Dict[str, str]: A dictionary mapping file names to their corresponding paths.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_API_KEY\", \"\")\n\n    if api_key == \"\":\n        raise ValueError(\"GOOGLE_API_KEY is required to use this function.\")\n\n    url = \"https://solar.googleapis.com/v1/dataLayers:get\"\n    params = {\n        \"location.latitude\": lat,\n        \"location.longitude\": lon,\n        \"radiusMeters\": radiusMeters,\n        \"view\": view,\n        \"requiredQuality\": requiredQuality,\n        \"pixelSizeMeters\": pixelSizeMeters,\n        \"key\": api_key,\n    }\n\n    solar_data = requests.get(url, params=params, headers=header).json()\n\n    links = {}\n\n    for key in solar_data.keys():\n        if \"Url\" in key:\n            if isinstance(solar_data[key], list):\n                urls = [url + \"&amp;key=\" + api_key for url in solar_data[key]]\n                links[key] = urls\n            else:\n                links[key] = solar_data[key] + \"&amp;key=\" + api_key\n\n    if basename is None:\n        date = solar_data[\"imageryDate\"]\n        year = date[\"year\"]\n        month = date[\"month\"]\n        day = date[\"day\"]\n        basename = f\"{year}_{str(month).zfill(2)}_{str(day).zfill(2)}\"\n\n    filenames = {}\n\n    for link in links:\n        if isinstance(links[link], list):\n            for i, url in enumerate(links[link]):\n                filename = (\n                    f\"{basename}_{link.replace('Urls', '')}_{str(i+1).zfill(2)}.tif\"\n                )\n                if out_dir is not None:\n                    filename = os.path.join(out_dir, filename)\n                download_file(url, filename, quiet=quiet, **kwargs)\n                filenames[link.replace(\"Urls\", \"\") + \"_\" + str(i).zfill(2)] = filename\n        else:\n            name = link.replace(\"Url\", \"\")\n            filename = f\"{basename}_{name}.tif\"\n            if out_dir is not None:\n                filename = os.path.join(out_dir, filename)\n            download_file(links[link], filename, quiet=quiet, **kwargs)\n            filenames[name] = filename\n\n    return filenames\n</code></pre>"},{"location":"common/#leafmap.common.get_stac_collections","title":"<code>get_stac_collections(url, **kwargs)</code>","text":"<p>Retrieve a list of STAC collections from a URL. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31. Credits to Mykola Kozyr.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Client.open() method. See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of STAC collections.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_stac_collections(url, **kwargs):\n    \"\"\"Retrieve a list of STAC collections from a URL.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31.\n    Credits to Mykola Kozyr.\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        **kwargs: Additional keyword arguments to pass to the pystac Client.open() method.\n            See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open\n\n    Returns:\n        list: A list of STAC collections.\n    \"\"\"\n    from pystac_client import Client\n\n    # Expensive function. Added cache for it.\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    root_catalog = Client.open(url, **kwargs)\n    collections_list = []\n    # Reading collections in the Catalog\n    collections = list(root_catalog.get_collections())\n    print(collections)\n    for collection in collections:\n        id = collection.id\n        title = collection.title\n        # bbox = collection.extent.spatial.bboxes # not in use for the first release\n        # interval = collection.extent.temporal.intervals # not in use for the first release\n        description = collection.description\n\n        # creating a list of lists of values\n        collections_list.append([id, title, description])\n    return collections_list\n</code></pre>"},{"location":"common/#leafmap.common.get_stac_items","title":"<code>get_stac_items(url, collection, limit=None, bbox=None, datetime=None, intersects=None, ids=None, open_args=None, **kwargs)</code>","text":"<p>Retrieve a list of STAC items from a URL and a collection. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49. Credits to Mykola Kozyr. Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>collection</code> <code>str</code> <p>A STAC collection ID.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return (page size). Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple</code> <p>Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>datetime</code> <code>str</code> <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.</p> <code>None</code> <code>intersects</code> <code>dict</code> <p>A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.</p> <code>None</code> <code>ids</code> <code>list</code> <p>A list of item ids to return.</p> <code>None</code> <code>open_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Catalog.search() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoPandas.GeoDataFraem</code> <p>A GeoDataFrame with the STAC items.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_stac_items(\n    url,\n    collection,\n    limit=None,\n    bbox=None,\n    datetime=None,\n    intersects=None,\n    ids=None,\n    open_args=None,\n    **kwargs,\n):\n    \"\"\"Retrieve a list of STAC items from a URL and a collection.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49.\n    Credits to Mykola Kozyr.\n    Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        collection (str): A STAC collection ID.\n        limit (int, optional): The maximum number of results to return (page size). Defaults to None.\n        bbox (tuple, optional): Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.\n        datetime (str, optional): Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.\n        intersects (dict, optional): A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.\n        ids (list, optional): A list of item ids to return.\n        open_args (dict, optional): A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.\n        **kwargs: Additional keyword arguments to pass to the Catalog.search() method.\n\n    Returns:\n        GeoPandas.GeoDataFraem: A GeoDataFrame with the STAC items.\n    \"\"\"\n\n    import itertools\n    import geopandas as gpd\n    from shapely.geometry import shape\n    from pystac_client import Client\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    items_list = []\n\n    if open_args is None:\n        open_args = {}\n\n    root_catalog = Client.open(url)\n\n    if limit:\n        kwargs[\"limit\"] = limit\n    if bbox:\n        kwargs[\"bbox\"] = bbox\n    if datetime:\n        kwargs[\"datetime\"] = datetime\n    if intersects:\n        kwargs[\"intersects\"] = intersects\n    if ids:\n        kwargs[\"ids\"] = ids\n\n    if kwargs:\n        try:\n            catalog = root_catalog.search(collections=collection, **kwargs)\n        except NotImplementedError:\n            catalog = root_catalog\n    else:\n        catalog = root_catalog\n\n    iterable = catalog.get_all_items()\n    items = list(\n        itertools.islice(iterable, limit)\n    )  # getting first 25000 items. To Do some smarter logic\n    if len(items) == 0:\n        try:\n            catalog = root_catalog.get_child(collection)\n            iterable = catalog.get_all_items()\n            items = list(itertools.islice(iterable, limit))\n        except Exception as _:\n            print(\"Ooops, it looks like this collection does not have items.\")\n            return None\n    # Iterating over items to collect main information\n    for item in items:\n        id = item.id\n        geometry = shape(item.geometry)\n        datetime = (\n            item.datetime\n            or item.properties[\"datetime\"]\n            or item.properties[\"end_datetime\"]\n            or item.properties[\"start_datetime\"]\n        )\n        links = item.links\n        for link in links:\n            if link.rel == \"self\":\n                self_url = link.target\n        assets_list = []\n        assets = item.assets\n        for asset in assets:\n            assets_list.append(asset)\n\n        # creating a list of lists of values\n        items_list.append([id, geometry, datetime, self_url, assets_list])\n\n    if limit is not None:\n        items_list = items_list[:limit]\n    items_df = gpd.GeoDataFrame(items_list)\n    items_df.columns = [\"id\", \"geometry\", \"datetime\", \"self_url\", \"assets_list\"]\n\n    items_gdf = items_df.set_geometry(\"geometry\")\n    items_gdf[\"datetime\"] = items_gdf[\"datetime\"].astype(\n        str\n    )  # specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    # items_gdf[\"assets_list\"] = items_gdf[\"assets_list\"].astype(str) #specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    items_gdf.set_crs(epsg=4326, inplace=True)\n    return items_gdf\n</code></pre>"},{"location":"common/#leafmap.common.get_wms_layers","title":"<code>get_wms_layers(url)</code>","text":"<p>Returns a list of WMS layers from a WMS service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS service.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of WMS layers.</p> Source code in <code>leafmap/common.py</code> <pre><code>def get_wms_layers(url):\n    \"\"\"Returns a list of WMS layers from a WMS service.\n\n    Args:\n        url (str): The URL of the WMS service.\n\n    Returns:\n        list: A list of WMS layers.\n    \"\"\"\n    try:\n        from owslib.wms import WebMapService\n    except ImportError:\n        raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n    wms = WebMapService(url)\n    layers = list(wms.contents)\n    layers.sort()\n    return layers\n</code></pre>"},{"location":"common/#leafmap.common.gif_fading","title":"<code>gif_fading(in_gif, out_gif, duration=1, verbose=True)</code>","text":"<p>Fade in/out the gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>duration</code> <code>float</code> <p>The duration of the fading. Defaults to 1.</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gif_fading(in_gif, out_gif, duration=1, verbose=True):\n    \"\"\"Fade in/out the gif.\n\n    Args:\n        in_gif (str): The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        duration (float, optional): The duration of the fading. Defaults to 1.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import glob\n    import tempfile\n\n    current_dir = os.getcwd()\n\n    if isinstance(in_gif, str) and in_gif.startswith(\"http\"):\n        ext = os.path.splitext(in_gif)[1]\n        file_path = temp_file_path(ext)\n        download_from_url(in_gif, file_path, verbose=verbose)\n        in_gif = file_path\n\n    in_gif = os.path.abspath(in_gif)\n    if not in_gif.endswith(\".gif\"):\n        raise Exception(\"in_gif must be a gif file.\")\n\n    if \" \" in in_gif:\n        raise Exception(\"The filename cannot contain spaces.\")\n\n    out_gif = os.path.abspath(out_gif)\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    temp_dir = os.path.join(tempfile.gettempdir(), basename)\n    if os.path.exists(temp_dir):\n        shutil.rmtree(temp_dir)\n\n    gif_to_png(in_gif, temp_dir, verbose=verbose)\n\n    os.chdir(temp_dir)\n\n    images = list(glob.glob(os.path.join(temp_dir, \"*.png\")))\n    count = len(images)\n\n    files = []\n    for i in range(1, count + 1):\n        files.append(f\"-loop 1 -t {duration} -i {i}.png\")\n    inputs = \" \".join(files)\n\n    filters = []\n    for i in range(1, count):\n        if i == 1:\n            filters.append(\n                f\"\\\"[1:v][0:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v0];\"\n            )\n        else:\n            filters.append(\n                f\"[{i}:v][{i-1}:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v{i-1}];\"\n            )\n\n    last_filter = \"\"\n    for i in range(count - 1):\n        last_filter += f\"[v{i}]\"\n    last_filter += f'concat=n={count-1}:v=1:a=0[v]\" -map \"[v]\"'\n    filters.append(last_filter)\n    filters = \" \".join(filters)\n\n    cmd = f\"ffmpeg -y -loglevel error {inputs} -filter_complex {filters} {out_gif}\"\n\n    os.system(cmd)\n    try:\n        shutil.rmtree(temp_dir)\n    except Exception as e:\n        print(e)\n\n    os.chdir(current_dir)\n</code></pre>"},{"location":"common/#leafmap.common.gif_to_mp4","title":"<code>gif_to_mp4(in_gif, out_mp4)</code>","text":"<p>Converts a gif to mp4.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_mp4</code> <code>str</code> <p>The output mp4 file.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def gif_to_mp4(in_gif, out_mp4):\n    \"\"\"Converts a gif to mp4.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_mp4 (str): The output mp4 file.\n    \"\"\"\n    from PIL import Image\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    out_mp4 = os.path.abspath(out_mp4)\n    if not out_mp4.endswith(\".mp4\"):\n        out_mp4 = out_mp4 + \".mp4\"\n\n    if not os.path.exists(os.path.dirname(out_mp4)):\n        os.makedirs(os.path.dirname(out_mp4))\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer.\")\n        return\n\n    width, height = Image.open(in_gif).size\n\n    if width % 2 == 0 and height % 2 == 0:\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n    else:\n        width += width % 2\n        height += height % 2\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vf scale={width}:{height} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n\n    if not os.path.exists(out_mp4):\n        raise Exception(f\"Failed to create mp4 file.\")\n</code></pre>"},{"location":"common/#leafmap.common.gif_to_png","title":"<code>gif_to_png(in_gif, out_dir=None, prefix='', verbose=True)</code>","text":"<p>Converts a gif to png.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The prefix of the output png files. Defaults to None.</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def gif_to_png(in_gif, out_dir=None, prefix=\"\", verbose=True):\n    \"\"\"Converts a gif to png.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_dir (str, optional): The output directory. Defaults to None.\n        prefix (str, optional): The prefix of the output png files. Defaults to None.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import tempfile\n\n    in_gif = os.path.abspath(in_gif)\n    if \" \" in in_gif:\n        raise Exception(\"in_gif cannot contain spaces.\")\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    if out_dir is None:\n        out_dir = os.path.join(tempfile.gettempdir(), basename)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n    elif isinstance(out_dir, str) and not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    elif not isinstance(out_dir, str):\n        raise Exception(\"out_dir must be a string.\")\n\n    out_dir = os.path.abspath(out_dir)\n    cmd = f\"ffmpeg -loglevel error -i {in_gif} -vsync 0 {out_dir}/{prefix}%d.png\"\n    os.system(cmd)\n\n    if verbose:\n        print(f\"Images are saved to {out_dir}\")\n</code></pre>"},{"location":"common/#leafmap.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>leafmap/common.py</code> <pre><code>def github_raw_url(url):\n    \"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n    return url\n</code></pre>"},{"location":"common/#leafmap.common.google_buildings_csv_to_vector","title":"<code>google_buildings_csv_to_vector(filename, output=None, **kwargs)</code>","text":"<p>Convert a CSV file containing Google Buildings data to a GeoJSON vector file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The path to the output GeoJSON file. If not provided, the output file will have the same name as the input file with the extension changed to '.geojson'.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the <code>to_file</code> method of the GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def google_buildings_csv_to_vector(\n    filename: str, output: Optional[str] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a CSV file containing Google Buildings data to a GeoJSON vector file.\n\n    Args:\n        filename (str): The path to the input CSV file.\n        output (str, optional): The path to the output GeoJSON file. If not provided, the output file will have the same\n            name as the input file with the extension changed to '.geojson'.\n        **kwargs: Additional keyword arguments that are passed to the `to_file` method of the GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    df = pd.read_csv(filename)\n\n    # Create a geometry column from the \"geometry\" column in the DataFrame\n    df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n    # Convert the pandas DataFrame to a GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n    gdf.crs = \"EPSG:4326\"\n\n    if output is None:\n        output = os.path.splitext(filename)[0] + \".geojson\"\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.h5_keys","title":"<code>h5_keys(filename)</code>","text":"<p>Retrieve the keys (dataset names) within an HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HDF5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of dataset names present in the HDF5 file.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = h5_keys('data.h5')\n&gt;&gt;&gt; print(keys)\n[\n</code></pre> Source code in <code>leafmap/common.py</code> <pre><code>def h5_keys(filename: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the keys (dataset names) within an HDF5 file.\n\n    Args:\n        filename (str): The filename of the HDF5 file.\n\n    Returns:\n        List[str]: A list of dataset names present in the HDF5 file.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; keys = h5_keys('data.h5')\n        &gt;&gt;&gt; print(keys)\n        [\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        keys = list(f.keys())\n\n    return keys\n</code></pre>"},{"location":"common/#leafmap.common.h5_to_gdf","title":"<code>h5_to_gdf(filenames, dataset, lat='lat_lowestmode', lon='lon_lowestmode', columns=None, crs='EPSG:4326', nodata=None, **kwargs)</code>","text":"<p>Read data from one or multiple HDF5 files and return as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>str or List[str]</code> <p>The filename(s) of the HDF5 file(s).</p> required <code>dataset</code> <code>str</code> <p>The dataset name within the H5 file(s).</p> required <code>lat</code> <code>str</code> <p>The column name representing latitude. Default is 'lat_lowestmode'.</p> <code>'lat_lowestmode'</code> <code>lon</code> <code>str</code> <p>The column name representing longitude. Default is 'lon_lowestmode'.</p> <code>'lon_lowestmode'</code> <code>columns</code> <code>List[str]</code> <p>List of column names to include. If None, all columns will be included. Default is None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system code. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the GeoDataFrame constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the data from the H5 file(s).</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <code>ValueError</code> <p>Raised if the provided filenames argument is not a valid type or if a specified file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n&gt;&gt;&gt; print(gdf.head())\n   column1  column2        lat        lon                    geometry\n0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n...\n</code></pre> Source code in <code>leafmap/common.py</code> <pre><code>def h5_to_gdf(\n    filenames: str,\n    dataset: str,\n    lat: str = \"lat_lowestmode\",\n    lon: str = \"lon_lowestmode\",\n    columns: Optional[List[str]] = None,\n    crs: str = \"EPSG:4326\",\n    nodata=None,\n    **kwargs,\n):\n    \"\"\"\n    Read data from one or multiple HDF5 files and return as a GeoDataFrame.\n\n    Args:\n        filenames (str or List[str]): The filename(s) of the HDF5 file(s).\n        dataset (str): The dataset name within the H5 file(s).\n        lat (str): The column name representing latitude. Default is 'lat_lowestmode'.\n        lon (str): The column name representing longitude. Default is 'lon_lowestmode'.\n        columns (List[str], optional): List of column names to include. If None, all columns will be included. Default is None.\n        crs (str, optional): The coordinate reference system code. Default is \"EPSG:4326\".\n        **kwargs: Additional keyword arguments to be passed to the GeoDataFrame constructor.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoDataFrame containing the data from the H5 file(s).\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n        ValueError: Raised if the provided filenames argument is not a valid type or if a specified file does not exist.\n\n    Example:\n        &gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n        &gt;&gt;&gt; print(gdf.head())\n           column1  column2        lat        lon                    geometry\n        0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n        1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n        ...\n\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        install_package(\"h5py\")\n        import h5py\n\n    import glob\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(filenames, str):\n        if os.path.exists(filenames):\n            files = [filenames]\n        else:\n            files = glob.glob(filenames)\n            if not files:\n                raise ValueError(f\"File {filenames} does not exist.\")\n            files.sort()\n    elif isinstance(filenames, list):\n        files = filenames\n    else:\n        raise ValueError(\"h5_file must be a string or a list of strings.\")\n\n    out_df = pd.DataFrame()\n\n    for file in files:\n        h5 = h5py.File(file, \"r\")\n        try:\n            data = h5[dataset]\n        except KeyError:\n            print(f\"Dataset {dataset} not found in file {file}. Skipping...\")\n            continue\n        col_names = []\n        col_val = []\n\n        for key, value in data.items():\n            if columns is None or key in columns or key == lat or key == lon:\n                col_names.append(key)\n                col_val.append(value[:].tolist())\n\n        df = pd.DataFrame(map(list, zip(*col_val)), columns=col_names)\n        out_df = pd.concat([out_df, df])\n        h5.close()\n\n    if nodata is not None and columns is not None:\n        out_df = out_df[out_df[columns[0]] != nodata]\n\n    gdf = gpd.GeoDataFrame(\n        out_df, geometry=gpd.points_from_xy(out_df[lon], out_df[lat]), crs=crs, **kwargs\n    )\n\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.h5_variables","title":"<code>h5_variables(filename, key)</code>","text":"<p>Retrieve the variables (column names) within a specific key (dataset) in an H5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the H5 file.</p> required <code>key</code> <code>str</code> <p>The key (dataset name) within the H5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of variable names (column names) within the specified key.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n&gt;&gt;&gt; print(variables)\n['var1', 'var2', 'var3']\n</code></pre> Source code in <code>leafmap/common.py</code> <pre><code>def h5_variables(filename: str, key: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the variables (column names) within a specific key (dataset) in an H5 file.\n\n    Args:\n        filename (str): The filename of the H5 file.\n        key (str): The key (dataset name) within the H5 file.\n\n    Returns:\n        List[str]: A list of variable names (column names) within the specified key.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n        &gt;&gt;&gt; print(variables)\n        ['var1', 'var2', 'var3']\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        cols = list(f[key].keys())\n\n    return cols\n</code></pre>"},{"location":"common/#leafmap.common.has_transparency","title":"<code>has_transparency(img)</code>","text":"<p>Checks whether an image has transparency.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>a PIL Image object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it has transparency, False otherwise.</p> Source code in <code>leafmap/common.py</code> <pre><code>def has_transparency(img) -&gt; bool:\n    \"\"\"Checks whether an image has transparency.\n\n    Args:\n        img (object):  a PIL Image object.\n\n    Returns:\n        bool: True if it has transparency, False otherwise.\n    \"\"\"\n\n    if img.mode == \"P\":\n        transparent = img.info.get(\"transparency\", -1)\n        for _, index in img.getcolors():\n            if index == transparent:\n                return True\n    elif img.mode == \"RGBA\":\n        extrema = img.getextrema()\n        if extrema[3][0] &lt; 255:\n            return True\n\n    return False\n</code></pre>"},{"location":"common/#leafmap.common.hex_to_rgb","title":"<code>hex_to_rgb(value='FFFFFF')</code>","text":"<p>Converts hex color to RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hex color code as a string. Defaults to 'FFFFFF'.</p> <code>'FFFFFF'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>RGB color as a tuple.</p> Source code in <code>leafmap/common.py</code> <pre><code>def hex_to_rgb(value: Optional[str] = \"FFFFFF\") -&gt; Tuple[int, int, int]:\n    \"\"\"Converts hex color to RGB color.\n\n    Args:\n        value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'.\n\n    Returns:\n        tuple: RGB color as a tuple.\n    \"\"\"\n    value = value.lstrip(\"#\")\n    lv = len(value)\n    return tuple(int(value[i : i + lv // 3], 16) for i in range(0, lv, lv // 3))\n</code></pre>"},{"location":"common/#leafmap.common.html_to_gradio","title":"<code>html_to_gradio(html, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>leafmap/common.py</code> <pre><code>def html_to_gradio(html, width=\"100%\", height=\"500px\", **kwargs):\n    \"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    if isinstance(html, str):\n        with open(html, \"r\") as f:\n            lines = f.readlines()\n    elif isinstance(html, list):\n        lines = html\n    else:\n        raise TypeError(\"html must be a file path or a list of strings\")\n\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera;\n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms\n    allow-scripts allow-same-origin allow-popups\n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\"\n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"common/#leafmap.common.html_to_streamlit","title":"<code>html_to_streamlit(filename, width=None, height=None, scrolling=False, replace_dict={})</code>","text":"<p>Renders an HTML file as a Streamlit component.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HTML file.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>replace_dict</code> <code>dict</code> <p>A dictionary of strings to replace in the HTML file. Defaults to {}.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the filename does not exist.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def html_to_streamlit(\n    filename, width=None, height=None, scrolling=False, replace_dict={}\n):\n    \"\"\"Renders an HTML file as a Streamlit component.\n    Args:\n        filename (str): The filename of the HTML file.\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        replace_dict (dict, optional): A dictionary of strings to replace in the HTML file. Defaults to {}.\n\n    Raises:\n        ValueError: If the filename does not exist.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    import streamlit.components.v1 as components\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    f = open(filename, \"r\")\n\n    html = f.read()\n\n    for key, value in replace_dict.items():\n        html = html.replace(key, value)\n\n    f.close()\n    return components.html(html, width=width, height=height, scrolling=scrolling)\n</code></pre>"},{"location":"common/#leafmap.common.image_bandcount","title":"<code>image_bandcount(image, **kwargs)</code>","text":"<p>Get the number of bands in an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bands in the image.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_bandcount(image, **kwargs):\n    \"\"\"Get the number of bands in an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        int: The number of bands in the image.\n    \"\"\"\n\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return len(client.metadata()[\"bands\"])\n</code></pre>"},{"location":"common/#leafmap.common.image_bounds","title":"<code>image_bounds(image, **kwargs)</code>","text":"<p>Get the bounds of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [(south, west), (north, east)].</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_bounds(image, **kwargs):\n    \"\"\"Get the bounds of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of bounds in the form of [(south, west), (north, east)].\n    \"\"\"\n\n    image_check(image)\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    bounds = client.bounds()\n    return [(bounds[0], bounds[2]), (bounds[1], bounds[3])]\n</code></pre>"},{"location":"common/#leafmap.common.image_center","title":"<code>image_center(image, **kwargs)</code>","text":"<p>Get the center of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (latitude, longitude).</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_center(image, **kwargs):\n    \"\"\"Get the center of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (latitude, longitude).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.center()\n</code></pre>"},{"location":"common/#leafmap.common.image_client","title":"<code>image_client(image, **kwargs)</code>","text":"<p>Get a LocalTileserver TileClient from an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>TileClient</code> <p>A LocalTileserver TileClient.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_client(image, **kwargs):\n    \"\"\"Get a LocalTileserver TileClient from an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        TileClient: A LocalTileserver TileClient.\n    \"\"\"\n    image_check(image)\n\n    _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    return client\n</code></pre>"},{"location":"common/#leafmap.common.image_comparison","title":"<code>image_comparison(img1, img2, label1='1', label2='2', width=704, show_labels=True, starting_position=50, make_responsive=True, in_memory=True, out_html=None)</code>","text":"<p>Create a comparison slider for two images. The source code is adapted from     https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.     Users can also use https://juxtapose.knightlab.com to create a comparison slider.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image. It can be a local file path, a URL, or a numpy array.</p> required <code>img2</code> <code>str</code> <p>Path to the second image. It can be a local file path, a URL, or a numpy array.</p> required <code>label1</code> <code>str</code> <p>Label for the first image. Defaults to \"1\".</p> <code>'1'</code> <code>label2</code> <code>str</code> <p>Label for the second image. Defaults to \"2\".</p> <code>'2'</code> <code>width</code> <code>int</code> <p>Width of the component in pixels. Defaults to 704.</p> <code>704</code> <code>show_labels</code> <code>bool</code> <p>Whether to show labels on the images. Default is True.</p> <code>True</code> <code>starting_position</code> <code>int</code> <p>Starting position of the slider as a percentage (0-100). Default is 50.</p> <code>50</code> <code>make_responsive</code> <code>bool</code> <p>Whether to enable responsive mode. Default is True.</p> <code>True</code> <code>in_memory</code> <code>bool</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>True</code> <code>out_html</code> <code>str</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def image_comparison(\n    img1: str,\n    img2: str,\n    label1: str = \"1\",\n    label2: str = \"2\",\n    width: int = 704,\n    show_labels: bool = True,\n    starting_position: int = 50,\n    make_responsive: bool = True,\n    in_memory: bool = True,\n    out_html: str = None,\n):\n    \"\"\"Create a comparison slider for two images. The source code is adapted from\n        https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.\n        Users can also use https://juxtapose.knightlab.com to create a comparison slider.\n\n    Args:\n        img1 (str): Path to the first image. It can be a local file path, a URL, or a numpy array.\n        img2 (str): Path to the second image. It can be a local file path, a URL, or a numpy array.\n        label1 (str, optional): Label for the first image. Defaults to \"1\".\n        label2 (str, optional): Label for the second image. Defaults to \"2\".\n        width (int, optional): Width of the component in pixels. Defaults to 704.\n        show_labels (bool, optional): Whether to show labels on the images. Default is True.\n        starting_position (int, optional): Starting position of the slider as a percentage (0-100). Default is 50.\n        make_responsive (bool, optional): Whether to enable responsive mode. Default is True.\n        in_memory (bool, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n        out_html (str, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n\n    \"\"\"\n\n    from PIL import Image\n    import base64\n    import io\n    import os\n    import uuid\n    from typing import Union\n    import requests\n    import tempfile\n    import numpy as np\n    from IPython.display import HTML, display\n\n    TEMP_DIR = os.path.join(tempfile.gettempdir(), random_string(6))\n    os.makedirs(TEMP_DIR, exist_ok=True)\n\n    def exif_transpose(image: Image.Image):\n        \"\"\"\n        Transpose a PIL image accordingly if it has an EXIF Orientation tag.\n        Inplace version of https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageOps.py exif_transpose()\n        :param image: The image to transpose.\n        :return: An image.\n        \"\"\"\n        exif = image.getexif()\n        orientation = exif.get(0x0112, 1)  # default 1\n        if orientation &gt; 1:\n            method = {\n                2: Image.FLIP_LEFT_RIGHT,\n                3: Image.ROTATE_180,\n                4: Image.FLIP_TOP_BOTTOM,\n                5: Image.TRANSPOSE,\n                6: Image.ROTATE_270,\n                7: Image.TRANSVERSE,\n                8: Image.ROTATE_90,\n            }.get(orientation)\n            if method is not None:\n                image = image.transpose(method)\n                del exif[0x0112]\n                image.info[\"exif\"] = exif.tobytes()\n        return image\n\n    def read_image_as_pil(\n        image: Union[Image.Image, str, np.ndarray], exif_fix: bool = False\n    ):\n        \"\"\"\n        Loads an image as PIL.Image.Image.\n        Args:\n            image : Can be image path or url (str), numpy image (np.ndarray) or PIL.Image\n        \"\"\"\n        # https://stackoverflow.com/questions/56174099/how-to-load-images-larger-than-max-image-pixels-with-pil\n        Image.MAX_IMAGE_PIXELS = None\n\n        if isinstance(image, Image.Image):\n            image_pil = image.convert(\"RGB\")\n        elif isinstance(image, str):\n            # read image if str image path is provided\n            try:\n                image_pil = Image.open(\n                    requests.get(image, stream=True).raw\n                    if str(image).startswith(\"http\")\n                    else image\n                ).convert(\"RGB\")\n                if exif_fix:\n                    image_pil = exif_transpose(image_pil)\n            except:  # handle large/tiff image reading\n                try:\n                    import skimage.io\n                except ImportError:\n                    raise ImportError(\n                        \"Please run 'pip install -U scikit-image imagecodecs' for large image handling.\"\n                    )\n                image_sk = skimage.io.imread(image).astype(np.uint8)\n                if len(image_sk.shape) == 2:  # b&amp;w\n                    image_pil = Image.fromarray(image_sk, mode=\"1\").convert(\"RGB\")\n                elif image_sk.shape[2] == 4:  # rgba\n                    image_pil = Image.fromarray(image_sk, mode=\"RGBA\").convert(\"RGB\")\n                elif image_sk.shape[2] == 3:  # rgb\n                    image_pil = Image.fromarray(image_sk, mode=\"RGB\")\n                else:\n                    raise TypeError(\n                        f\"image with shape: {image_sk.shape[3]} is not supported.\"\n                    )\n        elif isinstance(image, np.ndarray):\n            if image.shape[0] &lt; 5:  # image in CHW\n                image = image[:, :, ::-1]\n            image_pil = Image.fromarray(image).convert(\"RGB\")\n        else:\n            raise TypeError(\"read image with 'pillow' using 'Image.open()'\")\n\n        return image_pil\n\n    def pillow_to_base64(image: Image.Image) -&gt; str:\n        \"\"\"\n        Convert a PIL image to a base64-encoded string.\n\n        Parameters\n        ----------\n        image: PIL.Image.Image\n            The image to be converted.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        in_mem_file = io.BytesIO()\n        image.save(in_mem_file, format=\"JPEG\", subsampling=0, quality=100)\n        img_bytes = in_mem_file.getvalue()  # bytes\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def local_file_to_base64(image_path: str) -&gt; str:\n        \"\"\"\n        Convert a local image file to a base64-encoded string.\n\n        Parameters\n        ----------\n        image_path: str\n            The path to the image file.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        file_ = open(image_path, \"rb\")\n        img_bytes = file_.read()\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        file_.close()\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def pillow_local_file_to_base64(image: Image.Image, temp_dir: str):\n        \"\"\"\n        Convert a Pillow image to a base64 string, using a temporary file on disk.\n\n        Parameters\n        ----------\n        image : PIL.Image.Image\n            The Pillow image to convert.\n        temp_dir : str\n            The directory to use for the temporary file.\n\n        Returns\n        -------\n        str\n            A base64-encoded string representing the image.\n        \"\"\"\n        # Create temporary file path using os.path.join()\n        img_path = os.path.join(temp_dir, str(uuid.uuid4()) + \".jpg\")\n\n        # Save image to temporary file\n        image.save(img_path, subsampling=0, quality=100)\n\n        # Convert temporary file to base64 string\n        base64_src = local_file_to_base64(img_path)\n\n        return base64_src\n\n    # Prepare images\n    img1_pillow = read_image_as_pil(img1)\n    img2_pillow = read_image_as_pil(img2)\n\n    img_width, img_height = img1_pillow.size\n    h_to_w = img_height / img_width\n    height = int((width * h_to_w) * 0.95)\n\n    if in_memory:\n        # Convert images to base64 strings\n        img1 = pillow_to_base64(img1_pillow)\n        img2 = pillow_to_base64(img2_pillow)\n    else:\n        # Create base64 strings from temporary files\n        os.makedirs(TEMP_DIR, exist_ok=True)\n        for file_ in os.listdir(TEMP_DIR):\n            if file_.endswith(\".jpg\"):\n                os.remove(os.path.join(TEMP_DIR, file_))\n        img1 = pillow_local_file_to_base64(img1_pillow, TEMP_DIR)\n        img2 = pillow_local_file_to_base64(img2_pillow, TEMP_DIR)\n\n    # Load CSS and JS\n    cdn_path = \"https://cdn.knightlab.com/libs/juxtapose/latest\"\n    css_block = f'&lt;link rel=\"stylesheet\" href=\"{cdn_path}/css/juxtapose.css\"&gt;'\n    js_block = f'&lt;script src=\"{cdn_path}/js/juxtapose.min.js\"&gt;&lt;/script&gt;'\n\n    # write html block\n    htmlcode = f\"\"\"\n        &lt;html&gt;\n        &lt;head&gt;\n        &lt;style&gt;body {{ margin: unset; }}&lt;/style&gt;\n        {css_block}\n        {js_block}\n        &lt;div id=\"foo\" style=\"height: {height}; width: {width or '100%'};\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n        slider = new juxtapose.JXSlider('#foo',\n            [\n                {{\n                    src: '{img1}',\n                    label: '{label1}',\n                }},\n                {{\n                    src: '{img2}',\n                    label: '{label2}',\n                }}\n            ],\n            {{\n                animate: true,\n                showLabels: {'true' if show_labels else 'false'},\n                showCredits: true,\n                startingPosition: \"{starting_position}%\",\n                makeResponsive: {'true' if make_responsive else 'false'},\n            }});\n        &lt;/script&gt;\n        &lt;/head&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    if out_html is not None:\n        with open(out_html, \"w\") as f:\n            f.write(htmlcode)\n\n    shutil.rmtree(TEMP_DIR)\n\n    display(HTML(htmlcode))\n</code></pre>"},{"location":"common/#leafmap.common.image_filesize","title":"<code>image_filesize(region, cellsize, bands=1, dtype='uint8', unit='MB', source_crs='epsg:4326', dst_crs='epsg:3857', bbox=False)</code>","text":"<p>Calculate the size of an image in a given region and cell size.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>cellsize</code> <code>float</code> <p>The resolution of the image.</p> required <code>bands</code> <code>int</code> <p>Number of bands. Defaults to 1.</p> <code>1</code> <code>dtype</code> <code>str</code> <p>Data type, such as unit8, float32. For more info, see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.</p> <code>'uint8'</code> <code>unit</code> <code>str</code> <p>The unit of the output. Defaults to 'MB'.</p> <code>'MB'</code> <code>source_crs</code> <code>str</code> <p>The CRS of the region. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS to calculate the area. Defaults to 'epsg:3857'.</p> <code>'epsg:3857'</code> <code>bbox</code> <code>bool</code> <p>Whether to use the bounding box of the region to calculate the area. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>The size of the image in a given unit.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_filesize(\n    region,\n    cellsize,\n    bands=1,\n    dtype=\"uint8\",\n    unit=\"MB\",\n    source_crs=\"epsg:4326\",\n    dst_crs=\"epsg:3857\",\n    bbox=False,\n):\n    \"\"\"Calculate the size of an image in a given region and cell size.\n\n    Args:\n        region (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        cellsize (float): The resolution of the image.\n        bands (int, optional): Number of bands. Defaults to 1.\n        dtype (str, optional): Data type, such as unit8, float32. For more info,\n            see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.\n        unit (str, optional): The unit of the output. Defaults to 'MB'.\n        source_crs (str, optional): The CRS of the region. Defaults to 'epsg:4326'.\n        dst_crs (str, optional): The destination CRS to calculate the area. Defaults to 'epsg:3857'.\n        bbox (bool, optional): Whether to use the bounding box of the region to calculate the area. Defaults to False.\n\n    Returns:\n        float: The size of the image in a given unit.\n    \"\"\"\n    import numpy as np\n    import geopandas as gpd\n\n    if bbox:\n        if isinstance(region, gpd.GeoDataFrame):\n            region = region.to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, str) and os.path.exists(region):\n            region = gpd.read_file(region).to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, list):\n            region = (\n                bbox_to_gdf(region, crs=source_crs)\n                .to_crs(dst_crs)\n                .total_bounds.tolist()\n            )\n        else:\n            raise ValueError(\"Invalid input region.\")\n\n        bytes = (\n            np.prod(\n                [\n                    int((region[2] - region[0]) / cellsize),\n                    int((region[3] - region[1]) / cellsize),\n                    bands,\n                ]\n            )\n            * np.dtype(dtype).itemsize\n        )\n    else:\n        if isinstance(region, list):\n            region = bbox_to_gdf(region, crs=source_crs)\n\n        bytes = (\n            vector_area(region, crs=dst_crs)\n            / pow(cellsize, 2)\n            * np.dtype(dtype).itemsize\n            * bands\n        )\n\n    unit = unit.upper()\n\n    if unit == \"KB\":\n        return bytes / 1024\n    elif unit == \"MB\":\n        return bytes / pow(1024, 2)\n    elif unit == \"GB\":\n        return bytes / pow(1024, 3)\n    elif unit == \"TB\":\n        return bytes / pow(1024, 4)\n    elif unit == \"PB\":\n        return bytes / pow(1024, 5)\n    else:\n        return bytes\n</code></pre>"},{"location":"common/#leafmap.common.image_geotransform","title":"<code>image_geotransform(image, **kwargs)</code>","text":"<p>Get the geotransform of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of geotransform values.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_geotransform(image, **kwargs):\n    \"\"\"Get the geotransform of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of geotransform values.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"]\n</code></pre>"},{"location":"common/#leafmap.common.image_metadata","title":"<code>image_metadata(image, **kwargs)</code>","text":"<p>Get the metadata of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image metadata.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_metadata(image, **kwargs):\n    \"\"\"Get the metadata of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        dict: A dictionary of image metadata.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()\n</code></pre>"},{"location":"common/#leafmap.common.image_min_max","title":"<code>image_min_max(image, bands=None)</code>","text":"<p>Computes the minimum and maximum pixel values of an image.</p> <p>This function opens an image file using xarray and rasterio, optionally     selects specific bands, and then computes the minimum and maximum pixel     values in the image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The path to the image file.</p> required <code>bands</code> <code>int or list</code> <p>The band or list of bands to select. If None, all bands are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>The minimum and maximum pixel values in the image.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_min_max(\n    image: str, bands: Optional[Union[int, list]] = None\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Computes the minimum and maximum pixel values of an image.\n\n    This function opens an image file using xarray and rasterio, optionally\n        selects specific bands, and then computes the minimum and maximum pixel\n        values in the image.\n\n    Args:\n        image (str): The path to the image file.\n        bands (int or list, optional): The band or list of bands to select. If\n            None, all bands are used.\n\n    Returns:\n        Tuple[float, float]: The minimum and maximum pixel values in the image.\n    \"\"\"\n\n    import rioxarray\n    import xarray as xr\n\n    dataset = xr.open_dataset(image, engine=\"rasterio\")\n\n    if bands is not None:\n        dataset = dataset.sel(band=bands)\n\n    vmin = dataset[\"band_data\"].min().values.item()\n    vmax = dataset[\"band_data\"].max().values.item()\n\n    return vmin, vmax\n</code></pre>"},{"location":"common/#leafmap.common.image_projection","title":"<code>image_projection(image, **kwargs)</code>","text":"<p>Get the projection of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The projection of the image.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_projection(image, **kwargs):\n    \"\"\"Get the projection of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        str: The projection of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"Projection\"]\n</code></pre>"},{"location":"common/#leafmap.common.image_resolution","title":"<code>image_resolution(image, **kwargs)</code>","text":"<p>Get the resolution of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the image.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_resolution(image, **kwargs):\n    \"\"\"Get the resolution of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        float: The resolution of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"][1]\n</code></pre>"},{"location":"common/#leafmap.common.image_set_crs","title":"<code>image_set_crs(image, epsg)</code>","text":"<p>Define the CRS of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath</p> required <code>epsg</code> <code>int</code> <p>The EPSG code of the CRS to set.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def image_set_crs(image, epsg):\n    \"\"\"Define the CRS of an image.\n\n    Args:\n        image (str): The input image filepath\n        epsg (int): The EPSG code of the CRS to set.\n    \"\"\"\n\n    from rasterio.crs import CRS\n    import rasterio\n\n    with rasterio.open(image, \"r+\") as rds:\n        rds.crs = CRS.from_epsg(epsg)\n</code></pre>"},{"location":"common/#leafmap.common.image_size","title":"<code>image_size(image, **kwargs)</code>","text":"<p>Get the size (width, height) of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (width, height).</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_size(image, **kwargs):\n    \"\"\"Get the size (width, height) of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (width, height).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n\n    metadata = client.metadata()\n    return metadata[\"sourceSizeX\"], metadata[\"sourceSizeY\"]\n</code></pre>"},{"location":"common/#leafmap.common.image_to_cog","title":"<code>image_to_cog(source, dst_path=None, profile='deflate', **kwargs)</code>","text":"<p>Converts an image to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>An output dataset path or or PathLike object. Defaults to None.</p> <code>None</code> <code>profile</code> <code>str</code> <p>COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".</p> <code>'deflate'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rio-cogeo is not installed.</p> <code>FileNotFoundError</code> <p>If the source file could not be found.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_to_cog(source, dst_path=None, profile=\"deflate\", **kwargs):\n    \"\"\"Converts an image to a COG file.\n\n    Args:\n        source (str): A dataset path, URL or rasterio.io.DatasetReader object.\n        dst_path (str, optional): An output dataset path or or PathLike object. Defaults to None.\n        profile (str, optional): COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".\n\n    Raises:\n        ImportError: If rio-cogeo is not installed.\n        FileNotFoundError: If the source file could not be found.\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_translate\n        from rio_cogeo.profiles import cog_profiles\n\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if dst_path is None:\n        if not source.startswith(\"http\"):\n            dst_path = os.path.splitext(source)[0] + \"_cog.tif\"\n        else:\n            dst_path = temp_file_path(extension=\".tif\")\n\n    dst_path = check_file_path(dst_path)\n\n    dst_profile = cog_profiles.get(profile)\n    cog_translate(source, dst_path, dst_profile, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.image_to_numpy","title":"<code>image_to_numpy(image)</code>","text":"<p>Converts an image to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>np.array</code> <p>A numpy array.</p> Source code in <code>leafmap/common.py</code> <pre><code>def image_to_numpy(image):\n    \"\"\"Converts an image to a numpy array.\n\n    Args:\n        image (str): A dataset path, URL or rasterio.io.DatasetReader object.\n\n    Raises:\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        np.array: A numpy array.\n    \"\"\"\n    import rasterio\n\n    from osgeo import gdal\n\n    # ... and suppress errors\n    gdal.PushErrorHandler(\"CPLQuietErrorHandler\")\n\n    try:\n        with rasterio.open(image, \"r\") as ds:\n            arr = ds.read()  # read all raster values\n        return arr\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.images_to_tiles","title":"<code>images_to_tiles(images, names=None, **kwargs)</code>","text":"<p>Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>The path to a directory of images or a list of image paths.</p> required <code>names</code> <code>list</code> <p>A list of names for the layers. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to get_local_tile_layer().</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet.TileLayer objects.</p> Source code in <code>leafmap/common.py</code> <pre><code>def images_to_tiles(\n    images: Union[str, List[str]], names: List[str] = None, **kwargs\n) -&gt; Dict[str, ipyleaflet.TileLayer]:\n    \"\"\"Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.\n\n    Args:\n        images (str | list): The path to a directory of images or a list of image paths.\n        names (list, optional): A list of names for the layers. Defaults to None.\n        **kwargs: Additional arguments to pass to get_local_tile_layer().\n\n    Returns:\n        dict: A dictionary of ipyleaflet.TileLayer objects.\n    \"\"\"\n\n    tiles = {}\n\n    if isinstance(images, str):\n        images = os.path.abspath(images)\n        images = find_files(images, ext=\".tif\", recursive=False)\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list of image paths or a directory\")\n\n    if names is None:\n        names = [os.path.splitext(os.path.basename(image))[0] for image in images]\n\n    if len(names) != len(images):\n        raise ValueError(\"names must have the same length as images\")\n\n    for index, image in enumerate(images):\n        name = names[index]\n        try:\n            if image.startswith(\"http\") and image.endswith(\".tif\"):\n                url = cog_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            elif image.startswith(\"http\"):\n                url = stac_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            else:\n                tile = get_local_tile_layer(image, layer_name=name, **kwargs)\n            tiles[name] = tile\n        except Exception as e:\n            print(image, e)\n\n    return tiles\n</code></pre>"},{"location":"common/#leafmap.common.install_package","title":"<code>install_package(package)</code>","text":"<p>Install a Python package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str | list</code> <p>The package name or a GitHub URL or a list of package names or GitHub URLs.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def install_package(package):\n    \"\"\"Install a Python package.\n\n    Args:\n        package (str | list): The package name or a GitHub URL or a list of package names or GitHub URLs.\n    \"\"\"\n    import subprocess\n\n    if isinstance(package, str):\n        packages = [package]\n\n    for package in packages:\n        if package.startswith(\"https\"):\n            package = f\"git+{package}\"\n\n        # Execute pip install command and show output in real-time\n        command = f\"pip install {package}\"\n        process = subprocess.Popen(command.split(), stdout=subprocess.PIPE)\n\n        # Print output in real-time\n        while True:\n            output = process.stdout.readline()\n            if output == b\"\" and process.poll() is not None:\n                break\n            if output:\n                print(output.decode(\"utf-8\").strip())\n\n        # Wait for process to complete\n        process.wait()\n</code></pre>"},{"location":"common/#leafmap.common.is_arcpy","title":"<code>is_arcpy()</code>","text":"<p>Check if arcpy is available.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if arcpy is available, False otherwise.</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_arcpy():\n    \"\"\"Check if arcpy is available.\n\n    Returns:\n        book: True if arcpy is available, False otherwise.\n    \"\"\"\n    import sys\n\n    if \"arcpy\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#leafmap.common.is_array","title":"<code>is_array(x)</code>","text":"<p>Test whether x is either a numpy.ndarray or xarray.DataArray</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_array(x):\n    \"\"\"Test whether x is either a numpy.ndarray or xarray.DataArray\"\"\"\n    import sys\n\n    if isinstance(x, sys.modules[\"numpy\"].ndarray):\n        return True\n    if \"xarray\" in sys.modules:\n        if isinstance(x, sys.modules[\"xarray\"].DataArray):\n            return True\n    return False\n</code></pre>"},{"location":"common/#leafmap.common.is_jupyterlite","title":"<code>is_jupyterlite()</code>","text":"<p>Check if the current notebook is running on JupyterLite.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if the notebook is running on JupyterLite.</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_jupyterlite():\n    \"\"\"Check if the current notebook is running on JupyterLite.\n\n    Returns:\n        book: True if the notebook is running on JupyterLite.\n    \"\"\"\n    import sys\n\n    if \"pyodide\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#leafmap.common.is_on_aws","title":"<code>is_on_aws()</code>","text":"<p>Check if the current notebook is running on AWS.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on AWS.</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_on_aws():\n    \"\"\"Check if the current notebook is running on AWS.\n\n    Returns:\n        bool: True if the notebook is running on AWS.\n    \"\"\"\n\n    import psutil\n\n    on_aws = False\n    try:\n        output = psutil.Process().parent().cmdline()\n\n        for item in output:\n            if item.endswith(\".aws\") or \"ec2-user\" in item:\n                on_aws = True\n    except:\n        pass\n    return on_aws\n</code></pre>"},{"location":"common/#leafmap.common.is_studio_lab","title":"<code>is_studio_lab()</code>","text":"<p>Check if the current notebook is running on Studio Lab.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on Studio Lab.</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_studio_lab():\n    \"\"\"Check if the current notebook is running on Studio Lab.\n\n    Returns:\n        bool: True if the notebook is running on Studio Lab.\n    \"\"\"\n\n    import psutil\n\n    on_studio_lab = False\n\n    try:\n        output = psutil.Process().parent().cmdline()\n\n        for item in output:\n            if \"studiolab/bin\" in item:\n                on_studio_lab = True\n    except:\n        pass\n    return on_studio_lab\n</code></pre>"},{"location":"common/#leafmap.common.is_tool","title":"<code>is_tool(name)</code>","text":"<p>Check whether <code>name</code> is on PATH and marked as executable.</p> Source code in <code>leafmap/common.py</code> <pre><code>def is_tool(name):\n    \"\"\"Check whether `name` is on PATH and marked as executable.\"\"\"\n\n    return shutil.which(name) is not None\n</code></pre>"},{"location":"common/#leafmap.common.kml_to_geojson","title":"<code>kml_to_geojson(in_kml, out_geojson=None)</code>","text":"<p>Converts a KML to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a GeoJSON.</p> Source code in <code>leafmap/common.py</code> <pre><code>def kml_to_geojson(in_kml, out_geojson=None):\n    \"\"\"Converts a KML to GeoJSON.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_geojson (str): The file path to the output GeoJSON. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    if out_geojson is not None:\n        out_geojson = os.path.abspath(out_geojson)\n        ext = os.path.splitext(out_geojson)[1].lower()\n        if ext not in [\".json\", \".geojson\"]:\n            raise TypeError(\"The output file must be a GeoJSON.\")\n\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # import fiona\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    gdf = gpd.read_file(in_kml, driver=\"KML\")\n\n    if out_geojson is not None:\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#leafmap.common.kml_to_shp","title":"<code>kml_to_shp(in_kml, out_shp)</code>","text":"<p>Converts a KML to shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a shapefile.</p> Source code in <code>leafmap/common.py</code> <pre><code>def kml_to_shp(in_kml, out_shp):\n    \"\"\"Converts a KML to shapefile.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_shp (str): The file path to the output shapefile.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a shapefile.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    out_shp = os.path.abspath(out_shp)\n    if not out_shp.endswith(\".shp\"):\n        raise TypeError(\"The output must be a shapefile.\")\n\n    out_dir = os.path.dirname(out_shp)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    df = gpd.read_file(in_kml, driver=\"KML\")\n    df.to_file(out_shp)\n</code></pre>"},{"location":"common/#leafmap.common.list_palettes","title":"<code>list_palettes(add_extra=False, lowercase=False)</code>","text":"<p>List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of colormap names.</p> Source code in <code>leafmap/common.py</code> <pre><code>def list_palettes(add_extra=False, lowercase=False):\n    \"\"\"List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Returns:\n        list: The list of colormap names.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    result = plt.colormaps()\n    if add_extra:\n        result += [\"dem\", \"ndvi\", \"ndwi\"]\n    if lowercase:\n        result = [i.lower() for i in result]\n    result.sort()\n    return result\n</code></pre>"},{"location":"common/#leafmap.common.lnglat_to_meters","title":"<code>lnglat_to_meters(longitude, latitude)</code>","text":"<p>coordinate conversion between lat/lon in decimal degrees to web mercator</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>The longitude.</p> required <code>latitude</code> <code>float</code> <p>The latitude.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x, y) in meters.</p> Source code in <code>leafmap/common.py</code> <pre><code>def lnglat_to_meters(longitude, latitude):\n    \"\"\"coordinate conversion between lat/lon in decimal degrees to web mercator\n\n    Args:\n        longitude (float): The longitude.\n        latitude (float): The latitude.\n\n    Returns:\n        tuple: A tuple of (x, y) in meters.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n\n    if np.isnan(easting):\n        if longitude &gt; 0:\n            easting = 20026376\n        else:\n            easting = -20026376\n\n    if np.isnan(northing):\n        if latitude &gt; 0:\n            northing = 20048966\n        else:\n            northing = -20048966\n\n    return (easting, northing)\n</code></pre>"},{"location":"common/#leafmap.common.local_tile_bands","title":"<code>local_tile_bands(source)</code>","text":"<p>Get band names from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of band names.</p> Source code in <code>leafmap/common.py</code> <pre><code>def local_tile_bands(source):\n    \"\"\"Get band names from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient\n\n    Returns:\n        list: A list of band names.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    return tile_client.band_names\n</code></pre>"},{"location":"common/#leafmap.common.local_tile_pixel_value","title":"<code>local_tile_pixel_value(lon, lat, tile_client, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> required <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>PointData</code> <p>rio-tiler point data.</p> Source code in <code>leafmap/common.py</code> <pre><code>def local_tile_pixel_value(\n    lon,\n    lat,\n    tile_client,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        PointData: rio-tiler point data.\n    \"\"\"\n    return tile_client.point(lon, lat, coord_crs=\"EPSG:4326\", **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.local_tile_vmin_vmax","title":"<code>local_tile_vmin_vmax(source, bands=None, **kwargs)</code>","text":"<p>Get vmin and vmax from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient object.</p> required <code>bands</code> <code>str | list</code> <p>A list of band names. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If source is not a TileClient object or a local COG file path.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of vmin and vmax.</p> Source code in <code>leafmap/common.py</code> <pre><code>def local_tile_vmin_vmax(\n    source,\n    bands=None,\n    **kwargs,\n):\n    \"\"\"Get vmin and vmax from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient object.\n        bands (str | list, optional): A list of band names. Defaults to None.\n\n    Raises:\n        ValueError: If source is not a TileClient object or a local COG file path.\n\n    Returns:\n        tuple: A tuple of vmin and vmax.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    bandnames = tile_client.band_names\n    stats = tile_client.reader.statistics()\n\n    if isinstance(bands, str):\n        bands = [bands]\n    elif isinstance(bands, list):\n        pass\n    elif bands is None:\n        bands = bandnames\n\n    if all(b in bandnames for b in bands):\n        vmin = min([stats[b][\"min\"] for b in bands])\n        vmax = max([stats[b][\"max\"] for b in bands])\n    else:\n        vmin = min([stats[b][\"min\"] for b in bandnames])\n        vmax = max([stats[b][\"max\"] for b in bandnames])\n    return vmin, vmax\n</code></pre>"},{"location":"common/#leafmap.common.make_gif","title":"<code>make_gif(images, out_gif, ext='jpg', fps=10, loop=0, mp4=False, clean_up=False)</code>","text":"<p>Creates a gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to 'jpg'.</p> <code>'jpg'</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/common.py</code> <pre><code>def make_gif(images, out_gif, ext=\"jpg\", fps=10, loop=0, mp4=False, clean_up=False):\n    \"\"\"Creates a gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to 'jpg'.\n        fps (int, optional): The frames per second of the gif. Defaults to 10.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n\n    \"\"\"\n    import glob\n    from PIL import Image\n\n    ext = ext.replace(\".\", \"\")\n\n    if isinstance(images, str) and os.path.isdir(images):\n        images = list(glob.glob(os.path.join(images, f\"*.{ext}\")))\n        if len(images) == 0:\n            raise ValueError(\"No images found in the input directory.\")\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    frames = [Image.open(image) for image in images]\n    frame_one = frames[0]\n    frame_one.save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames,\n        save_all=True,\n        duration=int(1000 / fps),\n        loop=loop,\n    )\n\n    if mp4:\n        if not is_tool(\"ffmpeg\"):\n            print(\"ffmpeg is not installed on your computer.\")\n            return\n\n        if os.path.exists(out_gif):\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            cmd = f\"ffmpeg -loglevel error -i {out_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n            os.system(cmd)\n            if not os.path.exists(out_mp4):\n                raise Exception(f\"Failed to create mp4 file.\")\n    if clean_up:\n        for image in images:\n            os.remove(image)\n</code></pre>"},{"location":"common/#leafmap.common.map_tiles_to_geotiff","title":"<code>map_tiles_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.mbtiles_to_pmtiles","title":"<code>mbtiles_to_pmtiles(input_file, output_file, max_zoom=99)</code>","text":"<p>Converts mbtiles to pmtiles using the pmtiles package.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input .mbtiles file.</p> required <code>output_file</code> <code>str</code> <p>Path to the output .pmtiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the conversion. Defaults to 99.</p> <code>99</code> <p>Returns:</p> Type Description <code>None</code> <p>The function returns None either upon successful completion or when the pmtiles package is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def mbtiles_to_pmtiles(\n    input_file: str, output_file: str, max_zoom: int = 99\n) -&gt; Optional[None]:\n    \"\"\"\n    Converts mbtiles to pmtiles using the pmtiles package.\n\n    Args:\n        input_file (str): Path to the input .mbtiles file.\n        output_file (str): Path to the output .pmtiles file.\n        max_zoom (int): Maximum zoom level for the conversion. Defaults to 99.\n\n    Returns:\n        None: The function returns None either upon successful completion or when the pmtiles package is not installed.\n\n    Raises:\n        Any exception raised by pmtiles.convert.mbtiles_to_pmtiles will be propagated up.\n    \"\"\"\n\n    try:\n        import pmtiles.convert as convert\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n\n    convert.mbtiles_to_pmtiles(input_file, output_file, maxzoom=max_zoom)\n</code></pre>"},{"location":"common/#leafmap.common.merge_gifs","title":"<code>merge_gifs(in_gifs, out_gif)</code>","text":"<p>Merge multiple gifs into one.</p> <p>Parameters:</p> Name Type Description Default <code>in_gifs</code> <code>str | list</code> <p>The input gifs as a list or a directory path.</p> required <code>out_gif</code> <code>str</code> <p>The output gif.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception when gifsicle is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def merge_gifs(in_gifs, out_gif):\n    \"\"\"Merge multiple gifs into one.\n\n    Args:\n        in_gifs (str | list): The input gifs as a list or a directory path.\n        out_gif (str): The output gif.\n\n    Raises:\n        Exception:  Raise exception when gifsicle is not installed.\n    \"\"\"\n    import glob\n\n    try:\n        if isinstance(in_gifs, str) and os.path.isdir(in_gifs):\n            in_gifs = glob.glob(os.path.join(in_gifs, \"*.gif\"))\n        elif not isinstance(in_gifs, list):\n            raise Exception(\"in_gifs must be a list.\")\n\n        in_gifs = \" \".join(in_gifs)\n\n        cmd = f\"gifsicle {in_gifs} &gt; {out_gif}\"\n        os.system(cmd)\n\n    except Exception as e:\n        print(\n            \"gifsicle is not installed. Run 'sudo apt-get install -y gifsicle' to install it.\"\n        )\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.merge_rasters","title":"<code>merge_rasters(input_dir, output, input_pattern='*.tif', output_format='GTiff', output_nodata=None, output_options=['COMPRESS=DEFLATE'])</code>","text":"<p>Merge a directory of rasters into a single raster.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The path to the input directory.</p> required <code>output</code> <code>str</code> <p>The path to the output raster.</p> required <code>input_pattern</code> <code>str</code> <p>The pattern to match the input files. Defaults to \"*.tif\".</p> <code>'*.tif'</code> <code>output_format</code> <code>str</code> <p>The output format. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>output_nodata</code> <code>float</code> <p>The output nodata value. Defaults to None.</p> <code>None</code> <code>output_options</code> <code>list</code> <p>A list of output options. Defaults to [\"COMPRESS=DEFLATE\"].</p> <code>['COMPRESS=DEFLATE']</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if GDAL is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def merge_rasters(\n    input_dir,\n    output,\n    input_pattern=\"*.tif\",\n    output_format=\"GTiff\",\n    output_nodata=None,\n    output_options=[\"COMPRESS=DEFLATE\"],\n):\n    \"\"\"Merge a directory of rasters into a single raster.\n\n    Args:\n        input_dir (str): The path to the input directory.\n        output (str): The path to the output raster.\n        input_pattern (str, optional): The pattern to match the input files. Defaults to \"*.tif\".\n        output_format (str, optional): The output format. Defaults to \"GTiff\".\n        output_nodata (float, optional): The output nodata value. Defaults to None.\n        output_options (list, optional): A list of output options. Defaults to [\"COMPRESS=DEFLATE\"].\n\n    Raises:\n        ImportError: Raised if GDAL is not installed.\n    \"\"\"\n\n    import glob\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        )\n    # Get a list of all the input files\n    input_files = glob.glob(os.path.join(input_dir, input_pattern))\n\n    # Merge the input files into a single output file\n    gdal.Warp(\n        output,\n        input_files,\n        format=output_format,\n        dstNodata=output_nodata,\n        options=output_options,\n    )\n</code></pre>"},{"location":"common/#leafmap.common.merge_vector","title":"<code>merge_vector(files, output, crs=None, ext='geojson', recursive=False, quiet=False, return_gdf=False, **kwargs)</code>","text":"<p>Merge vector files into a single GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[str, List[str]]</code> <p>A string or a list of file paths to be merged.</p> required <code>output</code> <code>str</code> <p>The file path to save the merged GeoDataFrame.</p> required <code>crs</code> <code>str</code> <p>Optional. The coordinate reference system (CRS) of the output GeoDataFrame.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Optional. The file extension of the input files. Default is 'geojson'.</p> <code>'geojson'</code> <code>recursive</code> <code>bool</code> <p>Optional. If True, search for files recursively in subdirectories. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses progress messages. Default is False.</p> <code>False</code> <code>return_gdf</code> <code>bool</code> <p>Optional. If True, returns the merged GeoDataFrame. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.read_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>If <code>return_gdf</code> is True, returns the merged GeoDataFrame. Otherwise, returns None.</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>files</code> is not a list of file paths.</p> Source code in <code>leafmap/common.py</code> <pre><code>def merge_vector(\n    files: Union[str, List[str]],\n    output: str,\n    crs: str = None,\n    ext: str = \"geojson\",\n    recursive: bool = False,\n    quiet: bool = False,\n    return_gdf: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Merge vector files into a single GeoDataFrame.\n\n    Args:\n        files: A string or a list of file paths to be merged.\n        output: The file path to save the merged GeoDataFrame.\n        crs: Optional. The coordinate reference system (CRS) of the output GeoDataFrame.\n        ext: Optional. The file extension of the input files. Default is 'geojson'.\n        recursive: Optional. If True, search for files recursively in subdirectories. Default is False.\n        quiet: Optional. If True, suppresses progress messages. Default is False.\n        return_gdf: Optional. If True, returns the merged GeoDataFrame. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.read_file` function.\n\n    Returns:\n        If `return_gdf` is True, returns the merged GeoDataFrame. Otherwise, returns None.\n\n    Raises:\n        TypeError: If `files` is not a list of file paths.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(files, str):\n        files = find_files(files, ext=ext, recursive=recursive)\n\n    if not isinstance(files, list):\n        raise TypeError(\"files must be a list of file paths\")\n\n    gdfs = []\n    for index, filename in enumerate(files):\n        if not quiet:\n            print(f\"Reading {index+1} of {len(files)}: {filename}\")\n        gdf = gpd.read_file(filename, **kwargs)\n        if crs is None:\n            crs = gdf.crs\n        gdfs.append(gdf)\n\n    if not quiet:\n        print(\"Merging GeoDataFrames ...\")\n    gdf = gpd.GeoDataFrame(pd.concat(gdfs, ignore_index=True), crs=crs)\n\n    if not quiet:\n        print(f\"Saving merged file to {output} ...\")\n    gdf.to_file(output)\n    print(f\"Saved merged file to {output}\")\n\n    if return_gdf:\n        return gdf\n</code></pre>"},{"location":"common/#leafmap.common.meters_to_lnglat","title":"<code>meters_to_lnglat(x, y)</code>","text":"<p>coordinate conversion between web mercator to lat/lon in decimal degrees</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (longitude, latitude) in decimal degrees.</p> Source code in <code>leafmap/common.py</code> <pre><code>def meters_to_lnglat(x, y):\n    \"\"\"coordinate conversion between web mercator to lat/lon in decimal degrees\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n\n    Returns:\n        tuple: A tuple of (longitude, latitude) in decimal degrees.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    longitude = (x / origin_shift) * 180.0\n    latitude = (y / origin_shift) * 180.0\n    latitude = (\n        180 / np.pi * (2 * np.arctan(np.exp(latitude * np.pi / 180.0)) - np.pi / 2.0)\n    )\n    return (longitude, latitude)\n</code></pre>"},{"location":"common/#leafmap.common.mosaic","title":"<code>mosaic(images, output, ext='tif', recursive=True, merge_args={}, to_cog=True, verbose=True, **kwargs)</code>","text":"<p>Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>An input directory containing images or a list of images.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>ext</code> <code>str</code> <p>The file extension of the images. Defaults to 'tif'.</p> <code>'tif'</code> <code>recursive</code> <code>bool</code> <p>Whether to recursively search for images in the input directory. Defaults to True.</p> <code>True</code> <code>merge_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.</p> <code>{}</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/common.py</code> <pre><code>def mosaic(\n    images,\n    output,\n    ext=\"tif\",\n    recursive=True,\n    merge_args={},\n    to_cog=True,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.\n\n    Args:\n        images (str | list): An input directory containing images or a list of images.\n        output (str): The output image filepath.\n        ext (str, optional): The file extension of the images. Defaults to 'tif'.\n        recursive (bool, optional): Whether to recursively search for images in the input directory. Defaults to True.\n        merge_args (dict, optional): A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        verbose (bool, optional): Whether to print progress. Defaults to True.\n\n    \"\"\"\n    from rasterio.merge import merge\n    import rasterio as rio\n    from pathlib import Path\n\n    output = os.path.abspath(output)\n\n    if isinstance(images, str):\n        raster_files = find_files(images, ext=ext, recursive=recursive)\n    elif isinstance(images, list):\n        raster_files = images\n    else:\n        raise ValueError(\"images must be a list of raster files.\")\n\n    raster_to_mosiac = []\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    for index, p in enumerate(raster_files):\n        if verbose:\n            print(f\"Reading {index+1}/{len(raster_files)}: {os.path.basename(p)}\")\n        raster = rio.open(p, **kwargs)\n        raster_to_mosiac.append(raster)\n\n    if verbose:\n        print(\"Merging rasters...\")\n    arr, transform = merge(raster_to_mosiac, **merge_args)\n\n    output_meta = raster.meta.copy()\n    output_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": arr.shape[1],\n            \"width\": arr.shape[2],\n            \"transform\": transform,\n        }\n    )\n\n    with rio.open(output, \"w\", **output_meta) as m:\n        m.write(arr)\n\n    if to_cog:\n        if verbose:\n            print(\"Converting to COG...\")\n        image_to_cog(output, output)\n\n    if verbose:\n        print(f\"Saved mosaic to {output}\")\n</code></pre>"},{"location":"common/#leafmap.common.mosaic_bounds","title":"<code>mosaic_bounds(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the bounding box of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>leafmap/common.py</code> <pre><code>def mosaic_bounds(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the bounding box of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/bounds\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"bounds\"]\n</code></pre>"},{"location":"common/#leafmap.common.mosaic_info","title":"<code>mosaic_info(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.</p> Source code in <code>leafmap/common.py</code> <pre><code>def mosaic_info(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#leafmap.common.mosaic_info_geojson","title":"<code>mosaic_info_geojson(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing a dict of GeoJSON.</p> Source code in <code>leafmap/common.py</code> <pre><code>def mosaic_info_geojson(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary representing a dict of GeoJSON.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info.geojson\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#leafmap.common.mosaic_tile","title":"<code>mosaic_tile(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the tile URL from a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL.</p> Source code in <code>leafmap/common.py</code> <pre><code>def mosaic_tile(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the tile URL from a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        str: The tile URL.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/tilejson.json\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"common/#leafmap.common.nasa_data_download","title":"<code>nasa_data_download(granules, out_dir=None, provider=None, threads=8)</code>","text":"<p>Downloads NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>The granules to download.</p> required <code>out_dir</code> <code>str</code> <p>The output directory where the granules will be downloaded. Defaults to None (current directory).</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the granules.</p> <code>None</code> <code>threads</code> <code>int</code> <p>The number of threads to use for downloading. Defaults to 8.</p> <code>8</code> Source code in <code>leafmap/common.py</code> <pre><code>def nasa_data_download(\n    granules: List[dict],\n    out_dir: Optional[str] = None,\n    provider: Optional[str] = None,\n    threads: int = 8,\n) -&gt; None:\n    \"\"\"Downloads NASA Earthdata granules.\n\n    Args:\n        granules (List[dict]): The granules to download.\n        out_dir (str, optional): The output directory where the granules will be downloaded. Defaults to None (current directory).\n        provider (str, optional): The provider of the granules.\n        threads (int, optional): The number of threads to use for downloading. Defaults to 8.\n    \"\"\"\n    import earthaccess\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    earthaccess.download(\n        granules, local_path=out_dir, provider=provider, threads=threads\n    )\n</code></pre>"},{"location":"common/#leafmap.common.nasa_data_granules_to_gdf","title":"<code>nasa_data_granules_to_gdf(granules, crs='EPSG:4326', output=None, **kwargs)</code>","text":"<p>Converts granules data to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>A list of granules.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The resulting GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def nasa_data_granules_to_gdf(\n    granules: List[dict], crs: str = \"EPSG:4326\", output: str = None, **kwargs\n):\n    \"\"\"Converts granules data to a GeoDataFrame.\n\n    Args:\n        granules (List[dict]): A list of granules.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        output (str, optional): The output file path to save the GeoDataFrame as a file. Defaults to None.\n        **kwargs: Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.\n\n    Returns:\n        gpd.GeoDataFrame: The resulting GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import box, Polygon\n\n    df = pd.json_normalize([dict(i.items()) for i in granules])\n    df.columns = [col.split(\".\")[-1] for col in df.columns]\n    df = df.drop(\"Version\", axis=1)\n\n    def get_bbox(rectangles):\n        xmin = min(rectangle[\"WestBoundingCoordinate\"] for rectangle in rectangles)\n        ymin = min(rectangle[\"SouthBoundingCoordinate\"] for rectangle in rectangles)\n        xmax = max(rectangle[\"EastBoundingCoordinate\"] for rectangle in rectangles)\n        ymax = max(rectangle[\"NorthBoundingCoordinate\"] for rectangle in rectangles)\n\n        bbox = (xmin, ymin, xmax, ymax)\n        return bbox\n\n    def get_polygon(coordinates):\n        # Extract the points from the dictionary\n        points = [\n            (point[\"Longitude\"], point[\"Latitude\"])\n            for point in coordinates[0][\"Boundary\"][\"Points\"]\n        ]\n\n        # Create a Polygon\n        polygon = Polygon(points)\n        return polygon\n\n    if \"BoundingRectangles\" in df.columns:\n        df[\"bbox\"] = df[\"BoundingRectangles\"].apply(get_bbox)\n        df[\"geometry\"] = df[\"bbox\"].apply(lambda x: box(*x))\n    elif \"GPolygons\" in df.columns:\n        df[\"geometry\"] = df[\"GPolygons\"].apply(get_polygon)\n\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n\n    gdf.crs = crs\n\n    if output is not None:\n        for column in gdf.columns:\n            if gdf[column].apply(lambda x: isinstance(x, list)).any():\n                gdf[column] = gdf[column].apply(lambda x: str(x))\n\n        gdf.to_file(output, **kwargs)\n\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.nasa_data_login","title":"<code>nasa_data_login(strategy='all', persist=False, **kwargs)</code>","text":"<p>Logs in to NASA Earthdata.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>The authentication method.    \"all\": (default) try all methods until one works     \"interactive\": enter username and password.     \"netrc\": retrieve username and password from ~/.netrc.     \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD. persist (bool, optional): Whether to persist credentials in a .netrc file. Defaults to False.</p> <code>'all'</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.login() function.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def nasa_data_login(strategy: str = \"all\", persist: bool = False, **kwargs) -&gt; None:\n    \"\"\"Logs in to NASA Earthdata.\n\n    Args:\n        strategy (str, optional): The authentication method.\n               \"all\": (default) try all methods until one works\n                \"interactive\": enter username and password.\n                \"netrc\": retrieve username and password from ~/.netrc.\n                \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD.\n           persist (bool, optional): Whether to persist credentials in a .netrc file. Defaults to False.\n        **kwargs: Additional keyword arguments for the earthaccess.login() function.\n    \"\"\"\n    try:\n        import earthaccess\n    except ImportError:\n        install_package(\"earthaccess\")\n        import earthaccess\n\n    try:\n        earthaccess.login(strategy=strategy, persist=persist, **kwargs)\n    except:\n        print(\n            \"Please login to Earthdata first. Register at https://urs.earthdata.nasa.gov\"\n        )\n</code></pre>"},{"location":"common/#leafmap.common.nasa_data_search","title":"<code>nasa_data_search(count=-1, short_name=None, bbox=None, temporal=None, version=None, doi=None, daac=None, provider=None, output=None, crs='EPSG:4326', return_gdf=False, **kwargs)</code>","text":"<p>Searches for NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of granules to retrieve. Defaults to -1 (retrieve all).</p> <code>-1</code> <code>short_name</code> <code>str</code> <p>The short name of the dataset.</p> <code>None</code> <code>bbox</code> <code>List[float]</code> <p>The bounding box coordinates [xmin, ymin, xmax, ymax].</p> <code>None</code> <code>temporal</code> <code>str</code> <p>The temporal extent of the data.</p> <code>None</code> <code>version</code> <code>str</code> <p>The version of the dataset.</p> <code>None</code> <code>doi</code> <code>str</code> <p>The Digital Object Identifier (DOI) of the dataset.</p> <code>None</code> <code>daac</code> <code>str</code> <p>The Distributed Active Archive Center (DAAC) of the dataset.</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the dataset.</p> <code>None</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>return_gdf</code> <code>bool</code> <p>Whether to return the GeoDataFrame in addition to the granules. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.search_data() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[List[dict], tuple]</code> <p>The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def nasa_data_search(\n    count: int = -1,\n    short_name: Optional[str] = None,\n    bbox: Optional[List[float]] = None,\n    temporal: Optional[str] = None,\n    version: Optional[str] = None,\n    doi: Optional[str] = None,\n    daac: Optional[str] = None,\n    provider: Optional[str] = None,\n    output: Optional[str] = None,\n    crs: str = \"EPSG:4326\",\n    return_gdf: bool = False,\n    **kwargs,\n) -&gt; Union[List[dict], tuple]:\n    \"\"\"Searches for NASA Earthdata granules.\n\n    Args:\n        count (int, optional): The number of granules to retrieve. Defaults to -1 (retrieve all).\n        short_name (str, optional): The short name of the dataset.\n        bbox (List[float], optional): The bounding box coordinates [xmin, ymin, xmax, ymax].\n        temporal (str, optional): The temporal extent of the data.\n        version (str, optional): The version of the dataset.\n        doi (str, optional): The Digital Object Identifier (DOI) of the dataset.\n        daac (str, optional): The Distributed Active Archive Center (DAAC) of the dataset.\n        provider (str, optional): The provider of the dataset.\n        output (str, optional): The output file path to save the GeoDataFrame as a file.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        return_gdf (bool, optional): Whether to return the GeoDataFrame in addition to the granules. Defaults to False.\n        **kwargs: Additional keyword arguments for the earthaccess.search_data() function.\n\n    Returns:\n        Union[List[dict], tuple]: The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.\n    \"\"\"\n    import earthaccess\n\n    if short_name is not None:\n        kwargs[\"short_name\"] = short_name\n    if bbox is not None:\n        kwargs[\"bounding_box\"] = bbox\n    if temporal is not None:\n        kwargs[\"temporal\"] = temporal\n    if version is not None:\n        kwargs[\"version\"] = version\n    if doi is not None:\n        kwargs[\"doi\"] = doi\n    if daac is not None:\n        kwargs[\"daac\"] = daac\n    if provider is not None:\n        kwargs[\"provider\"] = provider\n\n    granules = earthaccess.search_data(\n        count=count,\n        **kwargs,\n    )\n\n    if output is not None:\n        nasa_data_granules_to_gdf(granules, crs=crs, output=output)\n\n    if return_gdf:\n        gdf = nasa_data_granules_to_gdf(granules, crs=crs)\n        return granules, gdf\n    else:\n        return granules\n</code></pre>"},{"location":"common/#leafmap.common.nasa_datasets","title":"<code>nasa_datasets(keyword=None, df=None, return_short_name=False)</code>","text":"<p>Searches for NASA datasets based on a keyword in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for. Defaults to None.</p> <code>None</code> <code>df</code> <code>pd.DataFrame</code> <p>The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.</p> <code>None</code> <code>return_short_name</code> <code>bool</code> <p>If True, only returns the list of short names of the matched datasets. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, List[str]]</code> <p>Filtered DataFrame if return_short_name is False, otherwise a list of short names.</p> Source code in <code>leafmap/common.py</code> <pre><code>def nasa_datasets(keyword=None, df=None, return_short_name=False):\n    \"\"\"\n    Searches for NASA datasets based on a keyword in a DataFrame.\n\n    Args:\n        keyword (str, optional): The keyword to search for. Defaults to None.\n        df (pd.DataFrame, optional): The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.\n        return_short_name (bool, optional): If True, only returns the list of short names of the matched datasets. Defaults to False.\n\n    Returns:\n        Union[pd.DataFrame, List[str]]: Filtered DataFrame if return_short_name is False, otherwise a list of short names.\n\n    \"\"\"\n    import pandas as pd\n\n    if df is None:\n        url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\n        df = pd.read_csv(url, sep=\"\\t\")\n\n    if keyword is not None:\n        # Convert keyword and DataFrame values to lowercase\n        keyword_lower = keyword.lower()\n        df_lower = df.applymap(lambda x: x.lower() if isinstance(x, str) else x)\n\n        # Use boolean indexing to filter the DataFrame\n        filtered_df = df[\n            df_lower.astype(str).apply(lambda x: keyword_lower in \" \".join(x), axis=1)\n        ].reset_index(drop=True)\n\n        if return_short_name:\n            return filtered_df[\"ShortName\"].tolist()\n        else:\n            return filtered_df\n    else:\n        if return_short_name:\n            return df[\"ShortName\"].tolist()\n        else:\n            return df\n</code></pre>"},{"location":"common/#leafmap.common.netcdf_tile_layer","title":"<code>netcdf_tile_layer(filename, variables=None, colormap=None, vmin=None, vmax=None, nodata=None, port='default', debug=False, attribution=None, tile_format='ipyleaflet', layer_name='NetCDF layer', return_client=False, shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>projection</code> <code>str</code> <p>The projection of the GeoTIFF. Defaults to \"EPSG:3857\".</p> required <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"NetCDF layer\".</p> <code>'NetCDF layer'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def netcdf_tile_layer(\n    filename,\n    variables=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    port=\"default\",\n    debug=False,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"NetCDF layer\",\n    return_client=False,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        projection (str, optional): The projection of the GeoTIFF. Defaults to \"EPSG:3857\".\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to \"NetCDF layer\".\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    output = filename.replace(\".nc\", \".tif\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds.lon)\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a subset of {allowed_vars}.\")\n        variables = [variables]\n\n    if variables is not None and len(variables) &gt; 3:\n        raise ValueError(\"Only 3 variables can be plotted at a time.\")\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    if variables is None:\n        if len(allowed_vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        band_idx = [allowed_vars.index(var) + 1 for var in variables]\n\n    tile_layer = get_local_tile_layer(\n        output,\n        port=port,\n        debug=debug,\n        indexes=band_idx,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=tile_format,\n        layer_name=layer_name,\n        return_client=return_client,\n    )\n    return tile_layer\n</code></pre>"},{"location":"common/#leafmap.common.netcdf_to_tif","title":"<code>netcdf_to_tif(filename, output=None, variables=None, shift_lon=True, lat='lat', lon='lon', lev='lev', level_index=0, time=0, crs='epsg:4326', return_vars=False, **kwargs)</code>","text":"<p>Convert a netcdf file to a GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the netcdf file.</p> required <code>output</code> <code>str</code> <p>Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.</p> <code>None</code> <code>variables</code> <code>str | list</code> <p>Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <code>lev</code> <code>str</code> <p>Name of the level variable. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>Index of the level dimension. Defaults to 0'.</p> <code>0</code> <code>time</code> <code>int</code> <p>Index of the time dimension. Defaults to 0'.</p> <code>0</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <code>return_vars</code> <code>bool</code> <p>Flag to return all variables. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <code>ValueError</code> <p>If the variable is not found in the netcdf file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def netcdf_to_tif(\n    filename,\n    output=None,\n    variables=None,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    lev=\"lev\",\n    level_index=0,\n    time=0,\n    crs=\"epsg:4326\",\n    return_vars=False,\n    **kwargs,\n):\n    \"\"\"Convert a netcdf file to a GeoTIFF file.\n\n    Args:\n        filename (str): Path to the netcdf file.\n        output (str, optional): Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.\n        variables (str | list, optional): Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        lev (str, optional): Name of the level variable. Defaults to 'lev'.\n        level_index (int, optional): Index of the level dimension. Defaults to 0'.\n        time (int, optional): Index of the time dimension. Defaults to 0'.\n        crs (str, optional): The coordinate reference system. Defaults to 'epsg:4326'.\n        return_vars (bool, optional): Flag to return all variables. Defaults to False.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n        ValueError: If the variable is not found in the netcdf file.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    if output is None:\n        ext = os.path.splitext(filename)[1].lower()\n        if ext not in [\".nc\", \".nc4\"]:\n            raise TypeError(\n                \"The output file must be a netCDF with extension .nc or .nc4.\"\n            )\n        output = filename.replace(ext, \".tif\")\n    else:\n        output = check_file_path(output)\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    coords = list(xds.coords.keys())\n    if \"time\" in coords:\n        xds = xds.isel(time=time, drop=True)\n\n    if lev in coords:\n        xds = xds.isel(lev=level_index, drop=True)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds[lon])\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a valid variable.\")\n        variables = [variables]\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    if variables is None:\n        xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.write_crs(crs).rio.to_raster(\n            output\n        )\n    else:\n        xds[variables].rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.write_crs(\n            crs\n        ).rio.to_raster(output)\n\n    if return_vars:\n        return output, allowed_vars\n    else:\n        return output\n</code></pre>"},{"location":"common/#leafmap.common.numpy_to_cog","title":"<code>numpy_to_cog(np_array, out_cog, bounds=None, profile=None, dtype=None, dst_crs=None, coord_crs=None)</code>","text":"<p>Converts a numpy array to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.array</code> <p>A numpy array representing an image or an HTTP URL to an image.</p> required <code>out_cog</code> <code>str</code> <p>The output COG file path.</p> required <code>bounds</code> <code>tuple</code> <p>The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>profile</code> <code>str | dict</code> <p>File path to an existing COG file or a dictionary representing the profile. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The data type of the output COG file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate reference system of bbox coordinates. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def numpy_to_cog(\n    np_array,\n    out_cog,\n    bounds=None,\n    profile=None,\n    dtype=None,\n    dst_crs=None,\n    coord_crs=None,\n):\n    \"\"\"Converts a numpy array to a COG file.\n\n    Args:\n        np_array (np.array): A numpy array representing an image or an HTTP URL to an image.\n        out_cog (str): The output COG file path.\n        bounds (tuple, optional): The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.\n        profile (str | dict, optional): File path to an existing COG file or a dictionary representing the profile. Defaults to None.\n        dtype (str, optional): The data type of the output COG file. Defaults to None.\n        dst_crs (str, optional): The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".\n        coord_crs (str, optional): The coordinate reference system of bbox coordinates. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    from rasterio.io import MemoryFile\n    from rasterio.transform import from_bounds\n\n    from rio_cogeo.cogeo import cog_translate\n    from rio_cogeo.profiles import cog_profiles\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        with rasterio.open(np_array, \"r\") as ds:\n            np_array = ds.read()\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The input array must be a numpy array.\")\n\n    out_dir = os.path.dirname(out_cog)\n    check_dir(out_dir)\n\n    if profile is not None:\n        if isinstance(profile, str):\n            if (not profile.startswith(\"http\")) and (not os.path.exists(profile)):\n                raise FileNotFoundError(\"The provided file could not be found.\")\n            with rasterio.open(profile) as ds:\n                dst_crs = ds.crs\n                if bounds is None:\n                    bounds = ds.bounds\n\n        elif isinstance(profile, rasterio.profiles.Profile):\n            profile = dict(profile)\n        elif not isinstance(profile, dict):\n            raise TypeError(\"The provided profile must be a file path or a dictionary.\")\n\n    if bounds is None:\n        print(\n            \"warning: bounds is not set. Using the default bounds (-180.0, -85.0511, 180.0, 85.0511)\"\n        )\n        bounds = (-180.0, -85.0511287798066, 180.0, 85.0511287798066)\n\n    if not isinstance(bounds, tuple) and len(bounds) != 4:\n        raise TypeError(\"The provided bounds must be a tuple of length 4.\")\n\n    # Rasterio uses numpy array of shape of `(bands, height, width)`\n\n    if len(np_array.shape) == 3:\n        nbands = np_array.shape[0]\n        height = np_array.shape[1]\n        width = np_array.shape[2]\n    elif len(np_array.shape) == 2:\n        nbands = 1\n        height = np_array.shape[0]\n        width = np_array.shape[1]\n        np_array = np_array.reshape((1, height, width))\n    else:\n        raise ValueError(\"The input array must be a 2D or 3D numpy array.\")\n\n    if coord_crs is not None and dst_crs is not None:\n        bounds = transform_bbox_coords(bounds, coord_crs, dst_crs)\n\n    src_transform = from_bounds(*bounds, width=width, height=height)\n    if dtype is None:\n        dtype = str(np_array.dtype)\n\n    if dst_crs is None:\n        dst_crs = \"epsg:4326\"\n\n    if isinstance(profile, dict):\n        src_profile = profile\n        src_profile[\"count\"] = nbands\n    else:\n        src_profile = dict(\n            driver=\"GTiff\",\n            dtype=dtype,\n            count=nbands,\n            height=height,\n            width=width,\n            crs=dst_crs,\n            transform=src_transform,\n        )\n\n    with MemoryFile() as memfile:\n        with memfile.open(**src_profile) as mem:\n            # Populate the input file with numpy array\n            mem.write(np_array)\n\n            dst_profile = cog_profiles.get(\"deflate\")\n            cog_translate(\n                mem,\n                out_cog,\n                dst_profile,\n                in_memory=True,\n                quiet=True,\n            )\n</code></pre>"},{"location":"common/#leafmap.common.numpy_to_image","title":"<code>numpy_to_image(np_array, filename, transpose=True, bands=None, size=None, resize_args=None, **kwargs)</code>","text":"<p>Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.ndarray</code> <p>A numpy array or a path to a raster file.</p> required <code>filename</code> <code>str</code> <p>The output filename.</p> required <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.</p> <code>True</code> <code>bands</code> <code>int | list</code> <p>The band(s) to use, starting from 0. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def numpy_to_image(\n    np_array,\n    filename: str,\n    transpose: bool = True,\n    bands: Union[int, list] = None,\n    size: Tuple = None,\n    resize_args: dict = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.\n\n    Args:\n        np_array (np.ndarray): A numpy array or a path to a raster file.\n        filename (str): The output filename.\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.\n        bands (int | list, optional): The band(s) to use, starting from 0. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    from PIL import Image\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        np_array = image_to_numpy(np_array)\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The provided input must be a numpy array.\")\n\n    if np_array.dtype == np.float64 or np_array.dtype == np.float32:\n        # Convert the array to uint8\n        # np_array = (np_array * 255).astype(np.uint8)\n        np.interp(np_array, (np_array.min(), np_array.max()), (0, 255)).astype(np.uint8)\n    else:\n        # The array is already uint8\n        np_array = np_array\n\n    if np_array.ndim == 2:\n        img = Image.fromarray(np_array)\n    elif np_array.ndim == 3:\n        if transpose:\n            np_array = np_array.transpose(1, 2, 0)\n        if bands is None:\n            if np_array.shape[2] &lt; 3:\n                np_array = np_array[:, :, 0]\n            elif np_array.shape[2] &gt; 3:\n                np_array = np_array[:, :, :3]\n\n        elif isinstance(bands, list):\n            if len(bands) == 1:\n                np_array = np_array[:, :, bands[0]]\n            else:\n                np_array = np_array[:, :, bands]\n        elif isinstance(bands, int):\n            np_array = np_array[:, :, bands]\n        img = Image.fromarray(np_array)\n    else:\n        raise ValueError(\"The provided input must be a 2D or 3D numpy array.\")\n\n    if isinstance(size, tuple):\n        try:\n            from skimage.transform import resize\n        except ImportError:\n            raise ImportError(\n                \"The scikit-image package is not installed. Please install it with `pip install scikit-image` \\\n                  or `conda install scikit-image -c conda-forge`.\"\n            )\n        if resize_args is None:\n            resize_args = {}\n        if \"preserve_range\" not in resize_args:\n            resize_args[\"preserve_range\"] = True\n        np_array = resize(np_array, size, **resize_args).astype(\"uint8\")\n        img = Image.fromarray(np_array)\n\n    img.save(filename, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.open_image_from_url","title":"<code>open_image_from_url(url)</code>","text":"<p>Loads an image from the specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the image.</p> required <p>Returns:</p> Type Description <code>object</code> <p>Image object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def open_image_from_url(url: str):\n    \"\"\"Loads an image from the specified URL.\n\n    Args:\n        url (str): URL of the image.\n\n    Returns:\n        object: Image object.\n    \"\"\"\n    from PIL import Image\n\n    from io import BytesIO\n\n    # from urllib.parse import urlparse\n\n    try:\n        response = requests.get(url)\n        img = Image.open(BytesIO(response.content))\n        return img\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.overlay_images","title":"<code>overlay_images(image1, image2, alpha=0.5, backend='TkAgg', height_ratios=[10, 1], show_args1={}, show_args2={})</code>","text":"<p>Overlays two images using a slider to control the opacity of the top image.</p> <p>Parameters:</p> Name Type Description Default <code>image1</code> <code>str | np.ndarray</code> <p>The first input image at the bottom represented as a NumPy array or the path to the image.</p> required <code>image2</code> <code>_type_</code> <p>The second input image on top represented as a NumPy array or the path to the image.</p> required <code>alpha</code> <code>float</code> <p>The alpha value of the top image. Defaults to 0.5.</p> <code>0.5</code> <code>backend</code> <code>str</code> <p>The backend of the matplotlib plot. Defaults to \"TkAgg\".</p> <code>'TkAgg'</code> <code>height_ratios</code> <code>list</code> <p>The height ratios of the two subplots. Defaults to [10, 1].</p> <code>[10, 1]</code> <code>show_args1</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.</p> <code>{}</code> <code>show_args2</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def overlay_images(\n    image1,\n    image2,\n    alpha=0.5,\n    backend=\"TkAgg\",\n    height_ratios=[10, 1],\n    show_args1={},\n    show_args2={},\n):\n    \"\"\"Overlays two images using a slider to control the opacity of the top image.\n\n    Args:\n        image1 (str | np.ndarray): The first input image at the bottom represented as a NumPy array or the path to the image.\n        image2 (_type_): The second input image on top represented as a NumPy array or the path to the image.\n        alpha (float, optional): The alpha value of the top image. Defaults to 0.5.\n        backend (str, optional): The backend of the matplotlib plot. Defaults to \"TkAgg\".\n        height_ratios (list, optional): The height ratios of the two subplots. Defaults to [10, 1].\n        show_args1 (dict, optional): The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.\n        show_args2 (dict, optional): The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.\n\n    \"\"\"\n    import sys\n    import matplotlib\n    import matplotlib.pyplot as plt\n    import matplotlib.widgets as mpwidgets\n\n    if \"google.colab\" in sys.modules:\n        backend = \"inline\"\n        print(\n            \"The TkAgg backend is not supported in Google Colab. The overlay_images function will not work on Colab.\"\n        )\n        return\n\n    matplotlib.use(backend)\n\n    if isinstance(image1, str):\n        if image1.startswith(\"http\"):\n            image1 = download_file(image1)\n\n        if not os.path.exists(image1):\n            raise ValueError(f\"Input path {image1} does not exist.\")\n\n    if isinstance(image2, str):\n        if image2.startswith(\"http\"):\n            image2 = download_file(image2)\n\n        if not os.path.exists(image2):\n            raise ValueError(f\"Input path {image2} does not exist.\")\n\n    # Load the two images\n    x = plt.imread(image1)\n    y = plt.imread(image2)\n\n    # Create the plot\n    fig, (ax0, ax1) = plt.subplots(2, 1, gridspec_kw={\"height_ratios\": height_ratios})\n    img0 = ax0.imshow(x, **show_args1)\n    img1 = ax0.imshow(y, alpha=alpha, **show_args2)\n\n    # Define the update function\n    def update(value):\n        img1.set_alpha(value)\n        fig.canvas.draw_idle()\n\n    # Create the slider\n    slider0 = mpwidgets.Slider(ax=ax1, label=\"alpha\", valmin=0, valmax=1, valinit=alpha)\n    slider0.on_changed(update)\n\n    # Display the plot\n    plt.show()\n</code></pre>"},{"location":"common/#leafmap.common.pandas_to_geojson","title":"<code>pandas_to_geojson(df, coordinates=['lng', 'lat'], geometry_type='Point', properties=None, output=None)</code>","text":"<p>Convert a DataFrame to a GeoJSON format.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The input DataFrame containing the data.</p> required <code>coordinates</code> <code>list</code> <p>A list of two column names representing the longitude and latitude coordinates.</p> <code>['lng', 'lat']</code> <code>geometry_type</code> <code>str</code> <p>The type of geometry for the GeoJSON features (e.g., \"Point\", \"LineString\", \"Polygon\").</p> <code>'Point'</code> <code>properties</code> <code>list</code> <p>A list of column names to include in the properties of each GeoJSON feature. If None, all columns except the coordinate columns are included.</p> <code>None</code> <code>output</code> <code>str</code> <p>The file path to save the GeoJSON output. If None, the GeoJSON is not saved to a file.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing the GeoJSON object.</p> Source code in <code>leafmap/common.py</code> <pre><code>def pandas_to_geojson(\n    df,\n    coordinates=[\"lng\", \"lat\"],\n    geometry_type: str = \"Point\",\n    properties: list = None,\n    output: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"\n    Convert a DataFrame to a GeoJSON format.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame containing the data.\n        coordinates (list): A list of two column names representing the\n            longitude and latitude coordinates.\n        geometry_type (str): The type of geometry for the GeoJSON features\n            (e.g., \"Point\", \"LineString\", \"Polygon\").\n        properties (list): A list of column names to include in the properties\n            of each GeoJSON feature. If None, all columns except the coordinate\n            columns are included.\n        output (str, optional): The file path to save the GeoJSON output. If None,\n            the GeoJSON is not saved to a file.\n\n    Returns:\n        dict: A dictionary representing the GeoJSON object.\n    \"\"\"\n\n    import pandas as pd\n\n    if isinstance(df, str):\n        if df.endswith(\".csv\"):\n            df = pd.read_csv(df)\n        elif df.endswith(\".json\"):\n            df = pd.read_json(df)\n        else:\n            raise ValueError(\"The input file must be a CSV or JSON file.\")\n\n    geojson = {\"type\": \"FeatureCollection\", \"features\": []}\n\n    if properties is None:\n        properties = [col for col in df.columns if col not in coordinates]\n\n    for _, row in df.iterrows():\n        feature = {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": geometry_type, \"coordinates\": []},\n        }\n        feature[\"geometry\"][\"coordinates\"] = list(row[coordinates])\n        for prop in properties:\n            feature[\"properties\"][prop] = row[prop]\n\n        geojson[\"features\"].append(feature)\n\n    if output:\n        with open(output, \"w\") as f:\n            json.dump(geojson, f, indent=4)\n\n    return geojson\n</code></pre>"},{"location":"common/#leafmap.common.planet_biannual_tiles_tropical","title":"<code>planet_biannual_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_biannual_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_biannual_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 15]\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#leafmap.common.planet_biannual_tropical","title":"<code>planet_biannual_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_biannual_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    dates = [\n        \"2015-12_2016-05\",\n        \"2016-06_2016-11\",\n        \"2016-12_2017-05\",\n        \"2017-06_2017-11\",\n        \"2017-12_2018-05\",\n        \"2018-06_2018-11\",\n        \"2018-12_2019-05\",\n        \"2019-06_2019-11\",\n        \"2019-12_2020-05\",\n        \"2020-06_2020-08\",\n    ]\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for d in dates:\n        url = f\"{prefix}{d}{subfix}{api_key}\"\n        link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#leafmap.common.planet_by_month","title":"<code>planet_by_month(year=2016, month=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_by_month(\n    year=2016,\n    month=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The month is invalid.\n        ValueError: The month is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    # quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and month &gt;= month_now:\n        raise ValueError(f\"Month must be less than {month_now} for year {year_now}\")\n\n    if month &lt; 1 or month &gt; 12:\n        raise ValueError(\"Month must be between 1 and 12.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"_\" + str(month).zfill(2)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#leafmap.common.planet_by_quarter","title":"<code>planet_by_quarter(year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_by_quarter(\n    year=2016,\n    quarter=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The quarter is invalid.\n        ValueError: The quarter is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and quarter &gt;= quarter_now:\n        raise ValueError(f\"Quarter must be less than {quarter_now} for year {year_now}\")\n\n    if quarter &lt; 1 or quarter &gt; 4:\n        raise ValueError(\"Quarter must be between 1 and 4.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"q\" + str(quarter)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#leafmap.common.planet_catalog","title":"<code>planet_catalog(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_catalog(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    quarterly = planet_quarterly(api_key, token_name)\n    monthly = planet_monthly(api_key, token_name)\n    return quarterly + monthly\n</code></pre>"},{"location":"common/#leafmap.common.planet_catalog_tropical","title":"<code>planet_catalog_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_catalog_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    biannual = planet_biannual_tropical(api_key, token_name)\n    monthly = planet_monthly_tropical(api_key, token_name)\n    return biannual + monthly\n</code></pre>"},{"location":"common/#leafmap.common.planet_monthly","title":"<code>planet_monthly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_monthly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"_\" + str(month).zfill(2)\n\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#leafmap.common.planet_monthly_tiles","title":"<code>planet_monthly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_monthly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly(api_key, token_name)\n\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#leafmap.common.planet_monthly_tiles_tropical","title":"<code>planet_monthly_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_monthly_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#leafmap.common.planet_monthly_tropical","title":"<code>planet_monthly_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_monthly_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    links = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2020, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"-\" + str(month).zfill(2)\n\n            if year == 2020 and month &lt; 9:\n                continue\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            links.append(url)\n\n    return links\n</code></pre>"},{"location":"common/#leafmap.common.planet_quarterly","title":"<code>planet_quarterly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_quarterly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for quarter in range(1, 5):\n            m_str = str(year) + \"q\" + str(quarter)\n\n            if year == year_now and quarter &gt;= quarter_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#leafmap.common.planet_quarterly_tiles","title":"<code>planet_quarterly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_quarterly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    links = planet_quarterly(api_key, token_name)\n\n    for url in links:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 6]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#leafmap.common.planet_tile_by_month","title":"<code>planet_tile_by_month(year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_tile_by_month(\n    year=2016,\n    month=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_month(year, month, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_\" + str(month).zfill(2)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#leafmap.common.planet_tile_by_quarter","title":"<code>planet_tile_by_quarter(year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_tile_by_quarter(\n    year=2016,\n    quarter=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_quarter(year, quarter, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_q\" + str(quarter)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#leafmap.common.planet_tiles","title":"<code>planet_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_tiles(api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"):\n    \"\"\"Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    quarterly = planet_quarterly_tiles(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles(api_key, token_name, tile_format)\n\n    for key in quarterly:\n        catalog[key] = quarterly[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#leafmap.common.planet_tiles_tropical","title":"<code>planet_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>leafmap/common.py</code> <pre><code>def planet_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    biannul = planet_biannual_tiles_tropical(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles_tropical(api_key, token_name, tile_format)\n\n    for key in biannul:\n        catalog[key] = biannul[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#leafmap.common.plot_raster","title":"<code>plot_raster(image, band=None, cmap='terrain', proj='EPSG:3857', figsize=None, open_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray </code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>figsize</code> <code>tuple</code> <p>The figure size as a tuple, such as (10, 8). Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def plot_raster(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    proj=\"EPSG:3857\",\n    figsize=None,\n    open_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image.\n\n    Args:\n        image (str | xarray.DataArray ): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        figsize (tuple, optional): The figure size as a tuple, such as (10, 8). Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import pvxarray\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    kwargs[\"cmap\"] = cmap\n    kwargs[\"figsize\"] = figsize\n    da.plot(**kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.plot_raster_3d","title":"<code>plot_raster_3d(image, band=None, cmap='terrain', factor=1.0, proj='EPSG:3857', background=None, x=None, y=None, z=None, order=None, component=None, open_kwargs={}, mesh_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray</code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>factor</code> <code>float</code> <p>The scaling factor for the raster. Defaults to 1.0.</p> <code>1.0</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>background</code> <code>str</code> <p>The background color. Defaults to None.</p> <code>None</code> <code>x</code> <code>str</code> <p>The x coordinate. Defaults to None.</p> <code>None</code> <code>y</code> <code>str</code> <p>The y coordinate. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>The z coordinate. Defaults to None.</p> <code>None</code> <code>order</code> <code>str</code> <p>The order of the coordinates. Defaults to None.</p> <code>None</code> <code>component</code> <code>str</code> <p>The component of the coordinates. Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>mesh_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def plot_raster_3d(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    factor=1.0,\n    proj=\"EPSG:3857\",\n    background=None,\n    x=None,\n    y=None,\n    z=None,\n    order=None,\n    component=None,\n    open_kwargs={},\n    mesh_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image in 3D.\n\n    Args:\n        image (str | xarray.DataArray): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        factor (float, optional): The scaling factor for the raster. Defaults to 1.0.\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        background (str, optional): The background color. Defaults to None.\n        x (str, optional): The x coordinate. Defaults to None.\n        y (str, optional): The y coordinate. Defaults to None.\n        z (str, optional): The z coordinate. Defaults to None.\n        order (str, optional): The order of the coordinates. Defaults to None.\n        component (str, optional): The component of the coordinates. Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        mesh_kwargs (dict, optional): The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n    \"\"\"\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    try:\n        import pvxarray\n        import pyvista\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(background, str):\n        pyvista.global_theme.background = background\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    mesh_kwargs[\"factor\"] = factor\n    kwargs[\"cmap\"] = cmap\n\n    coords = list(da.coords)\n\n    if x is None:\n        if \"x\" in coords:\n            x = \"x\"\n        elif \"lon\" in coords:\n            x = \"lon\"\n    if y is None:\n        if \"y\" in coords:\n            y = \"y\"\n        elif \"lat\" in coords:\n            y = \"lat\"\n    if z is None:\n        if \"z\" in coords:\n            z = \"z\"\n        elif \"elevation\" in coords:\n            z = \"elevation\"\n        elif \"band\" in coords:\n            z = \"band\"\n\n    # Grab the mesh object for use with PyVista\n    mesh = da.pyvista.mesh(x=x, y=y, z=z, order=order, component=component)\n\n    # Warp top and plot in 3D\n    mesh.warp_by_scalar(**mesh_kwargs).plot(**kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.pmtiles_header","title":"<code>pmtiles_header(input_file)</code>","text":"<p>Fetch the header information from a local or remote .pmtiles file.</p> <p>This function retrieves the header from a PMTiles file, either local or hosted remotely. It deserializes the header and calculates the center and bounds of the tiles from the given metadata in the header.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the header information, including center and bounds.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(header[\"center\"])\n[52.5200, 13.4050]\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function only downloads the first 127 bytes of the file to retrieve the header.</p> Source code in <code>leafmap/common.py</code> <pre><code>def pmtiles_header(input_file: str):\n    \"\"\"\n    Fetch the header information from a local or remote .pmtiles file.\n\n    This function retrieves the header from a PMTiles file, either local or hosted remotely.\n    It deserializes the header and calculates the center and bounds of the tiles from the\n    given metadata in the header.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the header information, including center and bounds.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(header[\"center\"])\n        [52.5200, 13.4050]\n\n    Note:\n        If fetching a remote PMTiles file, this function only downloads the first 127 bytes\n        of the file to retrieve the header.\n    \"\"\"\n\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource\n        from pmtiles.tile import deserialize_header\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    if input_file.startswith(\"http\"):\n        # Fetch only the first 127 bytes\n        headers = {\"Range\": \"bytes=0-127\"}\n        response = requests.get(input_file, headers=headers)\n        header = deserialize_header(response.content)\n\n    else:\n        if not os.path.exists(input_file):\n            raise ValueError(f\"Input file {input_file} does not exist.\")\n\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            header = reader.header()\n\n    header[\"center\"] = [header[\"center_lat_e7\"] / 1e7, header[\"center_lon_e7\"] / 1e7]\n    header[\"bounds\"] = [\n        header[\"min_lon_e7\"] / 1e7,\n        header[\"min_lat_e7\"] / 1e7,\n        header[\"max_lon_e7\"] / 1e7,\n        header[\"max_lat_e7\"] / 1e7,\n    ]\n\n    return header\n</code></pre>"},{"location":"common/#leafmap.common.pmtiles_metadata","title":"<code>pmtiles_metadata(input_file)</code>","text":"<p>Fetch the metadata from a local or remote .pmtiles file.</p> <p>This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely. If it's remote, the function fetches the header to determine the range of bytes to download for obtaining the metadata. It then reads the metadata and extracts the layer names.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the metadata information, including layer names.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(metadata[\"layer_names\"])\n['buildings', 'roads']\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function may perform multiple requests to minimize the amount of data downloaded.</p> Source code in <code>leafmap/common.py</code> <pre><code>def pmtiles_metadata(input_file: str) -&gt; Dict[str, Union[str, int, List[str]]]:\n    \"\"\"\n    Fetch the metadata from a local or remote .pmtiles file.\n\n    This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely.\n    If it's remote, the function fetches the header to determine the range of bytes to download\n    for obtaining the metadata. It then reads the metadata and extracts the layer names.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the metadata information, including layer names.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(metadata[\"layer_names\"])\n        ['buildings', 'roads']\n\n    Note:\n        If fetching a remote PMTiles file, this function may perform multiple requests to minimize\n        the amount of data downloaded.\n    \"\"\"\n\n    import json\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource, MemorySource\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n\n    # ignore uri parameters when checking file suffix\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    header = pmtiles_header(input_file)\n    metadata_offset = header[\"metadata_offset\"]\n    metadata_length = header[\"metadata_length\"]\n\n    if input_file.startswith(\"http\"):\n        headers = {\"Range\": f\"bytes=0-{metadata_offset + metadata_length}\"}\n        response = requests.get(input_file, headers=headers)\n        content = MemorySource(response.content)\n        metadata = Reader(content).metadata()\n    else:\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            metadata = reader.metadata()\n            if \"json\" in metadata:\n                metadata[\"vector_layers\"] = json.loads(metadata[\"json\"])[\n                    \"vector_layers\"\n                ]\n\n    vector_layers = metadata[\"vector_layers\"]\n    layer_names = [layer[\"id\"] for layer in vector_layers]\n\n    if \"tilestats\" in metadata:\n        geometries = [layer[\"geometry\"] for layer in metadata[\"tilestats\"][\"layers\"]]\n        metadata[\"geometries\"] = geometries\n\n    metadata[\"layer_names\"] = layer_names\n    metadata[\"center\"] = header[\"center\"]\n    metadata[\"bounds\"] = header[\"bounds\"]\n    return metadata\n</code></pre>"},{"location":"common/#leafmap.common.pmtiles_style","title":"<code>pmtiles_style(url, layers=None, cmap='Set3', n_class=None, opacity=0.5, circle_radius=5, line_width=1, attribution='PMTiles', **kwargs)</code>","text":"<p>Generates a Mapbox style JSON for rendering PMTiles data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>layers</code> <code>str or list[str]</code> <p>The layers to include in the style. If None, all layers will be included. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The color map to use for styling the layers. Defaults to \"Set3\".</p> <code>'Set3'</code> <code>n_class</code> <code>int</code> <p>The number of classes to use for styling. If None, the number of classes will be determined automatically based on the color map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The fill opacity for polygon layers. Defaults to 0.5.</p> <code>0.5</code> <code>circle_radius</code> <code>int</code> <p>The circle radius for point layers. Defaults to 5.</p> <code>5</code> <code>line_width</code> <code>int</code> <p>The line width for line layers. Defaults to 1.</p> <code>1</code> <code>attribution</code> <code>str</code> <p>The attribution text for the data source. Defaults to \"PMTiles\".</p> <code>'PMTiles'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The Mapbox style JSON.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layers argument is not a string or a list.</p> <code>ValueError</code> <p>If a layer specified in the layers argument does not exist in the PMTiles file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def pmtiles_style(\n    url: str,\n    layers: Optional[Union[str, List[str]]] = None,\n    cmap: str = \"Set3\",\n    n_class: Optional[int] = None,\n    opacity: float = 0.5,\n    circle_radius: int = 5,\n    line_width: int = 1,\n    attribution: str = \"PMTiles\",\n    **kwargs,\n):\n    \"\"\"\n    Generates a Mapbox style JSON for rendering PMTiles data.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        layers (str or list[str], optional): The layers to include in the style. If None, all layers will be included.\n            Defaults to None.\n        cmap (str, optional): The color map to use for styling the layers. Defaults to \"Set3\".\n        n_class (int, optional): The number of classes to use for styling. If None, the number of classes will be\n            determined automatically based on the color map. Defaults to None.\n        opacity (float, optional): The fill opacity for polygon layers. Defaults to 0.5.\n        circle_radius (int, optional): The circle radius for point layers. Defaults to 5.\n        line_width (int, optional): The line width for line layers. Defaults to 1.\n        attribution (str, optional): The attribution text for the data source. Defaults to \"PMTiles\".\n\n    Returns:\n        dict: The Mapbox style JSON.\n\n    Raises:\n        ValueError: If the layers argument is not a string or a list.\n        ValueError: If a layer specified in the layers argument does not exist in the PMTiles file.\n    \"\"\"\n\n    if cmap == \"Set3\":\n        palette = [\n            \"#8dd3c7\",\n            \"#ffffb3\",\n            \"#bebada\",\n            \"#fb8072\",\n            \"#80b1d3\",\n            \"#fdb462\",\n            \"#b3de69\",\n            \"#fccde5\",\n            \"#d9d9d9\",\n            \"#bc80bd\",\n            \"#ccebc5\",\n            \"#ffed6f\",\n        ]\n    elif isinstance(cmap, list):\n        palette = cmap\n    else:\n        from .colormaps import get_palette\n\n        palette = [\"#\" + c for c in get_palette(cmap, n_class)]\n\n    n_class = len(palette)\n\n    metadata = pmtiles_metadata(url)\n    layer_names = metadata[\"layer_names\"]\n\n    style = {\n        \"version\": 8,\n        \"sources\": {\n            \"source\": {\n                \"type\": \"vector\",\n                \"url\": \"pmtiles://\" + url,\n                \"attribution\": attribution,\n            }\n        },\n        \"layers\": [],\n    }\n\n    if layers is None:\n        layers = layer_names\n    elif isinstance(layers, str):\n        layers = [layers]\n    elif isinstance(layers, list):\n        for layer in layers:\n            if layer not in layer_names:\n                raise ValueError(f\"Layer {layer} does not exist in the PMTiles file.\")\n    else:\n        raise ValueError(\"The layers argument must be a string or a list.\")\n\n    for i, layer_name in enumerate(layers):\n        layer_point = {\n            \"id\": f\"{layer_name}_point\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"circle\",\n            \"paint\": {\n                \"circle-color\": palette[i % n_class],\n                \"circle-radius\": circle_radius,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Point\"],\n        }\n\n        layer_stroke = {\n            \"id\": f\"{layer_name}_stroke\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"line\",\n            \"paint\": {\n                \"line-color\": palette[i % n_class],\n                \"line-width\": line_width,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"LineString\"],\n        }\n\n        layer_fill = {\n            \"id\": f\"{layer_name}_fill\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"fill\",\n            \"paint\": {\n                \"fill-color\": palette[i % n_class],\n                \"fill-opacity\": opacity,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Polygon\"],\n        }\n\n        style[\"layers\"].extend([layer_point, layer_stroke, layer_fill])\n\n    return style\n</code></pre>"},{"location":"common/#leafmap.common.png_to_gif","title":"<code>png_to_gif(in_dir, out_gif, fps=10, loop=0)</code>","text":"<p>Convert a list of png images to gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing png images.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the gif.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>bool</code> <p>controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>No png images could be found.</p> Source code in <code>leafmap/common.py</code> <pre><code>def png_to_gif(in_dir, out_gif, fps=10, loop=0):\n    \"\"\"Convert a list of png images to gif.\n\n    Args:\n        in_dir (str): The input directory containing png images.\n        out_gif (str): The output file path to the gif.\n        fps (int, optional): Frames per second. Defaults to 10.\n        loop (bool, optional): controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    Raises:\n        FileNotFoundError: No png images could be found.\n    \"\"\"\n    import glob\n\n    from PIL import Image\n\n    if not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The out_gif must be a gif file.\")\n\n    out_gif = os.path.abspath(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Create the frames\n    frames = []\n    imgs = list(glob.glob(os.path.join(in_dir, \"*.png\")))\n    imgs.sort()\n\n    if len(imgs) == 0:\n        raise FileNotFoundError(f\"No png could be found in {in_dir}.\")\n\n    for i in imgs:\n        new_frame = Image.open(i)\n        frames.append(new_frame)\n\n    # Save into a GIF file that loops forever\n    frames[0].save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames[1:],\n        save_all=True,\n        duration=1000 / fps,\n        loop=loop,\n    )\n</code></pre>"},{"location":"common/#leafmap.common.points_from_xy","title":"<code>points_from_xy(data, x='longitude', y='latitude', z=None, crs=None, **kwargs)</code>","text":"<p>Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>z</code> <code>str</code> <p>The column name for the z values. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str | int</code> <p>The coordinate reference system for the GeoDataFrame. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoPandas GeoDataFrame containing x, y, z values.</p> Source code in <code>leafmap/common.py</code> <pre><code>def points_from_xy(data, x=\"longitude\", y=\"latitude\", z=None, crs=None, **kwargs):\n    \"\"\"Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        z (str, optional): The column name for the z values. Defaults to None.\n        crs (str | int, optional): The coordinate reference system for the GeoDataFrame. Defaults to None.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoPandas GeoDataFrame containing x, y, z values.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import pandas as pd\n\n    if crs is None:\n        crs = \"epsg:4326\"\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        if not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data, **kwargs)\n    else:\n        raise TypeError(\"The data must be a pandas DataFrame or a csv file path.\")\n\n    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y], z=z, crs=crs))\n\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.random_string","title":"<code>random_string(string_length=3)</code>","text":"<p>Generates a random string of fixed length.</p> <p>Parameters:</p> Name Type Description Default <code>string_length</code> <code>int</code> <p>Fixed length. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>A random string</p> Source code in <code>leafmap/common.py</code> <pre><code>def random_string(string_length: Optional[int] = 3) -&gt; str:\n    \"\"\"Generates a random string of fixed length.\n\n    Args:\n        string_length (int, optional): Fixed length. Defaults to 3.\n\n    Returns:\n        str: A random string\n    \"\"\"\n    import random\n    import string\n\n    # random.seed(1001)\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(string_length))\n</code></pre>"},{"location":"common/#leafmap.common.raster_to_vector","title":"<code>raster_to_vector(source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs)</code>","text":"<p>Vectorize a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the vector file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def raster_to_vector(\n    source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs\n):\n    \"\"\"Vectorize a raster dataset.\n\n    Args:\n        source (str): The path to the tiff file.\n        output (str): The path to the vector file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n    import rasterio\n    import shapely\n    import geopandas as gpd\n    from rasterio import features\n\n    with rasterio.open(source, **open_args) as src:\n        band = src.read()\n\n        mask = band != 0\n        shapes = features.shapes(band, mask=mask, transform=src.transform)\n\n    fc = [\n        {\"geometry\": shapely.geometry.shape(shape), \"properties\": {\"value\": value}}\n        for shape, value in shapes\n    ]\n    if simplify_tolerance is not None:\n        for i in fc:\n            i[\"geometry\"] = i[\"geometry\"].simplify(tolerance=simplify_tolerance)\n\n    gdf = gpd.GeoDataFrame.from_features(fc)\n    if src.crs is not None:\n        gdf.set_crs(crs=src.crs, inplace=True)\n\n    if dst_crs is not None:\n        gdf = gdf.to_crs(dst_crs)\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.read_file_from_url","title":"<code>read_file_from_url(url, return_type='list', encoding='utf-8')</code>","text":"<p>Reads a file from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>return_type</code> <code>str</code> <p>The return type, can either be string or list. Defaults to \"list\".</p> <code>'list'</code> <code>encoding</code> <code>str</code> <p>The encoding of the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The return type must be either list or string.</p> <p>Returns:</p> Type Description <code>str | list</code> <p>The contents of the file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_file_from_url(url, return_type=\"list\", encoding=\"utf-8\"):\n    \"\"\"Reads a file from a URL.\n\n    Args:\n        url (str): The URL of the file.\n        return_type (str, optional): The return type, can either be string or list. Defaults to \"list\".\n        encoding (str, optional): The encoding of the file. Defaults to \"utf-8\".\n\n    Raises:\n        ValueError: The return type must be either list or string.\n\n    Returns:\n        str | list: The contents of the file.\n    \"\"\"\n    from urllib.request import urlopen\n\n    if return_type == \"list\":\n        return [line.decode(encoding).rstrip() for line in urlopen(url).readlines()]\n    elif return_type == \"string\":\n        return urlopen(url).read().decode(encoding)\n    else:\n        raise ValueError(\"The return type must be either list or string.\")\n</code></pre>"},{"location":"common/#leafmap.common.read_lidar","title":"<code>read_lidar(filename, **kwargs)</code>","text":"<p>Read a LAS file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>A local file path or HTTP URL to a LAS file.</p> required <p>Returns:</p> Type Description <code>LasData</code> <p>The LasData object return by laspy.read.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_lidar(filename, **kwargs):\n    \"\"\"Read a LAS file.\n\n    Args:\n        filename (str): A local file path or HTTP URL to a LAS file.\n\n    Returns:\n        LasData: The LasData object return by laspy.read.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if (\n        isinstance(filename, str)\n        and filename.startswith(\"http\")\n        and (filename.endswith(\".las\") or filename.endswith(\".laz\"))\n    ):\n        filename = github_raw_url(filename)\n        filename = download_file(filename)\n\n    return laspy.read(filename, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.read_netcdf","title":"<code>read_netcdf(filename, **kwargs)</code>","text":"<p>Read a netcdf file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netcdf file.</p> required <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>The netcdf file as an xarray dataset.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_netcdf(filename, **kwargs):\n    \"\"\"Read a netcdf file.\n\n    Args:\n        filename (str): File path or HTTP URL to the netcdf file.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n\n    Returns:\n        xarray.Dataset: The netcdf file as an xarray dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n    return xds\n</code></pre>"},{"location":"common/#leafmap.common.read_parquet","title":"<code>read_parquet(source, geometry=None, columns=None, exclude=None, db=None, table_name=None, sql=None, limit=None, src_crs=None, dst_crs=None, return_type='gdf', **kwargs)</code>","text":"<p>Read Parquet data from a source and return a GeoDataFrame or DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the Parquet file or directory containing Parquet files.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column. Defaults to None.</p> <code>None</code> <code>columns</code> <code>str or list</code> <p>The columns to select. Defaults to None (select all columns).</p> <code>None</code> <code>exclude</code> <code>str or list</code> <p>The columns to exclude from the selection. Defaults to None.</p> <code>None</code> <code>db</code> <code>str</code> <p>The DuckDB database path or alias. Defaults to None.</p> <code>None</code> <code>table_name</code> <code>str</code> <p>The name of the table in the DuckDB database. Defaults to None.</p> <code>None</code> <code>sql</code> <code>str</code> <p>The SQL query to execute. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of rows to return. Defaults to None (return all rows).</p> <code>None</code> <code>src_crs</code> <code>str</code> <p>The source CRS (Coordinate Reference System) of the geometries. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The target CRS to reproject the geometries. Defaults to None.</p> <code>None</code> <code>return_type</code> <code>str</code> <p>The type of object to return: - 'gdf': GeoDataFrame (default) - 'df': DataFrame - 'numpy': NumPy array - 'arrow': Arrow Table - 'polars': Polars DataFrame</p> <code>'gdf'</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the DuckDB connection.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</code> <p>The loaded data.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the columns or exclude arguments are not of the correct type.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_parquet(\n    source: str,\n    geometry: Optional[str] = None,\n    columns: Optional[Union[str, list]] = None,\n    exclude: Optional[Union[str, list]] = None,\n    db: Optional[str] = None,\n    table_name: Optional[str] = None,\n    sql: Optional[str] = None,\n    limit: Optional[int] = None,\n    src_crs: Optional[str] = None,\n    dst_crs: Optional[str] = None,\n    return_type: str = \"gdf\",\n    **kwargs,\n):\n    \"\"\"\n    Read Parquet data from a source and return a GeoDataFrame or DataFrame.\n\n    Args:\n        source (str): The path to the Parquet file or directory containing Parquet files.\n        geometry (str, optional): The name of the geometry column. Defaults to None.\n        columns (str or list, optional): The columns to select. Defaults to None (select all columns).\n        exclude (str or list, optional): The columns to exclude from the selection. Defaults to None.\n        db (str, optional): The DuckDB database path or alias. Defaults to None.\n        table_name (str, optional): The name of the table in the DuckDB database. Defaults to None.\n        sql (str, optional): The SQL query to execute. Defaults to None.\n        limit (int, optional): The maximum number of rows to return. Defaults to None (return all rows).\n        src_crs (str, optional): The source CRS (Coordinate Reference System) of the geometries. Defaults to None.\n        dst_crs (str, optional): The target CRS to reproject the geometries. Defaults to None.\n        return_type (str, optional): The type of object to return:\n            - 'gdf': GeoDataFrame (default)\n            - 'df': DataFrame\n            - 'numpy': NumPy array\n            - 'arrow': Arrow Table\n            - 'polars': Polars DataFrame\n        **kwargs: Additional keyword arguments that are passed to the DuckDB connection.\n\n    Returns:\n        Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]: The loaded data.\n\n    Raises:\n        ValueError: If the columns or exclude arguments are not of the correct type.\n\n    \"\"\"\n    import duckdb\n\n    if isinstance(db, str):\n        con = duckdb.connect(db)\n    else:\n        con = duckdb.connect()\n\n    con.install_extension(\"httpfs\")\n    con.load_extension(\"httpfs\")\n\n    con.install_extension(\"spatial\")\n    con.load_extension(\"spatial\")\n\n    if columns is None:\n        columns = \"*\"\n    elif isinstance(columns, list):\n        columns = \", \".join(columns)\n    elif not isinstance(columns, str):\n        raise ValueError(\"columns must be a list or a string.\")\n\n    if exclude is not None:\n        if isinstance(exclude, list):\n            exclude = \", \".join(exclude)\n        elif not isinstance(exclude, str):\n            raise ValueError(\"exclude_columns must be a list or a string.\")\n        columns = f\"{columns} EXCLUDE {exclude}\"\n\n    if return_type in [\"df\", \"numpy\", \"arrow\", \"polars\"]:\n        if sql is None:\n            sql = f\"SELECT {columns} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        if return_type == \"df\":\n            result = con.sql(sql, **kwargs).df()\n        elif return_type == \"numpy\":\n            result = con.sql(sql, **kwargs).fetchnumpy()\n        elif return_type == \"arrow\":\n            result = con.sql(sql, **kwargs).arrow()\n        elif return_type == \"polars\":\n            result = con.sql(sql, **kwargs).pl()\n\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM result\", **kwargs)\n\n    elif return_type == \"gdf\":\n        if geometry is None:\n            geometry = \"geometry\"\n        if sql is None:\n            # if src_crs is not None and dst_crs is not None:\n            #     geom_sql = f\"ST_AsText(ST_Transform(ST_GeomFromWKB({geometry}), '{src_crs}', '{dst_crs}', true)) AS {geometry}\"\n            # else:\n            geom_sql = f\"ST_AsText(ST_GeomFromWKB({geometry})) AS {geometry}\"\n            sql = f\"SELECT {columns} EXCLUDE {geometry}, {geom_sql} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        df = con.sql(sql, **kwargs).df()\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM df\", **kwargs)\n        result = df_to_gdf(df, geometry=geometry, src_crs=src_crs, dst_crs=dst_crs)\n\n    con.close()\n    return result\n</code></pre>"},{"location":"common/#leafmap.common.read_postgis","title":"<code>read_postgis(sql, con, geom_col='geom', crs=None, **kwargs)</code>","text":"<p>Reads data from a PostGIS database and returns a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>geom_col</code> <code>str</code> <p>Column name to convert to shapely geometries. Defaults to \"geom\".</p> <code>'geom'</code> <code>crs</code> <code>str | dict</code> <p>CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_postgis(sql, con, geom_col=\"geom\", crs=None, **kwargs):\n    \"\"\"Reads data from a PostGIS database and returns a GeoDataFrame.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        geom_col (str, optional): Column name to convert to shapely geometries. Defaults to \"geom\".\n        crs (str | dict, optional): CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    gdf = gpd.read_postgis(sql, con, geom_col, crs, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#leafmap.common.read_raster","title":"<code>read_raster(source, window=None, return_array=True, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the raster on S3.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>return_array</code> <code>bool</code> <p>Whether to return a numpy array. Defaults to True.</p> <code>True</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_raster(\n    source,\n    window=None,\n    return_array=True,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        source (str): The path to the raster on S3.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        return_array (bool, optional): Whether to return a numpy array. Defaults to True.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import rasterio\n    from rasterio.windows import Window\n\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        src = rasterio.open(source, **open_args)\n        if not return_array:\n            return src\n        else:\n            if window is None:\n                window = Window(0, 0, src.width, src.height)\n            else:\n                if isinstance(window, list):\n                    coords = coords_to_xy(\n                        source,\n                        window,\n                        coord_crs,\n                        env_args=env_args,\n                        open_args=open_args,\n                    )\n                    window = xy_to_window(coords)\n                window = Window(*window)\n\n            array = src.read(window=window, **kwargs)\n            return array\n</code></pre>"},{"location":"common/#leafmap.common.read_rasters","title":"<code>read_rasters(sources, window=None, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str</code> <p>The list of paths to the raster files.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>leafmap/common.py</code> <pre><code>def read_rasters(\n    sources,\n    window=None,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        sources (str): The list of paths to the raster files.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import numpy as np\n\n    if not isinstance(sources, list):\n        sources = [sources]\n\n    array_list = []\n\n    for source in sources:\n        array = read_raster(\n            source,\n            window,\n            True,\n            coord_crs,\n            request_payer,\n            env_args,\n            open_args,\n            **kwargs,\n        )\n        array_list.append(array)\n\n    result = np.concatenate(array_list, axis=0)\n    return result\n</code></pre>"},{"location":"common/#leafmap.common.reduce_gif_size","title":"<code>reduce_gif_size(in_gif, out_gif=None)</code>","text":"<p>Reduces a GIF image using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the GIF image. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def reduce_gif_size(in_gif, out_gif=None):\n    \"\"\"Reduces a GIF image using ffmpeg.\n\n    Args:\n        in_gif (str): The input file path to the GIF image.\n        out_gif (str, optional): The output file path to the GIF image. Defaults to None.\n    \"\"\"\n\n    try:\n        import ffmpeg\n    except ImportError:\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if out_gif is None:\n        out_gif = in_gif\n    elif not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if in_gif == out_gif:\n        tmp_gif = in_gif.replace(\".gif\", \"_tmp.gif\")\n        shutil.copyfile(in_gif, tmp_gif)\n        stream = ffmpeg.input(tmp_gif)\n        stream = ffmpeg.output(stream, in_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n        os.remove(tmp_gif)\n\n    else:\n        stream = ffmpeg.input(in_gif)\n        stream = ffmpeg.output(stream, out_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n</code></pre>"},{"location":"common/#leafmap.common.regularize","title":"<code>regularize(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Regularize a polygon GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The input file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The output GeoDataFrame.</p> Source code in <code>leafmap/common.py</code> <pre><code>def regularize(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Regularize a polygon GeoDataFrame.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The input file path or a GeoDataFrame.\n        output (str, optional): The output file path. Defaults to None.\n\n\n    Returns:\n        gpd.GeoDataFrame: The output GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source)\n    elif isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        raise ValueError(\"The input source must be a GeoDataFrame or a file path.\")\n\n    polygons = gdf.geometry.apply(lambda geom: geom.minimum_rotated_rectangle)\n    result = gpd.GeoDataFrame(geometry=polygons, data=gdf.drop(\"geometry\", axis=1))\n\n    if crs is not None:\n        result.to_crs(crs, inplace=True)\n    if output is not None:\n        result.to_file(output, **kwargs)\n    else:\n        return result\n</code></pre>"},{"location":"common/#leafmap.common.replace_hyphens_in_keys","title":"<code>replace_hyphens_in_keys(d)</code>","text":"<p>Recursively replaces hyphens with underscores in dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict, List, Any]</code> <p>The input dictionary, list or any other data type.</p> required <p>Returns:</p> Type Description <code>Union[Dict, List, Any]</code> <p>The modified dictionary or list with keys having hyphens replaced with underscores, or the original input if it's not a dictionary or list.</p> Source code in <code>leafmap/common.py</code> <pre><code>def replace_hyphens_in_keys(d: Union[Dict, List, Any]) -&gt; Union[Dict, List, Any]:\n    \"\"\"\n    Recursively replaces hyphens with underscores in dictionary keys.\n\n    Args:\n        d (Union[Dict, List, Any]): The input dictionary, list or any other data type.\n\n    Returns:\n        Union[Dict, List, Any]: The modified dictionary or list with keys having hyphens replaced with underscores,\n        or the original input if it's not a dictionary or list.\n    \"\"\"\n    if isinstance(d, dict):\n        return {k.replace(\"-\", \"_\"): replace_hyphens_in_keys(v) for k, v in d.items()}\n    elif isinstance(d, list):\n        return [replace_hyphens_in_keys(i) for i in d]\n    else:\n        return d\n</code></pre>"},{"location":"common/#leafmap.common.replace_top_level_hyphens","title":"<code>replace_top_level_hyphens(d)</code>","text":"<p>Replaces hyphens with underscores in top-level dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict, Any]</code> <p>The input dictionary or any other data type.</p> required <p>Returns:</p> Type Description <code>Union[Dict, Any]</code> <p>The modified dictionary with top-level keys having hyphens replaced with underscores, or the original input if it's not a dictionary.</p> Source code in <code>leafmap/common.py</code> <pre><code>def replace_top_level_hyphens(d: Union[Dict, Any]) -&gt; Union[Dict, Any]:\n    \"\"\"\n    Replaces hyphens with underscores in top-level dictionary keys.\n\n    Args:\n        d (Union[Dict, Any]): The input dictionary or any other data type.\n\n    Returns:\n        Union[Dict, Any]: The modified dictionary with top-level keys having hyphens replaced with underscores,\n        or the original input if it's not a dictionary.\n    \"\"\"\n    if isinstance(d, dict):\n        return {k.replace(\"-\", \"_\"): v for k, v in d.items()}\n    return d\n</code></pre>"},{"location":"common/#leafmap.common.reproject","title":"<code>reproject(image, output, dst_crs='EPSG:4326', resampling='nearest', to_cog=True, **kwargs)</code>","text":"<p>Reprojects an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resampling</code> <code>Resampling</code> <p>The resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def reproject(\n    image, output, dst_crs=\"EPSG:4326\", resampling=\"nearest\", to_cog=True, **kwargs\n):\n    \"\"\"Reprojects an image.\n\n    Args:\n        image (str): The input image filepath.\n        output (str): The output image filepath.\n        dst_crs (str, optional): The destination CRS. Defaults to \"EPSG:4326\".\n        resampling (Resampling, optional): The resampling method. Defaults to \"nearest\".\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to rasterio.open.\n\n    \"\"\"\n    import rasterio as rio\n    from rasterio.warp import calculate_default_transform, reproject, Resampling\n\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n\n    image = os.path.abspath(image)\n    output = os.path.abspath(output)\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    with rio.open(image, **kwargs) as src:\n        transform, width, height = calculate_default_transform(\n            src.crs, dst_crs, src.width, src.height, *src.bounds\n        )\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": dst_crs,\n                \"transform\": transform,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n\n        with rio.open(output, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rio.band(src, i),\n                    destination=rio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                    **kwargs,\n                )\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#leafmap.common.rgb_to_hex","title":"<code>rgb_to_hex(rgb=(255, 255, 255))</code>","text":"<p>Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>tuple</code> <p>RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).</p> <code>(255, 255, 255)</code> <p>Returns:</p> Type Description <code>str</code> <p>hex color code</p> Source code in <code>leafmap/common.py</code> <pre><code>def rgb_to_hex(rgb: Optional[Tuple[int, int, int]] = (255, 255, 255)) -&gt; str:\n    \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.\n\n    Args:\n        rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).\n\n    Returns:\n        str: hex color code\n    \"\"\"\n    return \"%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"common/#leafmap.common.s3_download_file","title":"<code>s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The full path to the file. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>The key of the file. Defaults to None.</p> <code>None</code> <code>outfile</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If boto3 is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs):\n    \"\"\"Download a file from S3.\n\n    Args:\n        filename (str, optional): The full path to the file. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        key (str, optional): The key of the file. Defaults to None.\n        outfile (str, optional): The name of the output file. Defaults to None.\n    Raises:\n        ImportError: If boto3 is not installed.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\", **kwargs)\n\n    if filename is not None:\n        bucket = filename.split(\"/\")[2]\n        key = \"/\".join(filename.split(\"/\")[3:])\n\n    if outfile is None:\n        outfile = key.split(\"/\")[-1]\n\n    if not os.path.exists(outfile):\n        client.download_file(bucket, key, outfile)\n    else:\n        print(f\"File already exists: {outfile}\")\n</code></pre>"},{"location":"common/#leafmap.common.s3_download_files","title":"<code>s3_download_files(filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>list</code> <p>A list of filenames. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If neither filenames or keys are provided.</p> Source code in <code>leafmap/common.py</code> <pre><code>def s3_download_files(\n    filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        filenames (list, optional): A list of filenames. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        keys (list, optional): A list of keys. Defaults to None.\n        outdir (str, optional): The name of the output directory. Defaults to None.\n        quiet (bool, optional): Suppress output. Defaults to False.\n\n    Raises:\n        ValueError: If neither filenames or keys are provided.\n    \"\"\"\n\n    if keys is None:\n        keys = []\n\n    if filenames is not None:\n        if isinstance(filenames, list):\n            for filename in filenames:\n                bucket = filename.split(\"/\")[2]\n                key = \"/\".join(filename.split(\"/\")[3:])\n                keys.append(key)\n    elif filenames is None and keys is None:\n        raise ValueError(\"Either filenames or keys must be provided\")\n\n    for index, key in enumerate(keys):\n        if outdir is not None:\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            outfile = os.path.join(outdir, key.split(\"/\")[-1])\n        else:\n            outfile = key.split(\"/\")[-1]\n\n        if not quiet:\n            print(f\"Downloading {index+1} of {len(keys)}: {outfile}\")\n        s3_download_file(bucket=bucket, key=key, outfile=outfile, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.s3_get_object","title":"<code>s3_get_object(bucket, key, output=None, chunk_size=1048576, request_payer='bucket-owner', quiet=False, client_args={}, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>key</code> <code>key</code> <p>The key of the file.</p> required <code>output</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3.</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>False</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def s3_get_object(\n    bucket,\n    key,\n    output=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=False,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download a file from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        key (key): The key of the file.\n        output (str, optional): The name of the output file. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n        quiet (bool, optional): Suppress output. Defaults to False.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    # Set up the S3 client\n    s3 = boto3.client(\"s3\", **client_args)\n\n    if output is None:\n        output = key.split(\"/\")[-1]\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Set up the progress bar\n    def progress_callback(bytes_amount):\n        # This function will be called by the StreamingBody object\n        # to report the number of bytes downloaded so far\n        total_size = int(response[\"ContentLength\"])\n        progress_percent = int(bytes_amount / total_size * 100)\n        if not quiet:\n            print(f\"\\rDownloading: {progress_percent}% complete.\", end=\"\")\n\n    # Download the file\n    response = s3.get_object(\n        Bucket=bucket, Key=key, RequestPayer=request_payer, **kwargs\n    )\n\n    # Save the file to disk\n    with open(output, \"wb\") as f:\n        # Use the StreamingBody object to read the file in chunks\n        # and track the download progress\n        body = response[\"Body\"]\n        downloaded_bytes = 0\n        for chunk in body.iter_chunks(chunk_size=chunk_size):\n            f.write(chunk)\n            downloaded_bytes += len(chunk)\n            progress_callback(downloaded_bytes)\n</code></pre>"},{"location":"common/#leafmap.common.s3_get_objects","title":"<code>s3_get_objects(bucket, keys=None, out_dir=None, prefix=None, limit=None, ext=None, chunk_size=1048576, request_payer='bucket-owner', quiet=True, client_args={}, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to True.</p> <code>True</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def s3_get_objects(\n    bucket,\n    keys=None,\n    out_dir=None,\n    prefix=None,\n    limit=None,\n    ext=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=True,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        keys (list, optional): A list of keys. Defaults to None.\n        out_dir (str, optional): The name of the output directory. Defaults to None.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (int, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        quiet (bool, optional): Suppress output. Defaults to True.\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if keys is None:\n        fullpath = False\n        keys = s3_list_objects(\n            bucket, prefix, limit, ext, fullpath, request_payer, client_args, **kwargs\n        )\n\n    for index, key in enumerate(keys):\n        print(f\"Downloading {index+1} of {len(keys)}: {key}\")\n        output = os.path.join(out_dir, key.split(\"/\")[-1])\n        s3_get_object(\n            bucket, key, output, chunk_size, request_payer, quiet, client_args, **kwargs\n        )\n</code></pre>"},{"location":"common/#leafmap.common.s3_list_objects","title":"<code>s3_list_objects(bucket, prefix=None, limit=None, ext=None, fullpath=True, request_payer='bucket-owner', client_args={}, **kwargs)</code>","text":"<p>List objects in a S3 bucket</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>init</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Return full path. Defaults to True.</p> <code>True</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>List of objects.</p> Source code in <code>leafmap/common.py</code> <pre><code>def s3_list_objects(\n    bucket,\n    prefix=None,\n    limit=None,\n    ext=None,\n    fullpath=True,\n    request_payer=\"bucket-owner\",\n    client_args={},\n    **kwargs,\n):\n    \"\"\"List objects in a S3 bucket\n\n    Args:\n        bucket (str): The name of the bucket.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (init, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        fullpath (bool, optional): Return full path. Defaults to True.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n\n    Returns:\n        list: List of objects.\n    \"\"\"\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\", **client_args)\n\n    if prefix is not None:\n        kwargs[\"Prefix\"] = prefix\n\n    files = []\n    kwargs[\"RequestPayer\"] = request_payer\n    if isinstance(limit, int) and limit &lt; 1000:\n        kwargs[\"MaxKeys\"] = limit\n        response = client.list_objects_v2(Bucket=bucket, **kwargs)\n        for obj in response[\"Contents\"]:\n            files.append(obj)\n    else:\n        paginator = client.get_paginator(\"list_objects_v2\")\n        pages = paginator.paginate(Bucket=bucket, **kwargs)\n\n        for page in pages:\n            files.extend(page.get(\"Contents\", []))\n\n    if ext is not None:\n        files = [f for f in files if f[\"Key\"].endswith(ext)]\n\n    if fullpath:\n        return [f\"s3://{bucket}/{r['Key']}\" for r in files]\n    else:\n        return [r[\"Key\"] for r in files]\n</code></pre>"},{"location":"common/#leafmap.common.save_colorbar","title":"<code>save_colorbar(out_fig=None, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=10, label_weight='normal', tick_size=8, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, show_colorbar=True, **kwargs)</code>","text":"<p>Create a standalone colorbar and save it as an image.</p> <p>Parameters:</p> Name Type Description Default <code>out_fig</code> <code>str</code> <p>Path to the output image.</p> <code>None</code> <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>10</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>8</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>show_colorbar</code> <code>bool</code> <p>Whether to show the colorbar. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>leafmap/common.py</code> <pre><code>def save_colorbar(\n    out_fig=None,\n    width=4.0,\n    height=0.3,\n    vmin=0,\n    vmax=1.0,\n    palette=None,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    label_size=10,\n    label_weight=\"normal\",\n    tick_size=8,\n    bg_color=\"white\",\n    orientation=\"horizontal\",\n    dpi=\"figure\",\n    transparent=False,\n    show_colorbar=True,\n    **kwargs,\n):\n    \"\"\"Create a standalone colorbar and save it as an image.\n\n    Args:\n        out_fig (str): Path to the output image.\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        show_colorbar (bool, optional): Whether to show the colorbar. Defaults to True.\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from .colormaps import palettes, get_palette\n\n    if out_fig is None:\n        out_fig = temp_file_path(\"png\")\n    else:\n        out_fig = check_file_path(out_fig)\n\n    if vis_params is None:\n        vis_params = {}\n    elif not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if palette is not None:\n        if palette in [\"ndvi\", \"ndwi\", \"dem\"]:\n            palette = palettes[palette]\n        elif palette in list(palettes.keys()):\n            palette = get_palette(palette)\n        vis_params[\"palette\"] = palette\n\n    orientation = orientation.lower()\n    if orientation not in [\"horizontal\", \"vertical\"]:\n        raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n    if \"opacity\" in vis_params:\n        alpha = vis_params[\"opacity\"]\n        if type(alpha) not in (int, float):\n            raise ValueError(\"The provided opacity value must be type scalar.\")\n    else:\n        alpha = 1\n\n    if \"palette\" in vis_params:\n        hexcodes = to_hex_colors(vis_params[\"palette\"])\n        if discrete:\n            cmap = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, cmap.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n        else:\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    elif cmap is not None:\n        cmap = mpl.colormaps[cmap]\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = plt.subplots(figsize=(width, height))\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n    )\n    if label is not None:\n        cb.set_label(label=label, size=label_size, weight=label_weight)\n    cb.ax.tick_params(labelsize=tick_size)\n\n    if transparent:\n        bg_color = None\n\n    if bg_color is not None:\n        kwargs[\"facecolor\"] = bg_color\n    if \"bbox_inches\" not in kwargs:\n        kwargs[\"bbox_inches\"] = \"tight\"\n\n    fig.savefig(out_fig, dpi=dpi, transparent=transparent, **kwargs)\n    if not show_colorbar:\n        plt.close(fig)\n    return out_fig\n</code></pre>"},{"location":"common/#leafmap.common.save_data","title":"<code>save_data(data, file_ext=None, file_name=None)</code>","text":"<p>Save data in the memory to a file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>object</code> <p>The data to be saved.</p> required <code>file_ext</code> <code>str</code> <p>The file extension of the file.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>The name of the file to be saved. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path of the file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def save_data(data, file_ext=None, file_name=None):\n    \"\"\"Save data in the memory to a file.\n\n    Args:\n        data (object): The data to be saved.\n        file_ext (str): The file extension of the file.\n        file_name (str, optional): The name of the file to be saved. Defaults to None.\n\n    Returns:\n        str: The path of the file.\n    \"\"\"\n    import tempfile\n    import uuid\n\n    try:\n        if file_ext is None:\n            if hasattr(data, \"name\"):\n                _, file_ext = os.path.splitext(data.name)\n        else:\n            if not file_ext.startswith(\".\"):\n                file_ext = \".\" + file_ext\n\n        if file_name is not None:\n            file_path = os.path.abspath(file_name)\n            if not file_path.endswith(file_ext):\n                file_path = file_path + file_ext\n        else:\n            file_id = str(uuid.uuid4())\n            file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{file_ext}\")\n\n        with open(file_path, \"wb\") as file:\n            file.write(data.getbuffer())\n        return file_path\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#leafmap.common.screen_capture","title":"<code>screen_capture(outfile, monitor=1)</code>","text":"<p>Takes a full screenshot of the selected monitor.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the screenshot.</p> required <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>leafmap/common.py</code> <pre><code>def screen_capture(outfile, monitor=1):\n    \"\"\"Takes a full screenshot of the selected monitor.\n\n    Args:\n        outfile (str): The output file path to the screenshot.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    try:\n        from mss import mss\n    except ImportError:\n        raise ImportError(\"Please install mss using 'pip install mss'\")\n\n    out_dir = os.path.dirname(outfile)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not isinstance(monitor, int):\n        print(\"The monitor number must be an integer.\")\n        return\n\n    try:\n        with mss() as sct:\n            sct.shot(output=outfile, mon=monitor)\n            return outfile\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.search_qms","title":"<code>search_qms(keyword, limit=10, list_only=True, add_prefix=True)</code>","text":"<p>Search for QMS tile providers from Quick Map Services.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"qms.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of QMS tile providers.</p> Source code in <code>leafmap/common.py</code> <pre><code>def search_qms(keyword, limit=10, list_only=True, add_prefix=True):\n    \"\"\"Search for QMS tile providers from Quick Map Services.\n\n    Args:\n        keyword (str): The keyword to search for.\n        limit (int, optional): The maximum number of results to return. Defaults to 10.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"qms.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of QMS tile providers.\n    \"\"\"\n\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n    services = requests.get(\n        f\"{QMS_API}/?search={keyword}&amp;type=tms&amp;epsg=3857&amp;limit={limit}\"\n    )\n    services = services.json()\n    if services[\"results\"]:\n        providers = services[\"results\"]\n        if list_only:\n            if add_prefix:\n                return [\"qms.\" + provider[\"name\"] for provider in providers]\n            else:\n                return [provider[\"name\"] for provider in providers]\n        else:\n            return providers\n    else:\n        return None\n</code></pre>"},{"location":"common/#leafmap.common.search_xyz_services","title":"<code>search_xyz_services(keyword, name=None, list_only=True, add_prefix=True)</code>","text":"<p>Search for XYZ tile providers from xyzservices.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>name</code> <code>str</code> <p>The name of the xyz tile. Defaults to None.</p> <code>None</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of XYZ tile providers.</p> Source code in <code>leafmap/common.py</code> <pre><code>def search_xyz_services(keyword, name=None, list_only=True, add_prefix=True):\n    \"\"\"Search for XYZ tile providers from xyzservices.\n\n    Args:\n        keyword (str): The keyword to search for.\n        name (str, optional): The name of the xyz tile. Defaults to None.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of XYZ tile providers.\n    \"\"\"\n\n    import xyzservices.providers as xyz\n\n    if name is None:\n        providers = xyz.filter(keyword=keyword).flatten()\n    else:\n        providers = xyz.filter(name=name).flatten()\n\n    if list_only:\n        if add_prefix:\n            return [\"xyz.\" + provider for provider in providers]\n        else:\n            return [provider for provider in providers]\n    else:\n        return providers\n</code></pre>"},{"location":"common/#leafmap.common.select_largest","title":"<code>select_largest(source, column, count=1, output=None, **kwargs)</code>","text":"<p>Select the largest features in a GeoDataFrame based on a column.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>column</code> <code>str</code> <p>The column to sort by.</p> required <code>count</code> <code>int</code> <p>The number of features to select. Defaults to 1.</p> <code>1</code> <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the output vector file.</p> Source code in <code>leafmap/common.py</code> <pre><code>def select_largest(source, column, count=1, output=None, **kwargs):\n    \"\"\"Select the largest features in a GeoDataFrame based on a column.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        column (str): The column to sort by.\n        count (int, optional): The number of features to select. Defaults to 1.\n        output (str, optional): The path to the output vector file. Defaults to None.\n\n    Returns:\n        str: The path to the output vector file.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source, **kwargs)\n    else:\n        gdf = source\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = gdf.sort_values(column, ascending=False).head(count)\n\n    if output is not None:\n        gdf.to_file(output)\n\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#leafmap.common.set_api_key","title":"<code>set_api_key(key, name='GOOGLE_MAPS_API_KEY')</code>","text":"<p>Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The Google Maps API key.</p> required <code>name</code> <code>str</code> <p>The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".</p> <code>'GOOGLE_MAPS_API_KEY'</code> Source code in <code>leafmap/common.py</code> <pre><code>def set_api_key(key: str, name: str = \"GOOGLE_MAPS_API_KEY\"):\n    \"\"\"Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.\n\n    Args:\n        key (str): The Google Maps API key.\n        name (str, optional): The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".\n    \"\"\"\n    os.environ[name] = key\n</code></pre>"},{"location":"common/#leafmap.common.set_proxy","title":"<code>set_proxy(port=1080, ip='http://127.0.0.1')</code>","text":"<p>Sets proxy if needed. This is only needed for countries where Google services are not available.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The proxy port number. Defaults to 1080.</p> <code>1080</code> <code>ip</code> <code>str</code> <p>The IP address. Defaults to 'http://127.0.0.1'.</p> <code>'http://127.0.0.1'</code> Source code in <code>leafmap/common.py</code> <pre><code>def set_proxy(port: Optional[int] = 1080, ip: Optional[str] = \"http://127.0.0.1\"):\n    \"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available.\n\n    Args:\n        port (int, optional): The proxy port number. Defaults to 1080.\n        ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'.\n    \"\"\"\n\n    try:\n        if not ip.startswith(\"http\"):\n            ip = \"http://\" + ip\n        proxy = \"{}:{}\".format(ip, port)\n\n        os.environ[\"HTTP_PROXY\"] = proxy\n        os.environ[\"HTTPS_PROXY\"] = proxy\n\n        a = requests.get(\"https://google.com\")\n\n        if a.status_code != 200:\n            print(\n                \"Failed to connect to Google services. Please double check the port number and ip address.\"\n            )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.show_html","title":"<code>show_html(html)</code>","text":"<p>Shows HTML within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>File path or HTML string.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>ipywidgets.HTML</code> <p>HTML widget.</p> Source code in <code>leafmap/common.py</code> <pre><code>def show_html(html: str):\n    \"\"\"Shows HTML within Jupyter notebook.\n\n    Args:\n        html (str): File path or HTML string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n\n    Returns:\n        ipywidgets.HTML: HTML widget.\n    \"\"\"\n    if os.path.exists(html):\n        with open(html, \"r\") as f:\n            content = f.read()\n\n        widget = widgets.HTML(value=content)\n        return widget\n    else:\n        try:\n            widget = widgets.HTML(value=html)\n            return widget\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.show_image","title":"<code>show_image(img_path, width=None, height=None)</code>","text":"<p>Shows an image within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The image file path.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the image in pixels. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def show_image(\n    img_path: str, width: Optional[int] = None, height: Optional[int] = None\n):\n    \"\"\"Shows an image within Jupyter notebook.\n\n    Args:\n        img_path (str): The image file path.\n        width (int, optional): Width of the image in pixels. Defaults to None.\n        height (int, optional): Height of the image in pixels. Defaults to None.\n\n    \"\"\"\n    from IPython.display import display\n\n    try:\n        out = widgets.Output()\n        # layout={'border': '1px solid black'})\n        # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},)\n        out.outputs = ()\n        display(out)\n        with out:\n            file = open(img_path, \"rb\")\n            image = file.read()\n            if (width is None) and (height is None):\n                display(widgets.Image(value=image))\n            elif (width is not None) and (height is not None):\n                display(widgets.Image(value=image, width=width, height=height))\n            else:\n                print(\"You need set both width and height.\")\n                return\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#leafmap.common.show_youtube_video","title":"<code>show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs)</code>","text":"<p>Displays a Youtube video in a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>a link to a Youtube video.</p> required <code>width</code> <code>int</code> <p>the width of the video. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>the height of the video. Defaults to 600.</p> <code>450</code> <code>allow_autoplay</code> <code>bool</code> <p>whether to allow autoplay. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>further arguments for IPython.display.YouTubeVideo</p> <code>{}</code> <p>Returns:</p> Type Description <code>YouTubeVideo</code> <p>a video that is displayed in your notebook.</p> Source code in <code>leafmap/common.py</code> <pre><code>def show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs):\n    \"\"\"\n    Displays a Youtube video in a Jupyter notebook.\n\n    Args:\n        url (string): a link to a Youtube video.\n        width (int, optional): the width of the video. Defaults to 800.\n        height (int, optional): the height of the video. Defaults to 600.\n        allow_autoplay (bool, optional): whether to allow autoplay. Defaults to False.\n        **kwargs: further arguments for IPython.display.YouTubeVideo\n\n    Returns:\n        YouTubeVideo: a video that is displayed in your notebook.\n    \"\"\"\n    import re\n    from IPython.display import YouTubeVideo\n\n    if not isinstance(url, str):\n        raise TypeError(\"URL must be a string\")\n\n    match = re.match(\n        r\"^https?:\\/\\/(?:www\\.)?youtube\\.com\\/watch\\?(?=.*v=([^\\s&amp;]+)).*$|^https?:\\/\\/(?:www\\.)?youtu\\.be\\/([^\\s&amp;]+).*$\",\n        url,\n    )\n    if not match:\n        raise ValueError(\"Invalid YouTube video URL\")\n\n    video_id = match.group(1) if match.group(1) else match.group(2)\n\n    return YouTubeVideo(\n        video_id, width=width, height=height, allow_autoplay=allow_autoplay, **kwargs\n    )\n</code></pre>"},{"location":"common/#leafmap.common.shp_to_gdf","title":"<code>shp_to_gdf(in_shp)</code>","text":"<p>Converts a shapefile to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to the input shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shp could not be found.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>leafmap/common.py</code> <pre><code>def shp_to_gdf(in_shp):\n    \"\"\"Converts a shapefile to Geopandas dataframe.\n\n    Args:\n        in_shp (str): File path to the input shapefile.\n\n    Raises:\n        FileNotFoundError: The provided shp could not be found.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shp could not be found.\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    try:\n        return gpd.read_file(in_shp)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.shp_to_geojson","title":"<code>shp_to_geojson(in_shp, output=None, encoding='utf-8', crs='EPSG:4326', **kwargs)</code>","text":"<p>Converts a shapefile to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path of the input shapefile.</p> required <code>output</code> <code>str</code> <p>File path of the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>The json object representing the shapefile.</p> Source code in <code>leafmap/common.py</code> <pre><code>def shp_to_geojson(in_shp, output=None, encoding=\"utf-8\", crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Converts a shapefile to GeoJSON.\n\n    Args:\n        in_shp (str): File path of the input shapefile.\n        output (str, optional): File path of the output GeoJSON. Defaults to None.\n\n    Returns:\n        object: The json object representing the shapefile.\n    \"\"\"\n    try:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(in_shp, **kwargs)\n        gdf.to_crs(crs, inplace=True)\n        if output is None:\n            return gdf.__geo_interface__\n        else:\n            gdf.to_file(output, driver=\"GeoJSON\")\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.skip_mkdocs_build","title":"<code>skip_mkdocs_build()</code>","text":"<p>Skips the MkDocs build if the USE_MKDOCS environment variable is set.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether to skip the MkDocs build.</p> Source code in <code>leafmap/common.py</code> <pre><code>def skip_mkdocs_build():\n    \"\"\"Skips the MkDocs build if the USE_MKDOCS environment variable is set.\n\n    Returns:\n        bool: Whether to skip the MkDocs build.\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#leafmap.common.split_raster","title":"<code>split_raster(filename, out_dir, tile_size=256, overlap=0, prefix='tile')</code>","text":"<p>Split a raster into tiles.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path or http URL to the raster file.</p> required <code>out_dir</code> <code>str</code> <p>The path to the output directory.</p> required <code>tile_size</code> <code>int | tuple</code> <p>The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.</p> <code>256</code> <code>overlap</code> <code>int</code> <p>The number of pixels to overlap between tiles. Defaults to 0.</p> <code>0</code> <code>prefix</code> <code>str</code> <p>The prefix of the output tiles. Defaults to \"tile\".</p> <code>'tile'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if GDAL is not installed.</p> Source code in <code>leafmap/common.py</code> <pre><code>def split_raster(filename, out_dir, tile_size=256, overlap=0, prefix=\"tile\"):\n    \"\"\"Split a raster into tiles.\n\n    Args:\n        filename (str): The path or http URL to the raster file.\n        out_dir (str): The path to the output directory.\n        tile_size (int | tuple, optional): The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.\n        overlap (int, optional): The number of pixels to overlap between tiles. Defaults to 0.\n        prefix (str, optional): The prefix of the output tiles. Defaults to \"tile\".\n\n    Raises:\n        ImportError: Raised if GDAL is not installed.\n    \"\"\"\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        )\n\n    if isinstance(filename, str):\n        if filename.startswith(\"http\"):\n            output = filename.split(\"/\")[-1]\n            download_file(filename, output)\n            filename = output\n\n    # Open the input GeoTIFF file\n    ds = gdal.Open(filename)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(tile_size, int):\n        tile_width = tile_size\n        tile_height = tile_size\n    elif isinstance(tile_size, tuple):\n        tile_width = tile_size[0]\n        tile_height = tile_size[1]\n\n    # Get the size of the input raster\n    width = ds.RasterXSize\n    height = ds.RasterYSize\n\n    # Calculate the number of tiles needed in both directions, taking into account the overlap\n    num_tiles_x = (width - overlap) // (tile_width - overlap) + int(\n        (width - overlap) % (tile_width - overlap) &gt; 0\n    )\n    num_tiles_y = (height - overlap) // (tile_height - overlap) + int(\n        (height - overlap) % (tile_height - overlap) &gt; 0\n    )\n\n    # Get the georeferencing information of the input raster\n    geotransform = ds.GetGeoTransform()\n\n    # Loop over all the tiles\n    for i in range(num_tiles_x):\n        for j in range(num_tiles_y):\n            # Calculate the pixel coordinates of the tile, taking into account the overlap and clamping to the edge of the raster\n            x_min = i * (tile_width - overlap)\n            y_min = j * (tile_height - overlap)\n            x_max = min(x_min + tile_width, width)\n            y_max = min(y_min + tile_height, height)\n\n            # Adjust the size of the last tile in each row and column to include any remaining pixels\n            if i == num_tiles_x - 1:\n                x_min = max(x_max - tile_width, 0)\n            if j == num_tiles_y - 1:\n                y_min = max(y_max - tile_height, 0)\n\n            # Calculate the size of the tile, taking into account the overlap\n            tile_width = x_max - x_min\n            tile_height = y_max - y_min\n\n            # Set the output file name\n            output_file = f\"{out_dir}/{prefix}_{i}_{j}.tif\"\n\n            # Create a new dataset for the tile\n            driver = gdal.GetDriverByName(\"GTiff\")\n            tile_ds = driver.Create(\n                output_file,\n                tile_width,\n                tile_height,\n                ds.RasterCount,\n                ds.GetRasterBand(1).DataType,\n            )\n\n            # Calculate the georeferencing information for the output tile\n            tile_geotransform = (\n                geotransform[0] + x_min * geotransform[1],\n                geotransform[1],\n                0,\n                geotransform[3] + y_min * geotransform[5],\n                0,\n                geotransform[5],\n            )\n\n            # Set the geotransform and projection of the tile\n            tile_ds.SetGeoTransform(tile_geotransform)\n            tile_ds.SetProjection(ds.GetProjection())\n\n            # Read the data from the input raster band(s) and write it to the tile band(s)\n            for k in range(ds.RasterCount):\n                band = ds.GetRasterBand(k + 1)\n                tile_band = tile_ds.GetRasterBand(k + 1)\n                tile_data = band.ReadAsArray(x_min, y_min, tile_width, tile_height)\n                tile_band.WriteArray(tile_data)\n\n            # Close the tile dataset\n            tile_ds = None\n\n    # Close the input dataset\n    ds = None\n</code></pre>"},{"location":"common/#leafmap.common.st_download_button","title":"<code>st_download_button(label, data, file_name=None, mime=None, key=None, help=None, on_click=None, args=None, csv_sep=',', **kwargs)</code>","text":"<p>Streamlit function to create a download button.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A short label explaining to the user what this button is for..</p> required <code>data</code> <code>str | list</code> <p>The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.</p> required <code>file_name</code> <code>str</code> <p>An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.</p> <code>None</code> <code>mime</code> <code>str</code> <p>The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.</p> <code>None</code> <code>help</code> <code>str</code> <p>An optional tooltip that gets displayed when the button is hovered over. Defaults to None.</p> <code>None</code> <code>on_click</code> <code>str</code> <p>An optional callback invoked when this button is clicked. Defaults to None.</p> <code>None</code> <code>args</code> <code>list</code> <p>An optional tuple of args to pass to the callback. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>An optional tuple of args to pass to the callback.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def st_download_button(\n    label,\n    data,\n    file_name=None,\n    mime=None,\n    key=None,\n    help=None,\n    on_click=None,\n    args=None,\n    csv_sep=\",\",\n    **kwargs,\n):\n    \"\"\"Streamlit function to create a download button.\n\n    Args:\n        label (str): A short label explaining to the user what this button is for..\n        data (str | list): The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.\n        file_name (str, optional): An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.\n        mime (str, optional): The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.\n        key (str, optional): An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.\n        help (str, optional): An optional tooltip that gets displayed when the button is hovered over. Defaults to None.\n        on_click (str, optional): An optional callback invoked when this button is clicked. Defaults to None.\n        args (list, optional): An optional tuple of args to pass to the callback. Defaults to None.\n        kwargs (dict, optional): An optional tuple of args to pass to the callback.\n\n    \"\"\"\n    try:\n        import streamlit as st\n        import pandas as pd\n\n        if isinstance(data, str):\n            if file_name is None:\n                file_name = data.split(\"/\")[-1]\n\n            if data.endswith(\".csv\"):\n                data = pd.read_csv(data).to_csv(sep=csv_sep, index=False)\n                if mime is None:\n                    mime = \"text/csv\"\n                return st.download_button(\n                    label, data, file_name, mime, key, help, on_click, args, **kwargs\n                )\n            elif (\n                data.endswith(\".gif\") or data.endswith(\".png\") or data.endswith(\".jpg\")\n            ):\n                if mime is None:\n                    mime = f\"image/{os.path.splitext(data)[1][1:]}\"\n\n                with open(data, \"rb\") as file:\n                    return st.download_button(\n                        label,\n                        file,\n                        file_name,\n                        mime,\n                        key,\n                        help,\n                        on_click,\n                        args,\n                        **kwargs,\n                    )\n        elif isinstance(data, pd.DataFrame):\n            if file_name is None:\n                file_name = \"data.csv\"\n\n            data = data.to_csv(sep=csv_sep, index=False)\n            if mime is None:\n                mime = \"text/csv\"\n            return st.download_button(\n                label, data, file_name, mime, key, help, on_click, args, **kwargs\n            )\n\n        else:\n            # if mime is None:\n            #     mime = \"application/pdf\"\n            return st.download_button(\n                label,\n                data,\n                file_name,\n                mime,\n                key,\n                help,\n                on_click,\n                args,\n                **kwargs,\n            )\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.start_server","title":"<code>start_server(directory=None, port=8000, background=True, quiet=True)</code>","text":"<p>Start a simple web server to serve files from the specified directory with directory listing and CORS support. Optionally, run the server asynchronously in a background thread.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory from which files will be served.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port on which the web server will run. Defaults to 8000.</p> <code>8000</code> <code>background</code> <code>bool</code> <p>Whether to run the server in a separate background thread.                          Defaults to True.</p> <code>True</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If required modules are not found.</p> <code>Exception</code> <p>Catches other unexpected errors during execution.</p> <p>Returns:</p> Type Description <p>None. The function runs the server indefinitely until manually stopped.</p> Source code in <code>leafmap/common.py</code> <pre><code>def start_server(\n    directory: str = None, port: int = 8000, background: bool = True, quiet: bool = True\n):\n    \"\"\"\n    Start a simple web server to serve files from the specified directory\n    with directory listing and CORS support. Optionally, run the server\n    asynchronously in a background thread.\n\n    Args:\n        directory (str): The directory from which files will be served.\n        port (int, optional): The port on which the web server will run. Defaults to 8000.\n        background (bool, optional): Whether to run the server in a separate background thread.\n                                     Defaults to True.\n        quiet (bool, optional): If True, suppress the log output. Defaults to True.\n\n    Raises:\n        ImportError: If required modules are not found.\n        Exception: Catches other unexpected errors during execution.\n\n    Returns:\n        None. The function runs the server indefinitely until manually stopped.\n    \"\"\"\n\n    # If no directory is specified, use the current working directory\n    if directory is None:\n        directory = os.getcwd()\n\n    def run_flask():\n        try:\n            from flask import Flask, send_from_directory, render_template_string\n            from flask_cors import CORS\n\n            app = Flask(__name__, static_folder=directory)\n            CORS(app)  # Enable CORS for all routes\n\n            if quiet:\n                # This will disable Flask's logging\n                import logging\n\n                log = logging.getLogger(\"werkzeug\")\n                log.disabled = True\n                app.logger.disabled = True\n\n            @app.route(\"/&lt;path:path&gt;\", methods=[\"GET\"])\n            def serve_file(path):\n                return send_from_directory(directory, path)\n\n            @app.route(\"/\", methods=[\"GET\"])\n            def index():\n                # List files and directories under the specified directory\n                items = os.listdir(directory)\n                items.sort()\n                # Generate an HTML representation of the directory listing\n                listing_template = \"\"\"\n                &lt;h2&gt;Directory listing for /&lt;/h2&gt;\n                &lt;hr&gt;\n                &lt;ul&gt;\n                    {% for item in items %}\n                        &lt;li&gt;&lt;a href=\"{{ item }}\"&gt;{{ item }}&lt;/a&gt;&lt;/li&gt;\n                    {% endfor %}\n                &lt;/ul&gt;\n                \"\"\"\n                return render_template_string(listing_template, items=items)\n\n            print(f\"Server is running at http://127.0.0.1:{port}/\")\n            app.run(port=port)\n\n        except ImportError as e:\n            print(f\"Error importing module: {e}\")\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n    if background:\n        import threading\n\n        # Start the Flask server in a new background thread\n        t = threading.Thread(target=run_flask)\n        t.start()\n    else:\n        # Run the Flask server in the main thread\n        run_flask()\n</code></pre>"},{"location":"common/#leafmap.common.streamlit_legend","title":"<code>streamlit_legend(html, width=None, height=None, scrolling=True)</code>","text":"<p>Streamlit function to display a legend.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML string of the legend.</p> required <code>width</code> <code>str</code> <p>The width of the legend. Defaults to None.</p> <code>None</code> <code>height</code> <code>str</code> <p>The height of the legend. Defaults to None.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow scrolling in the legend. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/common.py</code> <pre><code>def streamlit_legend(html, width=None, height=None, scrolling=True):\n    \"\"\"Streamlit function to display a legend.\n\n    Args:\n        html (str): The HTML string of the legend.\n        width (str, optional): The width of the legend. Defaults to None.\n        height (str, optional): The height of the legend. Defaults to None.\n        scrolling (bool, optional): Whether to allow scrolling in the legend. Defaults to True.\n\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        components.html(html, width=width, height=height, scrolling=scrolling)\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n</code></pre>"},{"location":"common/#leafmap.common.system_fonts","title":"<code>system_fonts(show_full_path=False)</code>","text":"<p>Gets a list of system fonts</p> <pre><code># Common font locations:\n# Linux: /usr/share/fonts/TTF/\n# Windows: C:/Windows/Fonts\n# macOS:  System &gt; Library &gt; Fonts\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>show_full_path</code> <code>bool</code> <p>Whether to show the full path of each system font. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of system fonts.</p> Source code in <code>leafmap/common.py</code> <pre><code>def system_fonts(show_full_path: Optional[bool] = False) -&gt; List:\n    \"\"\"Gets a list of system fonts\n\n        # Common font locations:\n        # Linux: /usr/share/fonts/TTF/\n        # Windows: C:/Windows/Fonts\n        # macOS:  System &gt; Library &gt; Fonts\n\n    Args:\n        show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False.\n\n    Returns:\n        list: A list of system fonts.\n    \"\"\"\n    try:\n        import matplotlib.font_manager\n\n        font_list = matplotlib.font_manager.findSystemFonts(\n            fontpaths=None, fontext=\"ttf\"\n        )\n        font_list.sort()\n\n        font_names = [os.path.basename(f) for f in font_list]\n        font_names.sort()\n\n        if show_full_path:\n            return font_list\n        else:\n            return font_names\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.temp_file_path","title":"<code>temp_file_path(extension)</code>","text":"<p>Returns a temporary file path.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The temporary file path.</p> Source code in <code>leafmap/common.py</code> <pre><code>def temp_file_path(extension):\n    \"\"\"Returns a temporary file path.\n\n    Args:\n        extension (str): The file extension.\n\n    Returns:\n        str: The temporary file path.\n    \"\"\"\n\n    import tempfile\n    import uuid\n\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    file_id = str(uuid.uuid4())\n    file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{extension}\")\n\n    return file_path\n</code></pre>"},{"location":"common/#leafmap.common.tif_to_jp2","title":"<code>tif_to_jp2(filename, output, creationOptions=None)</code>","text":"<p>Converts a GeoTIFF to JPEG2000.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>output</code> <code>str</code> <p>The path to the output JPEG2000 file.</p> required <code>creationOptions</code> <code>list</code> <p>A list of creation options for the JPEG2000 file. See https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression ratio, use <code>[\"QUALITY=20\"]</code>. A value of 20 means the file will be 20% of the size in comparison to uncompressed data.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def tif_to_jp2(filename, output, creationOptions=None):\n    \"\"\"Converts a GeoTIFF to JPEG2000.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        output (str): The path to the output JPEG2000 file.\n        creationOptions (list): A list of creation options for the JPEG2000 file. See\n            https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression\n            ratio, use ``[\"QUALITY=20\"]``. A value of 20 means the file will be 20% of the size in comparison\n            to uncompressed data.\n\n    \"\"\"\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    if not output.endswith(\".jp2\"):\n        output += \".jp2\"\n\n    from osgeo import gdal\n\n    in_ds = gdal.Open(filename)\n    gdal.Translate(output, in_ds, format=\"JP2OpenJPEG\", creationOptions=creationOptions)\n    in_ds = None\n</code></pre>"},{"location":"common/#leafmap.common.tms_to_geotiff","title":"<code>tms_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.to_hex_colors","title":"<code>to_hex_colors(colors)</code>","text":"<p>Adds # to a list of hex color codes.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex color codes.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of hex color codes prefixed with #.</p> Source code in <code>leafmap/common.py</code> <pre><code>def to_hex_colors(colors):\n    \"\"\"Adds # to a list of hex color codes.\n\n    Args:\n        colors (list): A list of hex color codes.\n\n    Returns:\n        list: A list of hex color codes prefixed with #.\n    \"\"\"\n    result = all([len(color.strip()) == 6 for color in colors])\n    if result:\n        return [\"#\" + color.strip() for color in colors]\n    else:\n        return colors\n</code></pre>"},{"location":"common/#leafmap.common.transform_bbox_coords","title":"<code>transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | tuple</code> <p>The bounding box [x1, y1, x2, y2] coordinates.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>list</code> <p>The transformed bounding box [x1, y1, x2, y2] coordinates.</p> Source code in <code>leafmap/common.py</code> <pre><code>def transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs):\n    \"\"\"Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.\n\n    Args:\n        bbox (list | tuple): The bounding box [x1, y1, x2, y2] coordinates.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        list: The transformed bounding box [x1, y1, x2, y2] coordinates.\n    \"\"\"\n    x1, y1, x2, y2 = bbox\n\n    x1, y1 = transform_coords(x1, y1, src_crs, dst_crs, **kwargs)\n    x2, y2 = transform_coords(x2, y2, src_crs, dst_crs, **kwargs)\n\n    return [x1, y1, x2, y2]\n</code></pre>"},{"location":"common/#leafmap.common.transform_coords","title":"<code>transform_coords(x, y, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transform coordinates from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The transformed coordinates in the format of (x, y)</p> Source code in <code>leafmap/common.py</code> <pre><code>def transform_coords(x, y, src_crs, dst_crs, **kwargs):\n    \"\"\"Transform coordinates from one CRS to another.\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        dict: The transformed coordinates in the format of (x, y)\n    \"\"\"\n    import pyproj\n\n    transformer = pyproj.Transformer.from_crs(\n        src_crs, dst_crs, always_xy=True, **kwargs\n    )\n    return transformer.transform(x, y)\n</code></pre>"},{"location":"common/#leafmap.common.update_package","title":"<code>update_package()</code>","text":"<p>Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.</p> Source code in <code>leafmap/common.py</code> <pre><code>def update_package():\n    \"\"\"Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda.\n    In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.\n\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n        _clone_repo(out_dir=download_dir)\n\n        pkg_dir = os.path.join(download_dir, \"leafmap-master\")\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n\n        if shutil.which(\"pip\") is None:\n            cmd = \"pip3 install .\"\n        else:\n            cmd = \"pip install .\"\n\n        os.system(cmd)\n        os.chdir(work_dir)\n\n        print(\n            \"\\nPlease comment out 'leafmap.update_package()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\"\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.upload_to_imgur","title":"<code>upload_to_imgur(in_gif)</code>","text":"<p>Uploads an image to imgur.com</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the image.</p> required Source code in <code>leafmap/common.py</code> <pre><code>def upload_to_imgur(in_gif: str):\n    \"\"\"Uploads an image to imgur.com\n\n    Args:\n        in_gif (str): The file path to the image.\n    \"\"\"\n    import subprocess\n\n    pkg_name = \"imgur-uploader\"\n    if not _is_tool(pkg_name):\n        _check_install(pkg_name)\n\n    try:\n        IMGUR_API_ID = os.environ.get(\"IMGUR_API_ID\", None)\n        IMGUR_API_SECRET = os.environ.get(\"IMGUR_API_SECRET\", None)\n        credentials_path = os.path.join(\n            os.path.expanduser(\"~\"), \".config/imgur_uploader/uploader.cfg\"\n        )\n\n        if (\n            (IMGUR_API_ID is not None) and (IMGUR_API_SECRET is not None)\n        ) or os.path.exists(credentials_path):\n            proc = subprocess.Popen([\"imgur-uploader\", in_gif], stdout=subprocess.PIPE)\n            for _ in range(0, 2):\n                line = proc.stdout.readline()\n                print(line.rstrip().decode(\"utf-8\"))\n            # while True:\n            #     line = proc.stdout.readline()\n            #     if not line:\n            #         break\n            #     print(line.rstrip().decode(\"utf-8\"))\n        else:\n            print(\n                \"Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials\"\n            )\n            return\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.vector_area","title":"<code>vector_area(vector, unit='m2', crs='epsg:3857')</code>","text":"<p>Calculate the area of a vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str</code> <p>A local path or HTTP URL to a vector.</p> required <code>unit</code> <code>str</code> <p>The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.</p> <code>'m2'</code> <p>Returns:</p> Type Description <code>float</code> <p>The area of the vector.</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_area(vector, unit=\"m2\", crs=\"epsg:3857\"):\n    \"\"\"Calculate the area of a vector.\n\n    Args:\n        vector (str): A local path or HTTP URL to a vector.\n        unit (str, optional): The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.\n\n    Returns:\n        float: The area of the vector.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n\n    area = gdf.to_crs(crs).area.sum()\n\n    if unit == \"m2\":\n        return area\n    elif unit == \"km2\":\n        return area / 1000000\n    elif unit == \"ha\":\n        return area / 10000\n    elif unit == \"acres\":\n        return area / 4046.8564224\n    else:\n        raise ValueError(\"Invalid unit.\")\n</code></pre>"},{"location":"common/#leafmap.common.vector_col_names","title":"<code>vector_col_names(filename, **kwargs)</code>","text":"<p>Retrieves the column names of a vector attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of column names.</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_col_names(filename, **kwargs):\n    \"\"\"Retrieves the column names of a vector attribute table.\n\n    Args:\n        filename (str): The input file path.\n\n    Returns:\n        list: The list of column names.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n    else:\n        gdf = gpd.read_file(filename, **kwargs)\n    col_names = gdf.columns.values.tolist()\n    return col_names\n</code></pre>"},{"location":"common/#leafmap.common.vector_geom_type","title":"<code>vector_geom_type(data, first_only=True, **kwargs)</code>","text":"<p>Returns the geometry type of a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the geopandas.read_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame, such as Point, LineString,     Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_geom_type(data, first_only=True, **kwargs):\n    \"\"\"Returns the geometry type of a vector dataset.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the\n            first feature in the GeoDataFrame. Defaults to True.\n        kwargs: Additional keyword arguments to pass to the geopandas.read_file function.\n\n\n    Returns:\n        str: The geometry type of the GeoDataFrame, such as Point, LineString,\n            Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str) or isinstance(data, dict):\n        gdf = gpd.read_file(data, **kwargs)\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#leafmap.common.vector_set_crs","title":"<code>vector_set_crs(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Set CRS of a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS to set. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The GeoDataFrame with the new CRS.</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_set_crs(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Set CRS of a vector file.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS to set. Defaults to \"EPSG:4326\".\n\n\n    Returns:\n        gpd.GeoDataFrame: The GeoDataFrame with the new CRS.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        source = gpd.read_file(source, **kwargs)\n\n    if not isinstance(source, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = source.set_crs(crs)\n\n    if output is not None:\n        gdf.to_file(output)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_geojson","title":"<code>vector_to_geojson(filename, out_geojson=None, bbox=None, mask=None, rows=None, epsg='4326', encoding='utf-8', **kwargs)</code>","text":"<p>Converts any geopandas-supported vector dataset to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>The EPSG number to convert to. Defaults to \"4326\".</p> <code>'4326'</code> <code>encoding</code> <code>str</code> <p>The encoding of the input file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>When the output file path is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the GeoJSON.</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_geojson(\n    filename,\n    out_geojson=None,\n    bbox=None,\n    mask=None,\n    rows=None,\n    epsg=\"4326\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Converts any geopandas-supported vector dataset to GeoJSON.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        out_geojson (str, optional): The file path to the output GeoJSON. Defaults to None.\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        epsg (str, optional): The EPSG number to convert to. Defaults to \"4326\".\n        encoding (str, optional): The encoding of the input file. Defaults to \"utf-8\".\n\n\n    Raises:\n        ValueError: When the output file path is invalid.\n\n    Returns:\n        dict: A dictionary containing the GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n        if filename.endswith(\".zip\"):\n            filename = \"zip://\" + filename\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        df = gpd.read_file(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            driver=\"KML\",\n            encoding=encoding,\n            **kwargs,\n        )\n    else:\n        df = gpd.read_file(\n            filename, bbox=bbox, mask=mask, rows=rows, encoding=encoding, **kwargs\n        )\n    gdf = df.to_crs(epsg=epsg)\n\n    if out_geojson is not None:\n        if not out_geojson.lower().endswith(\".geojson\"):\n            raise ValueError(\"The output file must have a geojson file extension.\")\n\n        out_geojson = os.path.abspath(out_geojson)\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_gif","title":"<code>vector_to_gif(filename, out_gif, colname, vmin=None, vmax=None, step=1, facecolor='black', figsize=(10, 8), padding=3, title=None, add_text=True, xy=('1%', '1%'), fontsize=20, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, dpi=300, fps=10, loop=0, mp4=False, keep_png=False, verbose=True, open_args={}, plot_args={})</code>","text":"<p>Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at         https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>colname</code> <code>str</code> <p>The column name of the vector that contains numerical values.</p> required <code>vmin</code> <code>float</code> <p>The minimum value to filter the data. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to filter the data. Defaults to None.</p> <code>None</code> <code>step</code> <code>float</code> <p>The step to filter the data. Defaults to 1.</p> <code>1</code> <code>facecolor</code> <code>str</code> <p>The color to visualize the data. Defaults to \"black\".</p> <code>'black'</code> <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (10, 8).</p> <code>(10, 8)</code> <code>padding</code> <code>int</code> <p>The padding of the figure tight_layout. Defaults to 3.</p> <code>3</code> <code>title</code> <code>str</code> <p>The title of the figure. Defaults to None.</p> <code>None</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the figure. Defaults to True.</p> <code>True</code> <code>xy</code> <code>tuple</code> <p>The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").</p> <code>('1%', '1%')</code> <code>fontsize</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the figure. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar. Defaults to \"blue\".</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>dpi</code> <code>int</code> <p>The dpi of the figure. Defaults to 300.</p> <code>300</code> <code>fps</code> <code>int</code> <p>The frames per second (fps) of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of loops of the gif. Defaults to 0, infinite loop.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>keep_png</code> <code>bool</code> <p>Whether to keep the png files. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <code>open_args</code> <code>dict</code> <p>The arguments for the geopandas.read_file() function. Defaults to {}.</p> <code>{}</code> <code>plot_args</code> <code>dict</code> <p>The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_gif(\n    filename,\n    out_gif,\n    colname,\n    vmin=None,\n    vmax=None,\n    step=1,\n    facecolor=\"black\",\n    figsize=(10, 8),\n    padding=3,\n    title=None,\n    add_text=True,\n    xy=(\"1%\", \"1%\"),\n    fontsize=20,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    dpi=300,\n    fps=10,\n    loop=0,\n    mp4=False,\n    keep_png=False,\n    verbose=True,\n    open_args={},\n    plot_args={},\n):\n    \"\"\"Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at\n            https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.\n\n    Args:\n        filename (str): The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        colname (str): The column name of the vector that contains numerical values.\n        vmin (float, optional): The minimum value to filter the data. Defaults to None.\n        vmax (float, optional): The maximum value to filter the data. Defaults to None.\n        step (float, optional): The step to filter the data. Defaults to 1.\n        facecolor (str, optional): The color to visualize the data. Defaults to \"black\".\n        figsize (tuple, optional): The figure size. Defaults to (10, 8).\n        padding (int, optional): The padding of the figure tight_layout. Defaults to 3.\n        title (str, optional): The title of the figure. Defaults to None.\n        add_text (bool, optional): Whether to add text to the figure. Defaults to True.\n        xy (tuple, optional): The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").\n        fontsize (int, optional): The font size of the text. Defaults to 20.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the figure. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar. Defaults to \"blue\".\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        dpi (int, optional): The dpi of the figure. Defaults to 300.\n        fps (int, optional): The frames per second (fps) of the gif. Defaults to 10.\n        loop (int, optional): The number of loops of the gif. Defaults to 0, infinite loop.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        keep_png (bool, optional): Whether to keep the png files. Defaults to False.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n        open_args (dict, optional): The arguments for the geopandas.read_file() function. Defaults to {}.\n        plot_args (dict, optional): The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.\n\n    \"\"\"\n    import geopandas as gpd\n    import matplotlib.pyplot as plt\n\n    out_dir = os.path.dirname(out_gif)\n    tmp_dir = os.path.join(out_dir, \"tmp_png\")\n    if not os.path.exists(tmp_dir):\n        os.makedirs(tmp_dir)\n\n    if isinstance(filename, str):\n        gdf = gpd.read_file(filename, **open_args)\n    elif isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        raise ValueError(\n            \"filename must be a string or a geopandas.GeoDataFrame object.\"\n        )\n\n    bbox = gdf.total_bounds\n\n    if colname not in gdf.columns:\n        raise Exception(\n            f\"{colname} is not in the columns of the GeoDataFrame. It must be one of {gdf.columns}\"\n        )\n\n    values = gdf[colname].unique().tolist()\n    values.sort()\n\n    if vmin is None:\n        vmin = values[0]\n    if vmax is None:\n        vmax = values[-1]\n\n    options = range(vmin, vmax + step, step)\n\n    W = bbox[2] - bbox[0]\n    H = bbox[3] - bbox[1]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        raise Exception(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = float(x.replace(\"%\", \"\")) / 100.0 * W\n                y = float(y.replace(\"%\", \"\")) / 100.0 * H\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    x = bbox[0] + x\n    y = bbox[1] + y\n\n    for index, v in enumerate(options):\n        if verbose:\n            print(f\"Processing {index+1}/{len(options)}: {v}...\")\n        yrdf = gdf[gdf[colname] &lt;= v]\n        fig, ax = plt.subplots()\n        ax = yrdf.plot(facecolor=facecolor, figsize=figsize, **plot_args)\n        ax.set_title(title, fontsize=fontsize)\n        ax.set_axis_off()\n        ax.set_xlim([bbox[0], bbox[2]])\n        ax.set_ylim([bbox[1], bbox[3]])\n        if add_text:\n            ax.text(x, y, v, fontsize=fontsize)\n        fig = ax.get_figure()\n        plt.tight_layout(pad=padding)\n        fig.savefig(tmp_dir + os.sep + \"%s.png\" % v, dpi=dpi)\n        plt.clf()\n        plt.close(\"all\")\n\n    png_to_gif(tmp_dir, out_gif, fps=fps, loop=loop)\n\n    if add_progress_bar:\n        add_progress_bar_to_gif(\n            out_gif,\n            out_gif,\n            progress_bar_color,\n            progress_bar_height,\n            duration=1000 / fps,\n            loop=loop,\n        )\n\n    if mp4:\n        gif_to_mp4(out_gif, out_gif.replace(\".gif\", \".mp4\"))\n\n    if not keep_png:\n        shutil.rmtree(tmp_dir)\n\n    if verbose:\n        print(f\"Done. The GIF is saved to {out_gif}.\")\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_mbtiles","title":"<code>vector_to_mbtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>The path to the source vector dataset (GeoPackage, Shapefile, etc.).</p> required <code>target_path</code> <code>str</code> <p>The path to the target MBTiles file to be created.</p> required <code>max_zoom</code> <code>int</code> <p>The maximum zoom level for the MBTiles dataset. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>The name of the MBTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional options to be passed as keyword arguments. These options will be used as -dsco options       when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If the ogr2ogr command fails to execute.</p> <p>Examples:</p> <p>source_path = \"countries.gpkg\" target_path = \"target.mbtiles\" name = \"My MBTiles\" max_zoom = 5 vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_mbtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.\n\n    Args:\n        source_path (str): The path to the source vector dataset (GeoPackage, Shapefile, etc.).\n        target_path (str): The path to the target MBTiles file to be created.\n        max_zoom (int, optional): The maximum zoom level for the MBTiles dataset. Defaults to 5.\n        name (str, optional): The name of the MBTiles dataset. Defaults to None.\n        **kwargs: Additional options to be passed as keyword arguments. These options will be used as -dsco options\n                  when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.\n\n    Returns:\n        None\n\n    Raises:\n        subprocess.CalledProcessError: If the ogr2ogr command fails to execute.\n\n    Example:\n        source_path = \"countries.gpkg\"\n        target_path = \"target.mbtiles\"\n        name = \"My MBTiles\"\n        max_zoom = 5\n        vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)\n    \"\"\"\n    import subprocess\n\n    command = [\n        \"ogr2ogr\",\n        \"-f\",\n        \"MBTILES\",\n        target_path,\n        source_path,\n        \"-dsco\",\n        f\"MAXZOOM={max_zoom}\",\n    ]\n\n    if name:\n        command.extend([\"-dsco\", f\"NAME={name}\"])\n\n    for key, value in kwargs.items():\n        command.extend([\"-dsco\", f\"{key.upper()}={value}\"])\n\n    try:\n        subprocess.run(command, check=True)\n    except subprocess.CalledProcessError as e:\n        raise e\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_parquet","title":"<code>vector_to_parquet(source, output, crs=None, overwrite=False, **kwargs)</code>","text":"<p>Convert a GeoDataFrame or a file containing vector data to Parquet format.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[gpd.GeoDataFrame, str]</code> <p>The source data to convert. It can be either a GeoDataFrame or a file path to the vector data file.</p> required <code>output</code> <code>str</code> <p>The file path where the Parquet file will be saved.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) to use for the output file. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output file. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>to_parquet</code> function of GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_parquet(\n    source: str, output: str, crs=None, overwrite=False, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a GeoDataFrame or a file containing vector data to Parquet format.\n\n    Args:\n        source (Union[gpd.GeoDataFrame, str]): The source data to convert. It can be either a GeoDataFrame\n            or a file path to the vector data file.\n        output (str): The file path where the Parquet file will be saved.\n        crs (str, optional): The coordinate reference system (CRS) to use for the output file. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output file. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `to_parquet` function of GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n\n    import geopandas as gpd\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Skipping...\")\n        return\n\n    if isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        gdf = gpd.read_file(source)\n\n    if crs is not None:\n        gdf = gdf.to_crs(crs)\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    gdf.to_parquet(output, **kwargs)\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_pmtiles","title":"<code>vector_to_pmtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Converts a vector file to PMTiles format.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>Path to the source vector file.</p> required <code>target_path</code> <code>str</code> <p>Path to the target PMTiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the PMTiles. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>Name of the PMTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying conversion functions.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the target file does not have a .pmtiles extension.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_pmtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n):\n    \"\"\"\n    Converts a vector file to PMTiles format.\n\n    Args:\n        source_path (str): Path to the source vector file.\n        target_path (str): Path to the target PMTiles file.\n        max_zoom (int, optional): Maximum zoom level for the PMTiles. Defaults to 5.\n        name (str, optional): Name of the PMTiles dataset. Defaults to None.\n        **kwargs: Additional keyword arguments to be passed to the underlying conversion functions.\n\n    Raises:\n        ValueError: If the target file does not have a .pmtiles extension.\n\n    Returns:\n        None\n    \"\"\"\n    if not target_path.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: target file must be a .pmtiles file.\")\n    mbtiles = target_path.replace(\".pmtiles\", \".mbtiles\")\n    vector_to_mbtiles(source_path, mbtiles, max_zoom=max_zoom, name=name, **kwargs)\n    mbtiles_to_pmtiles(mbtiles, target_path)\n    os.remove(mbtiles)\n</code></pre>"},{"location":"common/#leafmap.common.vector_to_raster","title":"<code>vector_to_raster(vector, output, field='FID', assign='last', nodata=True, cell_size=None, base=None, callback=None, verbose=False, to_epsg=None)</code>","text":"<p>Convert a vector to a raster.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str | GeoPandas.GeoDataFrame</code> <p>The input vector data, can be a file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output raster file path.</p> required <code>field</code> <code>str</code> <p>Input field name in attribute table. Defaults to 'FID'.</p> <code>'FID'</code> <code>assign</code> <code>str</code> <p>Assignment operation, where multiple points are in the same grid cell; options include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.</p> <code>'last'</code> <code>nodata</code> <code>bool</code> <p>Background value to set to NoData. Without this flag, it will be set to 0.0.</p> <code>True</code> <code>cell_size</code> <code>float</code> <p>Optionally specified cell size of output raster. Not used when base raster is specified</p> <code>None</code> <code>base</code> <code>str</code> <p>Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.</p> <code>None</code> <code>callback</code> <code>fuct</code> <p>A callback function to report progress. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress to the console. Defaults to False.</p> <code>False</code> <code>to_epsg</code> <code>integer</code> <p>Optionally specified the EPSG code to reproject the raster to. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def vector_to_raster(\n    vector,\n    output,\n    field=\"FID\",\n    assign=\"last\",\n    nodata=True,\n    cell_size=None,\n    base=None,\n    callback=None,\n    verbose=False,\n    to_epsg=None,\n):\n    \"\"\"Convert a vector to a raster.\n\n    Args:\n        vector (str | GeoPandas.GeoDataFrame): The input vector data, can be a file path or a GeoDataFrame.\n        output (str): The output raster file path.\n        field (str, optional): Input field name in attribute table. Defaults to 'FID'.\n        assign (str, optional): Assignment operation, where multiple points are in the same grid cell; options\n            include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.\n        nodata (bool, optional): Background value to set to NoData. Without this flag, it will be set to 0.0.\n        cell_size (float, optional): Optionally specified cell size of output raster. Not used when base raster is specified\n        base (str, optional): Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.\n        callback (fuct, optional): A callback function to report progress. Defaults to None.\n        verbose (bool, optional): Whether to print progress to the console. Defaults to False.\n        to_epsg (integer, optional): Optionally specified the EPSG code to reproject the raster to. Defaults to None.\n\n    \"\"\"\n    import geopandas as gpd\n    import whitebox\n\n    output = os.path.abspath(output)\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n    else:\n        raise TypeError(\"vector must be a file path or a GeoDataFrame\")\n\n    if to_epsg is None:\n        to_epsg = 3857\n\n    if to_epsg == 4326:\n        raise ValueError(\"to_epsg cannot be 4326\")\n\n    if gdf.crs.is_geographic:\n        gdf = gdf.to_crs(epsg=to_epsg)\n        vector = temp_file_path(extension=\".shp\")\n        gdf.to_file(vector)\n    else:\n        to_epsg = gdf.crs.to_epsg()\n\n    wbt = whitebox.WhiteboxTools()\n    wbt.verbose = verbose\n\n    goem_type = gdf.geom_type[0]\n\n    if goem_type == \"LineString\":\n        wbt.vector_lines_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    elif goem_type == \"Polygon\":\n        wbt.vector_polygons_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    else:\n        wbt.vector_points_to_raster(\n            vector, output, field, assign, nodata, cell_size, base, callback\n        )\n\n    image_set_crs(output, to_epsg)\n</code></pre>"},{"location":"common/#leafmap.common.view_lidar","title":"<code>view_lidar(filename, cmap='terrain', backend='pyvista', background=None, eye_dome_lighting=False, **kwargs)</code>","text":"<p>View LiDAR data in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filepath to the LiDAR data.</p> required <code>cmap</code> <code>str</code> <p>The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.</p> <code>'terrain'</code> <code>backend</code> <code>str</code> <p>The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".</p> <code>'pyvista'</code> <code>background</code> <code>str</code> <p>The background color to use. Defaults to None.</p> <code>None</code> <code>eye_dome_lighting</code> <code>bool</code> <p>Whether to use eye dome lighting. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the backend is not supported.</p> Source code in <code>leafmap/common.py</code> <pre><code>def view_lidar(\n    filename,\n    cmap=\"terrain\",\n    backend=\"pyvista\",\n    background=None,\n    eye_dome_lighting=False,\n    **kwargs,\n):\n    \"\"\"View LiDAR data in 3D.\n\n    Args:\n        filename (str): The filepath to the LiDAR data.\n        cmap (str, optional): The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.\n        backend (str, optional): The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".\n        background (str, optional): The background color to use. Defaults to None.\n        eye_dome_lighting (bool, optional): Whether to use eye dome lighting. Defaults to False.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the backend is not supported.\n    \"\"\"\n\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    filename = os.path.abspath(filename)\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    backend = backend.lower()\n    if backend in [\"pyvista\", \"ipygany\", \"panel\"]:\n        try:\n            import pyntcloud\n        except ImportError:\n            print(\n                \"The pyvista and pyntcloud packages are required for this function. Use pip install leafmap[lidar] to install them.\"\n            )\n            return\n\n        try:\n            if backend == \"pyvista\":\n                backend = None\n            if backend == \"ipygany\":\n                cmap = None\n            data = pyntcloud.PyntCloud.from_file(filename)\n            mesh = data.to_instance(\"pyvista\", mesh=False)\n            mesh = mesh.elevation()\n            mesh.plot(\n                scalars=\"Elevation\",\n                cmap=cmap,\n                jupyter_backend=backend,\n                background=background,\n                eye_dome_lighting=eye_dome_lighting,\n                **kwargs,\n            )\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    elif backend == \"open3d\":\n        try:\n            import laspy\n            import open3d as o3d\n            import numpy as np\n        except ImportError:\n            print(\n                \"The laspy and open3d packages are required for this function. Use pip install laspy open3d to install them.\"\n            )\n            return\n\n        try:\n            las = laspy.read(filename)\n            point_data = np.stack([las.X, las.Y, las.Z], axis=0).transpose((1, 0))\n            geom = o3d.geometry.PointCloud()\n            geom.points = o3d.utility.Vector3dVector(point_data)\n            # geom.colors =  o3d.utility.Vector3dVector(colors)  # need to add colors. A list in the form of [[r,g,b], [r,g,b]] with value range 0-1. https://github.com/isl-org/Open3D/issues/614\n            o3d.visualization.draw_geometries([geom], **kwargs)\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    else:\n        raise ValueError(f\"{backend} is not a valid backend.\")\n</code></pre>"},{"location":"common/#leafmap.common.whiteboxgui","title":"<code>whiteboxgui(verbose=True, tree=False, reset=False, sandbox_path=None)</code>","text":"<p>Shows the WhiteboxTools GUI.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to show progress info when the tool is running. Defaults to True.</p> <code>True</code> <code>tree</code> <code>bool</code> <p>Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.</p> <code>False</code> <code>reset</code> <code>bool</code> <p>Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.</p> <code>False</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox folder. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>A toolbox GUI.</p> Source code in <code>leafmap/common.py</code> <pre><code>def whiteboxgui(\n    verbose: Optional[bool] = True,\n    tree: Optional[bool] = False,\n    reset: Optional[bool] = False,\n    sandbox_path: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Shows the WhiteboxTools GUI.\n\n    Args:\n        verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True.\n        tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.\n        reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.\n        sandbox_path (str, optional): The path to the sandbox folder. Defaults to None.\n\n    Returns:\n        object: A toolbox GUI.\n    \"\"\"\n    import whiteboxgui\n\n    return whiteboxgui.show(verbose, tree, reset, sandbox_path)\n</code></pre>"},{"location":"common/#leafmap.common.widget_template","title":"<code>widget_template(widget=None, opened=True, show_close_button=True, widget_icon='gear', close_button_icon='times', widget_args={}, close_button_args={}, display_widget=None, m=None, position='topright')</code>","text":"<p>Create a widget template.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed. Defaults to None.</p> <code>None</code> <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <code>show_close_button</code> <code>bool</code> <p>Whether to show the close button. Defaults to True.</p> <code>True</code> <code>widget_icon</code> <code>str</code> <p>The icon name for the toolbar button. Defaults to 'gear'.</p> <code>'gear'</code> <code>close_button_icon</code> <code>str</code> <p>The icon name for the close button. Defaults to \"times\".</p> <code>'times'</code> <code>widget_args</code> <code>dict</code> <p>Additional arguments to pass to the toolbar button. Defaults to {}.</p> <code>{}</code> <code>close_button_args</code> <code>dict</code> <p>Additional arguments to pass to the close button. Defaults to {}.</p> <code>{}</code> <code>display_widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed when the toolbar is clicked.</p> <code>None</code> <code>m</code> <code>geemap.Map</code> <p>The geemap.Map instance. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the toolbar. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>leafmap/common.py</code> <pre><code>def widget_template(\n    widget=None,\n    opened=True,\n    show_close_button=True,\n    widget_icon=\"gear\",\n    close_button_icon=\"times\",\n    widget_args={},\n    close_button_args={},\n    display_widget=None,\n    m=None,\n    position=\"topright\",\n):\n    \"\"\"Create a widget template.\n\n    Args:\n        widget (ipywidgets.Widget, optional): The widget to be displayed. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n        show_close_button (bool, optional): Whether to show the close button. Defaults to True.\n        widget_icon (str, optional): The icon name for the toolbar button. Defaults to 'gear'.\n        close_button_icon (str, optional): The icon name for the close button. Defaults to \"times\".\n        widget_args (dict, optional): Additional arguments to pass to the toolbar button. Defaults to {}.\n        close_button_args (dict, optional): Additional arguments to pass to the close button. Defaults to {}.\n        display_widget (ipywidgets.Widget, optional): The widget to be displayed when the toolbar is clicked.\n        m (geemap.Map, optional): The geemap.Map instance. Defaults to None.\n        position (str, optional): The position of the toolbar. Defaults to \"topright\".\n    \"\"\"\n\n    name = \"_\" + random_string()  # a random attribute name\n\n    if \"value\" not in widget_args:\n        widget_args[\"value\"] = False\n    if \"tooltip\" not in widget_args:\n        widget_args[\"tooltip\"] = \"Toolbar\"\n    if \"layout\" not in widget_args:\n        widget_args[\"layout\"] = widgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    widget_args[\"icon\"] = widget_icon\n\n    if \"value\" not in close_button_args:\n        close_button_args[\"value\"] = False\n    if \"tooltip\" not in close_button_args:\n        close_button_args[\"tooltip\"] = \"Close the tool\"\n    if \"button_style\" not in close_button_args:\n        close_button_args[\"button_style\"] = \"primary\"\n    if \"layout\" not in close_button_args:\n        close_button_args[\"layout\"] = widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    close_button_args[\"icon\"] = close_button_icon\n\n    toolbar_button = widgets.ToggleButton(**widget_args)\n\n    close_button = widgets.ToggleButton(**close_button_args)\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    if show_close_button:\n        toolbar_header.children = [close_button, toolbar_button]\n    else:\n        toolbar_header.children = [toolbar_button]\n    toolbar_footer = widgets.VBox()\n\n    if widget is not None:\n        toolbar_footer.children = [\n            widget,\n        ]\n    else:\n        toolbar_footer.children = []\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            if display_widget is not None:\n                widget.outputs = ()\n                with widget:\n                    display(display_widget)\n        else:\n            toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                control = getattr(m, name)\n                if control is not None and control in m.controls:\n                    m.remove_control(control)\n                    delattr(m, name)\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        import ipyleaflet\n\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n\n            setattr(m, name, toolbar_control)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"common/#leafmap.common.write_lidar","title":"<code>write_lidar(source, destination, do_compress=None, laz_backend=None)</code>","text":"<p>Writes to a stream or file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be written.</p> required <code>destination</code> <code>str</code> <p>The destination filepath.</p> required <code>do_compress</code> <code>bool</code> <p>Flags to indicate if you want to compress the data. Defaults to None.</p> <code>None</code> <code>laz_backend</code> <code>str</code> <p>The laz backend to use. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/common.py</code> <pre><code>def write_lidar(source, destination, do_compress=None, laz_backend=None):\n    \"\"\"Writes to a stream or file.\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be written.\n        destination (str): The destination filepath.\n        do_compress (bool, optional): Flags to indicate if you want to compress the data. Defaults to None.\n        laz_backend (str, optional): The laz backend to use. Defaults to None.\n    \"\"\"\n\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    source.write(destination, do_compress=do_compress, laz_backend=laz_backend)\n</code></pre>"},{"location":"common/#leafmap.common.xy_to_window","title":"<code>xy_to_window(xy)</code>","text":"<p>Converts a list of coordinates to a rasterio window.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2]]</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The rasterio window in the format of (col_off, row_off, width, height)</p> Source code in <code>leafmap/common.py</code> <pre><code>def xy_to_window(xy):\n    \"\"\"Converts a list of coordinates to a rasterio window.\n\n    Args:\n        xy (list): A list of coordinates in the format of [[x1, y1], [x2, y2]]\n\n    Returns:\n        tuple: The rasterio window in the format of (col_off, row_off, width, height)\n    \"\"\"\n\n    x1, y1 = xy[0]\n    x2, y2 = xy[1]\n\n    left = min(x1, x2)\n    right = max(x1, x2)\n    top = min(y1, y2)\n    bottom = max(y1, y2)\n\n    width = right - left\n    height = bottom - top\n\n    return (left, top, width, height)\n</code></pre>"},{"location":"common/#leafmap.common.zonal_stats","title":"<code>zonal_stats(vectors, raster, layer=0, band_num=1, nodata=None, affine=None, stats=None, all_touched=False, categorical=False, category_map=None, add_stats=None, raster_out=False, prefix=None, geojson_out=False, gdf_out=False, dst_crs=None, open_vector_args={}, open_raster_args={}, **kwargs)</code>","text":"<p>This function wraps rasterstats.zonal_stats and performs reprojection if necessary.     See https://pythonhosted.org/rasterstats/rasterstats.html.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>str | list | GeoDataFrame</code> <p>path to an vector source or geo-like python objects.</p> required <code>raster</code> <code>str | ndarray</code> <p>ndarray or path to a GDAL raster source.</p> required <code>layer</code> <code>int</code> <p>If vectors is a path to an fiona source, specify the vector layer to use either by name or number. Defaults to 0</p> <code>0</code> <code>band_num</code> <code>int | str</code> <p>If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.</p> <code>1</code> <code>nodata</code> <code>float</code> <p>If raster is a GDAL source, this value overrides any NODATA value specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any) will be used. defaults to None.</p> <code>None</code> <code>affine</code> <code>Affine</code> <p>required only for ndarrays, otherwise it is read from src. Defaults to None.</p> <code>None</code> <code>stats</code> <code>str | list</code> <p>Which statistics to calculate for each zone. It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics Defaults to None.</p> <code>None</code> <code>all_touched</code> <code>bool</code> <p>Whether to include every raster cell touched by a geometry, or only those having a center point within the polygon. defaults to False</p> <code>False</code> <code>categorical</code> <code>bool</code> <p>If True, the raster values will be treated as categorical.</p> <code>False</code> <code>category_map</code> <code>dict</code> <p>A dictionary mapping raster values to human-readable categorical names. Only applies when categorical is True</p> <code>None</code> <code>add_stats</code> <code>dict</code> <p>with names and functions of additional stats to compute. Defaults to None.</p> <code>None</code> <code>raster_out</code> <code>bool</code> <p>Include the masked numpy array for each feature?. Defaults to False.</p> <code>False</code> <code>prefix</code> <code>str</code> <p>add a prefix to the keys. Defaults to None.</p> <code>None</code> <code>geojson_out</code> <code>bool</code> <p>Return list of GeoJSON-like features (default: False) Original feature geometry and properties will be retained with zonal stats appended as additional properties. Use with prefix to ensure unique and meaningful property names.. Defaults to False.</p> <code>False</code> <code>gdf_out</code> <code>bool</code> <p>Return a GeoDataFrame. Defaults to False.</p> <code>False</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to None.</p> <code>None</code> <code>open_vector_args</code> <code>dict</code> <p>Pass additional arguments to geopandas.open_file(). Defaults to {}.</p> <code>{}</code> <code>open_raster_args</code> <code>dict</code> <p>Pass additional arguments to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | list | GeoDataFrame</code> <p>The zonal statistics results</p> Source code in <code>leafmap/common.py</code> <pre><code>def zonal_stats(\n    vectors,\n    raster,\n    layer=0,\n    band_num=1,\n    nodata=None,\n    affine=None,\n    stats=None,\n    all_touched=False,\n    categorical=False,\n    category_map=None,\n    add_stats=None,\n    raster_out=False,\n    prefix=None,\n    geojson_out=False,\n    gdf_out=False,\n    dst_crs=None,\n    open_vector_args={},\n    open_raster_args={},\n    **kwargs,\n):\n    \"\"\"This function wraps rasterstats.zonal_stats and performs reprojection if necessary.\n        See https://pythonhosted.org/rasterstats/rasterstats.html.\n\n    Args:\n        vectors (str | list | GeoDataFrame): path to an vector source or geo-like python objects.\n        raster (str | ndarray): ndarray or path to a GDAL raster source.\n        layer (int, optional): If vectors is a path to an fiona source, specify the vector layer to\n            use either by name or number. Defaults to 0\n        band_num (int | str, optional): If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.\n        nodata (float, optional): If raster is a GDAL source, this value overrides any NODATA value\n            specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any)\n            will be used. defaults to None.\n        affine (Affine, optional): required only for ndarrays, otherwise it is read from src. Defaults to None.\n        stats (str | list, optional): Which statistics to calculate for each zone.\n            It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics\n            Defaults to None.\n        all_touched (bool, optional): Whether to include every raster cell touched by a geometry, or only those having\n            a center point within the polygon. defaults to False\n        categorical (bool, optional): If True, the raster values will be treated as categorical.\n        category_map (dict, optional):A dictionary mapping raster values to human-readable categorical names.\n            Only applies when categorical is True\n        add_stats (dict, optional): with names and functions of additional stats to compute. Defaults to None.\n        raster_out (bool, optional): Include the masked numpy array for each feature?. Defaults to False.\n        prefix (str, optional): add a prefix to the keys. Defaults to None.\n        geojson_out (bool, optional): Return list of GeoJSON-like features (default: False)\n            Original feature geometry and properties will be retained with zonal stats\n            appended as additional properties. Use with prefix to ensure unique and\n            meaningful property names.. Defaults to False.\n        gdf_out (bool, optional): Return a GeoDataFrame. Defaults to False.\n        dst_crs (str, optional): The destination CRS. Defaults to None.\n        open_vector_args (dict, optional): Pass additional arguments to geopandas.open_file(). Defaults to {}.\n        open_raster_args (dict, optional): Pass additional arguments to rasterio.open(). Defaults to {}.\n\n    Returns:\n        dict | list | GeoDataFrame: The zonal statistics results\n    \"\"\"\n\n    import geopandas as gpd\n    import rasterio\n\n    try:\n        import rasterstats\n    except ImportError:\n        raise ImportError(\n            \"rasterstats is not installed. Install it with pip install rasterstats\"\n        )\n    try:\n        if isinstance(raster, str):\n            with rasterio.open(raster, **open_raster_args) as src:\n                affine = src.transform\n                nodata = src.nodata\n                array = src.read(band_num, masked=True)\n                raster_crs = src.crs\n        elif isinstance(raster, rasterio.io.DatasetReader):\n            affine = raster.transform\n            nodata = raster.nodata\n            array = raster.read(band_num, masked=True)\n            raster_crs = raster.crs\n        else:\n            array = raster\n\n        if isinstance(vectors, str):\n            gdf = gpd.read_file(vectors, **open_vector_args)\n        elif isinstance(vectors, list):\n            gdf = gpd.GeoDataFrame.from_features(vectors)\n        else:\n            gdf = vectors\n\n        vector_crs = gdf.crs\n\n        if gdf.crs.is_geographic:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n        elif gdf.crs != raster_crs:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n            else:\n                raise ValueError(\"The vector and raster CRSs are not compatible\")\n\n        if gdf_out is True:\n            geojson_out = True\n\n        result = rasterstats.zonal_stats(\n            gdf,\n            array,\n            layer=layer,\n            band_num=band_num,\n            nodata=nodata,\n            affine=affine,\n            stats=stats,\n            all_touched=all_touched,\n            categorical=categorical,\n            category_map=category_map,\n            add_stats=add_stats,\n            raster_out=raster_out,\n            prefix=prefix,\n            geojson_out=geojson_out,\n            **kwargs,\n        )\n\n        if gdf_out is True:\n            if dst_crs is None:\n                dst_crs = vector_crs\n\n            out_gdf = gpd.GeoDataFrame.from_features(result)\n            out_gdf.crs = raster_crs\n            return out_gdf.to_crs(dst_crs)\n        else:\n            return result\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#leafmap.common.zoom_level_resolution","title":"<code>zoom_level_resolution(zoom, latitude=0)</code>","text":"<p>Returns the approximate pixel scale based on zoom level and latutude.     See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <code>latitude</code> <code>float</code> <p>The latitude. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>leafmap/common.py</code> <pre><code>def zoom_level_resolution(zoom, latitude=0):\n    \"\"\"Returns the approximate pixel scale based on zoom level and latutude.\n        See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n\n    Args:\n        zoom (int): The zoom level.\n        latitude (float, optional): The latitude. Defaults to 0.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    import math\n\n    resolution = 156543.04 * math.cos(latitude) / math.pow(2, zoom)\n    return abs(resolution)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/opengeos/leafmap/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>leafmap could always use more documentation, whether as part of the official leafmap docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/opengeos/leafmap/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up leafmap for local development.</p> <ol> <li> <p>Fork the leafmap repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:your_name_here/leafmap.git\n</code></pre> </li> <li> <p>Install your local copy into a conda env. Assuming you have conda installed, this is how you set up your fork for local development:</p> <pre><code>conda create -n leafmap-test python\n</code></pre> <pre><code>conda activate leafmap-test\n</code></pre> <pre><code>cd leafmap/\n</code></pre> <pre><code>pip install -e .\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox:</p> <pre><code>flake8 leafmap tests\n</code></pre> <pre><code>python setup.py test or pytest\n</code></pre> <p>To get flake8 and tox, just pip install them into your conda env.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\n</code></pre> <pre><code>git commit -m \"Your detailed description of your changes.\"\n</code></pre> <pre><code>git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/opengeos/leafmap/actions and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"contributing/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,     and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the     overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or     advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email     address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a     professional setting</li> </ul>"},{"location":"contributing/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at giswqs@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"deck/","title":"pydeck module","text":""},{"location":"deck/#leafmap.deck.Layer","title":"<code> Layer            (Layer)         </code>","text":"<p>Configures a deck.gl layer for rendering on a map. Parameters passed here will be specific to the particular deck.gl layer that you are choosing to use. Please see the deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers) to determine the particular parameters of your layer. You are highly encouraged to look at the examples in the pydeck documentation.</p> Source code in <code>leafmap/deck.py</code> <pre><code>class Layer(pdk.Layer):\n    \"\"\"Configures a deck.gl layer for rendering on a map. Parameters passed here will be specific to the particular deck.gl layer that you are choosing to use.\n    Please see the deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers) to determine the particular parameters of your layer.\n    You are highly encouraged to look at the examples in the pydeck documentation.\n    \"\"\"\n\n    def __init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs):\n        \"\"\"Initialize a Layer object.\n\n        Args:\n            type (str):  Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)\n            data (str, optional): Unique name for layer. Defaults to None.\n            id (str | dict | pandas.DataFrame, optional): Either a URL of data to load in or an array of data. Defaults to None.\n            use_binary_transport (bool, optional): Boolean indicating binary data. Defaults to None.\n        \"\"\"\n        super().__init__(type, data, id, use_binary_transport, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Layer.__init__","title":"<code>__init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Layer object.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)</p> required <code>data</code> <code>str</code> <p>Unique name for layer. Defaults to None.</p> <code>None</code> <code>id</code> <code>str | dict | pandas.DataFrame</code> <p>Either a URL of data to load in or an array of data. Defaults to None.</p> <code>None</code> <code>use_binary_transport</code> <code>bool</code> <p>Boolean indicating binary data. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/deck.py</code> <pre><code>def __init__(self, type, data=None, id=None, use_binary_transport=None, **kwargs):\n    \"\"\"Initialize a Layer object.\n\n    Args:\n        type (str):  Type of layer to render, e.g., HexagonLayer. See deck.gl Layer catalog (https://deck.gl/docs/api-reference/layers)\n        data (str, optional): Unique name for layer. Defaults to None.\n        id (str | dict | pandas.DataFrame, optional): Either a URL of data to load in or an array of data. Defaults to None.\n        use_binary_transport (bool, optional): Boolean indicating binary data. Defaults to None.\n    \"\"\"\n    super().__init__(type, data, id, use_binary_transport, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map","title":"<code> Map            (Deck)         </code>","text":"<p>The Map class inherits pydeck.Deck.</p> <p>Returns:</p> Type Description <code>object</code> <p>pydeck.Deck object.</p> Source code in <code>leafmap/deck.py</code> <pre><code>class Map(pdk.Deck):\n    \"\"\"The Map class inherits pydeck.Deck.\n\n    Returns:\n        object: pydeck.Deck object.\n    \"\"\"\n\n    def __init__(self, center=(20, 0), zoom=1.2, **kwargs):\n        \"\"\"Initialize a Map object.\n\n        Args:\n            center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n            zoom (int, optional): The map zoom level. Defaults to 1.2.\n        \"\"\"\n        if \"initial_view_state\" not in kwargs:\n            kwargs[\"initial_view_state\"] = pdk.ViewState(\n                latitude=center[0], longitude=center[1], zoom=zoom\n            )\n\n        if \"map_style\" not in kwargs:\n            kwargs[\"map_style\"] = \"light\"\n\n        super().__init__(**kwargs)\n\n    def add_layer(self, layer, layer_name: Optional[str] = None, **kwargs):\n        \"\"\"Add a layer to the map.\n\n        Args:\n            layer (pydeck.Layer): A pydeck Layer object.\n        \"\"\"\n\n        try:\n            if isinstance(layer, str) and layer.startswith(\"http\"):\n                pdk.settings.custom_libraries = [\n                    {\n                        \"libraryName\": \"MyTileLayerLibrary\",\n                        \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                    }\n                ]\n                layer = pdk.Layer(\"MyTileLayer\", layer, id=layer_name)\n\n            self.layers.append(layer)\n        except Exception as e:\n            raise Exception(e)\n\n    def add_basemap(self, basemap: str = \"HYBRID\"):\n        \"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str): Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.\n        \"\"\"\n        import xyzservices\n\n        try:\n            if isinstance(basemap, xyzservices.TileProvider):\n                name = basemap.name\n                url = basemap.build_url()\n                self.add_layer(url, name)\n\n            elif basemap in basemaps:\n                # Use pydeck_myTileLayer from https://github.com/agressin/pydeck_myTileLayer\n                pdk.settings.custom_libraries = [\n                    {\n                        \"libraryName\": \"MyTileLayerLibrary\",\n                        \"resourceUri\": \"https://cdn.jsdelivr.net/gh/agressin/pydeck_myTileLayer@master/dist/bundle.js\",\n                    }\n                ]\n\n                layer = pdk.Layer(\"MyTileLayer\", basemaps[basemap].url, basemap)\n\n                self.add_layer(layer)\n\n            else:\n                print(\n                    \"Basemap can only be one of the following:\\n  {}\".format(\n                        \"\\n  \".join(basemaps.keys())\n                    )\n                )\n\n        except Exception:\n            raise ValueError(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_type=\"GeoJsonLayer\",\n        layer_name: Optional[str] = None,\n        random_color_column: Optional[str] = None,\n        **kwargs\n    ):\n        \"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoPandas.GeoDataFrame): The GeoPandas GeoDataFrame to add to the map.\n            layer_type (str, optional): The layer type to be used. Defaults to \"GeoJsonLayer\".\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            TypeError: gdf must be a GeoPandas GeoDataFrame.\n        \"\"\"\n\n        try:\n            import geopandas as gpd\n\n            if not isinstance(gdf, gpd.GeoDataFrame):\n                raise TypeError(\"gdf must be a GeoPandas GeoDataFrame.\")\n\n            if layer_name is None:\n                layer_name = \"layer_\" + random_string(3)\n\n            if \"layer_type\" == \"GeoJsonLayer\":\n                if \"pickable\" not in kwargs:\n                    kwargs[\"pickable\"] = True\n                if \"opacity\" not in kwargs:\n                    kwargs[\"opacity\"] = 0.5\n                if \"stroked\" not in kwargs:\n                    kwargs[\"stroked\"] = True\n                if \"filled\" not in kwargs:\n                    kwargs[\"filled\"] = True\n                if \"extruded\" not in kwargs:\n                    kwargs[\"extruded\"] = False\n                if \"wireframe\" not in kwargs:\n                    kwargs[\"wireframe\"] = True\n                if \"get_line_color\" not in kwargs:\n                    kwargs[\"get_line_color\"] = [0, 0, 0]\n                if \"get_line_width\" not in kwargs:\n                    kwargs[\"get_line_width\"] = 2\n                if \"line_width_min_pixels\" not in kwargs:\n                    kwargs[\"line_width_min_pixels\"] = 1\n\n            if random_color_column is not None:\n                if random_color_column not in gdf.columns.values.tolist():\n                    raise ValueError(\n                        \"The random_color_column provided does not exist in the vector file.\"\n                    )\n                color_lookup = pdk.data_utils.assign_random_colors(\n                    gdf[random_color_column]\n                )\n                gdf[\"color\"] = gdf.apply(\n                    lambda row: color_lookup.get(row[random_color_column]), axis=1\n                )\n                kwargs[\"get_fill_color\"] = \"color\"\n\n            layer = pdk.Layer(\n                layer_type,\n                gdf,\n                id=layer_name,\n                **kwargs,\n            )\n            self.add_layer(layer)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_vector(\n        self,\n        data: str,\n        layer_type: str = \"GeoJsonLayer\",\n        layer_name: Optional[str] = None,\n        random_color_column: Optional[str] = None,\n        **kwargs\n    ):\n        \"\"\"Adds a vector file to the map.\n\n        Args:\n            data (str): The input file path to the vector dataset.\n            layer_type (str, optional): The layer type to be used. Defaults to \"GeoJsonLayer\".\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n\n        try:\n            import geopandas as gpd\n            import fiona\n\n            if isinstance(data, str):\n                if not data.startswith(\"http\"):\n                    data = os.path.abspath(data)\n                    if data.endswith(\".zip\"):\n                        data = \"zip://\" + data\n\n                if data.endswith(\".kml\"):\n                    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n                    gdf = gpd.read_file(data, driver=\"KML\")\n                else:\n                    gdf = gpd.read_file(data)\n            else:\n                gdf = data\n\n            self.add_gdf(gdf, layer_type, layer_name, random_color_column, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_geojson(\n        self,\n        filename: str,\n        layer_name: Optional[str] = None,\n        random_color_column: Optional[str] = None,\n        **kwargs\n    ):\n        \"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n\n    def add_shp(\n        self,\n        filename: str,\n        layer_name: Optional[str] = None,\n        random_color_column: Optional[str] = None,\n        **kwargs\n    ):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n\n    def add_kml(\n        self,\n        filename: str,\n        layer_name: Optional[str] = None,\n        random_color_column: Optional[str] = None,\n        **kwargs\n    ):\n        \"\"\"Adds a KML file to the map.\n\n        Args:\n            filename (str): The input file path to the vector dataset.\n            layer_name (str, optional): The layer name to be used. Defaults to None.\n            random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided vector file could not be found.\n        \"\"\"\n        self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.__init__","title":"<code>__init__(self, center=(20, 0), zoom=1.2, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Center of the map in the format of (lat, lon). Defaults to (20, 0).</p> <code>(20, 0)</code> <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to 1.2.</p> <code>1.2</code> Source code in <code>leafmap/deck.py</code> <pre><code>def __init__(self, center=(20, 0), zoom=1.2, **kwargs):\n    \"\"\"Initialize a Map object.\n\n    Args:\n        center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n        zoom (int, optional): The map zoom level. Defaults to 1.2.\n    \"\"\"\n    if \"initial_view_state\" not in kwargs:\n        kwargs[\"initial_view_state\"] = pdk.ViewState(\n            latitude=center[0], longitude=center[1], zoom=zoom\n        )\n\n    if \"map_style\" not in kwargs:\n        kwargs[\"map_style\"] = \"light\"\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> Source code in <code>leafmap/deck.py</code> <pre><code>def add_basemap(self, basemap: str = \"HYBRID\"):\n    \"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str): Can be one of string from pydeck_basemaps. Defaults to 'HYBRID'.\n    \"\"\"\n    import xyzservices\n\n    try:\n        if isinstance(basemap, xyzservices.TileProvider):\n            name = basemap.name\n            url = basemap.build_url()\n            self.add_layer(url, name)\n\n        elif basemap in basemaps:\n            # Use pydeck_myTileLayer from https://github.com/agressin/pydeck_myTileLayer\n            pdk.settings.custom_libraries = [\n                {\n                    \"libraryName\": \"MyTileLayerLibrary\",\n                    \"resourceUri\": \"https://cdn.jsdelivr.net/gh/agressin/pydeck_myTileLayer@master/dist/bundle.js\",\n                }\n            ]\n\n            layer = pdk.Layer(\"MyTileLayer\", basemaps[basemap].url, basemap)\n\n            self.add_layer(layer)\n\n        else:\n            print(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    except Exception:\n        raise ValueError(\n            \"Basemap can only be one of the following:\\n  {}\".format(\n                \"\\n  \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_type='GeoJsonLayer', layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoPandas.GeoDataFrame</code> <p>The GeoPandas GeoDataFrame to add to the map.</p> required <code>layer_type</code> <code>str</code> <p>The layer type to be used. Defaults to \"GeoJsonLayer\".</p> <code>'GeoJsonLayer'</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>gdf must be a GeoPandas GeoDataFrame.</p> Source code in <code>leafmap/deck.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_type=\"GeoJsonLayer\",\n    layer_name: Optional[str] = None,\n    random_color_column: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoPandas.GeoDataFrame): The GeoPandas GeoDataFrame to add to the map.\n        layer_type (str, optional): The layer type to be used. Defaults to \"GeoJsonLayer\".\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        TypeError: gdf must be a GeoPandas GeoDataFrame.\n    \"\"\"\n\n    try:\n        import geopandas as gpd\n\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise TypeError(\"gdf must be a GeoPandas GeoDataFrame.\")\n\n        if layer_name is None:\n            layer_name = \"layer_\" + random_string(3)\n\n        if \"layer_type\" == \"GeoJsonLayer\":\n            if \"pickable\" not in kwargs:\n                kwargs[\"pickable\"] = True\n            if \"opacity\" not in kwargs:\n                kwargs[\"opacity\"] = 0.5\n            if \"stroked\" not in kwargs:\n                kwargs[\"stroked\"] = True\n            if \"filled\" not in kwargs:\n                kwargs[\"filled\"] = True\n            if \"extruded\" not in kwargs:\n                kwargs[\"extruded\"] = False\n            if \"wireframe\" not in kwargs:\n                kwargs[\"wireframe\"] = True\n            if \"get_line_color\" not in kwargs:\n                kwargs[\"get_line_color\"] = [0, 0, 0]\n            if \"get_line_width\" not in kwargs:\n                kwargs[\"get_line_width\"] = 2\n            if \"line_width_min_pixels\" not in kwargs:\n                kwargs[\"line_width_min_pixels\"] = 1\n\n        if random_color_column is not None:\n            if random_color_column not in gdf.columns.values.tolist():\n                raise ValueError(\n                    \"The random_color_column provided does not exist in the vector file.\"\n                )\n            color_lookup = pdk.data_utils.assign_random_colors(\n                gdf[random_color_column]\n            )\n            gdf[\"color\"] = gdf.apply(\n                lambda row: color_lookup.get(row[random_color_column]), axis=1\n            )\n            kwargs[\"get_fill_color\"] = \"color\"\n\n        layer = pdk.Layer(\n            layer_type,\n            gdf,\n            id=layer_name,\n            **kwargs,\n        )\n        self.add_layer(layer)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_geojson","title":"<code>add_geojson(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>leafmap/deck.py</code> <pre><code>def add_geojson(\n    self,\n    filename: str,\n    layer_name: Optional[str] = None,\n    random_color_column: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_kml","title":"<code>add_kml(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>leafmap/deck.py</code> <pre><code>def add_kml(\n    self,\n    filename: str,\n    layer_name: Optional[str] = None,\n    random_color_column: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"Adds a KML file to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_layer","title":"<code>add_layer(self, layer, layer_name=None, **kwargs)</code>","text":"<p>Add a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>pydeck.Layer</code> <p>A pydeck Layer object.</p> required Source code in <code>leafmap/deck.py</code> <pre><code>def add_layer(self, layer, layer_name: Optional[str] = None, **kwargs):\n    \"\"\"Add a layer to the map.\n\n    Args:\n        layer (pydeck.Layer): A pydeck Layer object.\n    \"\"\"\n\n    try:\n        if isinstance(layer, str) and layer.startswith(\"http\"):\n            pdk.settings.custom_libraries = [\n                {\n                    \"libraryName\": \"MyTileLayerLibrary\",\n                    \"resourceUri\": \"https://cdn.jsdelivr.net/gh/giswqs/pydeck_myTileLayer@master/dist/bundle.js\",\n                }\n            ]\n            layer = pdk.Layer(\"MyTileLayer\", layer, id=layer_name)\n\n        self.layers.append(layer)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_shp","title":"<code>add_shp(self, filename, layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>leafmap/deck.py</code> <pre><code>def add_shp(\n    self,\n    filename: str,\n    layer_name: Optional[str] = None,\n    random_color_column: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        filename (str): The input file path to the vector dataset.\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n    self.add_vector(filename, layer_name, random_color_column, **kwargs)\n</code></pre>"},{"location":"deck/#leafmap.deck.Map.add_vector","title":"<code>add_vector(self, data, layer_type='GeoJsonLayer', layer_name=None, random_color_column=None, **kwargs)</code>","text":"<p>Adds a vector file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The input file path to the vector dataset.</p> required <code>layer_type</code> <code>str</code> <p>The layer type to be used. Defaults to \"GeoJsonLayer\".</p> <code>'GeoJsonLayer'</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to None.</p> <code>None</code> <code>random_color_column</code> <code>str</code> <p>The column name to use for random color. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided vector file could not be found.</p> Source code in <code>leafmap/deck.py</code> <pre><code>def add_vector(\n    self,\n    data: str,\n    layer_type: str = \"GeoJsonLayer\",\n    layer_name: Optional[str] = None,\n    random_color_column: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"Adds a vector file to the map.\n\n    Args:\n        data (str): The input file path to the vector dataset.\n        layer_type (str, optional): The layer type to be used. Defaults to \"GeoJsonLayer\".\n        layer_name (str, optional): The layer name to be used. Defaults to None.\n        random_color_column (str, optional): The column name to use for random color. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided vector file could not be found.\n    \"\"\"\n\n    try:\n        import geopandas as gpd\n        import fiona\n\n        if isinstance(data, str):\n            if not data.startswith(\"http\"):\n                data = os.path.abspath(data)\n                if data.endswith(\".zip\"):\n                    data = \"zip://\" + data\n\n            if data.endswith(\".kml\"):\n                fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n                gdf = gpd.read_file(data, driver=\"KML\")\n            else:\n                gdf = gpd.read_file(data)\n        else:\n            gdf = data\n\n        self.add_gdf(gdf, layer_type, layer_name, random_color_column, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"deckgl/","title":"deckgl module","text":""},{"location":"deckgl/#leafmap.deckgl.Map","title":"<code> Map            (Map)         </code>","text":"<p>The Map class inherits lonboard.Map.</p> <p>Returns:</p> Type Description <code>object</code> <p>lonboard.Map object.</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>class Map(lonboard.Map):\n    \"\"\"The Map class inherits lonboard.Map.\n\n    Returns:\n        object: lonboard.Map object.\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (20, 0),\n        zoom: float = 1.2,\n        height: int = 600,\n        layers: List = [],\n        show_tooltip: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize a Map object.\n\n        Args:\n            center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n            zoom (float, optional): The map zoom level. Defaults to 1.2.\n            height (int, optional): Height of the map. Defaults to 600.\n            layers (list, optional): List of additional layers to add to the map. Defaults to [].\n            show_tooltip (bool, optional): Flag to show tooltips on the map. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to lonboard.Map.\n\n        Returns:\n            None\n        \"\"\"\n\n        kwargs[\"latitude\"] = center[0]\n        kwargs[\"longitude\"] = center[1]\n        kwargs[\"zoom\"] = zoom\n\n        super().__init__(\n            _height=height,\n            show_tooltip=show_tooltip,\n            layers=layers,\n            view_state=kwargs,\n        )\n\n    def add_gdf(\n        self,\n        gdf: gpd.GeoDataFrame,\n        zoom_to_layer: bool = True,\n        pickable: bool = True,\n        color_column: Optional[str] = None,\n        color_scheme: Optional[str] = \"Quantiles\",\n        color_map: Optional[Union[str, Dict]] = None,\n        color_k: Optional[int] = 5,\n        color_args: dict = {},\n        zoom: Optional[float] = 10.0,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame with geometry column.\n            zoom_to_layer (bool, optional): Flag to zoom to the added layer. Defaults to True.\n            pickable (bool, optional): Flag to enable picking on the added layer. Defaults to True.\n            color_column (Optional[str], optional): The column to be used for color encoding. Defaults to None.\n            color_map (Optional[Union[str, Dict]], optional): The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.\n            color_scheme (Optional[str], optional): The color scheme to use for color encoding. Defaults to \"Quantiles\".\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            color_k (Optional[int], optional): The number of classes to use for color encoding. Defaults to 5.\n            color_args (dict, optional): Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.\n            zoom (Optional[float], optional): The zoom level to zoom to. Defaults to 10.0.\n            **kwargs: Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()\n\n        Returns:\n            None\n        \"\"\"\n\n        from lonboard import ScatterplotLayer, PathLayer, SolidPolygonLayer\n\n        geom_type = gdf.geometry.iloc[0].geom_type\n        kwargs[\"pickable\"] = pickable\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            if \"get_radius\" not in kwargs:\n                kwargs[\"get_radius\"] = 10\n            if color_column is not None:\n                if isinstance(color_map, str):\n                    kwargs[\"get_fill_color\"] = assign_continuous_colors(\n                        gdf,\n                        color_column,\n                        color_map,\n                        scheme=color_scheme,\n                        k=color_k,\n                        **color_args,\n                    )\n                elif isinstance(color_map, dict):\n                    kwargs[\"get_fill_color\"] = assign_discrete_colors(\n                        gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                    )\n            if \"get_fill_color\" not in kwargs:\n                kwargs[\"get_fill_color\"] = [255, 0, 0, 180]\n            layer = ScatterplotLayer.from_geopandas(gdf, **kwargs)\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            if \"get_width\" not in kwargs:\n                kwargs[\"get_width\"] = 5\n            if color_column is not None:\n                if isinstance(color_map, str):\n                    kwargs[\"get_color\"] = assign_continuous_colors(\n                        gdf,\n                        color_column,\n                        color_map,\n                        scheme=color_scheme,\n                        k=color_k,\n                        **color_args,\n                    )\n                elif isinstance(color_map, dict):\n                    kwargs[\"get_color\"] = assign_discrete_colors(\n                        gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                    )\n            layer = PathLayer.from_geopandas(gdf, **kwargs)\n        elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n            if color_column is not None:\n                if isinstance(color_map, str):\n                    kwargs[\"get_fill_color\"] = assign_continuous_colors(\n                        gdf,\n                        color_column,\n                        color_map,\n                        scheme=color_scheme,\n                        k=color_k,\n                        **color_args,\n                    )\n                elif isinstance(color_map, dict):\n                    kwargs[\"get_fill_color\"] = assign_discrete_colors(\n                        gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                    )\n            if \"get_fill_color\" not in kwargs:\n                kwargs[\"get_fill_color\"] = [0, 0, 255, 128]\n            layer = SolidPolygonLayer.from_geopandas(gdf, **kwargs)\n\n        self.layers = self.layers + [layer]\n\n        if zoom_to_layer:\n            try:\n                bounds = gdf.total_bounds.tolist()\n                x = (bounds[0] + bounds[2]) / 2\n                y = (bounds[1] + bounds[3]) / 2\n\n                src_crs = gdf.crs\n                if src_crs is None:\n                    src_crs = \"EPSG:4326\"\n\n                lon, lat = convert_coordinates(x, y, src_crs, \"EPSG:4326\")\n\n                self.view_state = {\n                    \"latitude\": lat,\n                    \"longitude\": lon,\n                    \"zoom\": zoom,\n                }\n            except Exception as e:\n                print(e)\n\n    def add_vector(\n        self,\n        vector: Union[str, gpd.GeoDataFrame],\n        zoom_to_layer: bool = True,\n        pickable: bool = True,\n        color_column: Optional[str] = None,\n        color_scheme: Optional[str] = \"Quantiles\",\n        color_map: Optional[Union[str, Dict]] = None,\n        color_k: Optional[int] = 5,\n        color_args: dict = {},\n        open_args: dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Adds a vector layer to the map.\n\n        Args:\n            vector (Union[str, GeoDataFrame]): The file path or URL to the vector data, or a GeoDataFrame.\n            zoom_to_layer (bool, optional): Flag to zoom to the added layer. Defaults to True.\n            pickable (bool, optional): Flag to enable picking on the added layer. Defaults to True.\n            color_column (Optional[str], optional): The column to be used for color encoding. Defaults to None.\n            color_map (Optional[Union[str, Dict]], optional): The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.\n            color_scheme (Optional[str], optional): The color scheme to use for color encoding. Defaults to \"Quantiles\".\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            color_k (Optional[int], optional): The number of classes to use for color encoding. Defaults to 5.\n            color_args (dict, optional): Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.\n            open_args (dict, optional): Additional keyword arguments that will be passed to geopandas.read_file(). Defaults to {}.\n            **kwargs: Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()\n\n        Returns:\n            None\n        \"\"\"\n\n        if isinstance(vector, gpd.GeoDataFrame):\n            gdf = vector\n        else:\n            gdf = gpd.read_file(vector, **open_args)\n        self.add_gdf(\n            gdf,\n            zoom_to_layer,\n            pickable,\n            color_column,\n            color_scheme,\n            color_map,\n            color_k,\n            color_args,\n            **kwargs,\n        )\n\n    def add_layer(\n        self,\n        layer: Any,\n        zoom_to_layer: bool = True,\n        pickable: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Adds a layer to the map.\n\n        Args:\n            layer (Any): A lonboard layer object.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            pickable (bool, optional): Flag to enable picking on the added layer if it's a vector layer. Defaults to True.\n            **kwargs: Additional keyword arguments that will be passed to the vector layer if it's a vector layer.\n\n        Returns:\n            None\n        \"\"\"\n\n        from lonboard import ScatterplotLayer, PathLayer, SolidPolygonLayer\n\n        if type(layer) in [ScatterplotLayer, PathLayer, SolidPolygonLayer]:\n            self.layers = self.layers + [layer]\n\n            if zoom_to_layer:\n                from lonboard._viewport import compute_view\n\n                try:\n                    self.view_state = compute_view([self.layers[-1].table])\n                except Exception as e:\n                    print(e)\n        else:\n            self.add_vector(\n                layer, zoom_to_layer=zoom_to_layer, pickable=pickable, **kwargs\n            )\n\n    def to_html(self, filename: Optional[str] = None) -&gt; None:\n        \"\"\"Saves the map as an HTML file.\n\n        Args:\n            filename (Optional[str], optional): The output file path to the HTML file. Defaults to None.\n\n        Returns:\n            str: The HTML content if filename is None.\n        \"\"\"\n\n        if filename is None:\n            filename = temp_file_path(\"html\")\n            super().to_html(filename)\n            with open(filename) as f:\n                html = f.read()\n            return html\n        else:\n            super().to_html(filename)\n\n    def to_streamlit(\n        self,\n        width: Optional[int] = None,\n        height: Optional[int] = 600,\n        scrolling: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Renders `deckgl.Map`in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to None.\n            height (int, optional): Height of the map. Defaults to 600.\n            scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n\n            return components.html(\n                self.to_html(), width=width, height=height, scrolling=scrolling\n            )\n\n        except Exception as e:\n            raise e\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.__init__","title":"<code>__init__(self, center=(20, 0), zoom=1.2, height=600, layers=[], show_tooltip=True, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Center of the map in the format of (lat, lon). Defaults to (20, 0).</p> <code>(20, 0)</code> <code>zoom</code> <code>float</code> <p>The map zoom level. Defaults to 1.2.</p> <code>1.2</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>layers</code> <code>list</code> <p>List of additional layers to add to the map. Defaults to [].</p> <code>[]</code> <code>show_tooltip</code> <code>bool</code> <p>Flag to show tooltips on the map. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to lonboard.Map.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (20, 0),\n    zoom: float = 1.2,\n    height: int = 600,\n    layers: List = [],\n    show_tooltip: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialize a Map object.\n\n    Args:\n        center (tuple, optional): Center of the map in the format of (lat, lon). Defaults to (20, 0).\n        zoom (float, optional): The map zoom level. Defaults to 1.2.\n        height (int, optional): Height of the map. Defaults to 600.\n        layers (list, optional): List of additional layers to add to the map. Defaults to [].\n        show_tooltip (bool, optional): Flag to show tooltips on the map. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to lonboard.Map.\n\n    Returns:\n        None\n    \"\"\"\n\n    kwargs[\"latitude\"] = center[0]\n    kwargs[\"longitude\"] = center[1]\n    kwargs[\"zoom\"] = zoom\n\n    super().__init__(\n        _height=height,\n        show_tooltip=show_tooltip,\n        layers=layers,\n        view_state=kwargs,\n    )\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.add_gdf","title":"<code>add_gdf(self, gdf, zoom_to_layer=True, pickable=True, color_column=None, color_scheme='Quantiles', color_map=None, color_k=5, color_args={}, zoom=10.0, **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame with geometry column.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Flag to zoom to the added layer. Defaults to True.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Flag to enable picking on the added layer. Defaults to True.</p> <code>True</code> <code>color_column</code> <code>Optional[str]</code> <p>The column to be used for color encoding. Defaults to None.</p> <code>None</code> <code>color_map</code> <code>Optional[Union[str, Dict]]</code> <p>The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.</p> <code>None</code> <code>color_scheme</code> <code>Optional[str]</code> <p>The color scheme to use for color encoding. Defaults to \"Quantiles\". Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>color_k</code> <code>Optional[int]</code> <p>The number of classes to use for color encoding. Defaults to 5.</p> <code>5</code> <code>color_args</code> <code>dict</code> <p>Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.</p> <code>{}</code> <code>zoom</code> <code>Optional[float]</code> <p>The zoom level to zoom to. Defaults to 10.0.</p> <code>10.0</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def add_gdf(\n    self,\n    gdf: gpd.GeoDataFrame,\n    zoom_to_layer: bool = True,\n    pickable: bool = True,\n    color_column: Optional[str] = None,\n    color_scheme: Optional[str] = \"Quantiles\",\n    color_map: Optional[Union[str, Dict]] = None,\n    color_k: Optional[int] = 5,\n    color_args: dict = {},\n    zoom: Optional[float] = 10.0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Adds a GeoPandas GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame with geometry column.\n        zoom_to_layer (bool, optional): Flag to zoom to the added layer. Defaults to True.\n        pickable (bool, optional): Flag to enable picking on the added layer. Defaults to True.\n        color_column (Optional[str], optional): The column to be used for color encoding. Defaults to None.\n        color_map (Optional[Union[str, Dict]], optional): The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.\n        color_scheme (Optional[str], optional): The color scheme to use for color encoding. Defaults to \"Quantiles\".\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        color_k (Optional[int], optional): The number of classes to use for color encoding. Defaults to 5.\n        color_args (dict, optional): Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.\n        zoom (Optional[float], optional): The zoom level to zoom to. Defaults to 10.0.\n        **kwargs: Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()\n\n    Returns:\n        None\n    \"\"\"\n\n    from lonboard import ScatterplotLayer, PathLayer, SolidPolygonLayer\n\n    geom_type = gdf.geometry.iloc[0].geom_type\n    kwargs[\"pickable\"] = pickable\n\n    if geom_type in [\"Point\", \"MultiPoint\"]:\n        if \"get_radius\" not in kwargs:\n            kwargs[\"get_radius\"] = 10\n        if color_column is not None:\n            if isinstance(color_map, str):\n                kwargs[\"get_fill_color\"] = assign_continuous_colors(\n                    gdf,\n                    color_column,\n                    color_map,\n                    scheme=color_scheme,\n                    k=color_k,\n                    **color_args,\n                )\n            elif isinstance(color_map, dict):\n                kwargs[\"get_fill_color\"] = assign_discrete_colors(\n                    gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                )\n        if \"get_fill_color\" not in kwargs:\n            kwargs[\"get_fill_color\"] = [255, 0, 0, 180]\n        layer = ScatterplotLayer.from_geopandas(gdf, **kwargs)\n    elif geom_type in [\"LineString\", \"MultiLineString\"]:\n        if \"get_width\" not in kwargs:\n            kwargs[\"get_width\"] = 5\n        if color_column is not None:\n            if isinstance(color_map, str):\n                kwargs[\"get_color\"] = assign_continuous_colors(\n                    gdf,\n                    color_column,\n                    color_map,\n                    scheme=color_scheme,\n                    k=color_k,\n                    **color_args,\n                )\n            elif isinstance(color_map, dict):\n                kwargs[\"get_color\"] = assign_discrete_colors(\n                    gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                )\n        layer = PathLayer.from_geopandas(gdf, **kwargs)\n    elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n        if color_column is not None:\n            if isinstance(color_map, str):\n                kwargs[\"get_fill_color\"] = assign_continuous_colors(\n                    gdf,\n                    color_column,\n                    color_map,\n                    scheme=color_scheme,\n                    k=color_k,\n                    **color_args,\n                )\n            elif isinstance(color_map, dict):\n                kwargs[\"get_fill_color\"] = assign_discrete_colors(\n                    gdf, color_column, color_map, to_rgb=True, return_type=\"array\"\n                )\n        if \"get_fill_color\" not in kwargs:\n            kwargs[\"get_fill_color\"] = [0, 0, 255, 128]\n        layer = SolidPolygonLayer.from_geopandas(gdf, **kwargs)\n\n    self.layers = self.layers + [layer]\n\n    if zoom_to_layer:\n        try:\n            bounds = gdf.total_bounds.tolist()\n            x = (bounds[0] + bounds[2]) / 2\n            y = (bounds[1] + bounds[3]) / 2\n\n            src_crs = gdf.crs\n            if src_crs is None:\n                src_crs = \"EPSG:4326\"\n\n            lon, lat = convert_coordinates(x, y, src_crs, \"EPSG:4326\")\n\n            self.view_state = {\n                \"latitude\": lat,\n                \"longitude\": lon,\n                \"zoom\": zoom,\n            }\n        except Exception as e:\n            print(e)\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.add_layer","title":"<code>add_layer(self, layer, zoom_to_layer=True, pickable=True, **kwargs)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Any</code> <p>A lonboard layer object.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Flag to enable picking on the added layer if it's a vector layer. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that will be passed to the vector layer if it's a vector layer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def add_layer(\n    self,\n    layer: Any,\n    zoom_to_layer: bool = True,\n    pickable: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Adds a layer to the map.\n\n    Args:\n        layer (Any): A lonboard layer object.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        pickable (bool, optional): Flag to enable picking on the added layer if it's a vector layer. Defaults to True.\n        **kwargs: Additional keyword arguments that will be passed to the vector layer if it's a vector layer.\n\n    Returns:\n        None\n    \"\"\"\n\n    from lonboard import ScatterplotLayer, PathLayer, SolidPolygonLayer\n\n    if type(layer) in [ScatterplotLayer, PathLayer, SolidPolygonLayer]:\n        self.layers = self.layers + [layer]\n\n        if zoom_to_layer:\n            from lonboard._viewport import compute_view\n\n            try:\n                self.view_state = compute_view([self.layers[-1].table])\n            except Exception as e:\n                print(e)\n    else:\n        self.add_vector(\n            layer, zoom_to_layer=zoom_to_layer, pickable=pickable, **kwargs\n        )\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.add_vector","title":"<code>add_vector(self, vector, zoom_to_layer=True, pickable=True, color_column=None, color_scheme='Quantiles', color_map=None, color_k=5, color_args={}, open_args={}, **kwargs)</code>","text":"<p>Adds a vector layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>Union[str, GeoDataFrame]</code> <p>The file path or URL to the vector data, or a GeoDataFrame.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Flag to zoom to the added layer. Defaults to True.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Flag to enable picking on the added layer. Defaults to True.</p> <code>True</code> <code>color_column</code> <code>Optional[str]</code> <p>The column to be used for color encoding. Defaults to None.</p> <code>None</code> <code>color_map</code> <code>Optional[Union[str, Dict]]</code> <p>The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.</p> <code>None</code> <code>color_scheme</code> <code>Optional[str]</code> <p>The color scheme to use for color encoding. Defaults to \"Quantiles\". Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>color_k</code> <code>Optional[int]</code> <p>The number of classes to use for color encoding. Defaults to 5.</p> <code>5</code> <code>color_args</code> <code>dict</code> <p>Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional keyword arguments that will be passed to geopandas.read_file(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def add_vector(\n    self,\n    vector: Union[str, gpd.GeoDataFrame],\n    zoom_to_layer: bool = True,\n    pickable: bool = True,\n    color_column: Optional[str] = None,\n    color_scheme: Optional[str] = \"Quantiles\",\n    color_map: Optional[Union[str, Dict]] = None,\n    color_k: Optional[int] = 5,\n    color_args: dict = {},\n    open_args: dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Adds a vector layer to the map.\n\n    Args:\n        vector (Union[str, GeoDataFrame]): The file path or URL to the vector data, or a GeoDataFrame.\n        zoom_to_layer (bool, optional): Flag to zoom to the added layer. Defaults to True.\n        pickable (bool, optional): Flag to enable picking on the added layer. Defaults to True.\n        color_column (Optional[str], optional): The column to be used for color encoding. Defaults to None.\n        color_map (Optional[Union[str, Dict]], optional): The color map to use for color encoding. It can be a string or a dictionary. Defaults to None.\n        color_scheme (Optional[str], optional): The color scheme to use for color encoding. Defaults to \"Quantiles\".\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        color_k (Optional[int], optional): The number of classes to use for color encoding. Defaults to 5.\n        color_args (dict, optional): Additional keyword arguments that will be passed to assign_continuous_colors(). Defaults to {}.\n        open_args (dict, optional): Additional keyword arguments that will be passed to geopandas.read_file(). Defaults to {}.\n        **kwargs: Additional keyword arguments that will be passed to lonboard.Layer.from_geopandas()\n\n    Returns:\n        None\n    \"\"\"\n\n    if isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n    else:\n        gdf = gpd.read_file(vector, **open_args)\n    self.add_gdf(\n        gdf,\n        zoom_to_layer,\n        pickable,\n        color_column,\n        color_scheme,\n        color_map,\n        color_k,\n        color_args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.to_html","title":"<code>to_html(self, filename=None)</code>","text":"<p>Saves the map as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Optional[str]</code> <p>The output file path to the HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML content if filename is None.</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def to_html(self, filename: Optional[str] = None) -&gt; None:\n    \"\"\"Saves the map as an HTML file.\n\n    Args:\n        filename (Optional[str], optional): The output file path to the HTML file. Defaults to None.\n\n    Returns:\n        str: The HTML content if filename is None.\n    \"\"\"\n\n    if filename is None:\n        filename = temp_file_path(\"html\")\n        super().to_html(filename)\n        with open(filename) as f:\n            html = f.read()\n        return html\n    else:\n        super().to_html(filename)\n</code></pre>"},{"location":"deckgl/#leafmap.deckgl.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, **kwargs)</code>","text":"<p>Renders <code>deckgl.Map</code>in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/deckgl.py</code> <pre><code>def to_streamlit(\n    self,\n    width: Optional[int] = None,\n    height: Optional[int] = 600,\n    scrolling: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Renders `deckgl.Map`in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        return components.html(\n            self.to_html(), width=width, height=height, scrolling=scrolling\n        )\n\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"examples/","title":"examples module","text":""},{"location":"examples/#leafmap.examples.get_links","title":"<code>get_links()</code>","text":"<p>Get a list of HTTP URLs to the example datasets.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of HTTP URLs to the example datasets.</p> Source code in <code>leafmap/examples/__init__.py</code> <pre><code>def get_links():\n    \"\"\"Get a list of HTTP URLs to the example datasets.\n\n    Returns:\n        list: A list of HTTP URLs to the example datasets.\n    \"\"\"\n\n    return list(datasets.values())\n</code></pre>"},{"location":"examples/#leafmap.examples.get_names","title":"<code>get_names()</code>","text":"<p>Get a list of names of the example datasets.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of names of the example datasets.</p> Source code in <code>leafmap/examples/__init__.py</code> <pre><code>def get_names():\n    \"\"\"Get a list of names of the example datasets.\n\n    Returns:\n        list: A list of names of the example datasets.\n    \"\"\"\n\n    return list(datasets.keys())\n</code></pre>"},{"location":"examples/#leafmap.examples.get_path","title":"<code>get_path(name)</code>","text":"<p>Get the HTTP URL to an example dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the dataset name is not found.</p> <p>Returns:</p> Type Description <code>str</code> <p>The HTTP URL to the dataset.</p> Source code in <code>leafmap/examples/__init__.py</code> <pre><code>def get_path(name):\n    \"\"\"Get the HTTP URL to an example dataset.\n\n    Args:\n        name (str): The name of the dataset.\n\n    Raises:\n        ValueError: If the dataset name is not found.\n\n    Returns:\n        str: The HTTP URL to the dataset.\n    \"\"\"\n    if name in datasets:\n        return datasets[name]\n    else:\n        raise ValueError(\n            f\"{name} not found in example datasets. It must be one of {list(datasets.keys())}\"\n        )\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-do-i-report-an-issue-or-make-a-feature-request","title":"How do I report an issue or make a feature request","text":"<p>Please go to https://github.com/opengeos/leafmap/issues.</p>"},{"location":"faq/#whats-the-difference-between-folium-and-ipyleaflet","title":"What's the difference between folium and ipyleaflet","text":"<p>A key difference between ipyleaflet and folium is that ipyleaflet is built upon ipywidgets and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input, while folium is meant for displaying static data only (source). Note that Google Colab currently does not support ipyleaflet (source). Therefore, if you are using leafmap with Google Colab, <code>import leafmap</code> will automatically use the <code>folium</code> plotting backend. If you are using leafmap with Jupyter installed locally, <code>import leafmap</code> will automatically use the `ipyleaflet', which provides more functionalities for capturing user input (e.g., mouse-clicking and moving).</p>"},{"location":"faq/#how-to-use-a-specific-plotting-backend","title":"How to use a specific plotting backend","text":"<p><code>leafmap</code> has three plotting backends: folium, ipyleaflet, and here-map-widget-for-jupyter. If you are using <code>leafmap</code> with Jupyter installed locally, <code>import leafmap</code> will use the <code>ipyleaflet</code> plotting backend by default. If you are using <code>leafmap</code> with Google Colab, <code>import leafmap</code> will use the <code>folium</code> plotting backend by default. Note that Google Colab does not yet support <code>ipyleaflet</code> (source). Therefore, you won't be able to access the <code>leafmap</code> toolbar in Colab. Note that the backends do not offer equal functionality. Some interactive functionality in <code>ipyleaflet</code> might not be available in <code>folium</code> or <code>heremap</code>. To use a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> </ul>"},{"location":"faq/#why-the-interactive-map-does-not-show-up","title":"Why the interactive map does not show up","text":"<p>If the interactive map does not show up on Jupyter Notebook and JupyterLab, it is probably because the ipyleaflet extension is not installed properly. For example, you might receive an error message saying <code>Error displaying widget: model not found</code>. This a well-known issue related to ipyleaflet. See some relevant issues below.</p> <ul> <li>How to display map object using ipyleaflet in jupyter notebook or jupyter Lab</li> <li>ipyleaflet does not work in jupyter lab - \"Error displaying widget: model not found\"</li> <li>Error displaying widget: model not found</li> </ul> <p>Try some of the options below to resolve the issue. If the issue persists after trying these steps, you can open an issue on the ipyleaflet repository.</p> <p>For Jupyter notebook, try running the following two commands within your leafmap conda environment:</p> <pre><code>jupyter nbextension install --py --symlink --sys-prefix ipyleaflet\njupyter nbextension enable --py --sys-prefix ipyleaflet\n</code></pre> <p>For JupyterLab, try running the following command within your leafmap conda environment:</p> <pre><code>jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter-leaflet\n</code></pre> <p>Alternatively, you can run leafmap directly using binder:</p> <ul> <li>https://mybinder.org/v2/gh/opengeos/leafmap/HEAD</li> <li>https://mybinder.org/v2/gh/opengeos/leafmap/HEAD</li> </ul>"},{"location":"faq/#how-to-use-leafmap-in-countries-where-google-services-are-blocked","title":"How to use leafmap in countries where Google Services are blocked","text":"<p>If you are trying to use leafmap in countries where Google Services are blocked (e.g., China), you will need a VPN. Use <code>leafmap.set_proxy(port=your-port-number)</code> to connect to Google servers. Otherwise, you might encounter a connection timeout issue.</p> <pre><code>import leafmap\nleafmap.set_proxy(port=your-port-number)\nm = leafmap.Map()\nm\n</code></pre>"},{"location":"foliumap/","title":"foliumap module","text":""},{"location":"foliumap/#leafmap.foliumap.CustomControl","title":"<code> CustomControl            (MacroElement)         </code>","text":"<p>Put any HTML on the map as a Leaflet Control. Adopted from https://github.com/python-visualization/folium/pull/1662</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class CustomControl(MacroElement):\n    \"\"\"Put any HTML on the map as a Leaflet Control.\n    Adopted from https://github.com/python-visualization/folium/pull/1662\n\n    \"\"\"\n\n    _template = Template(\n        \"\"\"\n        {% macro script(this, kwargs) %}\n        L.Control.CustomControl = L.Control.extend({\n            onAdd: function(map) {\n                let div = L.DomUtil.create('div');\n                div.innerHTML = `{{ this.html }}`;\n                return div;\n            },\n            onRemove: function(map) {\n                // Nothing to do here\n            }\n        });\n        L.control.customControl = function(opts) {\n            return new L.Control.CustomControl(opts);\n        }\n        L.control.customControl(\n            { position: \"{{ this.position }}\" }\n        ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n    \"\"\"\n    )\n\n    def __init__(self, html, position=\"bottomleft\"):\n        def escape_backticks(text):\n            \"\"\"Escape backticks so text can be used in a JS template.\"\"\"\n            import re\n\n            return re.sub(r\"(?&lt;!\\\\)`\", r\"\\`\", text)\n\n        super().__init__()\n        self.html = escape_backticks(html)\n        self.position = position\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.FloatText","title":"<code> FloatText            (MacroElement)         </code>","text":"<p>Adds a floating image in HTML canvas on top of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class FloatText(MacroElement):\n    \"\"\"Adds a floating image in HTML canvas on top of the map.\"\"\"\n\n    _template = Template(\n        \"\"\"\n            {% macro header(this,kwargs) %}\n                &lt;style&gt;\n                    #{{this.get_name()}} {\n                        position:absolute;\n                        bottom:{{this.bottom}}%;\n                        left:{{this.left}}%;\n                        }\n                &lt;/style&gt;\n            {% endmacro %}\n\n            {% macro html(this, kwargs) %}\n\n            &lt;!doctype html&gt;\n            &lt;html lang=\"en\"&gt;\n            &lt;head&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n\n            &lt;div id='{{this.get_name()}}' class='{{this.get_name()}}'\n                style='position: absolute; z-index:9999; border:2px solid grey; background-color:rgba(255, 255, 255, 0.8);\n                border-radius:5px; padding: 5px; font-size:14px; '&gt;\n\n            &lt;div class='text'&gt;{{this.text}}&lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;/body&gt;\n            &lt;/html&gt;\n\n            &lt;style type='text/css'&gt;\n            .{{this.get_name()}} .text {\n                text-align: left;\n                margin-bottom: 0px;\n                font-size: 90%;\n                float: left;\n                }\n            &lt;/style&gt;\n            {% endmacro %}\n            \"\"\"\n    )\n\n    def __init__(self, text, bottom=75, left=75):\n        super(FloatText, self).__init__()\n        self._name = \"FloatText\"\n        self.text = text\n        self.bottom = bottom\n        self.left = left\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map","title":"<code> Map            (Map)         </code>","text":"<p>The Map class inherits folium.Map. By default, the Map will add OpenStreetMap as the basemap.</p> <p>Returns:</p> Type Description <code>object</code> <p>folium map object.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"The Map class inherits folium.Map. By default, the Map will add OpenStreetMap as the basemap.\n\n    Returns:\n        object: folium map object.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        # Default map center location and zoom level\n        latlon = [20, 0]\n        zoom = 2\n\n        # Interchangeable parameters between ipyleaflet and folium\n        if \"center\" in kwargs:\n            kwargs[\"location\"] = kwargs[\"center\"]\n            kwargs.pop(\"center\")\n        if \"location\" in kwargs:\n            latlon = kwargs[\"location\"]\n        else:\n            kwargs[\"location\"] = latlon\n\n        if \"zoom\" in kwargs:\n            kwargs[\"zoom_start\"] = kwargs[\"zoom\"]\n            kwargs.pop(\"zoom\")\n        if \"zoom_start\" in kwargs:\n            zoom = kwargs[\"zoom_start\"]\n        else:\n            kwargs[\"zoom_start\"] = zoom\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 24\n\n        if \"scale_control\" not in kwargs:\n            kwargs[\"scale_control\"] = True\n\n        if kwargs[\"scale_control\"]:\n            kwargs[\"control_scale\"] = True\n            kwargs.pop(\"scale_control\")\n\n        # if \"control_scale\" not in kwargs:\n        #     kwargs[\"control_scale\"] = True\n\n        if \"draw_export\" not in kwargs:\n            kwargs[\"draw_export\"] = False\n\n        if \"height\" in kwargs and isinstance(kwargs[\"height\"], str):\n            kwargs[\"height\"] = float(kwargs[\"height\"].replace(\"px\", \"\"))\n\n        if (\n            \"width\" in kwargs\n            and isinstance(kwargs[\"width\"], str)\n            and (\"%\" not in kwargs[\"width\"])\n        ):\n            kwargs[\"width\"] = float(kwargs[\"width\"].replace(\"px\", \"\"))\n\n        height = None\n        width = None\n\n        if \"height\" in kwargs:\n            height = kwargs.pop(\"height\")\n        else:\n            height = 600\n\n        if \"width\" in kwargs:\n            width = kwargs.pop(\"width\")\n        else:\n            width = \"100%\"\n\n        super().__init__(**kwargs)\n        self.baseclass = \"folium\"\n\n        if (height is not None) or (width is not None):\n            f = folium.Figure(width=width, height=height)\n            self.add_to(f)\n\n        if \"fullscreen_control\" not in kwargs:\n            kwargs[\"fullscreen_control\"] = True\n        if kwargs[\"fullscreen_control\"]:\n            plugins.Fullscreen().add_to(self)\n\n        if \"draw_control\" not in kwargs:\n            kwargs[\"draw_control\"] = True\n        if kwargs[\"draw_control\"]:\n            plugins.Draw(export=kwargs.get(\"draw_export\")).add_to(self)\n\n        if \"measure_control\" not in kwargs:\n            kwargs[\"measure_control\"] = True\n        if kwargs[\"measure_control\"]:\n            plugins.MeasureControl(position=\"bottomleft\").add_to(self)\n\n        if \"latlon_control\" not in kwargs:\n            kwargs[\"latlon_control\"] = False\n        if kwargs[\"latlon_control\"]:\n            folium.LatLngPopup().add_to(self)\n\n        if \"locate_control\" not in kwargs:\n            kwargs[\"locate_control\"] = False\n        if kwargs[\"locate_control\"]:\n            plugins.LocateControl().add_to(self)\n\n        if \"minimap_control\" not in kwargs:\n            kwargs[\"minimap_control\"] = False\n        if kwargs[\"minimap_control\"]:\n            plugins.MiniMap().add_to(self)\n\n        if \"search_control\" not in kwargs:\n            kwargs[\"search_control\"] = True\n        if kwargs[\"search_control\"]:\n            plugins.Geocoder(collapsed=True, position=\"topleft\").add_to(self)\n\n        if \"google_map\" not in kwargs:\n            pass\n        elif kwargs[\"google_map\"] is not None:\n            if kwargs[\"google_map\"].upper() == \"ROADMAP\":\n                layer = basemaps[\"ROADMAP\"]\n            elif kwargs[\"google_map\"].upper() == \"HYBRID\":\n                layer = basemaps[\"HYBRID\"]\n            elif kwargs[\"google_map\"].upper() == \"TERRAIN\":\n                layer = basemaps[\"TERRAIN\"]\n            elif kwargs[\"google_map\"].upper() == \"SATELLITE\":\n                layer = basemaps[\"SATELLITE\"]\n            else:\n                print(\n                    f'{kwargs[\"google_map\"]} is invalid. google_map must be one of: [\"ROADMAP\", \"HYBRID\", \"TERRAIN\", \"SATELLITE\"]. Adding the default ROADMAP.'\n                )\n                layer = basemaps[\"ROADMAP\"]\n            layer.add_to(self)\n\n        if \"layers_control\" not in kwargs:\n            self.options[\"layersControl\"] = True\n        else:\n            self.options[\"layersControl\"] = kwargs[\"layers_control\"]\n\n        self.fit_bounds([latlon, latlon], max_zoom=zoom)\n\n    def add(self, object, **kwargs):\n        \"\"\"Adds something to the map. This method is not implemented in folium.\"\"\"\n        pass\n\n    def add_layer(self, layer):\n        \"\"\"Adds a layer to the map.\n\n        Args:\n            layer (TileLayer): A TileLayer instance.\n        \"\"\"\n        layer.add_to(self)\n\n    def add_ee_layer(\n        self,\n        asset_id: str,\n        name: str = None,\n        attribution: str = \"Google Earth Engine\",\n        shown: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n            https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n        Args:\n            asset_id (str): The ID of the Earth Engine asset.\n            name (str, optional): The name of the tile layer. If not provided, the asset ID will be used. Default is None.\n            attribution (str, optional): The attribution text to be displayed. Default is \"Google Earth Engine\".\n            shown (bool, optional): Whether the tile layer should be shown on the map. Default is True.\n            opacity (float, optional): The opacity of the tile layer. Default is 1.0.\n            **kwargs: Additional keyword arguments to be passed to the underlying `add_tile_layer` method.\n\n        Returns:\n            None\n        \"\"\"\n        import pandas as pd\n\n        df = pd.read_csv(\n            \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n            sep=\"\\t\",\n        )\n\n        asset_id = asset_id.strip()\n        if name is None:\n            name = asset_id\n\n        if asset_id in df[\"id\"].values:\n            url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n            self.add_tile_layer(\n                url,\n                name,\n                attribution=attribution,\n                shown=shown,\n                opacity=opacity,\n                **kwargs,\n            )\n        else:\n            print(f\"The provided EE tile layer {asset_id} does not exist.\")\n\n    def add_pmtiles(\n        self,\n        url,\n        style=None,\n        name=None,\n        tooltip=True,\n        overlay=True,\n        control=True,\n        show=True,\n        zoom_to_layer=True,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a PMTiles layer to the map.\n\n        Args:\n            url (str): The URL of the PMTiles file.\n            style (str, optional): The CSS style to apply to the layer. Defaults to None.\n                See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n            name (str, optional): The name of the layer. Defaults to None.\n            tooltip (bool, optional): Whether to show a tooltip when hovering over the layer. Defaults to True.\n            overlay (bool, optional): Whether the layer should be added as an overlay. Defaults to True.\n            control (bool, optional): Whether to include the layer in the layer control. Defaults to True.\n            show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n        Returns:\n            None\n        \"\"\"\n\n        try:\n            if style is None:\n                style = pmtiles_style(url)\n            layer = PMTilesLayer(\n                url,\n                style=style,\n                name=name,\n                tooltip=tooltip,\n                overlay=overlay,\n                control=control,\n                show=show,\n                **kwargs,\n            )\n            self.add_child(layer)\n\n            if zoom_to_layer:\n                metadata = pmtiles_metadata(url)\n                bounds = metadata[\"bounds\"]\n                self.zoom_to_bounds(bounds)\n        except Exception as e:\n            print(e)\n\n    def add_layer_control(self):\n        \"\"\"Adds layer control to the map.\"\"\"\n        layer_ctrl = False\n        for item in self.to_dict()[\"children\"]:\n            if item.startswith(\"layer_control\"):\n                layer_ctrl = True\n                break\n        if not layer_ctrl:\n            folium.LayerControl().add_to(self)\n\n    def _repr_mimebundle_(self, **kwargs):\n        \"\"\"Adds Layer control to the map. Reference: https://ipython.readthedocs.io/en/stable/config/integrating.html#MyObject._repr_mimebundle_\"\"\"\n        if self.options[\"layersControl\"]:\n            self.add_layer_control()\n\n    def set_center(self, lon: float, lat: float, zoom: Optional[int] = 10):\n        \"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n        Args:\n            lon (float): The longitude of the center, in degrees.\n            lat (float): The latitude of the center, in degrees.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10.\n        \"\"\"\n        self.fit_bounds([[lat, lon], [lat, lon]], max_zoom=zoom)\n\n        arc_zoom_to_extent(lon, lat, lon, lat)\n\n    def zoom_to_bounds(\n        self, bounds: Union[List[float], Tuple[float, float, float, float]]\n    ):\n        \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n        Args:\n            bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n        \"\"\"\n        #  The folium fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def zoom_to_gdf(self, gdf):\n        \"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        \"\"\"\n        bounds = gdf.total_bounds\n        self.zoom_to_bounds(bounds)\n\n    def add_basemap(\n        self, basemap: Optional[str] = \"HYBRID\", show: Optional[bool] = True, **kwargs\n    ):\n        \"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'.\n            show (bool, optional): Whether to show the basemap. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to folium.TileLayer.\n        \"\"\"\n        import xyzservices\n\n        try:\n            if basemap in [\"ROADMAP\", \"SATELLITE\", \"HYBRID\", \"TERRAIN\"]:\n                layer = get_google_map(basemap, backend=\"folium\", show=show, **kwargs)\n                layer.add_to(self)\n                return\n\n            if isinstance(basemap, xyzservices.TileProvider):\n                name = basemap.name\n                url = basemap.build_url()\n                attribution = basemap.attribution\n                if \"max_zoom\" in basemap.keys():\n                    max_zoom = basemap[\"max_zoom\"]\n                else:\n                    max_zoom = 22\n                layer = folium.TileLayer(\n                    tiles=url,\n                    attr=attribution,\n                    name=name,\n                    max_zoom=max_zoom,\n                    overlay=True,\n                    control=True,\n                    show=show,\n                    **kwargs,\n                )\n\n                self.add_layer(layer)\n\n                arc_add_layer(url, name)\n\n            elif basemap in basemaps:\n                bmap = basemaps[basemap]\n                bmap.show = show\n                bmap.add_to(self)\n                if isinstance(basemaps[basemap], folium.TileLayer):\n                    url = basemaps[basemap].tiles\n                elif isinstance(basemaps[basemap], folium.WmsTileLayer):\n                    url = basemaps[basemap].url\n                arc_add_layer(url, basemap)\n            else:\n                print(\n                    \"Basemap can only be one of the following: {}\".format(\n                        \", \".join(basemaps.keys())\n                    )\n                )\n\n        except Exception:\n            raise Exception(\n                \"Basemap can only be one of the following: {}\".format(\n                    \", \".join(basemaps.keys())\n                )\n            )\n\n    def add_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        attribution: Optional[str] = \"\",\n        overlay: Optional[bool] = True,\n        control: Optional[bool] = True,\n        shown: Optional[bool] = True,\n        format: Optional[str] = \"image/png\",\n        transparent: Optional[bool] = True,\n        version: Optional[str] = \"1.1.1\",\n        styles: Optional[str] = \"\",\n        **kwargs,\n    ):\n        \"\"\"Add a WMS layer to the map.\n\n        Args:\n            url (str): The URL of the WMS web service.\n            layers (str): Comma-separated list of WMS layers to show.\n            name (str, optional): The layer name to use on the layer control. Defaults to None.\n            attribution (str, optional): The attribution of the data layer. Defaults to ''.\n            overlay (bool, optional): Allows overlay. Defaults to True.\n            control (bool, optional): Adds the layer to the layer control. Defaults to True.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n            transparent (bool, optional): Whether the layer shall allow transparency. Defaults to True.\n            version (str, optional): Version of the WMS service to use. Defaults to \"1.1.1\".\n            styles (str, optional): Comma-separated list of WMS styles. Defaults to \"\".\n        \"\"\"\n        try:\n            folium.raster_layers.WmsTileLayer(\n                url=url,\n                layers=layers,\n                name=name,\n                attr=attribution,\n                overlay=overlay,\n                control=control,\n                show=shown,\n                styles=styles,\n                fmt=format,\n                transparent=transparent,\n                version=version,\n                **kwargs,\n            ).add_to(self)\n        except Exception as e:\n            raise Exception(e)\n\n    def add_wms_legend(\n        self,\n        url,\n    ):\n        \"\"\"Add a WMS legend based on an image URL\n\n        Args:\n            url (str): URL of the WMS legend image. Should have this format if using wms legend: {geoserver}/wms?REQUEST=GetLegendGraphic&amp;FORMAT=image/png&amp;LAYER={layer}\n        \"\"\"\n        from branca.element import Figure, MacroElement, Element\n\n        # Check if the map is a Folium Map instance\n        if not isinstance(self, Map):\n            raise ValueError(\"The self argument must be an instance of folium.Map.\")\n\n        # HTML template for the legend\n        legend_html = f\"\"\"\n            {{% macro html(this, kwargs) %}}\n\n            &lt;div id=\"maplegend\" style=\"position: fixed;\n                        bottom: 50px;\n                        right: 50px;\n                        z-index:9999;\n                        \"&gt;\n                &lt;img src=\"{ url }\" alt=\"legend\" style=\"width: 100%; height: 100%;\"&gt;\n            &lt;/div&gt;\n            {{% endmacro %}}\n        \"\"\"\n\n        # Create an Element with the HTML and add it to the map\n        macro = MacroElement()\n        macro._template = Template(legend_html)\n\n        self.get_root().add_child(macro)\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: str,\n        attribution: str,\n        overlay: Optional[bool] = True,\n        control: Optional[bool] = True,\n        shown: Optional[bool] = True,\n        opacity: Optional[float] = 1.0,\n        API_key: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            url (str): The URL of the XYZ tile service.\n            name (str): The layer name to use on the layer control.\n            attribution (str): The attribution of the data layer.\n            overlay (bool, optional): Allows overlay. Defaults to True.\n            control (bool, optional): Adds the layer to the layer control. Defaults to True.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            opacity (float, optional): Sets the opacity for the layer.\n            API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.\n        \"\"\"\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in kwargs:\n            kwargs[\"max_native_zoom\"] = 30\n\n        try:\n            folium.raster_layers.TileLayer(\n                tiles=url,\n                name=name,\n                attr=attribution,\n                overlay=overlay,\n                control=control,\n                show=shown,\n                opacity=opacity,\n                API_key=API_key,\n                **kwargs,\n            ).add_to(self)\n\n            arc_add_layer(url, name, shown, opacity)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_raster(\n        self,\n        source: str,\n        indexes: Optional[int] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        attribution: Optional[str] = None,\n        layer_name: Optional[str] = \"Raster\",\n        array_args: Optional[Dict] = {},\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n            if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n            then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n            array_args (dict, optional): Additional arguments to pass to `array_to_image`. Defaults to {}.\n        \"\"\"\n\n        import numpy as np\n        import xarray as xr\n\n        if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n            source = array_to_image(source, **array_args)\n\n        tile_layer, tile_client = get_local_tile_layer(\n            source,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            tile_format=\"folium\",\n            layer_name=layer_name,\n            return_client=True,\n            **kwargs,\n        )\n        self.add_layer(tile_layer)\n\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = (\n            bounds[2],\n            bounds[0],\n            bounds[3],\n            bounds[1],\n        )  # [minx, miny, maxx, maxy]\n        self.zoom_to_bounds(bounds)\n\n        arc_add_layer(tile_layer.tiles, layer_name, True, 1.0)\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    add_local_tile = add_raster\n\n    def add_remote_tile(\n        self,\n        source: str,\n        indexes: Optional[int] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        attribution: Optional[str] = None,\n        layer_name: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n        Args:\n            source (str): The path to the remote Cloud Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n        \"\"\"\n        if isinstance(source, str) and source.startswith(\"http\"):\n            self.add_raster(\n                source,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                layer_name=layer_name,\n                **kwargs,\n            )\n        else:\n            raise Exception(\"The source must be a URL.\")\n\n    def add_netcdf(\n        self,\n        filename: str,\n        variables: Optional[int] = None,\n        port: str = \"default\",\n        palette: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        attribution: Optional[str] = None,\n        layer_name: Optional[str] = \"NetCDF layer\",\n        shift_lon: Optional[bool] = True,\n        lat: Optional[str] = \"lat\",\n        lon: Optional[str] = \"lon\",\n        **kwargs,\n    ):\n        \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n            try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n        Args:\n            filename (str): File path or HTTP URL to the netCDF file.\n            variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n            port (str, optional): The port to use for the server. Defaults to \"default\".\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n            shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n            lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n            lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        \"\"\"\n\n        tif, vars = netcdf_to_tif(\n            filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n        )\n\n        if variables is None:\n            if len(vars) &gt;= 3:\n                band_idx = [1, 2, 3]\n            else:\n                band_idx = [1]\n        else:\n            if not set(variables).issubset(set(vars)):\n                raise ValueError(f\"The variables must be a subset of {vars}.\")\n            else:\n                band_idx = [vars.index(v) + 1 for v in variables]\n\n        self.add_raster(\n            tif,\n            band=band_idx,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n\n    def add_heatmap(\n        self,\n        data: Union[str, List[List[float]], pd.DataFrame],\n        latitude: Optional[str] = \"latitude\",\n        longitude: Optional[str] = \"longitude\",\n        value: Optional[str] = \"value\",\n        name: Optional[str] = \"Heat map\",\n        radius: Optional[int] = 25,\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n                folium.FeatureGroup(name=name).add_to(self)\n            )\n        except Exception as e:\n            raise Exception(e)\n\n    def add_markers_from_xy(\n        self,\n        data: Union[str, pd.DataFrame],\n        x: Optional[str] = \"longitude\",\n        y: Optional[str] = \"latitude\",\n        popup: Optional[List[str]] = None,\n        min_width: Optional[int] = 100,\n        max_width: Optional[int] = 200,\n        layer_name: Optional[str] = \"Markers\",\n        icon: Optional[str] = None,\n        icon_shape: Optional[str] = \"circle-dot\",\n        border_width: Optional[int] = 3,\n        border_color: Optional[str] = \"#0000ff\",\n        **kwargs,\n    ):\n        \"\"\"Adds markers to the map from a csv or Pandas DataFrame containing x, y values.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            icon (str, optional): The Font-Awesome icon name to use to render the marker. Defaults to None.\n            icon_shape (str, optional): The shape of the marker, such as \"retangle-dot\", \"circle-dot\". Defaults to 'circle-dot'.\n            border_width (int, optional): The width of the border. Defaults to 3.\n            border_color (str, optional): The color of the border. Defaults to '#0000ff'.\n            kwargs (dict, optional): Additional keyword arguments to pass to BeautifyIcon. See\n                https://python-visualization.github.io/folium/plugins.html#folium.plugins.BeautifyIcon.\n\n        \"\"\"\n        import pandas as pd\n        from folium.plugins import BeautifyIcon\n\n        layer_group = folium.FeatureGroup(name=layer_name)\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if popup is None:\n            popup = col_names\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        for row in df.itertuples():\n            html = \"\"\n            for p in popup:\n                html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            marker_icon = BeautifyIcon(\n                icon, icon_shape, border_width, border_color, **kwargs\n            )\n            folium.Marker(\n                location=[getattr(row, y), getattr(row, x)],\n                popup=popup_html,\n                icon=marker_icon,\n            ).add_to(layer_group)\n\n        layer_group.add_to(self)\n\n    def add_osm_from_geocode(\n        self,\n        query: Union[str, dict, List],\n        which_result: Optional[int] = None,\n        by_osmid: Optional[bool] = False,\n        buffer_dist: Optional[float] = None,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n\n        gdf = osm_gdf_from_geocode(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_address(\n        self,\n        address: str,\n        tags: dict,\n        dist: Optional[int] = 1000,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n        Args:\n            address (str): The address to geocode and use as the central point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_address(address, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_place(\n        self,\n        query: Union[str, dict, List],\n        tags: dict,\n        which_result: Optional[int] = None,\n        buffer_dist: Optional[float] = None,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_point(\n        self,\n        center_point: Tuple[float, float],\n        tags: dict,\n        dist: Optional[int] = 1000,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n        Args:\n            center_point (tuple): The (lat, lng) center point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_point(center_point, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_polygon(\n        self,\n        polygon,\n        tags: dict,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n        Args:\n            polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_polygon(polygon, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_bbox(\n        self,\n        north: float,\n        south: float,\n        east: float,\n        west: float,\n        tags: dict,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n        Args:\n            north (float): Northern latitude of bounding box.\n            south (float): Southern latitude of bounding box.\n            east (float): Eastern longitude of bounding box.\n            west (float): Western longitude of bounding box.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_view(\n        self,\n        tags: dict,\n        layer_name: Optional[str] = \"Untitled\",\n        style: Optional[Dict] = {},\n        hover_style: Optional[Dict] = {},\n        style_callback: Optional[Callable[[Any], Any]] = None,\n        fill_colors: Optional[List] = [\"black\"],\n        info_mode: Optional[str] = \"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within the current map view to the map.\n\n        Args:\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        pass  # folium can't get map bounds. See https://github.com/python-visualization/folium/issues/1118\n        # bounds = self.get_bounds()\n        # north, south, east, west = (\n        #     bounds[1][0],\n        #     bounds[0][0],\n        #     bounds[1][1],\n        #     bounds[0][1],\n        # )\n\n        # gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        # geojson = gdf.__geo_interface__\n\n        # self.add_geojson(\n        #     geojson,\n        #     layer_name=layer_name,\n        #     style=style,\n        #     hover_style=hover_style,\n        #     style_callback=style_callback,\n        #     fill_colors=fill_colors,\n        #     info_mode=info_mode,\n        # )\n        # self.zoom_to_gdf(gdf)\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = \"Untitled\",\n        attribution: Optional[str] = \".\",\n        opacity: Optional[float] = 1.0,\n        shown: Optional[bool] = True,\n        bands: Optional[List] = None,\n        titiler_endpoint: Optional[str] = None,\n        zoom_to_layer=True,\n        **kwargs,\n    ):\n        \"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to '.'.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            bands (list, optional): A list of bands to use. Defaults to None.\n            titiler_endpoint (str, optional): TiTiler endpoint. Defaults to \"https://titiler.xyz\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n                color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n                apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        bounds = cog_bounds(url, titiler_endpoint)\n        self.add_tile_layer(\n            url=tile_url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            shown=shown,\n        )\n        if zoom_to_layer:\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n            arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    def add_cog_mosaic(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/opengeos/leafmap/issues/180.\"\n        )\n\n    def add_cog_mosaic_from_file(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/opengeos/leafmap/issues/180.\"\n        )\n\n    def add_stac_layer(\n        self,\n        url: str = None,\n        collection: str = None,\n        item: str = None,\n        assets: Union[str, List] = None,\n        bands: List = None,\n        titiler_endpoint: Optional[str] = None,\n        name: Optional[str] = \"STAC Layer\",\n        attribution: Optional[str] = \".\",\n        opacity: Optional[float] = 1.0,\n        shown: Optional[bool] = True,\n        fit_bounds: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            fit_bounds (bool, optional): A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        bounds = stac_bounds(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(\n            url=tile_url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            shown=shown,\n        )\n\n        if fit_bounds:\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n            arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    def add_mosaic_layer(\n        self,\n        url: str,\n        titiler_endpoint: Optional[str] = None,\n        name: Optional[str] = \"Mosaic Layer\",\n        attribution: Optional[str] = \".\",\n        opacity: Optional[float] = 1.0,\n        shown: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a MosaicJSON.\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n        tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n        bounds = mosaic_bounds(url, titiler_endpoint)\n        self.add_tile_layer(\n            url=tile_url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            shown=shown,\n        )\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_legend(\n        self,\n        title: Optional[str] = \"Legend\",\n        labels: Optional[List] = None,\n        colors: Optional[List] = None,\n        legend_dict: Optional[Dict] = None,\n        builtin_legend: Optional[str] = None,\n        opacity: Optional[float] = 1.0,\n        position: Optional[str] = \"bottomright\",\n        draggable: Optional[bool] = True,\n        style: Optional[Dict] = {},\n    ):\n        \"\"\"Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.\n            If you want to add multiple legends to the map, you need to set the `draggable` argument to False.\n\n        Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n            colors (list, optional): A list of legend colors. Defaults to None.\n            labels (list, optional): A list of legend labels. Defaults to None.\n            legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n                If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n            builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n            opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n            position (str, optional): The position of the legend, can be one of the following:\n                \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n                Note that position is only valid when draggable is False.\n            draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n            style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n                border, background-color, border-radius, padding, font-size, etc. The default style is:\n                style = {\n                    'position': 'fixed',\n                    'z-index': '9999',\n                    'border': '2px solid grey',\n                    'background-color': 'rgba(255, 255, 255, 0.8)',\n                    'border-radius': '5px',\n                    'padding': '10px',\n                    'font-size': '14px',\n                    'bottom': '20px',\n                    'right': '5px'\n                }\n\n        \"\"\"\n        content = create_legend(\n            title,\n            labels,\n            colors,\n            legend_dict,\n            builtin_legend,\n            opacity,\n            position,\n            draggable,\n            style=style,\n        )\n        if draggable:\n            from branca.element import Template, MacroElement\n\n            content = (\n                '\"\"\"\\n{% macro html(this, kwargs) %}\\n'\n                + content\n                + '\\n{% endmacro %}\"\"\"'\n            )\n\n            macro = MacroElement()\n            macro._template = Template(content)\n\n            self.get_root().add_child(macro)\n        else:\n            self.add_html(content, position=position)\n\n    def add_colorbar(\n        self,\n        colors: List,\n        vmin: Optional[int] = 0,\n        vmax: Optional[int] = 1,\n        index: Optional[List] = None,\n        caption: Optional[str] = \"\",\n        categorical: Optional[bool] = False,\n        step: Optional[int] = None,\n        **kwargs,\n    ):\n        \"\"\"Add a colorbar to the map.\n\n        Args:\n            colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n            vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n            vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n            index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n            caption (str, optional): The caption for the colormap. Defaults to \"\".\n            categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n            step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n        \"\"\"\n        from box import Box\n        from branca.colormap import LinearColormap\n\n        if isinstance(colors, Box):\n            try:\n                colors = list(colors[\"default\"])\n            except Exception as e:\n                print(\"The provided color list is invalid.\")\n                raise Exception(e)\n\n        if all(len(color) == 6 for color in colors):\n            colors = [\"#\" + color for color in colors]\n\n        colormap = LinearColormap(\n            colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n        )\n\n        if categorical:\n            if step is not None:\n                colormap = colormap.to_step(step)\n            elif index is not None:\n                colormap = colormap.to_step(len(index) - 1)\n            else:\n                colormap = colormap.to_step(3)\n\n        self.add_child(colormap)\n\n    def add_shp(\n        self,\n        in_shp: str,\n        layer_name: Optional[str] = \"Untitled\",\n        info_mode: Optional[str] = \"on_hover\",\n        zoom_to_layer: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.\n\n        Args:\n            in_shp (str): The input file path or HTTP URL (*.zip) to the shapefile.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n        import glob\n\n        if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n            out_dir = os.path.abspath(\"./cache/shp\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            basename = os.path.basename(in_shp)\n            filename = os.path.join(out_dir, basename)\n            # download_from_url(in_shp, out_dir=out_dir, verbose=False)\n            download_file(in_shp, filename)\n            files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n            if len(files) &gt; 0:\n                in_shp = files[0]\n            else:\n                raise FileNotFoundError(\n                    \"The downloaded zip file does not contain any shapefile in the root directory.\"\n                )\n        else:\n            in_shp = os.path.abspath(in_shp)\n            if not os.path.exists(in_shp):\n                raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        data = shp_to_geojson(in_shp)\n\n        self.add_geojson(\n            data,\n            layer_name=layer_name,\n            info_mode=info_mode,\n            zoom_to_layer=zoom_to_layer,\n            **kwargs,\n        )\n\n    def add_geojson(\n        self,\n        in_geojson: str,\n        layer_name: Optional[str] = \"Untitled\",\n        encoding: Optional[str] = \"utf-8\",\n        info_mode: Optional[str] = \"on_hover\",\n        zoom_to_layer: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str): The input file path to the GeoJSON.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n                Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n        \"\"\"\n        import json\n        import requests\n        import random\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    if is_jupyterlite():\n                        import pyodide\n\n                        output = os.path.basename(in_geojson)\n\n                        output = os.path.abspath(output)\n                        obj = pyodide.http.open_url(in_geojson)\n                        with open(output, \"w\") as fd:\n                            shutil.copyfileobj(obj, fd)\n                        with open(output, \"r\") as fd:\n                            data = json.load(fd)\n                    else:\n                        in_geojson = github_raw_url(in_geojson)\n                        data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        # interchangeable parameters between ipyleaflet and folium.\n        style_dict = {}\n        if \"style_function\" not in kwargs:\n            if \"style\" in kwargs:\n                style_dict = kwargs[\"style\"]\n                if isinstance(kwargs[\"style\"], dict) and len(kwargs[\"style\"]) &gt; 0:\n                    kwargs[\"style_function\"] = lambda x: style_dict\n                kwargs.pop(\"style\")\n            else:\n                style_dict = {\n                    # \"stroke\": True,\n                    \"color\": \"#3388ff\",\n                    \"weight\": 2,\n                    \"opacity\": 1,\n                    # \"fill\": True,\n                    # \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 0,\n                    # \"dashArray\": \"9\"\n                    # \"clickable\": True,\n                }\n                kwargs[\"style_function\"] = lambda x: style_dict\n\n        if \"style_callback\" in kwargs:\n            kwargs.pop(\"style_callback\")\n\n        if \"hover_style\" in kwargs:\n            kwargs.pop(\"hover_style\")\n\n        if \"fill_colors\" in kwargs:\n            fill_colors = kwargs[\"fill_colors\"]\n\n            def random_color(feature):\n                style_dict[\"fillColor\"] = random.choice(fill_colors)\n                return style_dict\n\n            kwargs[\"style_function\"] = random_color\n            kwargs.pop(\"fill_colors\")\n\n        if \"weight\" not in style_dict:\n            style_dict[\"weight\"] = 2\n\n        if \"highlight_function\" not in kwargs:\n            kwargs[\"highlight_function\"] = lambda feat: {\n                \"weight\": style_dict[\"weight\"] + 2,\n                \"fillOpacity\": 0,\n            }\n\n        tooltip = None\n        popup = None\n        if info_mode is not None:\n            if \"fields\" in kwargs:\n                props = kwargs[\"fields\"]\n                kwargs.pop(\"fields\")\n            else:\n                props = list(data[\"features\"][0][\"properties\"].keys())\n            if info_mode == \"on_hover\":\n                tooltip = folium.GeoJsonTooltip(fields=props)\n            elif info_mode == \"on_click\":\n                popup = folium.GeoJsonPopup(fields=props)\n\n        geojson = folium.GeoJson(\n            data=data, name=layer_name, tooltip=tooltip, popup=popup, **kwargs\n        )\n        geojson.add_to(self)\n\n        if zoom_to_layer:\n            bounds = get_bounds(data)\n            self.zoom_to_bounds(bounds)\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name: Optional[str] = \"Untitled\",\n        zoom_to_layer: Optional[bool] = True,\n        info_mode: Optional[str] = \"on_hover\",\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n\n        for col in gdf.columns:\n            if gdf[col].dtype in [\"datetime64[ns]\", \"datetime64[ns, UTC]\"]:\n                gdf[col] = gdf[col].astype(str)\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(\n            data,\n            layer_name=layer_name,\n            info_mode=info_mode,\n            zoom_to_layer=zoom_to_layer,\n            **kwargs,\n        )\n\n        # if zoom_to_layer:\n        #     import numpy as np\n\n        #     bounds = gdf.to_crs(epsg=\"4326\").bounds\n        #     west = np.min(bounds[\"minx\"])\n        #     south = np.min(bounds[\"miny\"])\n        #     east = np.max(bounds[\"maxx\"])\n        #     north = np.max(bounds[\"maxy\"])\n        #     self.fit_bounds([[south, east], [north, west]])\n\n    def add_gdf_from_postgis(\n        self,\n        sql: str,\n        con,\n        layer_name: Optional[str] = \"Untitled\",\n        zoom_to_layer: Optional[bool] = True,\n        info_mode: Optional[str] = \"on_hover\",\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        if \"fill_colors\" in kwargs:\n            kwargs.pop(\"fill_colors\")\n        gdf = read_postgis(sql, con, **kwargs)\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(data, layer_name=layer_name, info_mode=info_mode, **kwargs)\n\n        if zoom_to_layer:\n            import numpy as np\n\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n\n    def add_kml(\n        self,\n        in_kml: str,\n        layer_name: Optional[str] = \"Untitled\",\n        info_mode: Optional[str] = \"on_hover\",\n        **kwargs,\n    ):\n        \"\"\"Adds a KML file to the map.\n\n        Args:\n            in_kml (str): The input file path to the KML.\n            layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n            out_dir = os.path.abspath(\"./cache\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            in_kml = download_file(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n        else:\n            in_kml = os.path.abspath(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The provided KML could not be found.\")\n\n        data = kml_to_geojson(in_kml)\n\n        self.add_geojson(data, layer_name=layer_name, info_mode=info_mode, **kwargs)\n\n    def add_vector(\n        self,\n        filename: str,\n        layer_name: Optional[str] = \"Untitled\",\n        bbox: Optional[Tuple] = None,\n        mask: Optional[Dict] = None,\n        rows: Optional[Union[int, slice]] = None,\n        info_mode: Optional[str] = \"on_hover\",\n        zoom_to_layer: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n        Args:\n            filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n            layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n            bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n            mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n            rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n        \"\"\"\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".shp\":\n            self.add_shp(filename, layer_name, **kwargs)\n        elif ext in [\".json\", \".geojson\"]:\n            self.add_geojson(filename, layer_name, **kwargs)\n        else:\n            geojson = vector_to_geojson(\n                filename,\n                bbox=bbox,\n                mask=mask,\n                rows=rows,\n                epsg=\"4326\",\n                **kwargs,\n            )\n\n            self.add_geojson(\n                geojson,\n                layer_name,\n                info_mode=info_mode,\n                zoom_to_layer=zoom_to_layer,\n                **kwargs,\n            )\n\n    def add_planet_by_month(\n        self,\n        year: Optional[int] = 2016,\n        month: Optional[int] = 1,\n        layer_name: Optional[str] = None,\n        api_key: Optional[str] = None,\n        token_name: Optional[str] = \"PLANET_API_KEY\",\n        **kwargs,\n    ):\n        \"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        if layer_name is None and \"name\" in kwargs:\n            layer_name = kwargs.pop(\"name\")\n        layer = planet_tile_by_month(\n            year, month, layer_name, api_key, token_name, tile_format=\"folium\"\n        )\n        layer.add_to(self)\n\n    def add_planet_by_quarter(\n        self,\n        year: Optional[int] = 2016,\n        quarter: Optional[int] = 1,\n        layer_name: Optional[str] = None,\n        api_key: Optional[str] = None,\n        token_name: Optional[str] = \"PLANET_API_KEY\",\n        **kwargs,\n    ):\n        \"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        if layer_name is None and \"name\" in kwargs:\n            layer_name = kwargs.pop(\"name\")\n        layer = planet_tile_by_quarter(\n            year, quarter, layer_name, api_key, token_name, tile_format=\"folium\"\n        )\n        layer.add_to(self)\n\n    def publish(\n        self,\n        name: Optional[str] = \"Folium Map\",\n        description: Optional[str] = \"\",\n        source_url: Optional[str] = \"\",\n        tags: Optional[List] = None,\n        source_file: Optional[str] = None,\n        open: Optional[bool] = True,\n        formatting=None,\n        token: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Publish the map to datapane.com\n\n        Args:\n            name (str, optional): The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".\n            description (str, optional): A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.\n            source_url (str, optional): A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.\n            tags (list, optional): A list of tags (as strings) used to categorise your document. Defaults to None.\n            source_file (str, optional): Path of jupyter notebook file to upload. Defaults to None.\n            open (bool, optional): Whether to open the map. Defaults to True.\n            formatting (ReportFormatting, optional): Set the basic styling for your report.\n            token (str, optional): The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.\n        \"\"\"\n        import webbrowser\n        import warnings\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        warnings.filterwarnings(\"ignore\")\n        try:\n            import datapane as dp\n        except Exception:\n            webbrowser.open_new_tab(\"https://docs.datapane.com/\")\n            raise ImportError(\n                \"The datapane Python package is not installed. You need to install and authenticate datapane first.\"\n            )\n\n        if token is None:\n            try:\n                _ = dp.ping(verbose=False)\n            except Exception as e:\n                if os.environ.get(\"DP_TOKEN\") is not None:\n                    dp.login(token=os.environ.get(\"DP_TOKEN\"))\n                else:\n                    raise Exception(e)\n        else:\n            dp.login(token)\n\n        try:\n            dp.upload_report(\n                dp.Plot(self),\n                name=name,\n                description=description,\n                source_url=source_url,\n                tags=tags,\n                source_file=source_file,\n                open=open,\n                formatting=formatting,\n                **kwargs,\n            )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_html(self, outfile: Optional[str] = None, **kwargs) -&gt; str:\n        \"\"\"Exports a map as an HTML file.\n\n        Args:\n            outfile (str, optional): File path to the output HTML. Defaults to None.\n\n        Raises:\n            ValueError: If it is an invalid HTML file.\n\n        Returns:\n            str: A string containing the HTML code.\n        \"\"\"\n\n        if self.options[\"layersControl\"]:\n            self.add_layer_control()\n\n        if outfile is not None:\n            if not outfile.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            outfile = os.path.abspath(outfile)\n            out_dir = os.path.dirname(outfile)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            self.save(outfile, **kwargs)\n        else:\n            outfile = os.path.abspath(random_string() + \".html\")\n            self.save(outfile, **kwargs)\n            out_html = \"\"\n            with open(outfile) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(outfile)\n            return out_html\n\n    def to_streamlit(\n        self,\n        width: Optional[int] = None,\n        height: Optional[int] = 600,\n        scrolling: Optional[bool] = False,\n        add_layer_control: Optional[bool] = True,\n        bidirectional: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Renders `folium.Figure` or `folium.Map` in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to None.\n            height (int, optional): Height of the map. Defaults to 600.\n            scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n            add_layer_control (bool, optional): Whether to add the layer control. Defaults to True.\n            bidirectional (bool, optional): Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.\n\n        Raises:\n            ImportError: If streamlit is not installed.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n\n            if add_layer_control:\n                self.add_layer_control()\n\n            if bidirectional:\n                from streamlit_folium import st_folium\n\n                output = st_folium(self, width=width, height=height)\n                return output\n            else:\n                # if responsive:\n                #     make_map_responsive = \"\"\"\n                #     &lt;style&gt;\n                #     [title~=\"st.iframe\"] { width: 100%}\n                #     &lt;/style&gt;\n                #     \"\"\"\n                #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n                return components.html(\n                    self.to_html(), width=width, height=height, scrolling=scrolling\n                )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def st_map_center(self, st_component) -&gt; Tuple:\n        \"\"\"Get the center of the map.\n\n        Args:\n            st_component (st_folium): The streamlit component.\n\n        Returns:\n            tuple: The center of the map.\n        \"\"\"\n\n        bounds = st_component[\"bounds\"]\n        west = bounds[\"_southWest\"][\"lng\"]\n        south = bounds[\"_southWest\"][\"lat\"]\n        east = bounds[\"_northEast\"][\"lng\"]\n        north = bounds[\"_northEast\"][\"lat\"]\n        return (south + (north - south) / 2, west + (east - west) / 2)\n\n    def st_map_bounds(self, st_component) -&gt; Tuple:\n        \"\"\"Get the bounds of the map in the format of (miny, minx, maxy, maxx).\n\n        Args:\n            st_component (st_folium): The streamlit component.\n\n        Returns:\n            tuple: The bounds of the map.\n        \"\"\"\n\n        bounds = st_component[\"bounds\"]\n        south = bounds[\"_southWest\"][\"lat\"]\n        west = bounds[\"_southWest\"][\"lng\"]\n        north = bounds[\"_northEast\"][\"lat\"]\n        east = bounds[\"_northEast\"][\"lng\"]\n\n        bounds = [[south, west], [north, east]]\n        return bounds\n\n    def st_fit_bounds(self):\n        \"\"\"Fit the map to the bounds of the map.\n\n        Returns:\n            folium.Map: The map.\n        \"\"\"\n\n        try:\n            import streamlit as st\n\n            if \"map_bounds\" in st.session_state:\n                bounds = st.session_state[\"map_bounds\"]\n\n                self.fit_bounds(bounds)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def st_last_draw(self, st_component):\n        \"\"\"Get the last draw feature of the map.\n\n        Args:\n            st_component (st_folium): The streamlit component.\n\n        Returns:\n            str: The last draw of the map.\n        \"\"\"\n\n        return st_component[\"last_active_drawing\"]\n\n    def st_last_click(self, st_component):\n        \"\"\"Get the last click feature of the map.\n\n        Args:\n            st_component (st_folium): The streamlit component.\n\n        Returns:\n            str: The last click of the map.\n        \"\"\"\n\n        coords = st_component[\"last_clicked\"]\n        return (coords[\"lat\"], coords[\"lng\"])\n\n    def st_draw_features(self, st_component):\n        \"\"\"Get the draw features of the map.\n\n        Args:\n            st_component (st_folium): The streamlit component.\n\n        Returns:\n            list: The draw features of the map.\n        \"\"\"\n\n        return st_component[\"all_drawings\"]\n\n    def add_title(\n        self,\n        title: str,\n        align: Optional[str] = \"center\",\n        font_size: Optional[str] = \"16px\",\n        style=None,\n    ):\n        \"\"\"Adds a title to the map.\n\n        Args:\n            title (str): The title to use.\n            align (str, optional): The alignment of the title, can be [\"center\", \"left\", \"right\"]. Defaults to \"center\".\n            font_size (str, optional): The font size in the unit of px. Defaults to \"16px\".\n            style ([type], optional): The style to use. Defaults to None.\n        \"\"\"\n        if style is None:\n            title_html = \"\"\"\n                    &lt;h3 align={} style=\"font-size:{}\"&gt;&lt;b&gt;{}&lt;/b&gt;&lt;/h3&gt;\n                    \"\"\".format(\n                align, font_size, title\n            )\n        else:\n            title_html = \"\"\"\n                &lt;h3 align={} style={}&gt;&lt;b&gt;{}&lt;/b&gt;&lt;/h3&gt;\n                \"\"\".format(\n                align, style, title\n            )\n        self.get_root().html.add_child(folium.Element(title_html))\n\n    def static_map(\n        self,\n        width: Optional[int] = 950,\n        height: Optional[int] = 600,\n        read_only: Optional[bool] = False,\n        out_file: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Display a folium static map in a Jupyter Notebook.\n\n        Args\n            m (folium.Map): A folium map.\n            width (int, optional): Width of the map. Defaults to 950.\n            height (int, optional): Height of the map. Defaults to 600.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n            out_file (str, optional): Output html file path. Defaults to None.\n        \"\"\"\n        if isinstance(self, folium.Map):\n            if out_file is None:\n                out_file = \"./cache/\" + \"folium_\" + random_string(3) + \".html\"\n            out_dir = os.path.abspath(os.path.dirname(out_file))\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            self.to_html(out_file)\n            display_html(src=out_file, width=width, height=height)\n        else:\n            raise TypeError(\"The provided map is not a folium map.\")\n\n    def add_census_data(\n        self, wms: str, layer: str, census_dict: Optional[Dict] = None, **kwargs\n    ):\n        \"\"\"Adds a census data layer to the map.\n\n        Args:\n            wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n            layer (str): The layer name to add to the map.\n            census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n        \"\"\"\n\n        try:\n            if census_dict is None:\n                census_dict = get_census_dict()\n\n            if wms not in census_dict.keys():\n                raise ValueError(\n                    f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n                )\n\n            layers = census_dict[wms][\"layers\"]\n            if layer not in layers:\n                raise ValueError(\n                    f\"The layer name is not valid. It must be one of {layers}\"\n                )\n\n            url = census_dict[wms][\"url\"]\n            if \"name\" not in kwargs:\n                kwargs[\"name\"] = layer\n            if \"attribution\" not in kwargs:\n                kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n            if \"format\" not in kwargs:\n                kwargs[\"format\"] = \"image/png\"\n            if \"transparent\" not in kwargs:\n                kwargs[\"transparent\"] = True\n\n            self.add_wms_layer(url, layer, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_xyz_service(self, provider: str, **kwargs):\n        \"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n        Raises:\n            ValueError: The provider is not valid. It must start with xyz or qms.\n        \"\"\"\n        import xyzservices.providers as xyz\n        from xyzservices import TileProvider\n\n        if provider.startswith(\"xyz\"):\n            name = provider[4:]\n            xyz_provider = xyz.flatten()[name]\n            url = xyz_provider.build_url()\n            attribution = xyz_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        elif provider.startswith(\"qms\"):\n            name = provider[4:]\n            qms_provider = TileProvider.from_qms(name)\n            url = qms_provider.build_url()\n            attribution = qms_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url=url, name=name, attribution=attribution)\n        else:\n            raise ValueError(\n                f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n            )\n\n    def add_marker(\n        self,\n        location: Union[List, Tuple],\n        popup: Optional[str] = None,\n        tooltip: Optional[str] = None,\n        icon: Optional[str] = None,\n        draggable: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.\n\n        Args:\n            location (list | tuple): The location of the marker in the format of [lat, lng].\n            popup (str, optional): The popup text. Defaults to None.\n            tooltip (str, optional): The tooltip text. Defaults to None.\n            icon (str, optional): The icon to use. Defaults to None.\n            draggable (bool, optional): Whether the marker is draggable. Defaults to False.\n        \"\"\"\n        if isinstance(location, list):\n            location = tuple(location)\n        if isinstance(location, tuple):\n            folium.Marker(\n                location=location,\n                popup=popup,\n                tooltip=tooltip,\n                icon=icon,\n                draggable=draggable,\n                **kwargs,\n            ).add_to(self)\n\n        else:\n            raise TypeError(\"The location must be a list or a tuple.\")\n\n    def add_colormap(\n        self,\n        width: Optional[float] = 4.0,\n        height: Optional[float] = 0.3,\n        vmin: Optional[float] = 0,\n        vmax: Optional[float] = 1.0,\n        palette: Optional[List] = None,\n        vis_params: Optional[dict] = None,\n        cmap: Optional[str] = \"gray\",\n        discrete: Optional[bool] = False,\n        label: Optional[str] = None,\n        label_size: Optional[int] = 12,\n        label_weight: Optional[str] = \"normal\",\n        tick_size: Optional[int] = 10,\n        bg_color: Optional[str] = \"white\",\n        orientation: Optional[str] = \"horizontal\",\n        dpi: Optional[Union[str, float]] = \"figure\",\n        transparent: Optional[bool] = False,\n        position: Optional[Tuple] = (70, 5),\n        **kwargs,\n    ):\n        \"\"\"Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().\n\n        Args:\n            width (float): Width of the colorbar in inches. Default is 4.0.\n            height (float): Height of the colorbar in inches. Default is 0.3.\n            vmin (float): Minimum value of the colorbar. Default is 0.\n            vmax (float): Maximum value of the colorbar. Default is 1.0.\n            palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n            vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n            discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n            label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n            tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n            bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n            orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n            dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n            transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n            position (tuple, optional): The position of the colormap in the format of (x, y),\n                the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n            **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n        Returns:\n            str: Path to the output image.\n        \"\"\"\n\n        colorbar = save_colorbar(\n            None,\n            width,\n            height,\n            vmin,\n            vmax,\n            palette,\n            vis_params,\n            cmap,\n            discrete,\n            label,\n            label_size,\n            label_weight,\n            tick_size,\n            bg_color,\n            orientation,\n            dpi,\n            transparent,\n            show_colorbar=False,\n            **kwargs,\n        )\n\n        self.add_image(colorbar, position=position)\n\n    def add_points_from_xy(\n        self,\n        data: Union[str, pd.DataFrame],\n        x: Optional[str] = \"longitude\",\n        y: Optional[str] = \"latitude\",\n        popup: Optional[List] = None,\n        min_width: Optional[int] = 100,\n        max_width: Optional[int] = 200,\n        layer_name: Optional[str] = \"Marker Cluster\",\n        color_column: Optional[str] = None,\n        marker_colors: Optional[List] = None,\n        icon_colors: Optional[List] = [\"white\"],\n        icon_names: Optional[List] = [\"info\"],\n        angle: Optional[int] = 0,\n        prefix: Optional[str] = \"fa\",\n        add_legend: Optional[bool] = True,\n        max_cluster_radius: Optional[int] = 80,\n        **kwargs,\n    ):\n        \"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            color_column (str, optional): The column name for the color values. Defaults to None.\n            marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n            icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n            icon_names (list, optional): A list of names to be used for the icons. More icons can be found\n                at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n            angle (int, optional): The angle of the icon. Defaults to 0.\n            prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n            add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n            max_cluster_radius (int, optional): The maximum radius that a cluster will cover from the central marker (in pixels).\n            **kwargs: Other keyword arguments to pass to folium.MarkerCluster(). For a list of available options,\n                see https://github.com/Leaflet/Leaflet.markercluster. For example, to change the cluster radius, use options={\"maxClusterRadius\": 50}.\n        \"\"\"\n        import pandas as pd\n\n        if \"maxClusterRadius\" not in kwargs:\n            kwargs[\"maxClusterRadius\"] = max_cluster_radius\n\n        color_options = [\n            \"red\",\n            \"blue\",\n            \"green\",\n            \"purple\",\n            \"orange\",\n            \"darkred\",\n            \"lightred\",\n            \"beige\",\n            \"darkblue\",\n            \"darkgreen\",\n            \"cadetblue\",\n            \"darkpurple\",\n            \"white\",\n            \"pink\",\n            \"lightblue\",\n            \"lightgreen\",\n            \"gray\",\n            \"black\",\n            \"lightgray\",\n        ]\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if color_column is not None and color_column not in col_names:\n            raise ValueError(\n                f\"The color column {color_column} does not exist in the dataframe.\"\n            )\n\n        if color_column is not None:\n            items = list(set(df[color_column]))\n        else:\n            items = None\n\n        if color_column is not None and marker_colors is None:\n            if len(items) &gt; len(color_options):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n                )\n            else:\n                marker_colors = color_options[: len(items)]\n        elif color_column is not None and marker_colors is not None:\n            if len(items) != len(marker_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if items is not None:\n            if len(icon_colors) == 1:\n                icon_colors = icon_colors * len(items)\n            elif len(items) != len(icon_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n            if len(icon_names) == 1:\n                icon_names = icon_names * len(items)\n            elif len(items) != len(icon_names):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if popup is None:\n            popup = col_names\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        marker_cluster = plugins.MarkerCluster(name=layer_name, **kwargs).add_to(self)\n\n        for idx, row in df.iterrows():\n            html = \"\"\n            for p in popup:\n                html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(row[p]) + \"&lt;br&gt;\"\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            if items is not None:\n                index = items.index(row[color_column])\n                marker_icon = folium.Icon(\n                    color=marker_colors[index],\n                    icon_color=icon_colors[index],\n                    icon=icon_names[index],\n                    angle=angle,\n                    prefix=prefix,\n                )\n            else:\n                marker_icon = None\n\n            folium.Marker(\n                location=[row[y], row[x]],\n                popup=popup_html,\n                icon=marker_icon,\n            ).add_to(marker_cluster)\n\n        if items is not None and add_legend:\n            marker_colors = [check_color(c) for c in marker_colors]\n            self.add_legend(\n                title=color_column.title(), colors=marker_colors, labels=items\n            )\n\n    def add_circle_markers_from_xy(\n        self,\n        data: Union[str, pd.DataFrame],\n        x: Optional[str] = \"longitude\",\n        y: Optional[str] = \"latitude\",\n        radius: Optional[int] = 10,\n        popup: Optional[List] = None,\n        tooltip: Optional[List] = None,\n        min_width: Optional[int] = 100,\n        max_width: Optional[int] = 200,\n        font_size: Optional[int] = 2,\n        **kwargs,\n    ):\n        \"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            radius (int, optional): The radius of the circle. Defaults to 10.\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            tooltip (list, optional): A list of column names to be used as the tooltip. Defaults to None.\n            min_width (int, optional): The minimum width of the popup. Defaults to 100.\n            max_width (int, optional): The maximum width of the popup. Defaults to 200.\n            font_size (int, optional): The font size of the popup. Defaults to 2.\n\n        \"\"\"\n        import pandas as pd\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data)\n\n        col_names = df.columns.values.tolist()\n\n        if \"color\" not in kwargs:\n            kwargs[\"color\"] = None\n        if \"fill\" not in kwargs:\n            kwargs[\"fill\"] = True\n        if \"fill_color\" not in kwargs:\n            kwargs[\"fill_color\"] = \"blue\"\n        if \"fill_opacity\" not in kwargs:\n            kwargs[\"fill_opacity\"] = 0.7\n\n        if popup is None:\n            popup = col_names\n\n        if not isinstance(popup, list):\n            popup = [popup]\n\n        if tooltip is not None:\n            if not isinstance(tooltip, list):\n                tooltip = [tooltip]\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        for idx, row in df.iterrows():\n            html = \"\"\n            for p in popup:\n                html = (\n                    html\n                    + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                    + p\n                    + \"&lt;/b&gt;\"\n                    + \": \"\n                    + str(row[p])\n                    + \"&lt;br&gt;&lt;/font&gt;\"\n                )\n            popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n            if tooltip is not None:\n                html = \"\"\n                for p in tooltip:\n                    html = (\n                        html\n                        + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                        + p\n                        + \"&lt;/b&gt;\"\n                        + \": \"\n                        + str(row[p])\n                        + \"&lt;br&gt;&lt;/font&gt;\"\n                    )\n\n                tooltip_str = folium.Tooltip(html)\n            else:\n                tooltip_str = None\n\n            folium.CircleMarker(\n                location=[row[y], row[x]],\n                radius=radius,\n                popup=popup_html,\n                tooltip=tooltip_str,\n                **kwargs,\n            ).add_to(self)\n\n    def add_labels(\n        self,\n        data: Union[pd.DataFrame, str],\n        column: str,\n        font_size: Optional[str] = \"12pt\",\n        font_color: Optional[str] = \"black\",\n        font_family: Optional[str] = \"arial\",\n        font_weight: Optional[str] = \"normal\",\n        x: Optional[str] = \"longitude\",\n        y: Optional[str] = \"latitude\",\n        draggable: Optional[bool] = True,\n        layer_name: Optional[str] = \"Labels\",\n        **kwargs,\n    ):\n        \"\"\"Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon\n\n        Args:\n            data (pd.DataFrame | gpd.GeoDataFrame | str): The input data to label.\n            column (str): The column name of the data to label.\n            font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n            font_color (str, optional): The font color of the labels. Defaults to \"black\".\n            font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n            font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n            x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n            y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n            draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n            layer_name (str, optional): The name of the layer. Defaults to \"Labels\".\n\n        \"\"\"\n        import warnings\n        import pandas as pd\n        from folium.features import DivIcon\n\n        warnings.filterwarnings(\"ignore\")\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n            if \"geometry\" in data.columns or (\"geom\" in data.columns):\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n        elif isinstance(data, str):\n            ext = os.path.splitext(data)[1]\n            if ext == \".csv\":\n                df = pd.read_csv(data)\n            elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n                try:\n                    import geopandas as gpd\n\n                    df = gpd.read_file(data)\n                    df[x] = df.centroid.x\n                    df[y] = df.centroid.y\n                except ImportError:\n                    print(\"geopandas is required to read geojson.\")\n                    return\n        else:\n            raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n        if column not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if x not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if y not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n        try:\n            size = int(font_size.replace(\"pt\", \"\"))\n        except:\n            raise ValueError(\"font_size must be something like '10pt'\")\n\n        layer_group = folium.FeatureGroup(name=layer_name)\n        for index in df.index:\n            html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n            folium.Marker(\n                location=[df[y][index], df[x][index]],\n                icon=DivIcon(\n                    icon_size=(1, 1),\n                    icon_anchor=(size, size),\n                    html=html,\n                    **kwargs,\n                ),\n                draggable=draggable,\n            ).add_to(layer_group)\n\n        layer_group.add_to(self)\n\n    def split_map(\n        self,\n        left_layer: Optional[str] = \"TERRAIN\",\n        right_layer: Optional[str] = \"OpenTopoMap\",\n        left_args: Optional[dict] = {},\n        right_args: Optional[dict] = {},\n        left_array_args={},\n        right_array_args={},\n        left_label: Optional[str] = None,\n        right_label: Optional[str] = None,\n        left_position: Optional[str] = \"bottomleft\",\n        right_position: Optional[str] = \"bottomright\",\n        **kwargs,\n    ):\n        \"\"\"Adds a split-panel map.\n\n        Args:\n            left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n            right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n            left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n            right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n            left_array_args (dict, optional): The arguments for array_to_image for the left layer. Defaults to {}.\n            right_array_args (dict, optional): The arguments for array_to_image for the right layer. Defaults to {}.\n        \"\"\"\n        if \"max_zoom\" not in left_args:\n            left_args[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in left_args:\n            left_args[\"max_native_zoom\"] = 30\n\n        if \"max_zoom\" not in right_args:\n            right_args[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in right_args:\n            right_args[\"max_native_zoom\"] = 30\n\n        if \"layer_name\" not in left_args:\n            left_args[\"layer_name\"] = \"Left Layer\"\n\n        if \"layer_name\" not in right_args:\n            right_args[\"layer_name\"] = \"Right Layer\"\n\n        bounds = None\n\n        try:\n            if left_label is not None:\n                left_name = left_label\n            else:\n                left_name = \"Left Layer\"\n\n            if right_label is not None:\n                right_name = right_label\n            else:\n                right_name = \"Right Layer\"\n\n            if isinstance(left_layer, str):\n                if left_layer in basemaps.keys():\n                    left_layer = basemaps[left_layer]\n                elif left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                    url = cog_tile(left_layer, **left_args)\n                    bbox = cog_bounds(left_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    left_layer = folium.raster_layers.TileLayer(\n                        tiles=url,\n                        name=left_name,\n                        attr=\" \",\n                        overlay=True,\n                        **left_args,\n                    )\n\n                elif left_layer.startswith(\"http\") and left_layer.endswith(\".json\"):\n                    left_tile_url = stac_tile(left_layer, **left_args)\n                    bbox = stac_bounds(left_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    left_layer = folium.raster_layers.TileLayer(\n                        tiles=left_tile_url,\n                        name=left_name,\n                        attr=\" \",\n                        overlay=True,\n                        **left_args,\n                    )\n\n                elif os.path.exists(left_layer):\n                    left_layer, left_client = get_local_tile_layer(\n                        left_layer,\n                        tile_format=\"folium\",\n                        return_client=True,\n                        **left_args,\n                    )\n                    bounds = image_bounds(left_client)\n\n                else:\n                    left_layer = folium.raster_layers.TileLayer(\n                        tiles=left_layer,\n                        name=left_name,\n                        attr=\" \",\n                        overlay=True,\n                        **left_args,\n                    )\n            elif isinstance(left_layer, folium.raster_layers.TileLayer) or isinstance(\n                left_layer, folium.WmsTileLayer\n            ):\n                pass\n            elif is_array(left_layer):\n                left_layer = array_to_image(left_layer, **left_array_args)\n                left_layer, _ = get_local_tile_layer(\n                    left_layer,\n                    return_client=True,\n                    tile_format=\"folium\",\n                    **left_args,\n                )\n            else:\n                raise ValueError(\n                    f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            if isinstance(right_layer, str):\n                if right_layer in basemaps.keys():\n                    right_layer = basemaps[right_layer]\n                elif right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                    url = cog_tile(right_layer, **right_args)\n                    bbox = cog_bounds(right_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    right_layer = folium.raster_layers.TileLayer(\n                        tiles=url,\n                        name=right_name,\n                        attr=\" \",\n                        overlay=True,\n                        **right_args,\n                    )\n\n                elif right_layer.startswith(\"http\") and right_layer.endswith(\".json\"):\n                    right_tile_url = stac_tile(right_layer, **left_args)\n                    bbox = stac_bounds(right_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    right_layer = folium.raster_layers.TileLayer(\n                        tiles=right_tile_url,\n                        name=right_name,\n                        attr=\" \",\n                        overlay=True,\n                        **right_args,\n                    )\n\n                elif os.path.exists(right_layer):\n                    right_layer, right_client = get_local_tile_layer(\n                        right_layer,\n                        tile_format=\"folium\",\n                        return_client=True,\n                        **right_args,\n                    )\n                    bounds = image_bounds(right_client)\n                else:\n                    right_layer = folium.raster_layers.TileLayer(\n                        tiles=right_layer,\n                        name=right_name,\n                        attr=\" \",\n                        overlay=True,\n                        **right_args,\n                    )\n            elif isinstance(right_layer, folium.raster_layers.TileLayer) or isinstance(\n                left_layer, folium.WmsTileLayer\n            ):\n                pass\n            elif is_array(right_layer):\n                right_layer = array_to_image(right_layer, **right_array_args)\n                right_layer, _ = get_local_tile_layer(\n                    right_layer,\n                    return_client=True,\n                    tile_format=\"folium\",\n                    **right_args,\n                )\n            else:\n                raise ValueError(\n                    f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            control = folium.plugins.SideBySideLayers(\n                layer_left=left_layer, layer_right=right_layer\n            )\n            left_layer.add_to(self)\n            right_layer.add_to(self)\n            control.add_to(self)\n\n            if left_label is not None:\n                if \"&lt;\" not in left_label:\n                    left_label = f\"&lt;h4&gt;{left_label}&lt;/h4&gt;\"\n                self.add_html(left_label, position=left_position)\n\n            if right_label is not None:\n                if \"&lt;\" not in right_label:\n                    right_label = f\"&lt;h4&gt;{right_label}&lt;/h4&gt;\"\n                self.add_html(right_label, position=right_position)\n            if bounds is not None:\n                self.fit_bounds(bounds)\n\n        except Exception as e:\n            print(\"The provided layers are invalid!\")\n            raise ValueError(e)\n\n    def add_data(\n        self,\n        data: Union[str, pd.DataFrame],\n        column: str,\n        cmap: Optional[str] = None,\n        colors: Optional[List] = None,\n        labels: Optional[List] = None,\n        scheme: Optional[str] = \"Quantiles\",\n        k: Optional[int] = 5,\n        add_legend: Optional[bool] = True,\n        legend_title: Optional[str] = None,\n        legend_position: Optional[str] = \"bottomright\",\n        legend_kwds: Optional[dict] = None,\n        classification_kwds: Optional[dict] = None,\n        style_function: Optional[Callable] = None,\n        highlight_function: Optional[Callable] = None,\n        layer_name: Optional[str] = \"Untitled\",\n        info_mode: Optional[str] = \"on_hover\",\n        encoding: Optional[str] = \"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"Add vector data to the map with a variety of classification schemes.\n\n        Args:\n            data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n            column (str): The column to classify.\n            cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n            colors (list, optional): A list of colors to use for the classification. Defaults to None.\n            labels (list, optional): A list of labels to use for the legend. Defaults to None.\n            scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n            add_legend (bool, optional): Whether to add a legend to the map. Defaults to True.\n            legend_title (str, optional): The title of the legend. Defaults to None.\n            legend_position (str, optional): The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.\n            legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n                Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n                Additional accepted keywords when `scheme` is specified:\n                fmt : string\n                    A formatting specification for the bin edges of the classes in the\n                    legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n                labels : list-like\n                    A list of legend labels to override the auto-generated labblels.\n                    Needs to have the same number of elements as the number of\n                    classes (`k`).\n                interval : boolean (default False)\n                    An option to control brackets from mapclassify legend.\n                    If True, open/closed interval brackets are shown in the legend.\n            classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style_function (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n                style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n                style is a dictionary of the following form:\n                    style = {\n                    \"stroke\": False,\n                    \"color\": \"#ff0000\",\n                    \"weight\": 1,\n                    \"opacity\": 1,\n                    \"fill\": True,\n                    \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 1.0,\n                    \"dashArray\": \"9\"\n                    \"clickable\": True,\n                }\n            hightlight_function (function, optional): Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                highlight_function is a function that takes the feature as argument and should return a dictionary of the following form:\n                highlight_function = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n            **kwargs: Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.\n        \"\"\"\n\n        import warnings\n\n        gdf, legend_dict = classify(\n            data=data,\n            column=column,\n            cmap=cmap,\n            colors=colors,\n            labels=labels,\n            scheme=scheme,\n            k=k,\n            legend_kwds=legend_kwds,\n            classification_kwds=classification_kwds,\n        )\n\n        if legend_title is None:\n            legend_title = column\n\n        if \"style\" in kwargs:\n            warnings.warn(\n                \"The style arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"style\")\n\n        if \"hover_style\" in kwargs:\n            warnings.warn(\n                \"The hover_style arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"hover_style\")\n\n        if \"style_callback\" in kwargs:\n            warnings.warn(\n                \"The style_callback arguments is for ipyleaflet only. \",\n                UserWarning,\n            )\n            kwargs.pop(\"style_callback\")\n\n        if style_function is None:\n            style_function = lambda feat: {\n                # \"stroke\": False,\n                # \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n                \"fillColor\": feat[\"properties\"][\"color\"],\n            }\n\n        if highlight_function is None:\n            highlight_function = lambda feat: {\n                \"weight\": 2,\n                \"fillOpacity\": 0.5,\n            }\n\n        self.add_gdf(\n            gdf,\n            layer_name=layer_name,\n            style_function=style_function,\n            highlight_function=highlight_function,\n            info_mode=info_mode,\n            encoding=encoding,\n            **kwargs,\n        )\n        if add_legend:\n            self.add_legend(title=legend_title, legend_dict=legend_dict)\n\n    def add_image(\n        self,\n        image: str,\n        position: Optional[Tuple] = (0, 0),\n        **kwargs,\n    ):\n        \"\"\"Add an image to the map.\n\n        Args:\n            image (str | ipywidgets.Image): The image to add.\n            position (tuple, optional): The position of the image in the format of (x, y),\n                the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n        \"\"\"\n        import base64\n\n        if isinstance(image, str):\n            if image.startswith(\"http\"):\n                html = f'&lt;img src=\"{image}\"&gt;'\n                if isinstance(position, tuple):\n                    position = \"bottomright\"\n                self.add_html(html, position=position, **kwargs)\n\n            elif os.path.exists(image):\n                if position == \"bottomleft\":\n                    position = (5, 5)\n                elif position == \"bottomright\":\n                    position = (80, 5)\n                elif position == \"topleft\":\n                    position = (5, 60)\n                elif position == \"topright\":\n                    position = (80, 60)\n\n                with open(image, \"rb\") as lf:\n                    # open in binary mode, read bytes, encode, decode obtained bytes as utf-8 string\n                    b64_content = base64.b64encode(lf.read()).decode(\"utf-8\")\n                    widget = plugins.FloatImage(\n                        \"data:image/png;base64,{}\".format(b64_content),\n                        bottom=position[1],\n                        left=position[0],\n                    )\n                    widget.add_to(self)\n\n        else:\n            raise Exception(\"Invalid image\")\n\n    def add_widget(\n        self, content: str, position: Optional[str] = \"bottomright\", **kwargs\n    ):\n        \"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n        Args:\n            content (str): The widget to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        from matplotlib import figure\n        import base64\n        from io import BytesIO\n\n        allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n        if position not in allowed_positions:\n            raise Exception(f\"position must be one of {allowed_positions}\")\n\n        try:\n            if isinstance(content, str):\n                widget = CustomControl(content, position=position)\n                widget.add_to(self)\n            elif isinstance(content, figure.Figure):\n                buf = BytesIO()\n                content.savefig(buf, format=\"png\")\n                buf.seek(0)\n                b64_content = base64.b64encode(buf.read()).decode(\"utf-8\")\n                widget = CustomControl(\n                    f\"\"\"&lt;img src=\"data:image/png;base64,{b64_content}\"&gt;\"\"\",\n                    position=position,\n                )\n                widget.add_to(self)\n            else:\n                raise Exception(\"The content must be a string or a matplotlib figure\")\n\n        except Exception as e:\n            raise Exception(f\"Error adding widget: {e}\")\n\n    def add_html(self, html: str, position: Optional[str] = \"bottomright\", **kwargs):\n        \"\"\"Add HTML to the map.\n\n        Args:\n            html (str): The HTML to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        self.add_widget(html, position=position, **kwargs)\n\n    def add_text(\n        self,\n        text: str,\n        fontsize: Optional[int] = 20,\n        fontcolor: Optional[str] = \"black\",\n        bold: Optional[bool] = False,\n        padding: Optional[str] = \"5px\",\n        background: Optional[bool] = True,\n        bg_color: Optional[str] = \"white\",\n        border_radius: Optional[str] = \"5px\",\n        position: Optional[str] = \"bottomright\",\n        **kwargs,\n    ):\n        \"\"\"Add text to the map.\n\n        Args:\n            text (str): The text to add.\n            fontsize (int, optional): The font size. Defaults to 20.\n            fontcolor (str, optional): The font color. Defaults to \"black\".\n            bold (bool, optional): Whether to use bold font. Defaults to False.\n            padding (str, optional): The padding. Defaults to \"5px\".\n            background (bool, optional): Whether to use background. Defaults to True.\n            bg_color (str, optional): The background color. Defaults to \"white\".\n            border_radius (str, optional): The border radius. Defaults to \"5px\".\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        if background:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n            padding: {padding}; background-color: {bg_color};\n            border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n        else:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n            padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n        self.add_html(text, position=position, **kwargs)\n\n    def add_vector_tile(\n        self,\n        url: Optional[str],\n        styles: Optional[Union[dict, str]] = {},\n        layer_name: Optional[str] = \"Vector Tile\",\n        **kwargs,\n    ):\n        \"\"\"Adds a VectorTileLayer to the map. It wraps the folium.plugins.VectorGridProtobuf class. See\n            https://github.com/python-visualization/folium/blob/main/folium/plugins/vectorgrid_protobuf.py#L7\n\n        Args:\n            url (str, optional): The URL of the tile layer\n            styles (dict | str, optional): Style dict, specific to the vector tile source.\n                If styles is given as a string, it will be passed directly to folium.plugins.VectorGrid\n                directly, ignoring additional kwargs. See the \"conditional styling\" example in\n                https://github.com/iwpnd/folium-vectorgrid\n            layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n            kwargs: Additional keyword arguments to pass to the folium.plugins.VectorGridProtobuf class.\n        \"\"\"\n        if isinstance(styles, str):\n            options = styles\n        else:\n            options = {}\n            for key, value in kwargs.items():\n                options[key] = value\n\n            if \"vector_tile_layer_styles\" in options:\n                styles = options[\"vector_tile_layer_styles\"]\n                del options[\"vector_tile_layer_styles\"]\n\n            if styles:\n                options[\"vectorTileLayerStyles\"] = styles\n\n        vc = plugins.VectorGridProtobuf(url, layer_name, options)\n        self.add_child(vc)\n\n    add_vector_tile_layer = add_vector_tile\n\n    def to_gradio(\n        self, width: Optional[str] = \"100%\", height: Optional[str] = \"500px\", **kwargs\n    ):\n        \"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n            attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n        Args:\n            width (str, optional): The width of the map. Defaults to '100%'.\n            height (str, optional): The height of the map. Defaults to '500px'.\n\n        Returns:\n            str: The HTML string to use in Gradio.\n        \"\"\"\n\n        if isinstance(width, int):\n            width = f\"{width}px\"\n        if isinstance(height, int):\n            height = f\"{height}px\"\n\n        html = self.to_html()\n        lines = html.split(\"\\n\")\n        output = []\n        skipped_lines = []\n        for index, line in enumerate(lines):\n            if index in skipped_lines:\n                continue\n            if line.lstrip().startswith('{\"attribution\":'):\n                continue\n            elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n                for i in range(14):\n                    skipped_lines.append(index + i)\n            elif \"L.Control.geocoder\" in line:\n                for i in range(5):\n                    skipped_lines.append(index + i)\n            elif \"function(e)\" in line:\n                print(\n                    f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n                )\n            else:\n                output.append(line + \"\\n\")\n\n        return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera;\n        display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms\n        allow-scripts allow-same-origin allow-popups\n        allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\"\n        allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n\n    def oam_search(\n        self,\n        bbox: Optional[Union[List, str]] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        limit: Optional[int] = 100,\n        info_mode: Optional[str] = \"on_click\",\n        layer_args: Optional[dict] = {},\n        add_image: Optional[bool] = True,\n        **kwargs,\n    ):\n        \"\"\"Search OpenAerialMap for images within a bounding box and time range.\n\n        Args:\n            bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n            start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n            end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n            limit (int, optional): The maximum number of results to return. Defaults to 100.\n            info_mode (str, optional): The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.\n            layer_args (dict, optional): The layer arguments for add_gdf() function. Defaults to {}.\n            add_image (bool, optional): Whether to add the first 10 images to the map. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n        \"\"\"\n\n        gdf = oam_search(\n            bbox=bbox, start_date=start_date, end_date=end_date, limit=limit, **kwargs\n        )\n\n        if \"layer_name\" not in layer_args:\n            layer_args[\"layer_name\"] = \"Footprints\"\n\n        if \"style\" not in layer_args:\n            layer_args[\"style\"] = {\n                # \"stroke\": True,\n                \"color\": \"#3388ff\",\n                \"weight\": 2,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n\n        if \"highlight_function\" not in layer_args:\n            layer_args[\"highlight_function\"] = lambda feat: {\n                \"weight\": layer_args[\"style\"][\"weight\"] + 2,\n                \"fillOpacity\": 0,\n            }\n\n        if gdf is not None:\n            self.add_gdf(gdf, info_mode=info_mode, **layer_args)\n            setattr(self, \"oam_gdf\", gdf)\n\n            if add_image:\n                ids = gdf[\"_id\"].tolist()\n                images = gdf[\"tms\"].tolist()\n\n                if len(images) &gt; 5:\n                    print(f\"Found {len(images)} images. \\nShowing the first 5.\")\n\n                for index, image in enumerate(images):\n                    if index == 5:\n                        break\n                    self.add_tile_layer(\n                        url=image, name=ids[index], attribution=\"OpenAerialMap\"\n                    )\n        else:\n            print(\"No images found.\")\n\n    def remove_labels(self, **kwargs):\n        \"\"\"Removes a layer from the map.\"\"\"\n        print(\"The folium plotting backend does not support removing labels.\")\n\n    def add_minimap(self, zoom=5, position=\"bottomright\"):\n        \"\"\"Adds a minimap (overview) to the ipyleaflet map.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def add_point_layer(\n        self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n    ):\n        \"\"\"Adds a point layer to the map with a popup attribute.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def add_raster_legacy(\n        self,\n        image,\n        bands=None,\n        layer_name=None,\n        colormap=None,\n        x_dim=\"x\",\n        y_dim=\"y\",\n    ):\n        \"\"\"Adds a local raster dataset to the map.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def add_time_slider(\n        self,\n        layers_dict={},\n        labels=None,\n        time_interval=1,\n        position=\"bottomright\",\n        slider_length=\"150px\",\n        **kwargs,\n    ):\n        \"\"\"Adds a time slider to the map.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def add_xy_data(\n        self,\n        in_csv,\n        x=\"longitude\",\n        y=\"latitude\",\n        label=None,\n        layer_name=\"Marker cluster\",\n    ):\n        \"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def basemap_demo(self):\n        \"\"\"A demo for using leafmap basemaps.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def find_layer(self, name):\n        \"\"\"Finds layer by name.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def find_layer_index(self, name):\n        \"\"\"Finds layer index by name.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def get_layer_names(self):\n        \"\"\"Gets layer names as a list.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def get_scale(self):\n        \"\"\"Returns the approximate pixel scale of the current map view, in meters.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def image_overlay(self, url: str, bounds: Tuple, name: str):\n        \"\"\"Overlays an image from the Internet or locally on the map.\n\n        Args:\n            url (str): http URL or local file path to the image.\n            bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n            name (str): name of the layer to show on the layer control.\n        \"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def layer_opacity(self, name, value=1.0):\n        \"\"\"Changes layer opacity.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def to_image(self, outfile=None, monitor=1):\n        \"\"\"Saves the map as a PNG or JPG image.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def toolbar_reset(self):\n        \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def video_overlay(self, url, bounds, name):\n        \"\"\"Overlays a video from the Internet on the map.\"\"\"\n        raise NotImplementedError(\n            \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n        )\n\n    def add_search_control(\n        self, url, marker=None, zoom=None, position=\"topleft\", **kwargs\n    ):\n        \"\"\"Adds a search control to the map.\"\"\"\n        print(\"The folium plotting backend does not support this function.\")\n\n    def save_draw_features(self, out_file: str, indent: Optional[int] = 4, **kwargs):\n        \"\"\"Save the draw features to a file.\n\n        Args:\n            out_file (str): The output file path.\n            indent (int, optional): The indentation level when saving data as a GeoJSON. Defaults to 4.\n        \"\"\"\n        print(\"The folium plotting backend does not support this function.\")\n\n    def edit_vector(self, data: Union[str, dict], **kwargs):\n        \"\"\"Edit a vector layer.\n\n        Args:\n            data (dict | str): The data to edit. It can be a GeoJSON dictionary or a file path.\n        \"\"\"\n        print(\"The folium plotting backend does not support this function.\")\n\n    def add_velocity(\n        self,\n        data,\n        zonal_speed,\n        meridional_speed,\n        latitude_dimension=\"lat\",\n        longitude_dimension=\"lon\",\n        velocity_scale=0.01,\n        max_velocity=20,\n        display_options={},\n        name=\"Velocity\",\n        **kwargs,\n    ):\n        print(f\"The folium plotting backend does not support this function.\")\n\n    def user_roi_bounds(self, decimals: Optional[int] = 4) -&gt; List:\n        \"\"\"Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n\n        Args:\n            decimals (int, optional): The number of decimals to round the coordinates to. Defaults to 4.\n\n        Returns:\n            list: The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n        \"\"\"\n        print(f\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add","title":"<code>add(self, object, **kwargs)</code>","text":"<p>Adds something to the map. This method is not implemented in folium.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add(self, object, **kwargs):\n    \"\"\"Adds something to the map. This method is not implemented in folium.\"\"\"\n    pass\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID', show=True, **kwargs)</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from ee_basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>show</code> <code>bool</code> <p>Whether to show the basemap. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to folium.TileLayer.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_basemap(\n    self, basemap: Optional[str] = \"HYBRID\", show: Optional[bool] = True, **kwargs\n):\n    \"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from ee_basemaps. Defaults to 'HYBRID'.\n        show (bool, optional): Whether to show the basemap. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to folium.TileLayer.\n    \"\"\"\n    import xyzservices\n\n    try:\n        if basemap in [\"ROADMAP\", \"SATELLITE\", \"HYBRID\", \"TERRAIN\"]:\n            layer = get_google_map(basemap, backend=\"folium\", show=show, **kwargs)\n            layer.add_to(self)\n            return\n\n        if isinstance(basemap, xyzservices.TileProvider):\n            name = basemap.name\n            url = basemap.build_url()\n            attribution = basemap.attribution\n            if \"max_zoom\" in basemap.keys():\n                max_zoom = basemap[\"max_zoom\"]\n            else:\n                max_zoom = 22\n            layer = folium.TileLayer(\n                tiles=url,\n                attr=attribution,\n                name=name,\n                max_zoom=max_zoom,\n                overlay=True,\n                control=True,\n                show=show,\n                **kwargs,\n            )\n\n            self.add_layer(layer)\n\n            arc_add_layer(url, name)\n\n        elif basemap in basemaps:\n            bmap = basemaps[basemap]\n            bmap.show = show\n            bmap.add_to(self)\n            if isinstance(basemaps[basemap], folium.TileLayer):\n                url = basemaps[basemap].tiles\n            elif isinstance(basemaps[basemap], folium.WmsTileLayer):\n                url = basemaps[basemap].url\n            arc_add_layer(url, basemap)\n        else:\n            print(\n                \"Basemap can only be one of the following: {}\".format(\n                    \", \".join(basemaps.keys())\n                )\n            )\n\n    except Exception:\n        raise Exception(\n            \"Basemap can only be one of the following: {}\".format(\n                \", \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_census_data","title":"<code>add_census_data(self, wms, layer, census_dict=None, **kwargs)</code>","text":"<p>Adds a census data layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>wms</code> <code>str</code> <p>The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html</p> required <code>layer</code> <code>str</code> <p>The layer name to add to the map.</p> required <code>census_dict</code> <code>dict</code> <p>A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_census_data(\n    self, wms: str, layer: str, census_dict: Optional[Dict] = None, **kwargs\n):\n    \"\"\"Adds a census data layer to the map.\n\n    Args:\n        wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n        layer (str): The layer name to add to the map.\n        census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n    \"\"\"\n\n    try:\n        if census_dict is None:\n            census_dict = get_census_dict()\n\n        if wms not in census_dict.keys():\n            raise ValueError(\n                f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n            )\n\n        layers = census_dict[wms][\"layers\"]\n        if layer not in layers:\n            raise ValueError(\n                f\"The layer name is not valid. It must be one of {layers}\"\n            )\n\n        url = census_dict[wms][\"url\"]\n        if \"name\" not in kwargs:\n            kwargs[\"name\"] = layer\n        if \"attribution\" not in kwargs:\n            kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n        if \"format\" not in kwargs:\n            kwargs[\"format\"] = \"image/png\"\n        if \"transparent\" not in kwargs:\n            kwargs[\"transparent\"] = True\n\n        self.add_wms_layer(url, layer, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_circle_markers_from_xy","title":"<code>add_circle_markers_from_xy(self, data, x='longitude', y='latitude', radius=10, popup=None, tooltip=None, min_width=100, max_width=200, font_size=2, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>radius</code> <code>int</code> <p>The radius of the circle. Defaults to 10.</p> <code>10</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>list</code> <p>A list of column names to be used as the tooltip. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> <code>font_size</code> <code>int</code> <p>The font size of the popup. Defaults to 2.</p> <code>2</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_circle_markers_from_xy(\n    self,\n    data: Union[str, pd.DataFrame],\n    x: Optional[str] = \"longitude\",\n    y: Optional[str] = \"latitude\",\n    radius: Optional[int] = 10,\n    popup: Optional[List] = None,\n    tooltip: Optional[List] = None,\n    min_width: Optional[int] = 100,\n    max_width: Optional[int] = 200,\n    font_size: Optional[int] = 2,\n    **kwargs,\n):\n    \"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        radius (int, optional): The radius of the circle. Defaults to 10.\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        tooltip (list, optional): A list of column names to be used as the tooltip. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n        font_size (int, optional): The font size of the popup. Defaults to 2.\n\n    \"\"\"\n    import pandas as pd\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = None\n    if \"fill\" not in kwargs:\n        kwargs[\"fill\"] = True\n    if \"fill_color\" not in kwargs:\n        kwargs[\"fill_color\"] = \"blue\"\n    if \"fill_opacity\" not in kwargs:\n        kwargs[\"fill_opacity\"] = 0.7\n\n    if popup is None:\n        popup = col_names\n\n    if not isinstance(popup, list):\n        popup = [popup]\n\n    if tooltip is not None:\n        if not isinstance(tooltip, list):\n            tooltip = [tooltip]\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    for idx, row in df.iterrows():\n        html = \"\"\n        for p in popup:\n            html = (\n                html\n                + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                + p\n                + \"&lt;/b&gt;\"\n                + \": \"\n                + str(row[p])\n                + \"&lt;br&gt;&lt;/font&gt;\"\n            )\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        if tooltip is not None:\n            html = \"\"\n            for p in tooltip:\n                html = (\n                    html\n                    + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                    + p\n                    + \"&lt;/b&gt;\"\n                    + \": \"\n                    + str(row[p])\n                    + \"&lt;br&gt;&lt;/font&gt;\"\n                )\n\n            tooltip_str = folium.Tooltip(html)\n        else:\n            tooltip_str = None\n\n        folium.CircleMarker(\n            location=[row[y], row[x]],\n            radius=radius,\n            popup=popup_html,\n            tooltip=tooltip_str,\n            **kwargs,\n        ).add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='.', opacity=1.0, shown=True, bands=None, titiler_endpoint=None, zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to '.'.</p> <code>'.'</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>bands</code> <code>list</code> <p>A list of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = \"Untitled\",\n    attribution: Optional[str] = \".\",\n    opacity: Optional[float] = 1.0,\n    shown: Optional[bool] = True,\n    bands: Optional[List] = None,\n    titiler_endpoint: Optional[str] = None,\n    zoom_to_layer=True,\n    **kwargs,\n):\n    \"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to '.'.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        bands (list, optional): A list of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): TiTiler endpoint. Defaults to \"https://titiler.xyz\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n            color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n            apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    bounds = cog_bounds(url, titiler_endpoint)\n    self.add_tile_layer(\n        url=tile_url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        shown=shown,\n    )\n    if zoom_to_layer:\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_colorbar","title":"<code>add_colorbar(self, colors, vmin=0, vmax=1, index=None, caption='', categorical=False, step=None, **kwargs)</code>","text":"<p>Add a colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)</p> required <code>vmin</code> <code>int</code> <p>The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.</p> <code>1</code> <code>index</code> <code>list</code> <p>The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.</p> <code>None</code> <code>caption</code> <code>str</code> <p>The caption for the colormap. Defaults to \"\".</p> <code>''</code> <code>categorical</code> <code>bool</code> <p>Whether or not to create a categorical colormap. Defaults to False.</p> <code>False</code> <code>step</code> <code>int</code> <p>The step to split the LinearColormap into a StepColormap. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_colorbar(\n    self,\n    colors: List,\n    vmin: Optional[int] = 0,\n    vmax: Optional[int] = 1,\n    index: Optional[List] = None,\n    caption: Optional[str] = \"\",\n    categorical: Optional[bool] = False,\n    step: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"Add a colorbar to the map.\n\n    Args:\n        colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n        vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n        vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n        index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n        caption (str, optional): The caption for the colormap. Defaults to \"\".\n        categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n        step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n    \"\"\"\n    from box import Box\n    from branca.colormap import LinearColormap\n\n    if isinstance(colors, Box):\n        try:\n            colors = list(colors[\"default\"])\n        except Exception as e:\n            print(\"The provided color list is invalid.\")\n            raise Exception(e)\n\n    if all(len(color) == 6 for color in colors):\n        colors = [\"#\" + color for color in colors]\n\n    colormap = LinearColormap(\n        colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n    )\n\n    if categorical:\n        if step is not None:\n            colormap = colormap.to_step(step)\n        elif index is not None:\n            colormap = colormap.to_step(len(index) - 1)\n        else:\n            colormap = colormap.to_step(3)\n\n    self.add_child(colormap)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_colormap","title":"<code>add_colormap(self, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=12, label_weight='normal', tick_size=10, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, position=(70, 5), **kwargs)</code>","text":"<p>Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>12</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>10</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>position</code> <code>tuple</code> <p>The position of the colormap in the format of (x, y), the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).</p> <code>(70, 5)</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_colormap(\n    self,\n    width: Optional[float] = 4.0,\n    height: Optional[float] = 0.3,\n    vmin: Optional[float] = 0,\n    vmax: Optional[float] = 1.0,\n    palette: Optional[List] = None,\n    vis_params: Optional[dict] = None,\n    cmap: Optional[str] = \"gray\",\n    discrete: Optional[bool] = False,\n    label: Optional[str] = None,\n    label_size: Optional[int] = 12,\n    label_weight: Optional[str] = \"normal\",\n    tick_size: Optional[int] = 10,\n    bg_color: Optional[str] = \"white\",\n    orientation: Optional[str] = \"horizontal\",\n    dpi: Optional[Union[str, float]] = \"figure\",\n    transparent: Optional[bool] = False,\n    position: Optional[Tuple] = (70, 5),\n    **kwargs,\n):\n    \"\"\"Add a colorbar to the map. Under the hood, it uses matplotlib to generate the colorbar, save it as a png file, and add it to the map using m.add_image().\n\n    Args:\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        position (tuple, optional): The position of the colormap in the format of (x, y),\n            the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n\n    colorbar = save_colorbar(\n        None,\n        width,\n        height,\n        vmin,\n        vmax,\n        palette,\n        vis_params,\n        cmap,\n        discrete,\n        label,\n        label_size,\n        label_weight,\n        tick_size,\n        bg_color,\n        orientation,\n        dpi,\n        transparent,\n        show_colorbar=False,\n        **kwargs,\n    )\n\n    self.add_image(colorbar, position=position)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_data","title":"<code>add_data(self, data, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, add_legend=True, legend_title=None, legend_position='bottomright', legend_kwds=None, classification_kwds=None, style_function=None, highlight_function=None, layer_name='Untitled', info_mode='on_hover', encoding='utf-8', **kwargs)</code>","text":"<p>Add vector data to the map with a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>add_legend</code> <code>bool</code> <p>Whether to add a legend to the map. Defaults to True.</p> <code>True</code> <code>legend_title</code> <code>str</code> <p>The title of the legend. Defaults to None.</p> <code>None</code> <code>legend_position</code> <code>str</code> <p>The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style_function</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. style_callback is a function that takes the feature as argument and should return a dictionary of the following form: style_callback = lambda feat: {\"fillColor\": feat\"properties\"} style is a dictionary of the following form:     style = {     \"stroke\": False,     \"color\": \"#ff0000\",     \"weight\": 1,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#ffffff\",     \"fillOpacity\": 1.0,     \"dashArray\": \"9\"     \"clickable\": True, }</p> <code>None</code> <code>hightlight_function</code> <code>function</code> <p>Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. highlight_function is a function that takes the feature as argument and should return a dictionary of the following form: highlight_function = lambda feat: {\"fillColor\": feat\"properties\"}</p> required <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_data(\n    self,\n    data: Union[str, pd.DataFrame],\n    column: str,\n    cmap: Optional[str] = None,\n    colors: Optional[List] = None,\n    labels: Optional[List] = None,\n    scheme: Optional[str] = \"Quantiles\",\n    k: Optional[int] = 5,\n    add_legend: Optional[bool] = True,\n    legend_title: Optional[str] = None,\n    legend_position: Optional[str] = \"bottomright\",\n    legend_kwds: Optional[dict] = None,\n    classification_kwds: Optional[dict] = None,\n    style_function: Optional[Callable] = None,\n    highlight_function: Optional[Callable] = None,\n    layer_name: Optional[str] = \"Untitled\",\n    info_mode: Optional[str] = \"on_hover\",\n    encoding: Optional[str] = \"utf-8\",\n    **kwargs,\n):\n    \"\"\"Add vector data to the map with a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        add_legend (bool, optional): Whether to add a legend to the map. Defaults to True.\n        legend_title (str, optional): The title of the legend. Defaults to None.\n        legend_position (str, optional): The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style_function (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            style is a dictionary of the following form:\n                style = {\n                \"stroke\": False,\n                \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fill\": True,\n                \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                \"dashArray\": \"9\"\n                \"clickable\": True,\n            }\n        hightlight_function (function, optional): Highlighting function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            highlight_function is a function that takes the feature as argument and should return a dictionary of the following form:\n            highlight_function = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        **kwargs: Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.\n    \"\"\"\n\n    import warnings\n\n    gdf, legend_dict = classify(\n        data=data,\n        column=column,\n        cmap=cmap,\n        colors=colors,\n        labels=labels,\n        scheme=scheme,\n        k=k,\n        legend_kwds=legend_kwds,\n        classification_kwds=classification_kwds,\n    )\n\n    if legend_title is None:\n        legend_title = column\n\n    if \"style\" in kwargs:\n        warnings.warn(\n            \"The style arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"style\")\n\n    if \"hover_style\" in kwargs:\n        warnings.warn(\n            \"The hover_style arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"hover_style\")\n\n    if \"style_callback\" in kwargs:\n        warnings.warn(\n            \"The style_callback arguments is for ipyleaflet only. \",\n            UserWarning,\n        )\n        kwargs.pop(\"style_callback\")\n\n    if style_function is None:\n        style_function = lambda feat: {\n            # \"stroke\": False,\n            # \"color\": \"#ff0000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 1.0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n            \"fillColor\": feat[\"properties\"][\"color\"],\n        }\n\n    if highlight_function is None:\n        highlight_function = lambda feat: {\n            \"weight\": 2,\n            \"fillOpacity\": 0.5,\n        }\n\n    self.add_gdf(\n        gdf,\n        layer_name=layer_name,\n        style_function=style_function,\n        highlight_function=highlight_function,\n        info_mode=info_mode,\n        encoding=encoding,\n        **kwargs,\n    )\n    if add_legend:\n        self.add_legend(title=legend_title, legend_dict=legend_dict)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_ee_layer","title":"<code>add_ee_layer(self, asset_id, name=None, attribution='Google Earth Engine', shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a Google Earth Engine tile layer to the map based on the tile layer URL from     https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The ID of the Earth Engine asset.</p> required <code>name</code> <code>str</code> <p>The name of the tile layer. If not provided, the asset ID will be used. Default is None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution text to be displayed. Default is \"Google Earth Engine\".</p> <code>'Google Earth Engine'</code> <code>shown</code> <code>bool</code> <p>Whether the tile layer should be shown on the map. Default is True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the tile layer. Default is 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying <code>add_tile_layer</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_ee_layer(\n    self,\n    asset_id: str,\n    name: str = None,\n    attribution: str = \"Google Earth Engine\",\n    shown: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n        https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n    Args:\n        asset_id (str): The ID of the Earth Engine asset.\n        name (str, optional): The name of the tile layer. If not provided, the asset ID will be used. Default is None.\n        attribution (str, optional): The attribution text to be displayed. Default is \"Google Earth Engine\".\n        shown (bool, optional): Whether the tile layer should be shown on the map. Default is True.\n        opacity (float, optional): The opacity of the tile layer. Default is 1.0.\n        **kwargs: Additional keyword arguments to be passed to the underlying `add_tile_layer` method.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n\n    df = pd.read_csv(\n        \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n        sep=\"\\t\",\n    )\n\n    asset_id = asset_id.strip()\n    if name is None:\n        name = asset_id\n\n    if asset_id in df[\"id\"].values:\n        url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n        self.add_tile_layer(\n            url,\n            name,\n            attribution=attribution,\n            shown=shown,\n            opacity=opacity,\n            **kwargs,\n        )\n    else:\n        print(f\"The provided EE tile layer {asset_id} does not exist.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', zoom_to_layer=True, info_mode='on_hover', **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrameto the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name: Optional[str] = \"Untitled\",\n    zoom_to_layer: Optional[bool] = True,\n    info_mode: Optional[str] = \"on_hover\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n\n    for col in gdf.columns:\n        if gdf[col].dtype in [\"datetime64[ns]\", \"datetime64[ns, UTC]\"]:\n            gdf[col] = gdf[col].astype(str)\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(\n        data,\n        layer_name=layer_name,\n        info_mode=info_mode,\n        zoom_to_layer=zoom_to_layer,\n        **kwargs,\n    )\n\n    # if zoom_to_layer:\n    #     import numpy as np\n\n    #     bounds = gdf.to_crs(epsg=\"4326\").bounds\n    #     west = np.min(bounds[\"minx\"])\n    #     south = np.min(bounds[\"miny\"])\n    #     east = np.max(bounds[\"maxx\"])\n    #     north = np.max(bounds[\"maxy\"])\n    #     self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', zoom_to_layer=True, info_mode='on_hover', **kwargs)</code>","text":"<p>Adds a GeoPandas GeoDataFrameto the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_gdf_from_postgis(\n    self,\n    sql: str,\n    con,\n    layer_name: Optional[str] = \"Untitled\",\n    zoom_to_layer: Optional[bool] = True,\n    info_mode: Optional[str] = \"on_hover\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoPandas GeoDataFrameto the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    if \"fill_colors\" in kwargs:\n        kwargs.pop(\"fill_colors\")\n    gdf = read_postgis(sql, con, **kwargs)\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(data, layer_name=layer_name, info_mode=info_mode, **kwargs)\n\n    if zoom_to_layer:\n        import numpy as np\n\n        bounds = gdf.to_crs(epsg=\"4326\").bounds\n        west = np.min(bounds[\"minx\"])\n        south = np.min(bounds[\"miny\"])\n        east = np.max(bounds[\"maxx\"])\n        north = np.max(bounds[\"maxy\"])\n        self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', encoding='utf-8', info_mode='on_hover', zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str</code> <p>The input file path to the GeoJSON.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_geojson(\n    self,\n    in_geojson: str,\n    layer_name: Optional[str] = \"Untitled\",\n    encoding: Optional[str] = \"utf-8\",\n    info_mode: Optional[str] = \"on_hover\",\n    zoom_to_layer: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str): The input file path to the GeoJSON.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click.\n            Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import requests\n    import random\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                if is_jupyterlite():\n                    import pyodide\n\n                    output = os.path.basename(in_geojson)\n\n                    output = os.path.abspath(output)\n                    obj = pyodide.http.open_url(in_geojson)\n                    with open(output, \"w\") as fd:\n                        shutil.copyfileobj(obj, fd)\n                    with open(output, \"r\") as fd:\n                        data = json.load(fd)\n                else:\n                    in_geojson = github_raw_url(in_geojson)\n                    data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    # interchangeable parameters between ipyleaflet and folium.\n    style_dict = {}\n    if \"style_function\" not in kwargs:\n        if \"style\" in kwargs:\n            style_dict = kwargs[\"style\"]\n            if isinstance(kwargs[\"style\"], dict) and len(kwargs[\"style\"]) &gt; 0:\n                kwargs[\"style_function\"] = lambda x: style_dict\n            kwargs.pop(\"style\")\n        else:\n            style_dict = {\n                # \"stroke\": True,\n                \"color\": \"#3388ff\",\n                \"weight\": 2,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n            kwargs[\"style_function\"] = lambda x: style_dict\n\n    if \"style_callback\" in kwargs:\n        kwargs.pop(\"style_callback\")\n\n    if \"hover_style\" in kwargs:\n        kwargs.pop(\"hover_style\")\n\n    if \"fill_colors\" in kwargs:\n        fill_colors = kwargs[\"fill_colors\"]\n\n        def random_color(feature):\n            style_dict[\"fillColor\"] = random.choice(fill_colors)\n            return style_dict\n\n        kwargs[\"style_function\"] = random_color\n        kwargs.pop(\"fill_colors\")\n\n    if \"weight\" not in style_dict:\n        style_dict[\"weight\"] = 2\n\n    if \"highlight_function\" not in kwargs:\n        kwargs[\"highlight_function\"] = lambda feat: {\n            \"weight\": style_dict[\"weight\"] + 2,\n            \"fillOpacity\": 0,\n        }\n\n    tooltip = None\n    popup = None\n    if info_mode is not None:\n        if \"fields\" in kwargs:\n            props = kwargs[\"fields\"]\n            kwargs.pop(\"fields\")\n        else:\n            props = list(data[\"features\"][0][\"properties\"].keys())\n        if info_mode == \"on_hover\":\n            tooltip = folium.GeoJsonTooltip(fields=props)\n        elif info_mode == \"on_click\":\n            popup = folium.GeoJsonPopup(fields=props)\n\n    geojson = folium.GeoJson(\n        data=data, name=layer_name, tooltip=tooltip, popup=popup, **kwargs\n    )\n    geojson.add_to(self)\n\n    if zoom_to_layer:\n        bounds = get_bounds(data)\n        self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Union[str, List[List[float]], pd.DataFrame],\n    latitude: Optional[str] = \"latitude\",\n    longitude: Optional[str] = \"longitude\",\n    value: Optional[str] = \"value\",\n    name: Optional[str] = \"Heat map\",\n    radius: Optional[int] = 25,\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://stackoverflow.com/a/54756617\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        plugins.HeatMap(data, name=name, radius=radius, **kwargs).add_to(\n            folium.FeatureGroup(name=name).add_to(self)\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_html","title":"<code>add_html(self, html, position='bottomright', **kwargs)</code>","text":"<p>Add HTML to the map.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_html(self, html: str, position: Optional[str] = \"bottomright\", **kwargs):\n    \"\"\"Add HTML to the map.\n\n    Args:\n        html (str): The HTML to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    self.add_widget(html, position=position, **kwargs)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_image","title":"<code>add_image(self, image, position=(0, 0), **kwargs)</code>","text":"<p>Add an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | ipywidgets.Image</code> <p>The image to add.</p> required <code>position</code> <code>tuple</code> <p>The position of the image in the format of (x, y), the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).</p> <code>(0, 0)</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_image(\n    self,\n    image: str,\n    position: Optional[Tuple] = (0, 0),\n    **kwargs,\n):\n    \"\"\"Add an image to the map.\n\n    Args:\n        image (str | ipywidgets.Image): The image to add.\n        position (tuple, optional): The position of the image in the format of (x, y),\n            the percentage ranging from 0 to 100, starting from the lower-left corner. Defaults to (0, 0).\n    \"\"\"\n    import base64\n\n    if isinstance(image, str):\n        if image.startswith(\"http\"):\n            html = f'&lt;img src=\"{image}\"&gt;'\n            if isinstance(position, tuple):\n                position = \"bottomright\"\n            self.add_html(html, position=position, **kwargs)\n\n        elif os.path.exists(image):\n            if position == \"bottomleft\":\n                position = (5, 5)\n            elif position == \"bottomright\":\n                position = (80, 5)\n            elif position == \"topleft\":\n                position = (5, 60)\n            elif position == \"topright\":\n                position = (80, 60)\n\n            with open(image, \"rb\") as lf:\n                # open in binary mode, read bytes, encode, decode obtained bytes as utf-8 string\n                b64_content = base64.b64encode(lf.read()).decode(\"utf-8\")\n                widget = plugins.FloatImage(\n                    \"data:image/png;base64,{}\".format(b64_content),\n                    bottom=position[1],\n                    left=position[0],\n                )\n                widget.add_to(self)\n\n    else:\n        raise Exception(\"Invalid image\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', info_mode='on_hover', **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_kml(\n    self,\n    in_kml: str,\n    layer_name: Optional[str] = \"Untitled\",\n    info_mode: Optional[str] = \"on_hover\",\n    **kwargs,\n):\n    \"\"\"Adds a KML file to the map.\n\n    Args:\n        in_kml (str): The input file path to the KML.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n        out_dir = os.path.abspath(\"./cache\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        in_kml = download_file(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n    else:\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML could not be found.\")\n\n    data = kml_to_geojson(in_kml)\n\n    self.add_geojson(data, layer_name=layer_name, info_mode=info_mode, **kwargs)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_labels","title":"<code>add_labels(self, data, column, font_size='12pt', font_color='black', font_family='arial', font_weight='normal', x='longitude', y='latitude', draggable=True, layer_name='Labels', **kwargs)</code>","text":"<p>Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame | gpd.GeoDataFrame | str</code> <p>The input data to label.</p> required <code>column</code> <code>str</code> <p>The column name of the data to label.</p> required <code>font_size</code> <code>str</code> <p>The font size of the labels. Defaults to \"12pt\".</p> <code>'12pt'</code> <code>font_color</code> <code>str</code> <p>The font color of the labels. Defaults to \"black\".</p> <code>'black'</code> <code>font_family</code> <code>str</code> <p>The font family of the labels. Defaults to \"arial\".</p> <code>'arial'</code> <code>font_weight</code> <code>str</code> <p>The font weight of the labels, can be normal, bold. Defaults to \"normal\".</p> <code>'normal'</code> <code>x</code> <code>str</code> <p>The column name of the longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name of the latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>draggable</code> <code>bool</code> <p>Whether the labels are draggable. Defaults to True.</p> <code>True</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Labels\".</p> <code>'Labels'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_labels(\n    self,\n    data: Union[pd.DataFrame, str],\n    column: str,\n    font_size: Optional[str] = \"12pt\",\n    font_color: Optional[str] = \"black\",\n    font_family: Optional[str] = \"arial\",\n    font_weight: Optional[str] = \"normal\",\n    x: Optional[str] = \"longitude\",\n    y: Optional[str] = \"latitude\",\n    draggable: Optional[bool] = True,\n    layer_name: Optional[str] = \"Labels\",\n    **kwargs,\n):\n    \"\"\"Adds a label layer to the map. Reference: https://python-visualization.github.io/folium/modules.html#folium.features.DivIcon\n\n    Args:\n        data (pd.DataFrame | gpd.GeoDataFrame | str): The input data to label.\n        column (str): The column name of the data to label.\n        font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n        font_color (str, optional): The font color of the labels. Defaults to \"black\".\n        font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n        font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n        x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n        y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n        draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n        layer_name (str, optional): The name of the layer. Defaults to \"Labels\".\n\n    \"\"\"\n    import warnings\n    import pandas as pd\n    from folium.features import DivIcon\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n        if \"geometry\" in data.columns or (\"geom\" in data.columns):\n            df[x] = df.centroid.x\n            df[y] = df.centroid.y\n    elif isinstance(data, str):\n        ext = os.path.splitext(data)[1]\n        if ext == \".csv\":\n            df = pd.read_csv(data)\n        elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n            try:\n                import geopandas as gpd\n\n                df = gpd.read_file(data)\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n            except ImportError:\n                print(\"geopandas is required to read geojson.\")\n                return\n    else:\n        raise ValueError(\"data must be a DataFrame or an ee.FeatureCollection.\")\n\n    if column not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if x not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if y not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n    try:\n        size = int(font_size.replace(\"pt\", \"\"))\n    except:\n        raise ValueError(\"font_size must be something like '10pt'\")\n\n    layer_group = folium.FeatureGroup(name=layer_name)\n    for index in df.index:\n        html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n        folium.Marker(\n            location=[df[y][index], df[x][index]],\n            icon=DivIcon(\n                icon_size=(1, 1),\n                icon_anchor=(size, size),\n                html=html,\n                **kwargs,\n            ),\n            draggable=draggable,\n        ).add_to(layer_group)\n\n    layer_group.add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_layer","title":"<code>add_layer(self, layer)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>TileLayer</code> <p>A TileLayer instance.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_layer(self, layer):\n    \"\"\"Adds a layer to the map.\n\n    Args:\n        layer (TileLayer): A TileLayer instance.\n    \"\"\"\n    layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds layer control to the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds layer control to the map.\"\"\"\n    layer_ctrl = False\n    for item in self.to_dict()[\"children\"]:\n        if item.startswith(\"layer_control\"):\n            layer_ctrl = True\n            break\n    if not layer_ctrl:\n        folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_legend","title":"<code>add_legend(self, title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, style={})</code>","text":"<p>Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.     If you want to add multiple legends to the map, you need to set the <code>draggable</code> argument to False.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\". Note that position is only valid when draggable is False.</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>style</code> <code>Optional[Dict]</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_legend(\n    self,\n    title: Optional[str] = \"Legend\",\n    labels: Optional[List] = None,\n    colors: Optional[List] = None,\n    legend_dict: Optional[Dict] = None,\n    builtin_legend: Optional[str] = None,\n    opacity: Optional[float] = 1.0,\n    position: Optional[str] = \"bottomright\",\n    draggable: Optional[bool] = True,\n    style: Optional[Dict] = {},\n):\n    \"\"\"Adds a customized legend to the map. Reference: https://bit.ly/3oV6vnH.\n        If you want to add multiple legends to the map, you need to set the `draggable` argument to False.\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n            Note that position is only valid when draggable is False.\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    \"\"\"\n    content = create_legend(\n        title,\n        labels,\n        colors,\n        legend_dict,\n        builtin_legend,\n        opacity,\n        position,\n        draggable,\n        style=style,\n    )\n    if draggable:\n        from branca.element import Template, MacroElement\n\n        content = (\n            '\"\"\"\\n{% macro html(this, kwargs) %}\\n'\n            + content\n            + '\\n{% endmacro %}\"\"\"'\n        )\n\n        macro = MacroElement()\n        macro._template = Template(content)\n\n        self.get_root().add_child(macro)\n    else:\n        self.add_html(content, position=position)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_local_tile","title":"<code>add_local_tile(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', array_args={}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_image</code>. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    indexes: Optional[int] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    attribution: Optional[str] = None,\n    layer_name: Optional[str] = \"Raster\",\n    array_args: Optional[Dict] = {},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        array_args (dict, optional): Additional arguments to pass to `array_to_image`. Defaults to {}.\n    \"\"\"\n\n    import numpy as np\n    import xarray as xr\n\n    if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n        source = array_to_image(source, **array_args)\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=\"folium\",\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n    self.add_layer(tile_layer)\n\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    self.zoom_to_bounds(bounds)\n\n    arc_add_layer(tile_layer.tiles, layer_name, True, 1.0)\n    arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_marker","title":"<code>add_marker(self, location, popup=None, tooltip=None, icon=None, draggable=False, **kwargs)</code>","text":"<p>Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>list | tuple</code> <p>The location of the marker in the format of [lat, lng].</p> required <code>popup</code> <code>str</code> <p>The popup text. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>str</code> <p>The tooltip text. Defaults to None.</p> <code>None</code> <code>icon</code> <code>str</code> <p>The icon to use. Defaults to None.</p> <code>None</code> <code>draggable</code> <code>bool</code> <p>Whether the marker is draggable. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_marker(\n    self,\n    location: Union[List, Tuple],\n    popup: Optional[str] = None,\n    tooltip: Optional[str] = None,\n    icon: Optional[str] = None,\n    draggable: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Adds a marker to the map. More info about marker options at https://python-visualization.github.io/folium/modules.html#folium.map.Marker.\n\n    Args:\n        location (list | tuple): The location of the marker in the format of [lat, lng].\n        popup (str, optional): The popup text. Defaults to None.\n        tooltip (str, optional): The tooltip text. Defaults to None.\n        icon (str, optional): The icon to use. Defaults to None.\n        draggable (bool, optional): Whether the marker is draggable. Defaults to False.\n    \"\"\"\n    if isinstance(location, list):\n        location = tuple(location)\n    if isinstance(location, tuple):\n        folium.Marker(\n            location=location,\n            popup=popup,\n            tooltip=tooltip,\n            icon=icon,\n            draggable=draggable,\n            **kwargs,\n        ).add_to(self)\n\n    else:\n        raise TypeError(\"The location must be a list or a tuple.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_markers_from_xy","title":"<code>add_markers_from_xy(self, data, x='longitude', y='latitude', popup=None, min_width=100, max_width=200, layer_name='Markers', icon=None, icon_shape='circle-dot', border_width=3, border_color='#0000ff', **kwargs)</code>","text":"<p>Adds markers to the map from a csv or Pandas DataFrame containing x, y values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Markers'</code> <code>icon</code> <code>str</code> <p>The Font-Awesome icon name to use to render the marker. Defaults to None.</p> <code>None</code> <code>icon_shape</code> <code>str</code> <p>The shape of the marker, such as \"retangle-dot\", \"circle-dot\". Defaults to 'circle-dot'.</p> <code>'circle-dot'</code> <code>border_width</code> <code>int</code> <p>The width of the border. Defaults to 3.</p> <code>3</code> <code>border_color</code> <code>str</code> <p>The color of the border. Defaults to '#0000ff'.</p> <code>'#0000ff'</code> <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to BeautifyIcon. See https://python-visualization.github.io/folium/plugins.html#folium.plugins.BeautifyIcon.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_markers_from_xy(\n    self,\n    data: Union[str, pd.DataFrame],\n    x: Optional[str] = \"longitude\",\n    y: Optional[str] = \"latitude\",\n    popup: Optional[List[str]] = None,\n    min_width: Optional[int] = 100,\n    max_width: Optional[int] = 200,\n    layer_name: Optional[str] = \"Markers\",\n    icon: Optional[str] = None,\n    icon_shape: Optional[str] = \"circle-dot\",\n    border_width: Optional[int] = 3,\n    border_color: Optional[str] = \"#0000ff\",\n    **kwargs,\n):\n    \"\"\"Adds markers to the map from a csv or Pandas DataFrame containing x, y values.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        icon (str, optional): The Font-Awesome icon name to use to render the marker. Defaults to None.\n        icon_shape (str, optional): The shape of the marker, such as \"retangle-dot\", \"circle-dot\". Defaults to 'circle-dot'.\n        border_width (int, optional): The width of the border. Defaults to 3.\n        border_color (str, optional): The color of the border. Defaults to '#0000ff'.\n        kwargs (dict, optional): Additional keyword arguments to pass to BeautifyIcon. See\n            https://python-visualization.github.io/folium/plugins.html#folium.plugins.BeautifyIcon.\n\n    \"\"\"\n    import pandas as pd\n    from folium.plugins import BeautifyIcon\n\n    layer_group = folium.FeatureGroup(name=layer_name)\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if popup is None:\n        popup = col_names\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    for row in df.itertuples():\n        html = \"\"\n        for p in popup:\n            html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(getattr(row, p)) + \"&lt;br&gt;\"\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        marker_icon = BeautifyIcon(\n            icon, icon_shape, border_width, border_color, **kwargs\n        )\n        folium.Marker(\n            location=[getattr(row, y), getattr(row, x)],\n            popup=popup_html,\n            icon=marker_icon,\n        ).add_to(layer_group)\n\n    layer_group.add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_minimap","title":"<code>add_minimap(self, zoom=5, position='bottomright')</code>","text":"<p>Adds a minimap (overview) to the ipyleaflet map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_minimap(self, zoom=5, position=\"bottomright\"):\n    \"\"\"Adds a minimap (overview) to the ipyleaflet map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_mosaic_layer","title":"<code>add_mosaic_layer(self, url, titiler_endpoint=None, name='Mosaic Layer', attribution='.', opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Mosaic Layer'.</p> <code>'Mosaic Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>'.'</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_mosaic_layer(\n    self,\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n    name: Optional[str] = \"Mosaic Layer\",\n    attribution: Optional[str] = \".\",\n    opacity: Optional[float] = 1.0,\n    shown: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n    tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n    bounds = mosaic_bounds(url, titiler_endpoint)\n    self.add_tile_layer(\n        url=tile_url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        shown=shown,\n    )\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_netcdf","title":"<code>add_netcdf(self, filename, variables=None, port='default', palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='NetCDF layer', shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"netCDF layer\".</p> <code>'NetCDF layer'</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_netcdf(\n    self,\n    filename: str,\n    variables: Optional[int] = None,\n    port: str = \"default\",\n    palette: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    attribution: Optional[str] = None,\n    layer_name: Optional[str] = \"NetCDF layer\",\n    shift_lon: Optional[bool] = True,\n    lat: Optional[str] = \"lat\",\n    lon: Optional[str] = \"lon\",\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n    \"\"\"\n\n    tif, vars = netcdf_to_tif(\n        filename, shift_lon=shift_lon, lat=lat, lon=lon, return_vars=True\n    )\n\n    if variables is None:\n        if len(vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        if not set(variables).issubset(set(vars)):\n            raise ValueError(f\"The variables must be a subset of {vars}.\")\n        else:\n            band_idx = [vars.index(v) + 1 for v in variables]\n\n    self.add_raster(\n        tif,\n        band=band_idx,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_address","title":"<code>add_osm_from_address(self, address, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of address to the map.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_address(\n    self,\n    address: str,\n    tags: dict,\n    dist: Optional[int] = 1000,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_bbox","title":"<code>add_osm_from_bbox(self, north, south, east, west, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within a N, S, E, W bounding box to the map.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_bbox(\n    self,\n    north: float,\n    south: float,\n    east: float,\n    west: float,\n    tags: dict,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_geocode","title":"<code>add_osm_from_geocode(self, query, which_result=None, by_osmid=False, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM data of place(s) by name or ID to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_geocode(\n    self,\n    query: Union[str, dict, List],\n    which_result: Optional[int] = None,\n    by_osmid: Optional[bool] = False,\n    buffer_dist: Optional[float] = None,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n\n    gdf = osm_gdf_from_geocode(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_place","title":"<code>add_osm_from_place(self, query, tags, which_result=None, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of geocodable place(s) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_place(\n    self,\n    query: Union[str, dict, List],\n    tags: dict,\n    which_result: Optional[int] = None,\n    buffer_dist: Optional[float] = None,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_point","title":"<code>add_osm_from_point(self, center_point, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of a point to the map.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_point(\n    self,\n    center_point: Tuple[float, float],\n    tags: dict,\n    dist: Optional[int] = 1000,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_polygon","title":"<code>add_osm_from_polygon(self, polygon, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of a (multi)polygon to the map.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_polygon(\n    self,\n    polygon,\n    tags: dict,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_osm_from_view","title":"<code>add_osm_from_view(self, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within the current map view to the map.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_osm_from_view(\n    self,\n    tags: dict,\n    layer_name: Optional[str] = \"Untitled\",\n    style: Optional[Dict] = {},\n    hover_style: Optional[Dict] = {},\n    style_callback: Optional[Callable[[Any], Any]] = None,\n    fill_colors: Optional[List] = [\"black\"],\n    info_mode: Optional[str] = \"on_hover\",\n):\n    \"\"\"Adds OSM entities within the current map view to the map.\n\n    Args:\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    pass  # folium can't get map bounds. See https://github.com/python-visualization/folium/issues/1118\n    # bounds = self.get_bounds()\n    # north, south, east, west = (\n    #     bounds[1][0],\n    #     bounds[0][0],\n    #     bounds[1][1],\n    #     bounds[0][1],\n    # )\n\n    # gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    # geojson = gdf.__geo_interface__\n\n    # self.add_geojson(\n    #     geojson,\n    #     layer_name=layer_name,\n    #     style=style,\n    #     hover_style=hover_style,\n    #     style_callback=style_callback,\n    #     fill_colors=fill_colors,\n    #     info_mode=info_mode,\n    # )\n    # self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, layer_name=None, api_key=None, token_name='PLANET_API_KEY', **kwargs)</code>","text":"<p>Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_planet_by_month(\n    self,\n    year: Optional[int] = 2016,\n    month: Optional[int] = 1,\n    layer_name: Optional[str] = None,\n    api_key: Optional[str] = None,\n    token_name: Optional[str] = \"PLANET_API_KEY\",\n    **kwargs,\n):\n    \"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    if layer_name is None and \"name\" in kwargs:\n        layer_name = kwargs.pop(\"name\")\n    layer = planet_tile_by_month(\n        year, month, layer_name, api_key, token_name, tile_format=\"folium\"\n    )\n    layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, layer_name=None, api_key=None, token_name='PLANET_API_KEY', **kwargs)</code>","text":"<p>Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_planet_by_quarter(\n    self,\n    year: Optional[int] = 2016,\n    quarter: Optional[int] = 1,\n    layer_name: Optional[str] = None,\n    api_key: Optional[str] = None,\n    token_name: Optional[str] = \"PLANET_API_KEY\",\n    **kwargs,\n):\n    \"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    if layer_name is None and \"name\" in kwargs:\n        layer_name = kwargs.pop(\"name\")\n    layer = planet_tile_by_quarter(\n        year, quarter, layer_name, api_key, token_name, tile_format=\"folium\"\n    )\n    layer.add_to(self)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_pmtiles","title":"<code>add_pmtiles(self, url, style=None, name=None, tooltip=True, overlay=True, control=True, show=True, zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a PMTiles layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>style</code> <code>str</code> <p>The CSS style to apply to the layer. Defaults to None. See https://docs.mapbox.com/style-spec/reference/layers/ for more info.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>bool</code> <p>Whether to show a tooltip when hovering over the layer. Defaults to True.</p> <code>True</code> <code>overlay</code> <code>bool</code> <p>Whether the layer should be added as an overlay. Defaults to True.</p> <code>True</code> <code>control</code> <code>bool</code> <p>Whether to include the layer in the layer control. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether the layer should be shown initially. Defaults to True.</p> <code>True</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the PMTilesLayer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_pmtiles(\n    self,\n    url,\n    style=None,\n    name=None,\n    tooltip=True,\n    overlay=True,\n    control=True,\n    show=True,\n    zoom_to_layer=True,\n    **kwargs,\n):\n    \"\"\"\n    Adds a PMTiles layer to the map.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        style (str, optional): The CSS style to apply to the layer. Defaults to None.\n            See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n        name (str, optional): The name of the layer. Defaults to None.\n        tooltip (bool, optional): Whether to show a tooltip when hovering over the layer. Defaults to True.\n        overlay (bool, optional): Whether the layer should be added as an overlay. Defaults to True.\n        control (bool, optional): Whether to include the layer in the layer control. Defaults to True.\n        show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n    Returns:\n        None\n    \"\"\"\n\n    try:\n        if style is None:\n            style = pmtiles_style(url)\n        layer = PMTilesLayer(\n            url,\n            style=style,\n            name=name,\n            tooltip=tooltip,\n            overlay=overlay,\n            control=control,\n            show=show,\n            **kwargs,\n        )\n        self.add_child(layer)\n\n        if zoom_to_layer:\n            metadata = pmtiles_metadata(url)\n            bounds = metadata[\"bounds\"]\n            self.zoom_to_bounds(bounds)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_point_layer","title":"<code>add_point_layer(self, filename, popup=None, layer_name='Marker Cluster', **kwargs)</code>","text":"<p>Adds a point layer to the map with a popup attribute.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_point_layer(\n    self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n):\n    \"\"\"Adds a point layer to the map with a popup attribute.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_points_from_xy","title":"<code>add_points_from_xy(self, data, x='longitude', y='latitude', popup=None, min_width=100, max_width=200, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], angle=0, prefix='fa', add_legend=True, max_cluster_radius=80, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>min_width</code> <code>int</code> <p>The minimum width of the popup. Defaults to 100.</p> <code>100</code> <code>max_width</code> <code>int</code> <p>The maximum width of the popup. Defaults to 200.</p> <code>200</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].</p> <code>['info']</code> <code>angle</code> <code>int</code> <p>The angle of the icon. Defaults to 0.</p> <code>0</code> <code>prefix</code> <code>str</code> <p>The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.</p> <code>'fa'</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> <code>max_cluster_radius</code> <code>int</code> <p>The maximum radius that a cluster will cover from the central marker (in pixels).</p> <code>80</code> <code>**kwargs</code> <p>Other keyword arguments to pass to folium.MarkerCluster(). For a list of available options, see https://github.com/Leaflet/Leaflet.markercluster. For example, to change the cluster radius, use options={\"maxClusterRadius\": 50}.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_points_from_xy(\n    self,\n    data: Union[str, pd.DataFrame],\n    x: Optional[str] = \"longitude\",\n    y: Optional[str] = \"latitude\",\n    popup: Optional[List] = None,\n    min_width: Optional[int] = 100,\n    max_width: Optional[int] = 200,\n    layer_name: Optional[str] = \"Marker Cluster\",\n    color_column: Optional[str] = None,\n    marker_colors: Optional[List] = None,\n    icon_colors: Optional[List] = [\"white\"],\n    icon_names: Optional[List] = [\"info\"],\n    angle: Optional[int] = 0,\n    prefix: Optional[str] = \"fa\",\n    add_legend: Optional[bool] = True,\n    max_cluster_radius: Optional[int] = 80,\n    **kwargs,\n):\n    \"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        min_width (int, optional): The minimum width of the popup. Defaults to 100.\n        max_width (int, optional): The maximum width of the popup. Defaults to 200.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found\n            at https://fontawesome.com/v4/icons or https://getbootstrap.com/docs/3.3/components/?utm_source=pocket_mylist. Defaults to ['info'].\n        angle (int, optional): The angle of the icon. Defaults to 0.\n        prefix (str, optional): The prefix states the source of the icon. 'fa' for font-awesome or 'glyphicon' for bootstrap 3. Defaults to 'fa'.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n        max_cluster_radius (int, optional): The maximum radius that a cluster will cover from the central marker (in pixels).\n        **kwargs: Other keyword arguments to pass to folium.MarkerCluster(). For a list of available options,\n            see https://github.com/Leaflet/Leaflet.markercluster. For example, to change the cluster radius, use options={\"maxClusterRadius\": 50}.\n    \"\"\"\n    import pandas as pd\n\n    if \"maxClusterRadius\" not in kwargs:\n        kwargs[\"maxClusterRadius\"] = max_cluster_radius\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(data)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if popup is None:\n        popup = col_names\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    marker_cluster = plugins.MarkerCluster(name=layer_name, **kwargs).add_to(self)\n\n    for idx, row in df.iterrows():\n        html = \"\"\n        for p in popup:\n            html = html + \"&lt;b&gt;\" + p + \"&lt;/b&gt;\" + \": \" + str(row[p]) + \"&lt;br&gt;\"\n        popup_html = folium.Popup(html, min_width=min_width, max_width=max_width)\n\n        if items is not None:\n            index = items.index(row[color_column])\n            marker_icon = folium.Icon(\n                color=marker_colors[index],\n                icon_color=icon_colors[index],\n                icon=icon_names[index],\n                angle=angle,\n                prefix=prefix,\n            )\n        else:\n            marker_icon = None\n\n        folium.Marker(\n            location=[row[y], row[x]],\n            popup=popup_html,\n            icon=marker_icon,\n        ).add_to(marker_cluster)\n\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', array_args={}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_image</code>. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    indexes: Optional[int] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    attribution: Optional[str] = None,\n    layer_name: Optional[str] = \"Raster\",\n    array_args: Optional[Dict] = {},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        array_args (dict, optional): Additional arguments to pass to `array_to_image`. Defaults to {}.\n    \"\"\"\n\n    import numpy as np\n    import xarray as xr\n\n    if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n        source = array_to_image(source, **array_args)\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=\"folium\",\n        layer_name=layer_name,\n        return_client=True,\n        **kwargs,\n    )\n    self.add_layer(tile_layer)\n\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    self.zoom_to_bounds(bounds)\n\n    arc_add_layer(tile_layer.tiles, layer_name, True, 1.0)\n    arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_raster_legacy","title":"<code>add_raster_legacy(self, image, bands=None, layer_name=None, colormap=None, x_dim='x', y_dim='y')</code>","text":"<p>Adds a local raster dataset to the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_raster_legacy(\n    self,\n    image,\n    bands=None,\n    layer_name=None,\n    colormap=None,\n    x_dim=\"x\",\n    y_dim=\"y\",\n):\n    \"\"\"Adds a local raster dataset to the map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_remote_tile","title":"<code>add_remote_tile(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a remote Cloud Optimized GeoTIFF (COG) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the remote Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_remote_tile(\n    self,\n    source: str,\n    indexes: Optional[int] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    attribution: Optional[str] = None,\n    layer_name: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n    Args:\n        source (str): The path to the remote Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n    if isinstance(source, str) and source.startswith(\"http\"):\n        self.add_raster(\n            source,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n    else:\n        raise Exception(\"The source must be a URL.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_search_control","title":"<code>add_search_control(self, url, marker=None, zoom=None, position='topleft', **kwargs)</code>","text":"<p>Adds a search control to the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_search_control(\n    self, url, marker=None, zoom=None, position=\"topleft\", **kwargs\n):\n    \"\"\"Adds a search control to the map.\"\"\"\n    print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_shp","title":"<code>add_shp(self, in_shp, layer_name='Untitled', info_mode='on_hover', zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path or HTTP URL (*.zip) to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_shp(\n    self,\n    in_shp: str,\n    layer_name: Optional[str] = \"Untitled\",\n    info_mode: Optional[str] = \"on_hover\",\n    zoom_to_layer: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds a shapefile to the map. See https://python-visualization.github.io/folium/modules.html#folium.features.GeoJson for more info about setting style.\n\n    Args:\n        in_shp (str): The input file path or HTTP URL (*.zip) to the shapefile.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n    import glob\n\n    if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n        out_dir = os.path.abspath(\"./cache/shp\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        basename = os.path.basename(in_shp)\n        filename = os.path.join(out_dir, basename)\n        # download_from_url(in_shp, out_dir=out_dir, verbose=False)\n        download_file(in_shp, filename)\n        files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n        if len(files) &gt; 0:\n            in_shp = files[0]\n        else:\n            raise FileNotFoundError(\n                \"The downloaded zip file does not contain any shapefile in the root directory.\"\n            )\n    else:\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    data = shp_to_geojson(in_shp)\n\n    self.add_geojson(\n        data,\n        layer_name=layer_name,\n        info_mode=info_mode,\n        zoom_to_layer=zoom_to_layer,\n        **kwargs,\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='.', opacity=1.0, shown=True, fit_bounds=True, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>'.'</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    bands: List = None,\n    titiler_endpoint: Optional[str] = None,\n    name: Optional[str] = \"STAC Layer\",\n    attribution: Optional[str] = \".\",\n    opacity: Optional[float] = 1.0,\n    shown: Optional[bool] = True,\n    fit_bounds: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        fit_bounds (bool, optional): A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    bounds = stac_bounds(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(\n        url=tile_url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        shown=shown,\n    )\n\n    if fit_bounds:\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_text","title":"<code>add_text(self, text, fontsize=20, fontcolor='black', bold=False, padding='5px', background=True, bg_color='white', border_radius='5px', position='bottomright', **kwargs)</code>","text":"<p>Add text to the map.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add.</p> required <code>fontsize</code> <code>int</code> <p>The font size. Defaults to 20.</p> <code>20</code> <code>fontcolor</code> <code>str</code> <p>The font color. Defaults to \"black\".</p> <code>'black'</code> <code>bold</code> <code>bool</code> <p>Whether to use bold font. Defaults to False.</p> <code>False</code> <code>padding</code> <code>str</code> <p>The padding. Defaults to \"5px\".</p> <code>'5px'</code> <code>background</code> <code>bool</code> <p>Whether to use background. Defaults to True.</p> <code>True</code> <code>bg_color</code> <code>str</code> <p>The background color. Defaults to \"white\".</p> <code>'white'</code> <code>border_radius</code> <code>str</code> <p>The border radius. Defaults to \"5px\".</p> <code>'5px'</code> <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_text(\n    self,\n    text: str,\n    fontsize: Optional[int] = 20,\n    fontcolor: Optional[str] = \"black\",\n    bold: Optional[bool] = False,\n    padding: Optional[str] = \"5px\",\n    background: Optional[bool] = True,\n    bg_color: Optional[str] = \"white\",\n    border_radius: Optional[str] = \"5px\",\n    position: Optional[str] = \"bottomright\",\n    **kwargs,\n):\n    \"\"\"Add text to the map.\n\n    Args:\n        text (str): The text to add.\n        fontsize (int, optional): The font size. Defaults to 20.\n        fontcolor (str, optional): The font color. Defaults to \"black\".\n        bold (bool, optional): Whether to use bold font. Defaults to False.\n        padding (str, optional): The padding. Defaults to \"5px\".\n        background (bool, optional): Whether to use background. Defaults to True.\n        bg_color (str, optional): The background color. Defaults to \"white\".\n        border_radius (str, optional): The border radius. Defaults to \"5px\".\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    if background:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n        padding: {padding}; background-color: {bg_color};\n        border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n    else:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n        padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n    self.add_html(text, position=position, **kwargs)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_tile_layer","title":"<code>add_tile_layer(self, url, name, attribution, overlay=True, control=True, shown=True, opacity=1.0, API_key=None, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the XYZ tile service.</p> required <code>name</code> <code>str</code> <p>The layer name to use on the layer control.</p> required <code>attribution</code> <code>str</code> <p>The attribution of the data layer.</p> required <code>overlay</code> <code>bool</code> <p>Allows overlay. Defaults to True.</p> <code>True</code> <code>control</code> <code>bool</code> <p>Adds the layer to the layer control. Defaults to True.</p> <code>True</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Sets the opacity for the layer.</p> <code>1.0</code> <code>API_key</code> <code>str</code> <p>\u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: str,\n    attribution: str,\n    overlay: Optional[bool] = True,\n    control: Optional[bool] = True,\n    shown: Optional[bool] = True,\n    opacity: Optional[float] = 1.0,\n    API_key: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        url (str): The URL of the XYZ tile service.\n        name (str): The layer name to use on the layer control.\n        attribution (str): The attribution of the data layer.\n        overlay (bool, optional): Allows overlay. Defaults to True.\n        control (bool, optional): Adds the layer to the layer control. Defaults to True.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        opacity (float, optional): Sets the opacity for the layer.\n        API_key (str, optional): \u2013 API key for Cloudmade or Mapbox tiles. Defaults to True.\n    \"\"\"\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 30\n\n    try:\n        folium.raster_layers.TileLayer(\n            tiles=url,\n            name=name,\n            attr=attribution,\n            overlay=overlay,\n            control=control,\n            show=shown,\n            opacity=opacity,\n            API_key=API_key,\n            **kwargs,\n        ).add_to(self)\n\n        arc_add_layer(url, name, shown, opacity)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_time_slider","title":"<code>add_time_slider(self, layers_dict={}, labels=None, time_interval=1, position='bottomright', slider_length='150px', **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_time_slider(\n    self,\n    layers_dict={},\n    labels=None,\n    time_interval=1,\n    position=\"bottomright\",\n    slider_length=\"150px\",\n    **kwargs,\n):\n    \"\"\"Adds a time slider to the map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_title","title":"<code>add_title(self, title, align='center', font_size='16px', style=None)</code>","text":"<p>Adds a title to the map.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title to use.</p> required <code>align</code> <code>str</code> <p>The alignment of the title, can be [\"center\", \"left\", \"right\"]. Defaults to \"center\".</p> <code>'center'</code> <code>font_size</code> <code>str</code> <p>The font size in the unit of px. Defaults to \"16px\".</p> <code>'16px'</code> <code>style</code> <code>[type]</code> <p>The style to use. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_title(\n    self,\n    title: str,\n    align: Optional[str] = \"center\",\n    font_size: Optional[str] = \"16px\",\n    style=None,\n):\n    \"\"\"Adds a title to the map.\n\n    Args:\n        title (str): The title to use.\n        align (str, optional): The alignment of the title, can be [\"center\", \"left\", \"right\"]. Defaults to \"center\".\n        font_size (str, optional): The font size in the unit of px. Defaults to \"16px\".\n        style ([type], optional): The style to use. Defaults to None.\n    \"\"\"\n    if style is None:\n        title_html = \"\"\"\n                &lt;h3 align={} style=\"font-size:{}\"&gt;&lt;b&gt;{}&lt;/b&gt;&lt;/h3&gt;\n                \"\"\".format(\n            align, font_size, title\n        )\n    else:\n        title_html = \"\"\"\n            &lt;h3 align={} style={}&gt;&lt;b&gt;{}&lt;/b&gt;&lt;/h3&gt;\n            \"\"\".format(\n            align, style, title\n        )\n    self.get_root().html.add_child(folium.Element(title_html))\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_vector","title":"<code>add_vector(self, filename, layer_name='Untitled', bbox=None, mask=None, rows=None, info_mode='on_hover', zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds any geopandas-supported vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_vector(\n    self,\n    filename: str,\n    layer_name: Optional[str] = \"Untitled\",\n    bbox: Optional[Tuple] = None,\n    mask: Optional[Dict] = None,\n    rows: Optional[Union[int, slice]] = None,\n    info_mode: Optional[str] = \"on_hover\",\n    zoom_to_layer: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to True.\n\n    \"\"\"\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".shp\":\n        self.add_shp(filename, layer_name, **kwargs)\n    elif ext in [\".json\", \".geojson\"]:\n        self.add_geojson(filename, layer_name, **kwargs)\n    else:\n        geojson = vector_to_geojson(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            epsg=\"4326\",\n            **kwargs,\n        )\n\n        self.add_geojson(\n            geojson,\n            layer_name,\n            info_mode=info_mode,\n            zoom_to_layer=zoom_to_layer,\n            **kwargs,\n        )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_vector_tile","title":"<code>add_vector_tile(self, url, styles={}, layer_name='Vector Tile', **kwargs)</code>","text":"<p>Adds a VectorTileLayer to the map. It wraps the folium.plugins.VectorGridProtobuf class. See     https://github.com/python-visualization/folium/blob/main/folium/plugins/vectorgrid_protobuf.py#L7</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer</p> required <code>styles</code> <code>dict | str</code> <p>Style dict, specific to the vector tile source. If styles is given as a string, it will be passed directly to folium.plugins.VectorGrid directly, ignoring additional kwargs. See the \"conditional styling\" example in https://github.com/iwpnd/folium-vectorgrid</p> <code>{}</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Vector Tile'.</p> <code>'Vector Tile'</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the folium.plugins.VectorGridProtobuf class.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_vector_tile(\n    self,\n    url: Optional[str],\n    styles: Optional[Union[dict, str]] = {},\n    layer_name: Optional[str] = \"Vector Tile\",\n    **kwargs,\n):\n    \"\"\"Adds a VectorTileLayer to the map. It wraps the folium.plugins.VectorGridProtobuf class. See\n        https://github.com/python-visualization/folium/blob/main/folium/plugins/vectorgrid_protobuf.py#L7\n\n    Args:\n        url (str, optional): The URL of the tile layer\n        styles (dict | str, optional): Style dict, specific to the vector tile source.\n            If styles is given as a string, it will be passed directly to folium.plugins.VectorGrid\n            directly, ignoring additional kwargs. See the \"conditional styling\" example in\n            https://github.com/iwpnd/folium-vectorgrid\n        layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n        kwargs: Additional keyword arguments to pass to the folium.plugins.VectorGridProtobuf class.\n    \"\"\"\n    if isinstance(styles, str):\n        options = styles\n    else:\n        options = {}\n        for key, value in kwargs.items():\n            options[key] = value\n\n        if \"vector_tile_layer_styles\" in options:\n            styles = options[\"vector_tile_layer_styles\"]\n            del options[\"vector_tile_layer_styles\"]\n\n        if styles:\n            options[\"vectorTileLayerStyles\"] = styles\n\n    vc = plugins.VectorGridProtobuf(url, layer_name, options)\n    self.add_child(vc)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_vector_tile_layer","title":"<code>add_vector_tile_layer(self, url, styles={}, layer_name='Vector Tile', **kwargs)</code>","text":"<p>Adds a VectorTileLayer to the map. It wraps the folium.plugins.VectorGridProtobuf class. See     https://github.com/python-visualization/folium/blob/main/folium/plugins/vectorgrid_protobuf.py#L7</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer</p> required <code>styles</code> <code>dict | str</code> <p>Style dict, specific to the vector tile source. If styles is given as a string, it will be passed directly to folium.plugins.VectorGrid directly, ignoring additional kwargs. See the \"conditional styling\" example in https://github.com/iwpnd/folium-vectorgrid</p> <code>{}</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Vector Tile'.</p> <code>'Vector Tile'</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the folium.plugins.VectorGridProtobuf class.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_vector_tile(\n    self,\n    url: Optional[str],\n    styles: Optional[Union[dict, str]] = {},\n    layer_name: Optional[str] = \"Vector Tile\",\n    **kwargs,\n):\n    \"\"\"Adds a VectorTileLayer to the map. It wraps the folium.plugins.VectorGridProtobuf class. See\n        https://github.com/python-visualization/folium/blob/main/folium/plugins/vectorgrid_protobuf.py#L7\n\n    Args:\n        url (str, optional): The URL of the tile layer\n        styles (dict | str, optional): Style dict, specific to the vector tile source.\n            If styles is given as a string, it will be passed directly to folium.plugins.VectorGrid\n            directly, ignoring additional kwargs. See the \"conditional styling\" example in\n            https://github.com/iwpnd/folium-vectorgrid\n        layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n        kwargs: Additional keyword arguments to pass to the folium.plugins.VectorGridProtobuf class.\n    \"\"\"\n    if isinstance(styles, str):\n        options = styles\n    else:\n        options = {}\n        for key, value in kwargs.items():\n            options[key] = value\n\n        if \"vector_tile_layer_styles\" in options:\n            styles = options[\"vector_tile_layer_styles\"]\n            del options[\"vector_tile_layer_styles\"]\n\n        if styles:\n            options[\"vectorTileLayerStyles\"] = styles\n\n    vc = plugins.VectorGridProtobuf(url, layer_name, options)\n    self.add_child(vc)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_widget","title":"<code>add_widget(self, content, position='bottomright', **kwargs)</code>","text":"<p>Add a widget (e.g., text, HTML, figure) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_widget(\n    self, content: str, position: Optional[str] = \"bottomright\", **kwargs\n):\n    \"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n    Args:\n        content (str): The widget to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    from matplotlib import figure\n    import base64\n    from io import BytesIO\n\n    allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n    if position not in allowed_positions:\n        raise Exception(f\"position must be one of {allowed_positions}\")\n\n    try:\n        if isinstance(content, str):\n            widget = CustomControl(content, position=position)\n            widget.add_to(self)\n        elif isinstance(content, figure.Figure):\n            buf = BytesIO()\n            content.savefig(buf, format=\"png\")\n            buf.seek(0)\n            b64_content = base64.b64encode(buf.read()).decode(\"utf-8\")\n            widget = CustomControl(\n                f\"\"\"&lt;img src=\"data:image/png;base64,{b64_content}\"&gt;\"\"\",\n                position=position,\n            )\n            widget.add_to(self)\n        else:\n            raise Exception(\"The content must be a string or a matplotlib figure\")\n\n    except Exception as e:\n        raise Exception(f\"Error adding widget: {e}\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, attribution='', overlay=True, control=True, shown=True, format='image/png', transparent=True, version='1.1.1', styles='', **kwargs)</code>","text":"<p>Add a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS web service.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of WMS layers to show.</p> required <code>name</code> <code>str</code> <p>The layer name to use on the layer control. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution of the data layer. Defaults to ''.</p> <code>''</code> <code>overlay</code> <code>bool</code> <p>Allows overlay. Defaults to True.</p> <code>True</code> <code>control</code> <code>bool</code> <p>Adds the layer to the layer control. Defaults to True.</p> <code>True</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>format</code> <code>str</code> <p>WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether the layer shall allow transparency. Defaults to True.</p> <code>True</code> <code>version</code> <code>str</code> <p>Version of the WMS service to use. Defaults to \"1.1.1\".</p> <code>'1.1.1'</code> <code>styles</code> <code>str</code> <p>Comma-separated list of WMS styles. Defaults to \"\".</p> <code>''</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    attribution: Optional[str] = \"\",\n    overlay: Optional[bool] = True,\n    control: Optional[bool] = True,\n    shown: Optional[bool] = True,\n    format: Optional[str] = \"image/png\",\n    transparent: Optional[bool] = True,\n    version: Optional[str] = \"1.1.1\",\n    styles: Optional[str] = \"\",\n    **kwargs,\n):\n    \"\"\"Add a WMS layer to the map.\n\n    Args:\n        url (str): The URL of the WMS web service.\n        layers (str): Comma-separated list of WMS layers to show.\n        name (str, optional): The layer name to use on the layer control. Defaults to None.\n        attribution (str, optional): The attribution of the data layer. Defaults to ''.\n        overlay (bool, optional): Allows overlay. Defaults to True.\n        control (bool, optional): Adds the layer to the layer control. Defaults to True.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n        transparent (bool, optional): Whether the layer shall allow transparency. Defaults to True.\n        version (str, optional): Version of the WMS service to use. Defaults to \"1.1.1\".\n        styles (str, optional): Comma-separated list of WMS styles. Defaults to \"\".\n    \"\"\"\n    try:\n        folium.raster_layers.WmsTileLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            attr=attribution,\n            overlay=overlay,\n            control=control,\n            show=shown,\n            styles=styles,\n            fmt=format,\n            transparent=transparent,\n            version=version,\n            **kwargs,\n        ).add_to(self)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_wms_legend","title":"<code>add_wms_legend(self, url)</code>","text":"<p>Add a WMS legend based on an image URL</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the WMS legend image. Should have this format if using wms legend: {geoserver}/wms?REQUEST=GetLegendGraphic&amp;FORMAT=image/png&amp;LAYER={layer}</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_wms_legend(\n    self,\n    url,\n):\n    \"\"\"Add a WMS legend based on an image URL\n\n    Args:\n        url (str): URL of the WMS legend image. Should have this format if using wms legend: {geoserver}/wms?REQUEST=GetLegendGraphic&amp;FORMAT=image/png&amp;LAYER={layer}\n    \"\"\"\n    from branca.element import Figure, MacroElement, Element\n\n    # Check if the map is a Folium Map instance\n    if not isinstance(self, Map):\n        raise ValueError(\"The self argument must be an instance of folium.Map.\")\n\n    # HTML template for the legend\n    legend_html = f\"\"\"\n        {{% macro html(this, kwargs) %}}\n\n        &lt;div id=\"maplegend\" style=\"position: fixed;\n                    bottom: 50px;\n                    right: 50px;\n                    z-index:9999;\n                    \"&gt;\n            &lt;img src=\"{ url }\" alt=\"legend\" style=\"width: 100%; height: 100%;\"&gt;\n        &lt;/div&gt;\n        {{% endmacro %}}\n    \"\"\"\n\n    # Create an Element with the HTML and add it to the map\n    macro = MacroElement()\n    macro._template = Template(legend_html)\n\n    self.get_root().add_child(macro)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_xy_data","title":"<code>add_xy_data(self, in_csv, x='longitude', y='latitude', label=None, layer_name='Marker cluster')</code>","text":"<p>Adds points from a CSV file containing lat/lon information and display data on the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_xy_data(\n    self,\n    in_csv,\n    x=\"longitude\",\n    y=\"latitude\",\n    label=None,\n    layer_name=\"Marker cluster\",\n):\n    \"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.add_xyz_service","title":"<code>add_xyz_service(self, provider, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The provider is not valid. It must start with xyz or qms.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def add_xyz_service(self, provider: str, **kwargs):\n    \"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n    Raises:\n        ValueError: The provider is not valid. It must start with xyz or qms.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    if provider.startswith(\"xyz\"):\n        name = provider[4:]\n        xyz_provider = xyz.flatten()[name]\n        url = xyz_provider.build_url()\n        attribution = xyz_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    elif provider.startswith(\"qms\"):\n        name = provider[4:]\n        qms_provider = TileProvider.from_qms(name)\n        url = qms_provider.build_url()\n        attribution = qms_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url=url, name=name, attribution=attribution)\n    else:\n        raise ValueError(\n            f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n        )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.basemap_demo","title":"<code>basemap_demo(self)</code>","text":"<p>A demo for using leafmap basemaps.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def basemap_demo(self):\n    \"\"\"A demo for using leafmap basemaps.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.edit_vector","title":"<code>edit_vector(self, data, **kwargs)</code>","text":"<p>Edit a vector layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | str</code> <p>The data to edit. It can be a GeoJSON dictionary or a file path.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def edit_vector(self, data: Union[str, dict], **kwargs):\n    \"\"\"Edit a vector layer.\n\n    Args:\n        data (dict | str): The data to edit. It can be a GeoJSON dictionary or a file path.\n    \"\"\"\n    print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.find_layer","title":"<code>find_layer(self, name)</code>","text":"<p>Finds layer by name.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def find_layer(self, name):\n    \"\"\"Finds layer by name.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.find_layer_index","title":"<code>find_layer_index(self, name)</code>","text":"<p>Finds layer index by name.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def find_layer_index(self, name):\n    \"\"\"Finds layer index by name.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.get_layer_names","title":"<code>get_layer_names(self)</code>","text":"<p>Gets layer names as a list.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def get_layer_names(self):\n    \"\"\"Gets layer names as a list.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.get_scale","title":"<code>get_scale(self)</code>","text":"<p>Returns the approximate pixel scale of the current map view, in meters.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def get_scale(self):\n    \"\"\"Returns the approximate pixel scale of the current map view, in meters.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.image_overlay","title":"<code>image_overlay(self, url, bounds, name)</code>","text":"<p>Overlays an image from the Internet or locally on the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL or local file path to the image.</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>name</code> <code>str</code> <p>name of the layer to show on the layer control.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def image_overlay(self, url: str, bounds: Tuple, name: str):\n    \"\"\"Overlays an image from the Internet or locally on the map.\n\n    Args:\n        url (str): http URL or local file path to the image.\n        bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        name (str): name of the layer to show on the layer control.\n    \"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.layer_opacity","title":"<code>layer_opacity(self, name, value=1.0)</code>","text":"<p>Changes layer opacity.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def layer_opacity(self, name, value=1.0):\n    \"\"\"Changes layer opacity.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.oam_search","title":"<code>oam_search(self, bbox=None, start_date=None, end_date=None, limit=100, info_mode='on_click', layer_args={}, add_image=True, **kwargs)</code>","text":"<p>Search OpenAerialMap for images within a bounding box and time range.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | str</code> <p>The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 100.</p> <code>100</code> <code>info_mode</code> <code>str</code> <p>The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.</p> <code>'on_click'</code> <code>layer_args</code> <code>dict</code> <p>The layer arguments for add_gdf() function. Defaults to {}.</p> <code>{}</code> <code>add_image</code> <code>bool</code> <p>Whether to add the first 10 images to the map. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def oam_search(\n    self,\n    bbox: Optional[Union[List, str]] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    limit: Optional[int] = 100,\n    info_mode: Optional[str] = \"on_click\",\n    layer_args: Optional[dict] = {},\n    add_image: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Search OpenAerialMap for images within a bounding box and time range.\n\n    Args:\n        bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n        start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n        end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n        limit (int, optional): The maximum number of results to return. Defaults to 100.\n        info_mode (str, optional): The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.\n        layer_args (dict, optional): The layer arguments for add_gdf() function. Defaults to {}.\n        add_image (bool, optional): Whether to add the first 10 images to the map. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n    \"\"\"\n\n    gdf = oam_search(\n        bbox=bbox, start_date=start_date, end_date=end_date, limit=limit, **kwargs\n    )\n\n    if \"layer_name\" not in layer_args:\n        layer_args[\"layer_name\"] = \"Footprints\"\n\n    if \"style\" not in layer_args:\n        layer_args[\"style\"] = {\n            # \"stroke\": True,\n            \"color\": \"#3388ff\",\n            \"weight\": 2,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n\n    if \"highlight_function\" not in layer_args:\n        layer_args[\"highlight_function\"] = lambda feat: {\n            \"weight\": layer_args[\"style\"][\"weight\"] + 2,\n            \"fillOpacity\": 0,\n        }\n\n    if gdf is not None:\n        self.add_gdf(gdf, info_mode=info_mode, **layer_args)\n        setattr(self, \"oam_gdf\", gdf)\n\n        if add_image:\n            ids = gdf[\"_id\"].tolist()\n            images = gdf[\"tms\"].tolist()\n\n            if len(images) &gt; 5:\n                print(f\"Found {len(images)} images. \\nShowing the first 5.\")\n\n            for index, image in enumerate(images):\n                if index == 5:\n                    break\n                self.add_tile_layer(\n                    url=image, name=ids[index], attribution=\"OpenAerialMap\"\n                )\n    else:\n        print(\"No images found.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.publish","title":"<code>publish(self, name='Folium Map', description='', source_url='', tags=None, source_file=None, open=True, formatting=None, token=None, **kwargs)</code>","text":"<p>Publish the map to datapane.com</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".</p> <code>'Folium Map'</code> <code>description</code> <code>str</code> <p>A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.</p> <code>''</code> <code>source_url</code> <code>str</code> <p>A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.</p> <code>''</code> <code>tags</code> <code>list</code> <p>A list of tags (as strings) used to categorise your document. Defaults to None.</p> <code>None</code> <code>source_file</code> <code>str</code> <p>Path of jupyter notebook file to upload. Defaults to None.</p> <code>None</code> <code>open</code> <code>bool</code> <p>Whether to open the map. Defaults to True.</p> <code>True</code> <code>formatting</code> <code>ReportFormatting</code> <p>Set the basic styling for your report.</p> <code>None</code> <code>token</code> <code>str</code> <p>The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def publish(\n    self,\n    name: Optional[str] = \"Folium Map\",\n    description: Optional[str] = \"\",\n    source_url: Optional[str] = \"\",\n    tags: Optional[List] = None,\n    source_file: Optional[str] = None,\n    open: Optional[bool] = True,\n    formatting=None,\n    token: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Publish the map to datapane.com\n\n    Args:\n        name (str, optional): The document name - can include spaces, caps, symbols, etc., e.g. \"Profit &amp; Loss 2020\". Defaults to \"Folium Map\".\n        description (str, optional): A high-level description for the document, this is displayed in searches and thumbnails. Defaults to ''.\n        source_url (str, optional): A URL pointing to the source code for the document, e.g. a GitHub repo or a Colab notebook. Defaults to ''.\n        tags (list, optional): A list of tags (as strings) used to categorise your document. Defaults to None.\n        source_file (str, optional): Path of jupyter notebook file to upload. Defaults to None.\n        open (bool, optional): Whether to open the map. Defaults to True.\n        formatting (ReportFormatting, optional): Set the basic styling for your report.\n        token (str, optional): The token to use to datapane to publish the map. See https://docs.datapane.com/tut-getting-started. Defaults to None.\n    \"\"\"\n    import webbrowser\n    import warnings\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    try:\n        import datapane as dp\n    except Exception:\n        webbrowser.open_new_tab(\"https://docs.datapane.com/\")\n        raise ImportError(\n            \"The datapane Python package is not installed. You need to install and authenticate datapane first.\"\n        )\n\n    if token is None:\n        try:\n            _ = dp.ping(verbose=False)\n        except Exception as e:\n            if os.environ.get(\"DP_TOKEN\") is not None:\n                dp.login(token=os.environ.get(\"DP_TOKEN\"))\n            else:\n                raise Exception(e)\n    else:\n        dp.login(token)\n\n    try:\n        dp.upload_report(\n            dp.Plot(self),\n            name=name,\n            description=description,\n            source_url=source_url,\n            tags=tags,\n            source_file=source_file,\n            open=open,\n            formatting=formatting,\n            **kwargs,\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.remove_labels","title":"<code>remove_labels(self, **kwargs)</code>","text":"<p>Removes a layer from the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def remove_labels(self, **kwargs):\n    \"\"\"Removes a layer from the map.\"\"\"\n    print(\"The folium plotting backend does not support removing labels.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.save_draw_features","title":"<code>save_draw_features(self, out_file, indent=4, **kwargs)</code>","text":"<p>Save the draw features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <code>str</code> <p>The output file path.</p> required <code>indent</code> <code>int</code> <p>The indentation level when saving data as a GeoJSON. Defaults to 4.</p> <code>4</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def save_draw_features(self, out_file: str, indent: Optional[int] = 4, **kwargs):\n    \"\"\"Save the draw features to a file.\n\n    Args:\n        out_file (str): The output file path.\n        indent (int, optional): The indentation level when saving data as a GeoJSON. Defaults to 4.\n    \"\"\"\n    print(\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.set_center","title":"<code>set_center(self, lon, lat, zoom=10)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to 10.</p> <code>10</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def set_center(self, lon: float, lat: float, zoom: Optional[int] = 10):\n    \"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to 10.\n    \"\"\"\n    self.fit_bounds([[lat, lon], [lat, lon]], max_zoom=zoom)\n\n    arc_zoom_to_extent(lon, lat, lon, lat)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.split_map","title":"<code>split_map(self, left_layer='TERRAIN', right_layer='OpenTopoMap', left_args={}, right_args={}, left_array_args={}, right_array_args={}, left_label=None, right_label=None, left_position='bottomleft', right_position='bottomright', **kwargs)</code>","text":"<p>Adds a split-panel map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.</p> <code>'TERRAIN'</code> <code>right_layer</code> <code>str</code> <p>The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.</p> <code>'OpenTopoMap'</code> <code>left_args</code> <code>dict</code> <p>The arguments for the left tile layer. Defaults to {}.</p> <code>{}</code> <code>right_args</code> <code>dict</code> <p>The arguments for the right tile layer. Defaults to {}.</p> <code>{}</code> <code>left_array_args</code> <code>dict</code> <p>The arguments for array_to_image for the left layer. Defaults to {}.</p> <code>{}</code> <code>right_array_args</code> <code>dict</code> <p>The arguments for array_to_image for the right layer. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/foliumap.py</code> <pre><code>def split_map(\n    self,\n    left_layer: Optional[str] = \"TERRAIN\",\n    right_layer: Optional[str] = \"OpenTopoMap\",\n    left_args: Optional[dict] = {},\n    right_args: Optional[dict] = {},\n    left_array_args={},\n    right_array_args={},\n    left_label: Optional[str] = None,\n    right_label: Optional[str] = None,\n    left_position: Optional[str] = \"bottomleft\",\n    right_position: Optional[str] = \"bottomright\",\n    **kwargs,\n):\n    \"\"\"Adds a split-panel map.\n\n    Args:\n        left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n        right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n        left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n        right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n        left_array_args (dict, optional): The arguments for array_to_image for the left layer. Defaults to {}.\n        right_array_args (dict, optional): The arguments for array_to_image for the right layer. Defaults to {}.\n    \"\"\"\n    if \"max_zoom\" not in left_args:\n        left_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in left_args:\n        left_args[\"max_native_zoom\"] = 30\n\n    if \"max_zoom\" not in right_args:\n        right_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in right_args:\n        right_args[\"max_native_zoom\"] = 30\n\n    if \"layer_name\" not in left_args:\n        left_args[\"layer_name\"] = \"Left Layer\"\n\n    if \"layer_name\" not in right_args:\n        right_args[\"layer_name\"] = \"Right Layer\"\n\n    bounds = None\n\n    try:\n        if left_label is not None:\n            left_name = left_label\n        else:\n            left_name = \"Left Layer\"\n\n        if right_label is not None:\n            right_name = right_label\n        else:\n            right_name = \"Right Layer\"\n\n        if isinstance(left_layer, str):\n            if left_layer in basemaps.keys():\n                left_layer = basemaps[left_layer]\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                url = cog_tile(left_layer, **left_args)\n                bbox = cog_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = folium.raster_layers.TileLayer(\n                    tiles=url,\n                    name=left_name,\n                    attr=\" \",\n                    overlay=True,\n                    **left_args,\n                )\n\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".json\"):\n                left_tile_url = stac_tile(left_layer, **left_args)\n                bbox = stac_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = folium.raster_layers.TileLayer(\n                    tiles=left_tile_url,\n                    name=left_name,\n                    attr=\" \",\n                    overlay=True,\n                    **left_args,\n                )\n\n            elif os.path.exists(left_layer):\n                left_layer, left_client = get_local_tile_layer(\n                    left_layer,\n                    tile_format=\"folium\",\n                    return_client=True,\n                    **left_args,\n                )\n                bounds = image_bounds(left_client)\n\n            else:\n                left_layer = folium.raster_layers.TileLayer(\n                    tiles=left_layer,\n                    name=left_name,\n                    attr=\" \",\n                    overlay=True,\n                    **left_args,\n                )\n        elif isinstance(left_layer, folium.raster_layers.TileLayer) or isinstance(\n            left_layer, folium.WmsTileLayer\n        ):\n            pass\n        elif is_array(left_layer):\n            left_layer = array_to_image(left_layer, **left_array_args)\n            left_layer, _ = get_local_tile_layer(\n                left_layer,\n                return_client=True,\n                tile_format=\"folium\",\n                **left_args,\n            )\n        else:\n            raise ValueError(\n                f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        if isinstance(right_layer, str):\n            if right_layer in basemaps.keys():\n                right_layer = basemaps[right_layer]\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                url = cog_tile(right_layer, **right_args)\n                bbox = cog_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = folium.raster_layers.TileLayer(\n                    tiles=url,\n                    name=right_name,\n                    attr=\" \",\n                    overlay=True,\n                    **right_args,\n                )\n\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\".json\"):\n                right_tile_url = stac_tile(right_layer, **left_args)\n                bbox = stac_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = folium.raster_layers.TileLayer(\n                    tiles=right_tile_url,\n                    name=right_name,\n                    attr=\" \",\n                    overlay=True,\n                    **right_args,\n                )\n\n            elif os.path.exists(right_layer):\n                right_layer, right_client = get_local_tile_layer(\n                    right_layer,\n                    tile_format=\"folium\",\n                    return_client=True,\n                    **right_args,\n                )\n                bounds = image_bounds(right_client)\n            else:\n                right_layer = folium.raster_layers.TileLayer(\n                    tiles=right_layer,\n                    name=right_name,\n                    attr=\" \",\n                    overlay=True,\n                    **right_args,\n                )\n        elif isinstance(right_layer, folium.raster_layers.TileLayer) or isinstance(\n            left_layer, folium.WmsTileLayer\n        ):\n            pass\n        elif is_array(right_layer):\n            right_layer = array_to_image(right_layer, **right_array_args)\n            right_layer, _ = get_local_tile_layer(\n                right_layer,\n                return_client=True,\n                tile_format=\"folium\",\n                **right_args,\n            )\n        else:\n            raise ValueError(\n                f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        control = folium.plugins.SideBySideLayers(\n            layer_left=left_layer, layer_right=right_layer\n        )\n        left_layer.add_to(self)\n        right_layer.add_to(self)\n        control.add_to(self)\n\n        if left_label is not None:\n            if \"&lt;\" not in left_label:\n                left_label = f\"&lt;h4&gt;{left_label}&lt;/h4&gt;\"\n            self.add_html(left_label, position=left_position)\n\n        if right_label is not None:\n            if \"&lt;\" not in right_label:\n                right_label = f\"&lt;h4&gt;{right_label}&lt;/h4&gt;\"\n            self.add_html(right_label, position=right_position)\n        if bounds is not None:\n            self.fit_bounds(bounds)\n\n    except Exception as e:\n        print(\"The provided layers are invalid!\")\n        raise ValueError(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_draw_features","title":"<code>st_draw_features(self, st_component)</code>","text":"<p>Get the draw features of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_component</code> <code>st_folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The draw features of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_draw_features(self, st_component):\n    \"\"\"Get the draw features of the map.\n\n    Args:\n        st_component (st_folium): The streamlit component.\n\n    Returns:\n        list: The draw features of the map.\n    \"\"\"\n\n    return st_component[\"all_drawings\"]\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_fit_bounds","title":"<code>st_fit_bounds(self)</code>","text":"<p>Fit the map to the bounds of the map.</p> <p>Returns:</p> Type Description <code>folium.Map</code> <p>The map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_fit_bounds(self):\n    \"\"\"Fit the map to the bounds of the map.\n\n    Returns:\n        folium.Map: The map.\n    \"\"\"\n\n    try:\n        import streamlit as st\n\n        if \"map_bounds\" in st.session_state:\n            bounds = st.session_state[\"map_bounds\"]\n\n            self.fit_bounds(bounds)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_last_click","title":"<code>st_last_click(self, st_component)</code>","text":"<p>Get the last click feature of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_component</code> <code>st_folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The last click of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_last_click(self, st_component):\n    \"\"\"Get the last click feature of the map.\n\n    Args:\n        st_component (st_folium): The streamlit component.\n\n    Returns:\n        str: The last click of the map.\n    \"\"\"\n\n    coords = st_component[\"last_clicked\"]\n    return (coords[\"lat\"], coords[\"lng\"])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_last_draw","title":"<code>st_last_draw(self, st_component)</code>","text":"<p>Get the last draw feature of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_component</code> <code>st_folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The last draw of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_last_draw(self, st_component):\n    \"\"\"Get the last draw feature of the map.\n\n    Args:\n        st_component (st_folium): The streamlit component.\n\n    Returns:\n        str: The last draw of the map.\n    \"\"\"\n\n    return st_component[\"last_active_drawing\"]\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_map_bounds","title":"<code>st_map_bounds(self, st_component)</code>","text":"<p>Get the bounds of the map in the format of (miny, minx, maxy, maxx).</p> <p>Parameters:</p> Name Type Description Default <code>st_component</code> <code>st_folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The bounds of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_map_bounds(self, st_component) -&gt; Tuple:\n    \"\"\"Get the bounds of the map in the format of (miny, minx, maxy, maxx).\n\n    Args:\n        st_component (st_folium): The streamlit component.\n\n    Returns:\n        tuple: The bounds of the map.\n    \"\"\"\n\n    bounds = st_component[\"bounds\"]\n    south = bounds[\"_southWest\"][\"lat\"]\n    west = bounds[\"_southWest\"][\"lng\"]\n    north = bounds[\"_northEast\"][\"lat\"]\n    east = bounds[\"_northEast\"][\"lng\"]\n\n    bounds = [[south, west], [north, east]]\n    return bounds\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.st_map_center","title":"<code>st_map_center(self, st_component)</code>","text":"<p>Get the center of the map.</p> <p>Parameters:</p> Name Type Description Default <code>st_component</code> <code>st_folium</code> <p>The streamlit component.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The center of the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_map_center(self, st_component) -&gt; Tuple:\n    \"\"\"Get the center of the map.\n\n    Args:\n        st_component (st_folium): The streamlit component.\n\n    Returns:\n        tuple: The center of the map.\n    \"\"\"\n\n    bounds = st_component[\"bounds\"]\n    west = bounds[\"_southWest\"][\"lng\"]\n    south = bounds[\"_southWest\"][\"lat\"]\n    east = bounds[\"_northEast\"][\"lng\"]\n    north = bounds[\"_northEast\"][\"lat\"]\n    return (south + (north - south) / 2, west + (east - west) / 2)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.static_map","title":"<code>static_map(self, width=950, height=600, read_only=False, out_file=None, **kwargs)</code>","text":"<p>Display a folium static map in a Jupyter Notebook.</p> <p>Args     m (folium.Map): A folium map.     width (int, optional): Width of the map. Defaults to 950.     height (int, optional): Height of the map. Defaults to 600.     read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.     out_file (str, optional): Output html file path. Defaults to None.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def static_map(\n    self,\n    width: Optional[int] = 950,\n    height: Optional[int] = 600,\n    read_only: Optional[bool] = False,\n    out_file: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Display a folium static map in a Jupyter Notebook.\n\n    Args\n        m (folium.Map): A folium map.\n        width (int, optional): Width of the map. Defaults to 950.\n        height (int, optional): Height of the map. Defaults to 600.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n        out_file (str, optional): Output html file path. Defaults to None.\n    \"\"\"\n    if isinstance(self, folium.Map):\n        if out_file is None:\n            out_file = \"./cache/\" + \"folium_\" + random_string(3) + \".html\"\n        out_dir = os.path.abspath(os.path.dirname(out_file))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        self.to_html(out_file)\n        display_html(src=out_file, width=width, height=height)\n    else:\n        raise TypeError(\"The provided map is not a folium map.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.to_gradio","title":"<code>to_gradio(self, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def to_gradio(\n    self, width: Optional[str] = \"100%\", height: Optional[str] = \"500px\", **kwargs\n):\n    \"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    html = self.to_html()\n    lines = html.split(\"\\n\")\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera;\n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms\n    allow-scripts allow-same-origin allow-popups\n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\"\n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.to_html","title":"<code>to_html(self, outfile=None, **kwargs)</code>","text":"<p>Exports a map as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>File path to the output HTML. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If it is an invalid HTML file.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the HTML code.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def to_html(self, outfile: Optional[str] = None, **kwargs) -&gt; str:\n    \"\"\"Exports a map as an HTML file.\n\n    Args:\n        outfile (str, optional): File path to the output HTML. Defaults to None.\n\n    Raises:\n        ValueError: If it is an invalid HTML file.\n\n    Returns:\n        str: A string containing the HTML code.\n    \"\"\"\n\n    if self.options[\"layersControl\"]:\n        self.add_layer_control()\n\n    if outfile is not None:\n        if not outfile.endswith(\".html\"):\n            raise ValueError(\"The output file extension must be html.\")\n        outfile = os.path.abspath(outfile)\n        out_dir = os.path.dirname(outfile)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        self.save(outfile, **kwargs)\n    else:\n        outfile = os.path.abspath(random_string() + \".html\")\n        self.save(outfile, **kwargs)\n        out_html = \"\"\n        with open(outfile) as f:\n            lines = f.readlines()\n            out_html = \"\".join(lines)\n        os.remove(outfile)\n        return out_html\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.to_image","title":"<code>to_image(self, outfile=None, monitor=1)</code>","text":"<p>Saves the map as a PNG or JPG image.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def to_image(self, outfile=None, monitor=1):\n    \"\"\"Saves the map as a PNG or JPG image.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, add_layer_control=True, bidirectional=False, **kwargs)</code>","text":"<p>Renders <code>folium.Figure</code> or <code>folium.Map</code> in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>add_layer_control</code> <code>bool</code> <p>Whether to add the layer control. Defaults to True.</p> <code>True</code> <code>bidirectional</code> <code>bool</code> <p>Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def to_streamlit(\n    self,\n    width: Optional[int] = None,\n    height: Optional[int] = 600,\n    scrolling: Optional[bool] = False,\n    add_layer_control: Optional[bool] = True,\n    bidirectional: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Renders `folium.Figure` or `folium.Map` in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        add_layer_control (bool, optional): Whether to add the layer control. Defaults to True.\n        bidirectional (bool, optional): Whether to add bidirectional functionality to the map. The streamlit-folium package is required to use the bidirectional functionality. Defaults to False.\n\n    Raises:\n        ImportError: If streamlit is not installed.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        if add_layer_control:\n            self.add_layer_control()\n\n        if bidirectional:\n            from streamlit_folium import st_folium\n\n            output = st_folium(self, width=width, height=height)\n            return output\n        else:\n            # if responsive:\n            #     make_map_responsive = \"\"\"\n            #     &lt;style&gt;\n            #     [title~=\"st.iframe\"] { width: 100%}\n            #     &lt;/style&gt;\n            #     \"\"\"\n            #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                self.to_html(), width=width, height=height, scrolling=scrolling\n            )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.toolbar_reset","title":"<code>toolbar_reset(self)</code>","text":"<p>Reset the toolbar so that no tool is selected.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def toolbar_reset(self):\n    \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.user_roi_bounds","title":"<code>user_roi_bounds(self, decimals=4)</code>","text":"<p>Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>The number of decimals to round the coordinates to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def user_roi_bounds(self, decimals: Optional[int] = 4) -&gt; List:\n    \"\"\"Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n\n    Args:\n        decimals (int, optional): The number of decimals to round the coordinates to. Defaults to 4.\n\n    Returns:\n        list: The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n    \"\"\"\n    print(f\"The folium plotting backend does not support this function.\")\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.video_overlay","title":"<code>video_overlay(self, url, bounds, name)</code>","text":"<p>Overlays a video from the Internet on the map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def video_overlay(self, url, bounds, name):\n    \"\"\"Overlays a video from the Internet on the map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.zoom_to_bounds","title":"<code>zoom_to_bounds(self, bounds)</code>","text":"<p>Zooms to a bounding box in the form of [minx, miny, maxx, maxy].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list/tuple containing minx, miny, maxx, maxy values for the bounds.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def zoom_to_bounds(\n    self, bounds: Union[List[float], Tuple[float, float, float, float]]\n):\n    \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n    Args:\n        bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n    \"\"\"\n    #  The folium fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.Map.zoom_to_gdf","title":"<code>zoom_to_gdf(self, gdf)</code>","text":"<p>Zooms to the bounding box of a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def zoom_to_gdf(self, gdf):\n    \"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.PMTilesLayer","title":"<code> PMTilesLayer            (JSCSSMixin, Layer)         </code>","text":"<p>Creates a PMTilesLayer object for displaying PMTiles. Adapted from https://github.com/jtmiclat/folium-pmtiles. Credits to @jtmiclat.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class PMTilesLayer(JSCSSMixin, Layer):\n    \"\"\"Creates a PMTilesLayer object for displaying PMTiles.\n    Adapted from https://github.com/jtmiclat/folium-pmtiles. Credits to @jtmiclat.\n    \"\"\"\n\n    _template = Template(\n        \"\"\"\n            {% macro script(this, kwargs) -%}\n            var protocol = new pmtiles.Protocol();\n            maplibregl.addProtocol(\"pmtiles\", protocol.tile);\n\n            // see: https://github.com/maplibre/maplibre-gl-leaflet/issues/19\n            {{ this._parent.get_name() }}.createPane('overlay_{{ this.get_name() }}');\n            {{ this._parent.get_name() }}.getPane('overlay_{{ this.get_name() }}').style.zIndex = 650;\n            {{ this._parent.get_name() }}.getPane('overlay_{{ this.get_name() }}').style.pointerEvents = 'none';\n\n            var {{ this.get_name() }} = L.maplibreGL({\n                pane: 'overlay_{{ this.get_name() }}',\n                style: {{ this.style|tojson}},\n                interactive: true,\n            }).addTo({{ this._parent.get_name() }});\n\n            {%- endmacro %}\n            \"\"\"\n    )\n    default_css = [\n        (\"maplibre_css\", \"https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css\")\n    ]\n\n    default_js = [\n        (\"pmtiles\", \"https://unpkg.com/pmtiles@2.7.1/dist/index.js\"),\n        (\"maplibre-lib\", \"https://unpkg.com/maplibre-gl@2.2.1/dist/maplibre-gl.js\"),\n        (\n            \"maplibre-leaflet\",\n            \"https://unpkg.com/@maplibre/maplibre-gl-leaflet@0.0.19/leaflet-maplibre-gl.js\",\n        ),\n    ]\n\n    def __init__(\n        self,\n        url,\n        style=None,\n        name=None,\n        tooltip=True,\n        overlay=True,\n        show=True,\n        control=True,\n        **kwargs,\n    ):\n        \"\"\"\n        Initializes a PMTilesLayer object.\n\n        Args:\n            url (str): The URL of the PMTiles file.\n            style (dict, optional): The style to apply to the layer. Defaults to None.\n            name (str, optional): The name of the layer. Defaults to None.\n            tooltip (bool, optional): Whether to show a tooltip. Defaults to True.\n            overlay (bool, optional): Whether the layer should be added as an overlay. Defaults to True.\n            show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n            control (bool, optional): Whether to include the layer in the layer control. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the Layer constructor.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.layer_name = name if name else \"PMTilesVector\"\n\n        super().__init__(\n            name=self.layer_name, overlay=overlay, show=show, control=control, **kwargs\n        )\n\n        self.url = url\n        self._name = \"PMTilesVector\"\n\n        if tooltip:\n            self.add_child(PMTilesMapLibreTooltip())\n\n        if style is not None:\n            self.style = style\n        else:\n            self.style = {}\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.PMTilesLayer.__init__","title":"<code>__init__(self, url, style=None, name=None, tooltip=True, overlay=True, show=True, control=True, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a PMTilesLayer object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>style</code> <code>dict</code> <p>The style to apply to the layer. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>tooltip</code> <code>bool</code> <p>Whether to show a tooltip. Defaults to True.</p> <code>True</code> <code>overlay</code> <code>bool</code> <p>Whether the layer should be added as an overlay. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether the layer should be shown initially. Defaults to True.</p> <code>True</code> <code>control</code> <code>bool</code> <p>Whether to include the layer in the layer control. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Layer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def __init__(\n    self,\n    url,\n    style=None,\n    name=None,\n    tooltip=True,\n    overlay=True,\n    show=True,\n    control=True,\n    **kwargs,\n):\n    \"\"\"\n    Initializes a PMTilesLayer object.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        style (dict, optional): The style to apply to the layer. Defaults to None.\n        name (str, optional): The name of the layer. Defaults to None.\n        tooltip (bool, optional): Whether to show a tooltip. Defaults to True.\n        overlay (bool, optional): Whether the layer should be added as an overlay. Defaults to True.\n        show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n        control (bool, optional): Whether to include the layer in the layer control. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the Layer constructor.\n\n    Returns:\n        None\n    \"\"\"\n\n    self.layer_name = name if name else \"PMTilesVector\"\n\n    super().__init__(\n        name=self.layer_name, overlay=overlay, show=show, control=control, **kwargs\n    )\n\n    self.url = url\n    self._name = \"PMTilesVector\"\n\n    if tooltip:\n        self.add_child(PMTilesMapLibreTooltip())\n\n    if style is not None:\n        self.style = style\n    else:\n        self.style = {}\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.PMTilesMapLibreTooltip","title":"<code> PMTilesMapLibreTooltip            (JSCSSMixin, MacroElement)         </code>","text":"<p>Creates a PMTilesMapLibreTooltip object for displaying tooltips. Adapted from https://github.com/jtmiclat/folium-pmtiles. Credits to @jtmiclat.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class PMTilesMapLibreTooltip(JSCSSMixin, MacroElement):\n    \"\"\"Creates a PMTilesMapLibreTooltip object for displaying tooltips.\n    Adapted from https://github.com/jtmiclat/folium-pmtiles. Credits to @jtmiclat.\n    \"\"\"\n\n    _template = Template(\n        \"\"\"\n            {% macro header(this, kwargs) %}\n            &lt;style&gt;\n            .maplibregl-popup {\n                font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;\n                z-index: 651;\n            }\n            .feature-row{\n                margin-bottom: 0.5em;\n                &amp;:not(:last-of-type) {\n                    border-bottom: 1px solid black;\n                }\n            }\n            &lt;/style&gt;\n            {% endmacro %}\n            {% macro script(this, kwargs) -%}\n                var {{ this.get_name() }} = {{ this._parent.get_name() }}.getMaplibreMap();\n                const popup_{{ this.get_name() }} = new maplibregl.Popup({\n                    closeButton: false,\n                    closeOnClick: false\n                });\n\n                function setTooltipForPMTilesMapLibreLayer_{{ this.get_name() }}(maplibreLayer) {\n                    var mlMap = maplibreLayer.getMaplibreMap();\n                    var popup = popup_{{ this.get_name() }};\n\n                    mlMap.on('mousemove', (e) =&gt; {\n                        mlMap.getCanvas().style.cursor = 'pointer';\n                        const { x, y } = e.point;\n                        const r = 2; // radius around the point\n                        const features = mlMap.queryRenderedFeatures([\n                            [x - r, y - r],\n                            [x + r, y + r],\n                        ]);\n\n                        const {lng, lat}  = e.lngLat;\n                        const coordinates = [lng, lat]\n                        const html = features.map(f=&gt;`\n                        &lt;div class=\"feature-row\"&gt;\n                            &lt;span&gt;\n                                &lt;strong&gt;${f.layer['source-layer']}&lt;/strong&gt;\n                                &lt;span style=\"fontSize: 0.8em\" }&gt; (${f.geometry.type})&lt;/span&gt;\n                            &lt;/span&gt;\n                            &lt;table&gt;\n                                ${Object.entries(f.properties).map(([key, value]) =&gt;`&lt;tr&gt;&lt;td&gt;${key}&lt;/td&gt;&lt;td style=\"text-align: right\"&gt;${value}&lt;/td&gt;&lt;/tr&gt;`).join(\"\")}\n                            &lt;/table&gt;\n                        &lt;/div&gt;\n                        `).join(\"\")\n                        if(features.length){\n                            popup.setLngLat(e.lngLat).setHTML(html).addTo(mlMap);\n                        } else {\n                            popup.remove();\n                        }\n                    });\n                    mlMap.on('mouseleave', () =&gt; {popup.remove();});\n                }\n\n                // maplibre map object\n                {{ this.get_name() }}.on(\"load\", (e) =&gt; {\n                    setTooltipForPMTilesMapLibreLayer_{{ this.get_name() }}({{ this._parent.get_name() }});\n                })\n\n                // leaflet map object\n                {{ this._parent._parent.get_name() }}.on(\"layeradd\", (e) =&gt; {\n                    setTooltipForPMTilesMapLibreLayer_{{ this.get_name() }}({{ this._parent.get_name() }});\n                });\n            {%- endmacro %}\n            \"\"\"\n    )\n\n    def __init__(self, name=None, **kwargs):\n        # super().__init__(name=name if name else \"PMTilesTooltip\", **kwargs)\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.SideBySideLayers","title":"<code> SideBySideLayers            (JSCSSMixin, Layer)         </code>","text":"<p>Creates a SideBySideLayers that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin. Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side. Adopted from https://github.com/python-visualization/folium/pull/1292/files. Parameters</p> <p>Layer.</p> <p>The left Layer within the side by side control. Must be created and added to the map before being passed to this class.</p> <p>Layer.</p> <p>The right Layer within the side by side control. Must be created and added to the map before being passed to this class.</p>"},{"location":"foliumap/#leafmap.foliumap.SideBySideLayers--examples","title":"Examples","text":"<p>sidebyside = SideBySideLayers(layer_left, layer_right) sidebyside.add_to(m)</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class SideBySideLayers(JSCSSMixin, Layer):\n    \"\"\"\n    Creates a SideBySideLayers that takes two Layers and adds a sliding\n    control with the leaflet-side-by-side plugin.\n    Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side.\n    Adopted from https://github.com/python-visualization/folium/pull/1292/files.\n    Parameters\n    ----------\n    layer_left: Layer.\n        The left Layer within the side by side control.\n        Must be created and added to the map before being passed to this class.\n    layer_right: Layer.\n        The right Layer within the side by side control.\n        Must be created and added to the map before being passed to this class.\n    Examples\n    --------\n    &gt;&gt;&gt; sidebyside = SideBySideLayers(layer_left, layer_right)\n    &gt;&gt;&gt; sidebyside.add_to(m)\n    \"\"\"\n\n    _template = Template(\n        \"\"\"\n        {% macro script(this, kwargs) %}\n            var {{ this.get_name() }} = L.control.sideBySide(\n                {{ this.layer_left.get_name() }}, {{ this.layer_right.get_name() }}\n            ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n        \"\"\"\n    )\n\n    default_js = [\n        (\n            \"leaflet.sidebyside\",\n            \"https://cdn.jsdelivr.net/gh/digidem/leaflet-side-by-side@gh-pages/leaflet-side-by-side.min.js\",\n        ),\n    ]\n\n    def __init__(self, layer_left, layer_right):\n        super().__init__(control=False)\n        self._name = \"SideBySideLayers\"\n        self.layer_left = layer_left\n        self.layer_right = layer_right\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.SplitControl","title":"<code> SplitControl            (Layer)         </code>","text":"<p>Creates a SplitControl that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin. Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side Parameters. The source code is adapted from https://github.com/python-visualization/folium/pull/1292</p> <p>Layer.</p> <p>The left Layer within the side by side control. Must  be created and added to the map before being passed to this class.</p> <p>Layer.</p> <p>The left Layer within the side by side control. Must  be created and added to the map before being passed to this class.</p> <p>name : string, default None     The name of the Layer, as it will appear in LayerControls. overlay : bool, default True     Adds the layer as an optional overlay (True) or the base layer (False). control : bool, default True     Whether the Layer will be included in LayerControls.</p> <p>bool, default True</p> <p>Whether the layer will be shown on opening (only for overlays).</p>"},{"location":"foliumap/#leafmap.foliumap.SplitControl--examples","title":"Examples","text":"<p>sidebyside = SideBySideLayers(layer_left, layer_right) sidebyside.add_to(m)</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>class SplitControl(Layer):\n    \"\"\"\n    Creates a SplitControl that takes two Layers and adds a sliding control with the leaflet-side-by-side plugin.\n    Uses the Leaflet leaflet-side-by-side plugin https://github.com/digidem/leaflet-side-by-side Parameters.\n    The source code is adapted from https://github.com/python-visualization/folium/pull/1292\n    ----------\n    layer_left: Layer.\n        The left Layer within the side by side control.\n        Must  be created and added to the map before being passed to this class.\n    layer_right: Layer.\n        The left Layer within the side by side control.\n        Must  be created and added to the map before being passed to this class.\n    name : string, default None\n        The name of the Layer, as it will appear in LayerControls.\n    overlay : bool, default True\n        Adds the layer as an optional overlay (True) or the base layer (False).\n    control : bool, default True\n        Whether the Layer will be included in LayerControls.\n    show: bool, default True\n        Whether the layer will be shown on opening (only for overlays).\n    Examples\n    --------\n    &gt;&gt;&gt; sidebyside = SideBySideLayers(layer_left, layer_right)\n    &gt;&gt;&gt; sidebyside.add_to(m)\n    \"\"\"\n\n    _template = Template(\n        \"\"\"\n        {% macro script(this, kwargs) %}\n            var {{ this.get_name() }} = L.control.sideBySide(\n                {{ this.layer_left.get_name() }}, {{ this.layer_right.get_name() }}\n            ).addTo({{ this._parent.get_name() }});\n        {% endmacro %}\n        \"\"\"\n    )\n\n    def __init__(\n        self, layer_left, layer_right, name=None, overlay=True, control=True, show=True\n    ):\n        super(SplitControl, self).__init__(\n            name=name, overlay=overlay, control=control, show=show\n        )\n        self._name = \"SplitControl\"\n        self.layer_left = layer_left\n        self.layer_right = layer_right\n\n    def render(self, **kwargs):\n        super(SplitControl, self).render()\n\n        figure = self.get_root()\n        assert isinstance(figure, Figure), (\n            \"You cannot render this Element \" \"if it is not in a Figure.\"\n        )\n\n        figure.header.add_child(\n            JavascriptLink(\n                \"https://raw.githack.com/digidem/leaflet-side-by-side/gh-pages/leaflet-side-by-side.js\"\n            ),  # noqa\n            name=\"leaflet.sidebyside\",\n        )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.SplitControl.render","title":"<code>render(self, **kwargs)</code>","text":"<p>Renders the HTML representation of the element.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def render(self, **kwargs):\n    super(SplitControl, self).render()\n\n    figure = self.get_root()\n    assert isinstance(figure, Figure), (\n        \"You cannot render this Element \" \"if it is not in a Figure.\"\n    )\n\n    figure.header.add_child(\n        JavascriptLink(\n            \"https://raw.githack.com/digidem/leaflet-side-by-side/gh-pages/leaflet-side-by-side.js\"\n        ),  # noqa\n        name=\"leaflet.sidebyside\",\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.delete_dp_report","title":"<code>delete_dp_report(name)</code>","text":"<p>Deletes a datapane report.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the report to delete.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def delete_dp_report(name):\n    \"\"\"Deletes a datapane report.\n\n    Args:\n        name (str): Name of the report to delete.\n    \"\"\"\n    try:\n        import datapane as dp\n\n        reports = dp.Report.list()\n        items = list(reports)\n        names = list(map(lambda item: item[\"name\"], items))\n        if name in names:\n            report = dp.Report.get(name)\n            url = report.blocks[0][\"url\"]\n            # print('Deleting {}...'.format(url))\n            dp.Report.delete(dp.Report.by_id(url))\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.delete_dp_reports","title":"<code>delete_dp_reports()</code>","text":"<p>Deletes all datapane reports.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def delete_dp_reports():\n    \"\"\"Deletes all datapane reports.\"\"\"\n    try:\n        import datapane as dp\n\n        reports = dp.Report.list()\n        for item in reports:\n            print(item[\"name\"])\n            report = dp.Report.get(item[\"name\"])\n            url = report.blocks[0][\"url\"]\n            print(\"Deleting {}...\".format(url))\n            dp.Report.delete(dp.Report.by_id(url))\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.geojson_layer","title":"<code>geojson_layer(in_geojson, layer_name='Untitled', encoding='utf-8', info_mode='on_hover', **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str</code> <p>The input file path to the GeoJSON.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def geojson_layer(\n    in_geojson: str,\n    layer_name: Optional[str] = \"Untitled\",\n    encoding: Optional[str] = \"utf-8\",\n    info_mode: Optional[str] = \"on_hover\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str): The input file path to the GeoJSON.\n        layer_name (str, optional): The layer name to be used. Defaults to \"Untitled\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import requests\n    import random\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    # interchangeable parameters between ipyleaflet and folium.\n    if \"style_function\" not in kwargs:\n        if \"style\" in kwargs:\n            style_dict = kwargs[\"style\"]\n            if isinstance(kwargs[\"style\"], dict) and len(kwargs[\"style\"]) &gt; 0:\n                kwargs[\"style_function\"] = lambda x: style_dict\n            kwargs.pop(\"style\")\n        else:\n            style_dict = {\n                # \"stroke\": True,\n                \"color\": \"#000000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0.1,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n            kwargs[\"style_function\"] = lambda x: style_dict\n\n    if \"style_callback\" in kwargs:\n        kwargs.pop(\"style_callback\")\n\n    if \"hover_style\" in kwargs:\n        kwargs.pop(\"hover_style\")\n\n    if \"fill_colors\" in kwargs:\n        fill_colors = kwargs[\"fill_colors\"]\n\n        def random_color(feature):\n            style_dict[\"fillColor\"] = random.choice(fill_colors)\n            return style_dict\n\n        kwargs[\"style_function\"] = random_color\n        kwargs.pop(\"fill_colors\")\n\n    if \"highlight_function\" not in kwargs:\n        kwargs[\"highlight_function\"] = lambda feat: {\n            \"weight\": 2,\n            \"fillOpacity\": 0.5,\n        }\n\n    tooltip = None\n    popup = None\n    if info_mode is not None:\n        props = list(data[\"features\"][0][\"properties\"].keys())\n        if info_mode == \"on_hover\":\n            tooltip = folium.GeoJsonTooltip(fields=props)\n        elif info_mode == \"on_click\":\n            popup = folium.GeoJsonPopup(fields=props)\n\n    geojson = folium.GeoJson(\n        data=data, name=layer_name, tooltip=tooltip, popup=popup, **kwargs\n    )\n    return geojson\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.linked_maps","title":"<code>linked_maps(rows=2, cols=2, height='400px', layers=[], labels=[], label_position='topright', **kwargs)</code>","text":"<p>Create linked maps of XYZ tile layers.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    layers=[],\n    labels=[],\n    label_position=\"topright\",\n    **kwargs,\n):\n    \"\"\"Create linked maps of XYZ tile layers.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.split_map","title":"<code>split_map(left_layer='ROADMAP', right_layer='HYBRID', left_label=None, right_label=None, label_position='bottom', **kwargs)</code>","text":"<p>Creates a split-panel map.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def split_map(\n    left_layer=\"ROADMAP\",\n    right_layer=\"HYBRID\",\n    left_label=None,\n    right_label=None,\n    label_position=\"bottom\",\n    **kwargs,\n):\n    \"\"\"Creates a split-panel map.\"\"\"\n    raise NotImplementedError(\n        \"The folium plotting backend does not support this function. Use the ipyleaflet plotting backend instead.\"\n    )\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.st_map_center","title":"<code>st_map_center(lat, lon)</code>","text":"<p>Returns the map center coordinates for a given latitude and longitude. If the system variable 'map_center' exists, it is used. Otherwise, the default is returned.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>lon</code> <code>float</code> <p>Longitude.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>list</code> <p>The map center coordinates.</p> Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_map_center(lat: float, lon: float):\n    \"\"\"Returns the map center coordinates for a given latitude and longitude. If the system variable 'map_center' exists, it is used. Otherwise, the default is returned.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n\n    Raises:\n        Exception: If streamlit is not installed.\n\n    Returns:\n        list: The map center coordinates.\n    \"\"\"\n    try:\n        import streamlit as st\n\n        if \"map_center\" in st.session_state:\n            return st.session_state[\"map_center\"]\n        else:\n            return [lat, lon]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"foliumap/#leafmap.foliumap.st_save_bounds","title":"<code>st_save_bounds(st_component)</code>","text":"<p>Saves the map bounds to the session state.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>folium.folium.Map</code> <p>The map to save the bounds from.</p> required Source code in <code>leafmap/foliumap.py</code> <pre><code>def st_save_bounds(st_component: Map):\n    \"\"\"Saves the map bounds to the session state.\n\n    Args:\n        map (folium.folium.Map): The map to save the bounds from.\n    \"\"\"\n    try:\n        import streamlit as st\n\n        if st_component is not None:\n            bounds = st_component[\"bounds\"]\n            south = bounds[\"_southWest\"][\"lat\"]\n            west = bounds[\"_southWest\"][\"lng\"]\n            north = bounds[\"_northEast\"][\"lat\"]\n            east = bounds[\"_northEast\"][\"lng\"]\n\n            bounds = [[south, west], [north, east]]\n            center = [south + (north - south) / 2, west + (east - west) / 2]\n\n            st.session_state[\"map_bounds\"] = bounds\n            st.session_state[\"map_center\"] = center\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"get-started/","title":"Get Started","text":"<p>This Get Started guide is intended as a quick way to start programming with leafmap. You can try out leafmap by using Goolge Colab () or Binder () without having to install anything on your computer.</p>"},{"location":"get-started/#important-note","title":"Important Note","text":"<p>Leafmap has six plotting backends, including folium, ipyleaflet, plotly, pydeck, kepler.gl, and heremap. An interactive map created using one of the plotting backends can be displayed in a Jupyter environment, such as Google Colab, Jupyter Notebook, and JupyterLab. By default, <code>import leafmap</code> will use the <code>ipyleaflet</code> plotting backend.</p> <p>The six plotting backends do not offer equal functionality. The <code>ipyleaflet</code> plotting backend provides the richest interactive functionality, including the custom toolset for loading, analyzing, and visualizing geospatial data interactively without coding. For example, users can add vector data (e.g., GeoJSON, Shapefile, KML, GeoDataFrame) and raster data (e.g., GeoTIFF, Cloud Optimized GeoTIFF [COG]) to the map with a few clicks (see Figure 1). Users can also perform geospatial analysis using the WhiteboxTools GUI with 468 geoprocessing tools directly within the map interface (see Figure 2). Other interactive functionality (e.g., split-panel map, linked map, time slider, time-series inspector) can also be useful for visualizing geospatial data. The <code>ipyleaflet</code> package is built upon <code>ipywidgets</code> and allows bidirectional communication between the front-end and the backend enabling the use of the map to capture user input (source). In contrast, <code>folium</code> has relatively limited interactive functionality. It is meant for displaying static data only. Note that the aforementioned custom toolset and interactive functionality are not available for other plotting backends. Compared with <code>ipyleaflet</code> and <code>folium</code>, the <code>pydeck</code>, <code>kepler.gl</code>, and <code>heremap</code> plotting backend provides some unique 3D mapping functionality. An API key from the Here Developer Portal is required to use <code>heremap</code>.</p> <p>To choose a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.deck as leafmap</code></li> <li><code>import leafmap.kepler as leafmap</code></li> <li><code>import leafmap.plotlymap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> </ul> <p> Figure 1. The leafmap user interface built upon ipyleaflet and ipywidgets.</p> <p> Figure 2. The WhiteboxTools graphical user interface integrated into leafmap.</p>"},{"location":"get-started/#leafmap-modules","title":"Leafmap Modules","text":"<p>The key functionality of the leafmap Python package is organized into nine modules as shown in the table below.</p> Module Description basemaps A collection of XYZ and WMS tile layers to be used as basemaps colormaps Commonly used colormaps and palettes for visualizing geospatial data common Functions being used by multiple plotting backends to process geospatial data foliumap A plotting backend built upon the folium Python package heremap A plotting backend built upon the here-map-widget-for-jupyter kepler A plotting backend built upon keplergl Python package leafmap The default plotting backend built upon the ipyleaflet Python package legends Built-in legends for commonly used geospatial datasets osm Functions for extracting and downloading OpenStreetMap data pc Functions for working with Microsoft Planetary Computer plotlymap A plotting backend built upon plotly Python package pydeck A plotting backend built upon pydeck Python package toolbar A custom toolset with interactive tools built upon ipywidgets and ipyleaflet"},{"location":"get-started/#launch-jupyter-notebook","title":"Launch Jupyter notebook","text":"<pre><code>conda activate env_name\njupyter notebook\n</code></pre>"},{"location":"get-started/#use-ipyleaflet-plotting-backend","title":"Use ipyleaflet plotting backend","text":"<pre><code>import leafmap\nm = leafmap.Map(center=(40, -100), zoom=4)\nm\n</code></pre>"},{"location":"get-started/#use-folium-plotting-backend","title":"Use folium plotting backend","text":"<pre><code>import leafmap.foliumap as leafmap\nm = leafmap.Map(center=(40, -100), zoom=4)\nm\n</code></pre>"},{"location":"get-started/#use-heremap-plotting-backend","title":"Use heremap plotting backend","text":""},{"location":"get-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A HERE developer account, free and available under HERE Developer Portal</li> <li>An API key from the HERE Developer Portal</li> <li>Export API key into environment variable <code>HEREMAPS_API_KEY</code></li> </ul> <pre><code>export HEREMAPS_API_KEY=YOUR-ACTUAL-API-KEY\n</code></pre>"},{"location":"get-started/#create-an-interactive-map","title":"Create an interactive map","text":"<pre><code>import os\nimport leafmap.heremap as leafmap\nos.environ[\"HEREMAPS_API_KEY\"] = \"YOUR_HEREMAPS_API_KEY\"\napi_key = os.environ.get(\"HEREMAPS_API_KEY\") # read api_key from environment variable.\nm = leafmap.Map(api_key=api_key, center=(40, -100), zoom=4)\nm\n</code></pre>"},{"location":"get-started/#leafmap-demo-with-ipyleaflet-backend","title":"Leafmap demo with ipyleaflet backend","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>leafmap is available on PyPI. To install leafmap, run this command in your terminal:</p> <pre><code>pip install leafmap\n</code></pre>"},{"location":"installation/#install-from-conda-forge","title":"Install from conda-forge","text":"<p>leafmap is also available on conda-forge. If you have Anaconda or Miniconda installed on your computer, you can install leafmap using the following command:</p> <pre><code>conda install leafmap -c conda-forge\n</code></pre> <p>The leafmap package has some optional dependencies (e.g., geopandas and localtileserver), which can be challenging to install on some computers, especially Windows. It is highly recommended that you create a fresh conda environment to install geopandas and leafmap. Follow the commands below to set up a conda env and install geopandas, localtileserver, keplergl, pydeck, and leafmap.</p> <pre><code>conda install -n base mamba -c conda-forge\nmamba create -n geo leafmap geopandas localtileserver python -c conda-forge\n</code></pre> <p>Optionally, you can install some Jupyter notebook extensions, which can improve your productivity in the notebook environment. Some useful extensions include Table of Contents, Gist-it, Autopep8, Variable Inspector, etc. See this post for more information.</p> <pre><code>conda install jupyter_contrib_nbextensions -c conda-forge\n</code></pre>"},{"location":"installation/#install-from-github","title":"Install from GitHub","text":"<p>To install the development version from GitHub using Git, run the following command in your terminal:</p> <pre><code>pip install git+https://github.com/opengeos/leafmap\n</code></pre>"},{"location":"installation/#use-docker","title":"Use docker","text":"<p>You can also use docker to run leafmap:</p> <pre><code>docker run -it -p 8888:8888 giswqs/leafmap:latest\n</code></pre>"},{"location":"installation/#upgrade-leafmap","title":"Upgrade leafmap","text":"<p>If you have installed leafmap before and want to upgrade to the latest version, you can run the following command in your terminal:</p> <pre><code>pip install -U leafmap\n</code></pre> <p>If you use conda, you can update leafmap to the latest version by running the following command in your terminal:</p> <pre><code>conda update -c conda-forge leafmap\n</code></pre> <p>To install the development version from GitHub directly within Jupyter notebook without using Git, run the following code:</p> <pre><code>import leafmap\nleafmap.update_package()\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If the interactive map does not show up on Jupyter Notebook and JupyterLab, it is probably because the ipyleaflet extension is not installed properly. For example, you might receive an error message saying <code>Error displaying widget: model not found</code>. This a well-known issue related to ipyleaflet. See some relevant issues below.</p> <ul> <li>How to display map object using ipyleaflet in jupyter notebook or jupyter Lab</li> <li>ipyleaflet does not work in jupyter lab - \"Error displaying widget: model not found\"</li> <li>Error displaying widget: model not found</li> </ul> <p>Try some of the options below to resolve the issue. If the issue persists after trying these steps, you can open an issue on the ipyleaflet repository.</p> <p>For Jupyter notebook, try running the following two commands within your leafmap conda environment:</p> <pre><code>jupyter nbextension install --py --symlink --sys-prefix ipyleaflet\njupyter nbextension enable --py --sys-prefix ipyleaflet\n</code></pre> <p>For JupyterLab, try running the following command within your leafmap conda environment:</p> <pre><code>jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter-leaflet\n</code></pre> <p>Alternatively, you can run leafmap directly using binder:</p> <ul> <li>https://mybinder.org/v2/gh/opengeos/leafmap/HEAD</li> </ul>"},{"location":"kepler/","title":"kepler module","text":""},{"location":"kepler/#leafmap.kepler.Map","title":"<code> Map            (KeplerGl)         </code>","text":"<p>The Map class inherits keplergl.KeperGl.</p> <p>Returns:</p> Type Description <code>object</code> <p>keplergl.KeperGl map object.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>class Map(keplergl.KeplerGl):\n    \"\"\"The Map class inherits keplergl.KeperGl.\n\n    Returns:\n        object: keplergl.KeperGl map object.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        if \"center\" not in kwargs:\n            kwargs[\"center\"] = [20, 0]\n\n        if \"zoom\" not in kwargs:\n            kwargs[\"zoom\"] = 1.3\n\n        if \"height\" not in kwargs:\n            kwargs[\"height\"] = 600\n        elif \"px\" in str(kwargs[\"height\"]):\n            kwargs[\"height\"] = kwargs[\"height\"].replace(\"px\", \"\")\n\n        if \"width\" not in kwargs:\n            kwargs[\"width\"] = 600\n        elif \"px\" in str(kwargs[\"width\"]):\n            kwargs[\"width\"] = kwargs[\"width\"].replace(\"px\", \"\")\n\n        if \"widescreen\" not in kwargs:\n            kwargs[\"widescreen\"] = False\n\n        if \"pitch\" not in kwargs:\n            kwargs[\"pitch\"] = 0\n\n        if \"bearing\" not in kwargs:\n            kwargs[\"bearing\"] = 0\n\n        if \"dragRotate\" not in kwargs:\n            kwargs[\"dragRotate\"] = False\n\n        if \"isSplit\" not in kwargs:\n            kwargs[\"isSplit\"] = False\n\n        if kwargs[\"widescreen\"]:\n            display(HTML(\"&lt;style&gt;.container { width:100% !important; }&lt;/style&gt;\"))\n\n        config = {\n            \"version\": \"v1\",\n            \"config\": {\n                \"mapState\": {\n                    \"latitude\": kwargs[\"center\"][0],\n                    \"longitude\": kwargs[\"center\"][1],\n                    \"zoom\": kwargs[\"zoom\"],\n                    \"bearing\": kwargs[\"bearing\"],\n                    \"pitch\": kwargs[\"pitch\"],\n                    \"isSplit\": kwargs[\"isSplit\"],\n                    \"dragRotate\": kwargs[\"dragRotate\"],\n                    \"height\": kwargs[\"height\"],\n                    \"width\": kwargs[\"width\"],\n                }\n            },\n        }\n\n        kwargs.pop(\"widescreen\")\n        kwargs.pop(\"center\")\n        kwargs.pop(\"zoom\")\n        if \"show_docs\" not in kwargs:\n            kwargs[\"show_docs\"] = False\n\n        super().__init__(**kwargs)\n        self.config = config\n\n    # def _repr_mimebundle_(self, include=None, exclude=None):\n    #     \"\"\"Display the map in a notebook.\n\n    #     Args:\n    #         include (list, optional): A list of MIME types to include.\n    #         exclude (list, optional): A list of MIME types to exclude.\n\n    #     Returns:\n    #         dict: A dictionary of MIME type keyed dict of MIME type data.\n    #     \"\"\"\n    #     print(\"hello\")\n    #     # import base64\n\n    #     # bundle = super()._repr_mimebundle_(include=include, exclude=exclude)\n    #     # if bundle[\"text/html\"]:\n    #     #     bundle[\"text/html\"] = self.display_html()\n    #     # return bundle\n\n    def add_geojson(\n        self,\n        in_geojson: Union[str, dict],\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n            TypeError: The input geojson must be a type of str or dict.\n        \"\"\"\n\n        if \"encoding\" in kwargs:\n            encoding = kwargs[\"encoding\"]\n        else:\n            encoding = \"utf-8\"\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    if is_jupyterlite():\n                        import pyodide\n\n                        output = os.path.basename(in_geojson)\n\n                        output = os.path.abspath(output)\n                        obj = pyodide.http.open_url(in_geojson)\n                        with open(output, \"w\") as fd:\n                            shutil.copyfileobj(obj, fd)\n                        with open(output, \"r\") as fd:\n                            data = json.load(fd)\n                    else:\n                        in_geojson = github_raw_url(in_geojson)\n                        data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        self.add_data(data, name=layer_name)\n        self.load_config(config)\n\n    def add_shp(\n        self,\n        in_shp: str,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            in_shp (str): The input file path to the shapefile.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n\n        import glob\n\n        if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n            out_dir = os.path.abspath(\"./cache/shp\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            download_from_url(in_shp, out_dir=out_dir, verbose=False)\n            files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n            if len(files) &gt; 0:\n                in_shp = files[0]\n            else:\n                raise FileNotFoundError(\n                    \"The downloaded zip file does not contain any shapefile in the root directory.\"\n                )\n        else:\n            in_shp = os.path.abspath(in_shp)\n            if not os.path.exists(in_shp):\n                raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        geojson = shp_to_geojson(in_shp)\n        self.add_geojson(\n            geojson,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n        self.add_geojson(data, layer_name, **kwargs)\n        self.load_config(config)\n\n    def add_df(\n        self,\n        df: DataFrame,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a DataFrame to the map.\n\n        Args:\n            df (DataFrame): A Pandas DataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        try:\n            self.add_data(data=df, name=layer_name)\n            self.load_config(config)\n        except Exception as e:\n            print(e)\n\n    def add_csv(\n        self,\n        in_csv: str,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a CSV to the map.\n\n        Args:\n            in_csv (str): File path to the CSV.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n\n        df = pd.read_csv(in_csv)\n        self.add_df(df, layer_name, config, **kwargs)\n\n    def add_vector(\n        self,\n        filename: str,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n        Args:\n            filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n            layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".shp\":\n            self.add_shp(\n                filename,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n        elif ext in [\".json\", \".geojson\"]:\n            self.add_geojson(\n                filename,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n        else:\n            geojson = vector_to_geojson(\n                filename,\n                epsg=\"4326\",\n                **kwargs,\n            )\n\n            self.add_geojson(\n                geojson,\n                layer_name,\n                **kwargs,\n            )\n            self.load_config(config)\n\n    def add_kml(\n        self,\n        in_kml: str,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a KML file to the map.\n\n        Args:\n            in_kml (str): The input file path to the KML.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n            out_dir = os.path.abspath(\"./cache\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n            in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n        else:\n            in_kml = os.path.abspath(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The provided KML could not be found.\")\n\n        self.add_vector(\n            in_kml,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def add_gdf_from_postgis(\n        self,\n        sql: str,\n        con,\n        layer_name: Optional[str] = \"Untitled\",\n        config: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        \"\"\"\n        gdf = read_postgis(sql, con, **kwargs)\n        gdf = gdf.to_crs(\"epsg:4326\")\n        self.add_gdf(\n            gdf,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n\n    def static_map(\n        self,\n        width: Optional[int] = 950,\n        height: Optional[int] = 600,\n        read_only: Optional[bool] = False,\n        out_file: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Display a kepler.gl static map in a Jupyter Notebook.\n\n        Args\n            width (int, optional): Width of the map. Defaults to 950.\n            height (int, optional): Height of the map. Defaults to 600.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n            out_file (str, optional): Output html file path. Defaults to None.\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        if isinstance(self, keplergl.KeplerGl):\n            if out_file is None:\n                if os.environ.get(\"USE_MKDOCS\") is not None:\n                    out_file = \"../maps/\" + \"kepler_\" + random_string(3) + \".html\"\n                else:\n                    out_file = \"./cache/\" + \"kepler_\" + random_string(3) + \".html\"\n            out_dir = os.path.abspath(os.path.dirname(out_file))\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            output = widgets.Output()\n            with output:\n                self.save_to_html(file_name=out_file, read_only=read_only)\n            display_html(src=out_file, width=width, height=height)\n        else:\n            raise TypeError(\"The provided map is not a kepler.gl map.\")\n\n    def to_html(\n        self,\n        outfile: Optional[str] = None,\n        read_only: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Saves the map as a HTML file.\n\n        Args:\n            outfile (str, optional): The output file path to the HTML file.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        try:\n            save = True\n            if outfile is not None:\n                if not outfile.endswith(\".html\"):\n                    raise ValueError(\"The output file extension must be html.\")\n                outfile = os.path.abspath(outfile)\n                out_dir = os.path.dirname(outfile)\n                if not os.path.exists(out_dir):\n                    os.makedirs(out_dir)\n            else:\n                outfile = os.path.abspath(random_string() + \".html\")\n                save = False\n\n            output = widgets.Output()\n            with output:\n                self.save_to_html(file_name=outfile, read_only=read_only)\n\n            if not save:\n                out_html = \"\"\n                with open(outfile) as f:\n                    lines = f.readlines()\n                    out_html = \"\".join(lines)\n                os.remove(outfile)\n                return out_html\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_streamlit(\n        self,\n        width: Optional[int] = 800,\n        height: Optional[int] = 600,\n        responsive: Optional[bool] = True,\n        scrolling: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Renders `keplergl.KeplerGl` map figure in a Streamlit app.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to 800.\n            height (int, optional): Height of the map. Defaults to 600.\n            responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n            scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n        Raises:\n            ImportError: If streamlit is not installed.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit as st\n            import streamlit.components.v1 as components\n\n            html = self._repr_html_()\n            if responsive:\n                make_map_responsive = \"\"\"\n                &lt;style&gt;\n                [title~=\"st.iframe\"] { width: 100%}\n                &lt;/style&gt;\n                \"\"\"\n                st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                html, width=width, height=height, scrolling=scrolling\n            )\n\n        except ImportError:\n            raise ImportError(\n                \"streamlit is not installed. You need to install streamlitusing 'pip install streamlit'. Seehttps://docs.streamlit.io/library/get-started/installation\"\n            )\n\n    def load_config(self, config: Optional[str] = None):\n        \"\"\"Loads a kepler.gl config file.\n\n        Args:\n            config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n        Raises:\n            FileNotFoundError: The provided config file could not be found.\n            TypeError: The provided config file is not a kepler.gl config file.\n        \"\"\"\n        if config is None:\n            pass\n        elif isinstance(config, dict):\n            self.config = config\n        elif isinstance(config, str):\n            if config.startswith(\"http\"):\n                r = requests.get(config)\n                self.config = r.json()\n            elif os.path.isfile(config):\n                with open(config) as f:\n                    self.config = json.load(f)\n            else:\n                raise FileNotFoundError(\"The provided config file could not be found.\")\n        else:\n            raise TypeError(\"The provided config is not a dictionary or filepath.\")\n\n    def save_config(self, out_json):\n        \"\"\"Saves a kepler.gl config file.\n\n        Args:\n            out_json (str): Output file path to the config file.\n\n        Raises:\n            ValueError: The output file extension must be json.\n            TypeError: The provided filepath is invalid.\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        if isinstance(out_json, str):\n            if not out_json.endswith(\".json\"):\n                raise ValueError(\"The output file extension must be json.\")\n            out_json = os.path.abspath(out_json)\n            out_dir = os.path.dirname(out_json)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            json_str = json.dumps(self.config, indent=2)\n            with open(out_json, \"w\") as f:\n                f.write(json_str)\n        else:\n            raise TypeError(\"The provided filepath is invalid.\")\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_csv","title":"<code>add_csv(self, in_csv, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a CSV to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the CSV.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_csv(\n    self,\n    in_csv: str,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a CSV to the map.\n\n    Args:\n        in_csv (str): File path to the CSV.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n\n    df = pd.read_csv(in_csv)\n    self.add_df(df, layer_name, config, **kwargs)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_df","title":"<code>add_df(self, df, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a DataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A Pandas DataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_df(\n    self,\n    df: DataFrame,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a DataFrame to the map.\n\n    Args:\n        df (DataFrame): A Pandas DataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    try:\n        self.add_data(data=df, name=layer_name)\n        self.load_config(config)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n    self.add_geojson(data, layer_name, **kwargs)\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_gdf_from_postgis(\n    self,\n    sql: str,\n    con,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    gdf = read_postgis(sql, con, **kwargs)\n    gdf = gdf.to_crs(\"epsg:4326\")\n    self.add_gdf(\n        gdf,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> <code>TypeError</code> <p>The input geojson must be a type of str or dict.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_geojson(\n    self,\n    in_geojson: Union[str, dict],\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n        TypeError: The input geojson must be a type of str or dict.\n    \"\"\"\n\n    if \"encoding\" in kwargs:\n        encoding = kwargs[\"encoding\"]\n    else:\n        encoding = \"utf-8\"\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                if is_jupyterlite():\n                    import pyodide\n\n                    output = os.path.basename(in_geojson)\n\n                    output = os.path.abspath(output)\n                    obj = pyodide.http.open_url(in_geojson)\n                    with open(output, \"w\") as fd:\n                        shutil.copyfileobj(obj, fd)\n                    with open(output, \"r\") as fd:\n                        data = json.load(fd)\n                else:\n                    in_geojson = github_raw_url(in_geojson)\n                    data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    self.add_data(data, name=layer_name)\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_kml(\n    self,\n    in_kml: str,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a KML file to the map.\n\n    Args:\n        in_kml (str): The input file path to the KML.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n        out_dir = os.path.abspath(\"./cache\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_kml, out_dir=out_dir, unzip=False, verbose=False)\n        in_kml = os.path.join(out_dir, os.path.basename(in_kml))\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n    else:\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML could not be found.\")\n\n    self.add_vector(\n        in_kml,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_shp","title":"<code>add_shp(self, in_shp, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_shp(\n    self,\n    in_shp: str,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        in_shp (str): The input file path to the shapefile.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n\n    import glob\n\n    if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n        out_dir = os.path.abspath(\"./cache/shp\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_shp, out_dir=out_dir, verbose=False)\n        files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n        if len(files) &gt; 0:\n            in_shp = files[0]\n        else:\n            raise FileNotFoundError(\n                \"The downloaded zip file does not contain any shapefile in the root directory.\"\n            )\n    else:\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    geojson = shp_to_geojson(in_shp)\n    self.add_geojson(\n        geojson,\n        layer_name,\n        **kwargs,\n    )\n    self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.add_vector","title":"<code>add_vector(self, filename, layer_name='Untitled', config=None, **kwargs)</code>","text":"<p>Adds any geopandas-supported vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def add_vector(\n    self,\n    filename: str,\n    layer_name: Optional[str] = \"Untitled\",\n    config: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    \"\"\"\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".shp\":\n        self.add_shp(\n            filename,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n    elif ext in [\".json\", \".geojson\"]:\n        self.add_geojson(\n            filename,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n    else:\n        geojson = vector_to_geojson(\n            filename,\n            epsg=\"4326\",\n            **kwargs,\n        )\n\n        self.add_geojson(\n            geojson,\n            layer_name,\n            **kwargs,\n        )\n        self.load_config(config)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.load_config","title":"<code>load_config(self, config=None)</code>","text":"<p>Loads a kepler.gl config file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Local path or HTTP URL to the config file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided config file could not be found.</p> <code>TypeError</code> <p>The provided config file is not a kepler.gl config file.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def load_config(self, config: Optional[str] = None):\n    \"\"\"Loads a kepler.gl config file.\n\n    Args:\n        config (str, optional): Local path or HTTP URL to the config file. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The provided config file could not be found.\n        TypeError: The provided config file is not a kepler.gl config file.\n    \"\"\"\n    if config is None:\n        pass\n    elif isinstance(config, dict):\n        self.config = config\n    elif isinstance(config, str):\n        if config.startswith(\"http\"):\n            r = requests.get(config)\n            self.config = r.json()\n        elif os.path.isfile(config):\n            with open(config) as f:\n                self.config = json.load(f)\n        else:\n            raise FileNotFoundError(\"The provided config file could not be found.\")\n    else:\n        raise TypeError(\"The provided config is not a dictionary or filepath.\")\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.save_config","title":"<code>save_config(self, out_json)</code>","text":"<p>Saves a kepler.gl config file.</p> <p>Parameters:</p> Name Type Description Default <code>out_json</code> <code>str</code> <p>Output file path to the config file.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The output file extension must be json.</p> <code>TypeError</code> <p>The provided filepath is invalid.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def save_config(self, out_json):\n    \"\"\"Saves a kepler.gl config file.\n\n    Args:\n        out_json (str): Output file path to the config file.\n\n    Raises:\n        ValueError: The output file extension must be json.\n        TypeError: The provided filepath is invalid.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if isinstance(out_json, str):\n        if not out_json.endswith(\".json\"):\n            raise ValueError(\"The output file extension must be json.\")\n        out_json = os.path.abspath(out_json)\n        out_dir = os.path.dirname(out_json)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        json_str = json.dumps(self.config, indent=2)\n        with open(out_json, \"w\") as f:\n            f.write(json_str)\n    else:\n        raise TypeError(\"The provided filepath is invalid.\")\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.static_map","title":"<code>static_map(self, width=950, height=600, read_only=False, out_file=None, **kwargs)</code>","text":"<p>Display a kepler.gl static map in a Jupyter Notebook.</p> <p>Args     width (int, optional): Width of the map. Defaults to 950.     height (int, optional): Height of the map. Defaults to 600.     read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.     out_file (str, optional): Output html file path. Defaults to None.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def static_map(\n    self,\n    width: Optional[int] = 950,\n    height: Optional[int] = 600,\n    read_only: Optional[bool] = False,\n    out_file: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Display a kepler.gl static map in a Jupyter Notebook.\n\n    Args\n        width (int, optional): Width of the map. Defaults to 950.\n        height (int, optional): Height of the map. Defaults to 600.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n        out_file (str, optional): Output html file path. Defaults to None.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if isinstance(self, keplergl.KeplerGl):\n        if out_file is None:\n            if os.environ.get(\"USE_MKDOCS\") is not None:\n                out_file = \"../maps/\" + \"kepler_\" + random_string(3) + \".html\"\n            else:\n                out_file = \"./cache/\" + \"kepler_\" + random_string(3) + \".html\"\n        out_dir = os.path.abspath(os.path.dirname(out_file))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        output = widgets.Output()\n        with output:\n            self.save_to_html(file_name=out_file, read_only=read_only)\n        display_html(src=out_file, width=width, height=height)\n    else:\n        raise TypeError(\"The provided map is not a kepler.gl map.\")\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.to_html","title":"<code>to_html(self, outfile=None, read_only=False, **kwargs)</code>","text":"<p>Saves the map as a HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the HTML file.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether to hide the side panel to disable map customization. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/kepler.py</code> <pre><code>def to_html(\n    self,\n    outfile: Optional[str] = None,\n    read_only: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Saves the map as a HTML file.\n\n    Args:\n        outfile (str, optional): The output file path to the HTML file.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        save = True\n        if outfile is not None:\n            if not outfile.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            outfile = os.path.abspath(outfile)\n            out_dir = os.path.dirname(outfile)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n        else:\n            outfile = os.path.abspath(random_string() + \".html\")\n            save = False\n\n        output = widgets.Output()\n        with output:\n            self.save_to_html(file_name=outfile, read_only=read_only)\n\n        if not save:\n            out_html = \"\"\n            with open(outfile) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(outfile)\n            return out_html\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"kepler/#leafmap.kepler.Map.to_streamlit","title":"<code>to_streamlit(self, width=800, height=600, responsive=True, scrolling=False, **kwargs)</code>","text":"<p>Renders <code>keplergl.KeplerGl</code> map figure in a Streamlit app.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If streamlit is not installed.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/kepler.py</code> <pre><code>def to_streamlit(\n    self,\n    width: Optional[int] = 800,\n    height: Optional[int] = 600,\n    responsive: Optional[bool] = True,\n    scrolling: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Renders `keplergl.KeplerGl` map figure in a Streamlit app.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n    Raises:\n        ImportError: If streamlit is not installed.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit as st\n        import streamlit.components.v1 as components\n\n        html = self._repr_html_()\n        if responsive:\n            make_map_responsive = \"\"\"\n            &lt;style&gt;\n            [title~=\"st.iframe\"] { width: 100%}\n            &lt;/style&gt;\n            \"\"\"\n            st.markdown(make_map_responsive, unsafe_allow_html=True)\n        return components.html(\n            html, width=width, height=height, scrolling=scrolling\n        )\n\n    except ImportError:\n        raise ImportError(\n            \"streamlit is not installed. You need to install streamlitusing 'pip install streamlit'. Seehttps://docs.streamlit.io/library/get-started/installation\"\n        )\n</code></pre>"},{"location":"leafmap/","title":"leafmap module","text":"<p>Main module.</p>"},{"location":"leafmap/#leafmap.leafmap.ImageOverlay","title":"<code> ImageOverlay            (ImageOverlay)         </code>","text":"<p>ImageOverlay class.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL or local file path to the image.</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>class ImageOverlay(ipyleaflet.ImageOverlay):\n    \"\"\"ImageOverlay class.\n\n    Args:\n        url (str): http URL or local file path to the image.\n        bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        from base64 import b64encode\n        from PIL import Image, ImageSequence\n        from io import BytesIO\n\n        try:\n            url = kwargs.get(\"url\")\n            if not url.startswith(\"http\"):\n                url = os.path.abspath(url)\n                if not os.path.exists(url):\n                    raise FileNotFoundError(\"The provided file does not exist.\")\n\n                ext = os.path.splitext(url)[1][1:]  # file extension\n                image = Image.open(url)\n\n                f = BytesIO()\n                if ext.lower() == \"gif\":\n                    frames = []\n                    # Loop over each frame in the animated image\n                    for frame in ImageSequence.Iterator(image):\n                        frame = frame.convert(\"RGBA\")\n                        b = BytesIO()\n                        frame.save(b, format=\"gif\")\n                        frame = Image.open(b)\n                        frames.append(frame)\n                    frames[0].save(\n                        f,\n                        format=\"GIF\",\n                        save_all=True,\n                        append_images=frames[1:],\n                        loop=0,\n                    )\n                else:\n                    image.save(f, ext)\n\n                data = b64encode(f.getvalue())\n                data = data.decode(\"ascii\")\n                url = \"data:image/{};base64,\".format(ext) + data\n                kwargs[\"url\"] = url\n        except Exception as e:\n            raise Exception(e)\n\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map","title":"<code> Map            (Map)         </code>","text":"<p>The Map class inherits ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/api_reference/map.html. By default, the Map will add OpenStreetMap as the basemap.</p> <p>Returns:</p> Type Description <code>object</code> <p>ipyleaflet map object.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>class Map(ipyleaflet.Map):\n    \"\"\"The Map class inherits ipyleaflet.Map. The arguments you can pass to the Map can be found at https://ipyleaflet.readthedocs.io/en/latest/api_reference/map.html. By default, the Map will add OpenStreetMap as the basemap.\n\n    Returns:\n        object: ipyleaflet map object.\n    \"\"\"\n\n    @property\n    def _layer_editor(self) -&gt; Optional[map_widgets.LayerEditor]:\n        return self._find_widget_of_type(map_widgets.LayerEditor)\n\n    def __init__(self, **kwargs):\n        if \"center\" not in kwargs:\n            kwargs[\"center\"] = [20, 0]\n\n        if \"zoom\" not in kwargs:\n            kwargs[\"zoom\"] = 2\n\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 24\n\n        if \"scroll_wheel_zoom\" not in kwargs:\n            kwargs[\"scroll_wheel_zoom\"] = True\n\n        if \"basemap\" in kwargs:\n            if isinstance(kwargs[\"basemap\"], str):\n                kwargs[\"basemap\"] = get_basemap(kwargs[\"basemap\"])\n\n        super().__init__(**kwargs)\n        self.baseclass = \"ipyleaflet\"\n        self.toolbar = None\n        self.toolbar_button = None\n        self.tool_output = None\n        self.tool_output_ctrl = None\n        self.layer_control = None\n        self.draw_control = None\n        self.search_control = None\n        self.user_roi = None\n        self.user_rois = None\n        self.draw_features = []\n        self.api_keys = {}\n        self.geojson_layers = []\n        self.edit_mode = False\n        self.edit_props = []\n\n        # sandbox path for Voila app to restrict access to system directories.\n        if \"sandbox_path\" not in kwargs:\n            if os.environ.get(\"USE_VOILA\") is not None:\n                self.sandbox_path = os.getcwd()\n            else:\n                self.sandbox_path = None\n        else:\n            if os.path.exists(os.path.abspath(kwargs[\"sandbox_path\"])):\n                self.sandbox_path = kwargs[\"sandbox_path\"]\n            else:\n                print(\"The sandbox path is invalid.\")\n                self.sandbox_path = None\n\n        if \"height\" not in kwargs:\n            self.layout.height = \"600px\"\n        else:\n            if isinstance(kwargs[\"height\"], int):\n                kwargs[\"height\"] = str(kwargs[\"height\"]) + \"px\"\n            self.layout.height = kwargs[\"height\"]\n        if \"width\" in kwargs:\n            if isinstance(kwargs[\"width\"], int):\n                kwargs[\"width\"] = str(kwargs[\"width\"]) + \"px\"\n            self.layout.width = kwargs[\"width\"]\n\n        if \"layers_control\" not in kwargs:\n            kwargs[\"layers_control\"] = False\n        if kwargs[\"layers_control\"]:\n            self.add(ipyleaflet.LayersControl(position=\"topright\"))\n\n        if \"fullscreen_control\" not in kwargs:\n            kwargs[\"fullscreen_control\"] = True\n        if kwargs[\"fullscreen_control\"]:\n            self.add(ipyleaflet.FullScreenControl())\n\n        if \"search_control\" not in kwargs:\n            kwargs[\"search_control\"] = False\n        if kwargs[\"search_control\"]:\n            url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\n            search_control = ipyleaflet.SearchControl(\n                position=\"topleft\",\n                url=url,\n                zoom=12,\n                marker=None,\n            )\n            self.add(search_control)\n            self.search_control = search_control\n\n        if \"draw_control\" not in kwargs:\n            kwargs[\"draw_control\"] = True\n\n        if \"repeat_mode\" not in kwargs:\n            repeat_mode = False\n        else:\n            repeat_mode = kwargs[\"repeat_mode\"]\n            kwargs.pop(\"repeat_mode\")\n\n        if kwargs[\"draw_control\"]:\n            draw_control = ipyleaflet.DrawControl(\n                polyline={\"repeatMode\": repeat_mode},\n                polygon={\"repeatMode\": repeat_mode},\n                marker={\n                    \"shapeOptions\": {\"color\": \"#3388ff\"},\n                    \"repeatMode\": repeat_mode,\n                },\n                rectangle={\n                    \"shapeOptions\": {\"color\": \"#3388ff\"},\n                    \"repeatMode\": repeat_mode,\n                },\n                circle={\n                    \"shapeOptions\": {\"color\": \"#3388ff\"},\n                    \"repeatMode\": repeat_mode,\n                },\n                # circlemarker={\"repeatMode\": repeat_mode},\n                edit=True,\n                remove=True,\n                position=\"topleft\",\n            )\n            draw_control.circlemarker = {}\n            self.add(draw_control)\n            self.draw_control = draw_control\n\n            def handle_draw(target, action, geo_json):\n                if \"style\" in geo_json[\"properties\"]:\n                    del geo_json[\"properties\"][\"style\"]\n                self.user_roi = geo_json\n\n                if action in [\"created\", \"edited\"]:\n                    # feature = {\n                    #     \"type\": \"Feature\",\n                    #     \"geometry\": geo_json[\"geometry\"],\n                    # }\n                    self.draw_features.append(geo_json)\n\n                elif action == \"deleted\":\n                    geometries = [\n                        feature[\"geometry\"] for feature in self.draw_control.data\n                    ]\n                    for geom in geometries:\n                        if geom == geo_json[\"geometry\"]:\n                            geometries.remove(geom)\n                    for feature in self.draw_features:\n                        if feature[\"geometry\"] not in geometries:\n                            self.draw_features.remove(feature)\n\n                if self.edit_mode:\n                    import ipysheet\n\n                    with self.edit_output:\n                        self.edit_output.outputs = ()\n                        self.edit_sheet = ipysheet.from_dataframe(\n                            self.get_draw_props(n=self.num_attributes, return_df=True)\n                        )\n                        display(self.edit_sheet)\n\n                self.user_rois = {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": self.draw_features,\n                }\n\n            draw_control.on_draw(handle_draw)\n\n        if \"measure_control\" not in kwargs:\n            kwargs[\"measure_control\"] = False\n        if kwargs[\"measure_control\"]:\n            self.add(ipyleaflet.MeasureControl(position=\"topleft\"))\n\n        if \"scale_control\" not in kwargs:\n            kwargs[\"scale_control\"] = True\n        if kwargs[\"scale_control\"]:\n            self.add(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n\n        self.layers[0].name = \"OpenStreetMap\"\n\n        if \"toolbar_control\" not in kwargs:\n            kwargs[\"toolbar_control\"] = True\n        if kwargs[\"toolbar_control\"]:\n            from .toolbar import main_toolbar\n\n            main_toolbar(self)\n\n        if \"use_voila\" not in kwargs:\n            kwargs[\"use_voila\"] = False\n\n        if \"catalog_source\" in kwargs:\n            self.set_catalog_source(kwargs[\"catalog_source\"])\n\n    def add(self, object, index=None, **kwargs):\n        \"\"\"Adds a layer to the map.\n\n        Args:\n            layer (object): The layer to add to the map.\n            index (int, optional): The index at which to add the layer. Defaults to None.\n        \"\"\"\n        if isinstance(object, str):\n            if object in basemaps.keys():\n                object = get_basemap(object)\n            else:\n                if object == \"nasa_earth_data\":\n                    from .toolbar import nasa_data_gui\n\n                    nasa_data_gui(self, **kwargs)\n                elif object == \"inspector\":\n                    from .toolbar import inspector_gui\n\n                    inspector_gui(self, **kwargs)\n\n                elif object == \"stac\":\n                    self.add_stac_gui(**kwargs)\n                elif object == \"basemap\":\n                    self.add_basemap_gui(**kwargs)\n                elif object == \"inspector\":\n                    self.add_inspector_gui(**kwargs)\n                elif object == \"layer_manager\":\n                    self.add_layer_manager(**kwargs)\n                elif object == \"oam\":\n                    self.add_oam_gui(**kwargs)\n                return\n\n        super().add(object, index=index)\n\n        if hasattr(self, \"layer_manager_widget\"):\n            self.update_layer_manager()\n\n    def set_center(self, lon, lat, zoom=None):\n        \"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n        Args:\n            lon (float): The longitude of the center, in degrees.\n            lat (float): The latitude of the center, in degrees.\n            zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n        \"\"\"\n        self.center = (lat, lon)\n        if zoom is not None:\n            self.zoom = zoom\n\n    def zoom_to_bounds(self, bounds):\n        \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n        Args:\n            bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n        \"\"\"\n        #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def zoom_to_gdf(self, gdf):\n        \"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        \"\"\"\n        bounds = gdf.total_bounds\n        self.zoom_to_bounds(bounds)\n\n    def get_scale(self):\n        \"\"\"Returns the approximate pixel scale of the current map view, in meters.\n\n        Returns:\n            float: Map resolution in meters.\n        \"\"\"\n        import math\n\n        zoom_level = self.zoom\n        # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n        resolution = 156543.04 * math.cos(0) / math.pow(2, zoom_level)\n        return resolution\n\n    def get_layer_names(self):\n        \"\"\"Gets layer names as a list.\n\n        Returns:\n            list: A list of layer names.\n        \"\"\"\n        layer_names = []\n\n        for layer in list(self.layers):\n            if len(layer.name) &gt; 0:\n                layer_names.append(layer.name)\n\n        return layer_names\n\n    def add_marker(self, location, **kwargs):\n        \"\"\"Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.\n\n        Args:\n            location (list | tuple): The location of the marker in the format of [lat, lng].\n\n            **kwargs: Keyword arguments for the marker.\n        \"\"\"\n        if isinstance(location, list):\n            location = tuple(location)\n        if isinstance(location, tuple):\n            marker = ipyleaflet.Marker(location=location, **kwargs)\n            self.add(marker)\n        else:\n            raise TypeError(\"The location must be a list or a tuple.\")\n\n    def add_basemap(self, basemap=\"HYBRID\", show=True, **kwargs):\n        \"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from basemaps. Defaults to 'HYBRID'.\n            visible (bool, optional): Whether the basemap is visible or not. Defaults to True.\n            **kwargs: Keyword arguments for the TileLayer.\n        \"\"\"\n        import xyzservices\n\n        try:\n            layer_names = self.get_layer_names()\n\n            map_dict = {\n                \"ROADMAP\": \"Google Maps\",\n                \"SATELLITE\": \"Google Satellite\",\n                \"TERRAIN\": \"Google Terrain\",\n                \"HYBRID\": \"Google Hybrid\",\n            }\n\n            if isinstance(basemap, str):\n                if basemap.upper() in map_dict:\n                    layer = get_google_map(basemap.upper(), **kwargs)\n                    layer.visible = show\n                    self.add(layer)\n                    return\n\n            if isinstance(basemap, xyzservices.TileProvider):\n                name = basemap.name\n                url = basemap.build_url()\n                attribution = basemap.attribution\n                if \"max_zoom\" in basemap.keys():\n                    max_zoom = basemap[\"max_zoom\"]\n                else:\n                    max_zoom = 22\n                layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=name,\n                    max_zoom=max_zoom,\n                    attribution=attribution,\n                    visible=show,\n                    **kwargs,\n                )\n                self.add(layer)\n                arc_add_layer(url, name)\n            elif basemap in basemaps and basemaps[basemap].name not in layer_names:\n                self.add(basemap)\n                self.layers[-1].visible = show\n                arc_add_layer(basemaps[basemap].url, basemap)\n            elif basemap in basemaps and basemaps[basemap].name in layer_names:\n                print(f\"{basemap} has been already added before.\")\n            else:\n                print(\n                    \"Basemap can only be one of the following:\\n  {}\".format(\n                        \"\\n  \".join(basemaps.keys())\n                    )\n                )\n\n        except Exception as e:\n            raise ValueError(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    def find_layer(self, name):\n        \"\"\"Finds layer by name\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            object: ipyleaflet layer object.\n        \"\"\"\n        layers = self.layers\n\n        for layer in layers:\n            if layer.name == name:\n                return layer\n        return None\n\n    def find_layer_index(self, name):\n        \"\"\"Finds layer index by name\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            int: Index of the layer with the specified name\n        \"\"\"\n        layers = self.layers\n\n        for index, layer in enumerate(layers):\n            if layer.name == name:\n                return index\n\n        return -1\n\n    def add_layer(self, layer):\n        \"\"\"Adds a layer to the map.\n\n        Args:\n            layer (ipyleaflet layer): The layer to be added.\n        \"\"\"\n        existing_layer = self.find_layer(layer.name)\n        if existing_layer is not None:\n            self.remove_layer(existing_layer)\n        super().add(layer)\n\n    def add_ee_layer(\n        self,\n        asset_id: str,\n        name: str = None,\n        attribution: str = \"Google Earth Engine\",\n        shown: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n            https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n        Args:\n            asset_id (str): The ID of the Earth Engine asset.\n            name (str, optional): The name of the tile layer. If not provided, the asset ID will be used. Default is None.\n            attribution (str, optional): The attribution text to be displayed. Default is \"Google Earth Engine\".\n            shown (bool, optional): Whether the tile layer should be shown on the map. Default is True.\n            opacity (float, optional): The opacity of the tile layer. Default is 1.0.\n            **kwargs: Additional keyword arguments to be passed to the underlying `add_tile_layer` method.\n\n        Returns:\n            None\n        \"\"\"\n        import pandas as pd\n\n        df = pd.read_csv(\n            \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n            sep=\"\\t\",\n        )\n\n        asset_id = asset_id.strip()\n        if name is None:\n            name = asset_id\n\n        if asset_id in df[\"id\"].values:\n            url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n            self.add_tile_layer(\n                url,\n                name,\n                attribution=attribution,\n                shown=shown,\n                opacity=opacity,\n                **kwargs,\n            )\n        else:\n            print(f\"The provided EE tile layer {asset_id} does not exist.\")\n\n    def add_layer_control(self, position=\"topright\"):\n        \"\"\"Adds a layer control to the map.\n\n        Args:\n            position (str, optional): The position of the layer control. Defaults to 'topright'.\n        \"\"\"\n\n        self.add(ipyleaflet.LayersControl(position=position))\n\n    def layer_opacity(self, name, value=1.0):\n        \"\"\"Changes layer opacity.\n\n        Args:\n            name (str): The name of the layer to change opacity.\n            value (float, optional): The opacity value to set. Defaults to 1.0.\n        \"\"\"\n        layer = self.find_layer(name)\n        try:\n            layer.opacity = value\n        except Exception as e:\n            raise Exception(e)\n\n    def add_wms_layer(\n        self,\n        url,\n        layers,\n        name=None,\n        attribution=\"\",\n        format=\"image/png\",\n        transparent=True,\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n        \"\"\"Add a WMS layer to the map.\n\n        Args:\n            url (str): The URL of the WMS web service.\n            layers (str): Comma-separated list of WMS layers to show.\n            name (str, optional): The layer name to use on the layer control. Defaults to None.\n            attribution (str, optional): The attribution of the data layer. Defaults to ''.\n            format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n            transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n\n        if name is None:\n            name = str(layers)\n\n        try:\n            wms_layer = ipyleaflet.WMSLayer(\n                url=url,\n                layers=layers,\n                name=name,\n                attribution=attribution,\n                format=format,\n                transparent=transparent,\n                opacity=opacity,\n                visible=shown,\n                **kwargs,\n            )\n            self.add(wms_layer)\n\n        except Exception as e:\n            print(\"Failed to add the specified WMS TileLayer.\")\n            raise Exception(e)\n\n    def add_tile_layer(\n        self,\n        url,\n        name,\n        attribution,\n        opacity=1.0,\n        shown=True,\n        layer_index=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a TileLayer to the map.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str): The layer name to use for the layer.\n            attribution (str): The attribution to use.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            layer_index (int, optional): The index at which to add the layer. Defaults to None.\n        \"\"\"\n        if \"max_zoom\" not in kwargs:\n            kwargs[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in kwargs:\n            kwargs[\"max_native_zoom\"] = 30\n        try:\n            tile_layer = ipyleaflet.TileLayer(\n                url=url,\n                name=name,\n                attribution=attribution,\n                opacity=opacity,\n                visible=shown,\n                **kwargs,\n            )\n            self.add(tile_layer, index=layer_index)\n\n            arc_add_layer(url, name, shown, opacity)\n\n        except Exception as e:\n            print(\"Failed to add the specified TileLayer.\")\n            raise Exception(e)\n\n    def add_vector_tile(\n        self,\n        url,\n        styles: Optional[dict] = {},\n        layer_name: Optional[str] = \"Vector Tile\",\n        **kwargs,\n    ):\n        \"\"\"Adds a VectorTileLayer to the map. It wraps the ipyleaflet.VectorTileLayer class. See\n            https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html\n\n        Args:\n            url (str, optional): The URL of the tile layer\n            styles (dict,optional): Style dict, specific to the vector tile source.\n            layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n            kwargs: Additional keyword arguments to pass to the ipyleaflet.VectorTileLayer class.\n        \"\"\"\n        if \"vector_tile_layer_styles\" in kwargs:\n            styles = kwargs[\"vector_tile_layer_styles\"]\n            del kwargs[\"vector_tile_layer_styles\"]\n        try:\n            vector_tile_layer = ipyleaflet.VectorTileLayer(\n                url=url,\n                vector_tile_layer_styles=styles,\n                **kwargs,\n            )\n            vector_tile_layer.name = layer_name\n            self.add(vector_tile_layer)\n\n        except Exception as e:\n            print(\"Failed to add the specified VectorTileLayer.\")\n            raise Exception(e)\n\n    add_vector_tile_layer = add_vector_tile\n\n    def add_pmtiles(\n        self,\n        url,\n        style=None,\n        name=\"PMTiles\",\n        show=True,\n        zoom_to_layer=True,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a PMTiles layer to the map. This function is not officially supported yet by ipyleaflet yet.\n        Install it with the following command:\n        pip install git+https://github.com/giswqs/ipyleaflet.git@pmtiles\n\n        Args:\n            url (str): The URL of the PMTiles file.\n            style (str, optional): The CSS style to apply to the layer. Defaults to None.\n                See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n            name (str, optional): The name of the layer. Defaults to None.\n            show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n        Returns:\n            None\n        \"\"\"\n\n        try:\n            if \"sources\" in kwargs:\n                del kwargs[\"sources\"]\n\n            if \"version\" in kwargs:\n                del kwargs[\"version\"]\n\n            if style is None:\n                style = pmtiles_style(url)\n\n            layer = ipyleaflet.PMTilesLayer(\n                url=url,\n                style=style,\n                name=name,\n                visible=show,\n                **kwargs,\n            )\n            self.add(layer)\n\n            if zoom_to_layer:\n                metadata = pmtiles_metadata(url)\n                bounds = metadata[\"bounds\"]\n                self.zoom_to_bounds(bounds)\n        except Exception as e:\n            print(e)\n\n    def add_osm_from_geocode(\n        self,\n        query,\n        which_result=None,\n        by_osmid=False,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n\n        gdf = osm_gdf_from_geocode(\n            query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n        )\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_address(\n        self,\n        address,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n        Args:\n            address (str): The address to geocode and use as the central point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_address(address, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_place(\n        self,\n        query,\n        tags,\n        which_result=None,\n        buffer_dist=None,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n        Args:\n            query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n            buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_point(\n        self,\n        center_point,\n        tags,\n        dist=1000,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n        Args:\n            center_point (tuple): The (lat, lng) center point around which to get the geometries.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            dist (int, optional): Distance in meters. Defaults to 1000.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_point(center_point, tags, dist)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_polygon(\n        self,\n        polygon,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n        Args:\n            polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_polygon(polygon, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_bbox(\n        self,\n        north,\n        south,\n        east,\n        west,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n        Args:\n            north (float): Northern latitude of bounding box.\n            south (float): Southern latitude of bounding box.\n            east (float): Eastern longitude of bounding box.\n            west (float): Western longitude of bounding box.\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_osm_from_view(\n        self,\n        tags,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds OSM entities within the current map view to the map.\n\n        Args:\n            tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        \"\"\"\n        bounds = self.bounds\n        if len(bounds) == 0:\n            bounds = (\n                (40.74824858675827, -73.98933637940563),\n                (40.75068694343106, -73.98364473187601),\n            )\n        north, south, east, west = (\n            bounds[1][0],\n            bounds[0][0],\n            bounds[1][1],\n            bounds[0][1],\n        )\n\n        gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(\n            geojson,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n        self.zoom_to_gdf(gdf)\n\n    def add_cog_layer(\n        self,\n        url,\n        name=\"Untitled\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        bands=None,\n        titiler_endpoint=None,\n        zoom_to_layer=True,\n        layer_index=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            bands (list, optional): A list of bands to use for the layer. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            layer_index (int, optional): The index at which to add the layer. Defaults to None.\n            **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n                color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n                apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n        \"\"\"\n        band_names = cog_bands(url, titiler_endpoint)\n\n        if bands is not None:\n            if not isinstance(bands, list):\n                bands = [bands]\n\n            if all(isinstance(x, str) for x in bands):\n                kwargs[\"bidx\"] = [band_names.index(x) + 1 for x in bands]\n\n            elif all(isinstance(x, int) for x in bands):\n                kwargs[\"bidx\"] = bands\n            else:\n                raise ValueError(\"Bands must be a list of integers or strings.\")\n        elif \"bidx\" not in kwargs:\n            if len(band_names) == 1:\n                kwargs[\"bidx\"] = [1]\n            else:\n                kwargs[\"bidx\"] = [1, 2, 3]\n\n        vis_bands = [band_names[idx - 1] for idx in kwargs[\"bidx\"]]\n\n        if len(kwargs[\"bidx\"]) &gt; 1:\n            if \"colormap_name\" in kwargs:\n                kwargs.pop(\"colormap_name\")\n            if \"colormap\" in kwargs:\n                kwargs.pop(\"colormap\")\n\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        bounds = cog_bounds(url, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity, shown, layer_index)\n        if zoom_to_layer:\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n            arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n\n        vmin, vmax = cog_tile_vmin_vmax(url, bands=bands)\n\n        if \"colormap_name\" in kwargs:\n            colormap = kwargs[\"colormap_name\"]\n        else:\n            colormap = None\n\n        if \"nodata\" in kwargs:\n            nodata = kwargs[\"nodata\"]\n        else:\n            nodata = None\n\n        params = {\n            \"url\": url,\n            \"titiler_endpoint\": titiler_endpoint,\n            \"tile_layer\": self.find_layer(name),\n            \"bounds\": bounds,\n            \"indexes\": kwargs[\"bidx\"],\n            \"vis_bands\": vis_bands,\n            \"band_names\": band_names,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"nodata\": nodata,\n            \"colormap\": colormap,\n            \"opacity\": opacity,\n            \"layer_name\": name,\n            \"type\": \"COG\",\n        }\n        self.cog_layer_dict[name] = params\n\n    def add_cog_mosaic(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/opengeos/leafmap/issues/180.\"\n        )\n\n    def add_cog_mosaic_from_file(self, **kwargs):\n        raise NotImplementedError(\n            \"This function is no longer supported.See https://github.com/opengeos/leafmap/issues/180.\"\n        )\n\n    def add_stac_layer(\n        self,\n        url=None,\n        collection=None,\n        item=None,\n        assets=None,\n        bands=None,\n        titiler_endpoint=None,\n        name=\"STAC Layer\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        fit_bounds=True,\n        layer_index=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n            fit_bounds (bool, optional): A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.\n            layer_index (int, optional): The index at which to add the layer. Defaults to None.\n        \"\"\"\n        if \"colormap_name\" in kwargs and kwargs[\"colormap_name\"] is None:\n            kwargs.pop(\"colormap_name\")\n\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        bounds = stac_bounds(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity, shown, layer_index)\n        if fit_bounds:\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n            arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n\n        if assets is None and bands is not None:\n            assets = bands\n\n        if isinstance(assets, str) and \",\" in assets:\n            assets = assets.split(\",\")\n\n        if \"rescale\" in kwargs:\n            rescale = kwargs[\"rescale\"]\n            vmin, vmax = [float(v) for v in rescale.split(\",\")]\n        else:\n            vmin, vmax = stac_min_max(url, collection, item, assets, titiler_endpoint)\n\n        if \"nodata\" in kwargs:\n            nodata = kwargs[\"nodata\"]\n        else:\n            nodata = None\n\n        band_names = stac_bands(url, collection, item, titiler_endpoint)\n        indexes = [band_names.index(band) + 1 for band in assets]\n\n        params = {\n            \"url\": url,\n            \"titiler_endpoint\": titiler_endpoint,\n            \"collection\": collection,\n            \"item\": item,\n            \"assets\": assets,\n            \"tile_layer\": self.find_layer(name),\n            \"indexes\": indexes,\n            \"vis_bands\": assets,\n            \"band_names\": band_names,\n            \"bounds\": bounds,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"nodata\": nodata,\n            \"opacity\": opacity,\n            \"layer_name\": name,\n            \"type\": \"STAC\",\n        }\n\n        self.cog_layer_dict[name] = params\n\n    def add_mosaic_layer(\n        self,\n        url=None,\n        titiler_endpoint=None,\n        name=\"Mosaic Layer\",\n        attribution=\"\",\n        opacity=1.0,\n        shown=True,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a MosaicJSON.\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        \"\"\"\n        tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n\n        bounds = mosaic_bounds(url, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_minimap(self, zoom=5, position=\"bottomright\"):\n        \"\"\"Adds a minimap (overview) to the ipyleaflet map.\n\n        Args:\n            zoom (int, optional): Initial map zoom level. Defaults to 5.\n            position (str, optional): Position of the minimap. Defaults to \"bottomright\".\n        \"\"\"\n        layers = [get_basemap(\"Esri.WorldImagery\")]\n        minimap = ipyleaflet.Map(\n            zoom_control=False,\n            attribution_control=False,\n            zoom=zoom,\n            center=self.center,\n            layers=layers,\n        )\n        minimap.layout.width = \"150px\"\n        minimap.layout.height = \"150px\"\n        ipyleaflet.link((minimap, \"center\"), (self, \"center\"))\n        minimap_control = ipyleaflet.WidgetControl(widget=minimap, position=position)\n        self.add(minimap_control)\n\n    def marker_cluster(self, event=\"click\", add_marker=True):\n        \"\"\"Captures user inputs and add markers to the map.\n\n        Args:\n            event (str, optional): [description]. Defaults to 'click'.\n            add_marker (bool, optional): If True, add markers to the map. Defaults to True.\n\n        Returns:\n            object: a marker cluster.\n        \"\"\"\n        coordinates = []\n        markers = []\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n        self.last_click = []\n        self.all_clicks = []\n        if add_marker:\n            self.add(marker_cluster)\n\n        def handle_interaction(**kwargs):\n            latlon = kwargs.get(\"coordinates\")\n\n            if event == \"click\" and kwargs.get(\"type\") == \"click\":\n                coordinates.append(latlon)\n                self.last_click = latlon\n                self.all_clicks = coordinates\n                if add_marker:\n                    markers.append(ipyleaflet.Marker(location=latlon))\n                    marker_cluster.markers = markers\n            elif kwargs.get(\"type\") == \"mousemove\":\n                pass\n\n        # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n        self.default_style = {\"cursor\": \"crosshair\"}\n        self.on_interaction(handle_interaction)\n\n    def add_circle_markers_from_xy(\n        self,\n        data,\n        x=\"lon\",\n        y=\"lat\",\n        radius=10,\n        popup=None,\n        font_size=2,\n        stroke=True,\n        color=\"#0033FF\",\n        weight=2,\n        fill=True,\n        fill_color=None,\n        fill_opacity=0.2,\n        opacity=1.0,\n        layer_name=\"Circle Markers\",\n        **kwargs,\n    ):\n        \"\"\"Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/_modules/ipyleaflet/leaflet.html#Path\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"lon\".\n            y (str, optional): The column name for the y values. Defaults to \"lat\".\n            radius (int, optional): The radius of the circle. Defaults to 10.\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            font_size (int, optional): The font size of the popup. Defaults to 2.\n            stroke (bool, optional): Whether to stroke the path. Defaults to True.\n            color (str, optional): The color of the path. Defaults to \"#0033FF\".\n            weight (int, optional): The weight of the path. Defaults to 2.\n            fill (bool, optional): Whether to fill the path with color. Defaults to True.\n            fill_color (str, optional): The fill color of the path. Defaults to None.\n            fill_opacity (float, optional): The fill opacity of the path. Defaults to 0.2.\n            opacity (float, optional): The opacity of the path. Defaults to 1.0.\n            layer_name (str, optional): The layer name to use for the marker cluster. Defaults to \"Circle Markers\".\n\n        \"\"\"\n        import pandas as pd\n        import geopandas as gpd\n\n        if isinstance(data, pd.DataFrame) or isinstance(data, gpd.GeoDataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        elif isinstance(data, str) and data.endswith(\".csv\"):\n            df = pd.read_csv(data)\n        else:\n            df = gpd.read_file(data)\n\n        col_names = df.columns.values.tolist()\n        if \"geometry\" in col_names:\n            col_names.remove(\"geometry\")\n\n        if popup is None:\n            popup = col_names\n\n        if not isinstance(popup, list):\n            popup = [popup]\n\n        if x not in col_names:\n            if isinstance(df, gpd.GeoDataFrame):\n                df[x] = df.geometry.x\n            else:\n                raise ValueError(\n                    f\"x must be one of the following: {', '.join(col_names)}\"\n                )\n\n        if y not in col_names:\n            if isinstance(df, gpd.GeoDataFrame):\n                df[y] = df.geometry.y\n            else:\n                raise ValueError(\n                    f\"y must be one of the following: {', '.join(col_names)}\"\n                )\n\n        if fill_color is None:\n            fill_color = color\n\n        if isinstance(color, str):\n            colors = [color] * len(df)\n        elif isinstance(color, list):\n            colors = color\n        else:\n            raise ValueError(\"color must be either a string or a list.\")\n\n        if isinstance(fill_color, str):\n            fill_colors = [fill_color] * len(df)\n        elif isinstance(fill_color, list):\n            fill_colors = fill_color\n        else:\n            raise ValueError(\"fill_color must be either a string or a list.\")\n\n        if isinstance(radius, int):\n            radius = [radius] * len(df)\n        elif isinstance(radius, list):\n            radius = radius\n        else:\n            raise ValueError(\"radius must be either an integer or a list.\")\n\n        index = 0\n\n        layers = []\n        for idx, row in df.iterrows():\n            html = \"\"\n            for p in popup:\n                html = (\n                    html\n                    + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                    + p\n                    + \"&lt;/b&gt;\"\n                    + \": \"\n                    + str(row[p])\n                    + \"&lt;br&gt;&lt;/font&gt;\"\n                )\n            popup_html = widgets.HTML(html)\n\n            marker = ipyleaflet.CircleMarker(\n                location=[row[y], row[x]],\n                radius=radius[index],\n                popup=popup_html,\n                stroke=stroke,\n                color=colors[index],\n                weight=weight,\n                fill=fill,\n                fill_color=fill_colors[index],\n                fill_opacity=fill_opacity,\n                opacity=opacity,\n                **kwargs,\n            )\n            layers.append(marker)\n            index += 1\n\n        group = ipyleaflet.LayerGroup(layers=tuple(layers), name=layer_name)\n        self.add(group)\n\n    def add_markers(\n        self,\n        markers: Union[List[List[Union[int, float]]], List[Union[int, float]]],\n        x: str = \"lon\",\n        y: str = \"lat\",\n        radius: int = 10,\n        popup: Optional[str] = None,\n        font_size: int = 2,\n        stroke: bool = True,\n        color: str = \"#0033FF\",\n        weight: int = 2,\n        fill: bool = True,\n        fill_color: Optional[str] = None,\n        fill_opacity: float = 0.2,\n        opacity: float = 1.0,\n        shape: str = \"circle\",\n        layer_name: str = \"Markers\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Adds markers to the map.\n\n        Args:\n            markers (Union[List[List[Union[int, float]]], List[Union[int, float]]]): List of markers.\n                Each marker can be defined as a list of [x, y] coordinates or as a single [x, y] coordinate.\n            x (str, optional): Name of the x-coordinate column in the marker data. Defaults to \"lon\".\n            y (str, optional): Name of the y-coordinate column in the marker data. Defaults to \"lat\".\n            radius (int, optional): Radius of the markers. Defaults to 10.\n            popup (str, optional): Popup text for the markers. Defaults to None.\n            font_size (int, optional): Font size of the popup text. Defaults to 2.\n            stroke (bool, optional): Whether to display marker stroke. Defaults to True.\n            color (str, optional): Color of the marker stroke. Defaults to \"#0033FF\".\n            weight (int, optional): Weight of the marker stroke. Defaults to 2.\n            fill (bool, optional): Whether to fill markers. Defaults to True.\n            fill_color (str, optional): Fill color of the markers. Defaults to None.\n            fill_opacity (float, optional): Opacity of the marker fill. Defaults to 0.2.\n            opacity (float, optional): Opacity of the markers. Defaults to 1.0.\n            shape (str, optional): Shape of the markers. Options are \"circle\" or \"marker\". Defaults to \"circle\".\n            layer_name (str, optional): Name of the marker layer. Defaults to \"Markers\".\n            **kwargs: Additional keyword arguments to pass to the marker plotting function.\n\n        Returns:\n            None: This function does not return any value.\n        \"\"\"\n        import geopandas as gpd\n\n        if (\n            isinstance(markers, list)\n            and len(markers) == 2\n            and isinstance(markers[0], (int, float))\n            and isinstance(markers[1], (int, float))\n        ):\n            markers = [markers]\n\n        if isinstance(markers, list) and all(\n            isinstance(item, list) and len(item) == 2 for item in markers\n        ):\n            df = pd.DataFrame(markers, columns=[y, x])\n            markers = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y]))\n\n        if shape == \"circle\":\n            self.add_circle_markers_from_xy(\n                markers,\n                x,\n                y,\n                radius,\n                popup,\n                font_size,\n                stroke,\n                color,\n                weight,\n                fill,\n                fill_color,\n                fill_opacity,\n                opacity,\n                layer_name,\n                **kwargs,\n            )\n\n        elif shape == \"marker\":\n            self.add_gdf(markers, **kwargs)\n\n    def split_map(\n        self,\n        left_layer=\"TERRAIN\",\n        right_layer=\"OpenTopoMap\",\n        left_args={},\n        right_args={},\n        left_array_args={},\n        right_array_args={},\n        zoom_control=True,\n        fullscreen_control=True,\n        layer_control=True,\n        add_close_button=False,\n        left_label=None,\n        right_label=None,\n        left_position=\"bottomleft\",\n        right_position=\"bottomright\",\n        widget_layout=None,\n        draggable=True,\n    ):\n        \"\"\"Adds split map.\n\n        Args:\n            left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n            right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n            left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n            right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n            left_array_args (dict, optional): The arguments for array_to_image for the left layer. Defaults to {}.\n            right_array_args (dict, optional): The arguments for array_to_image for the right layer. Defaults to {}.\n            zoom_control (bool, optional): Whether to add zoom control. Defaults to True.\n            fullscreen_control (bool, optional): Whether to add fullscreen control. Defaults to True.\n            layer_control (bool, optional): Whether to add layer control. Defaults to True.\n            add_close_button (bool, optional): Whether to add a close button. Defaults to False.\n            left_label (str, optional): The label for the left layer. Defaults to None.\n            right_label (str, optional): The label for the right layer. Defaults to None.\n            left_position (str, optional): The position for the left label. Defaults to \"bottomleft\".\n            right_position (str, optional): The position for the right label. Defaults to \"bottomright\".\n            widget_layout (dict, optional): The layout for the widget. Defaults to None.\n            draggable (bool, optional): Whether the split map is draggable. Defaults to True.\n        \"\"\"\n        if \"max_zoom\" not in left_args:\n            left_args[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in left_args:\n            left_args[\"max_native_zoom\"] = 30\n\n        if \"max_zoom\" not in right_args:\n            right_args[\"max_zoom\"] = 30\n        if \"max_native_zoom\" not in right_args:\n            right_args[\"max_native_zoom\"] = 30\n\n        if \"layer_name\" not in left_args:\n            left_args[\"layer_name\"] = \"Left Layer\"\n\n        if \"layer_name\" not in right_args:\n            right_args[\"layer_name\"] = \"Right Layer\"\n\n        bounds = None\n\n        try:\n            controls = self.controls\n            layers = self.layers\n            self.clear_controls()\n\n            if zoom_control:\n                self.add(ipyleaflet.ZoomControl())\n            if fullscreen_control:\n                self.add(ipyleaflet.FullScreenControl())\n\n            if left_label is not None:\n                left_name = left_label\n            else:\n                left_name = \"Left Layer\"\n\n            if right_label is not None:\n                right_name = right_label\n            else:\n                right_name = \"Right Layer\"\n\n            if isinstance(left_layer, str):\n                if left_layer in basemaps.keys():\n                    left_layer = get_basemap(left_layer)\n                elif left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                    url = cog_tile(left_layer, **left_args)\n                    bbox = cog_bounds(left_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    left_layer = ipyleaflet.TileLayer(\n                        url=url,\n                        name=left_name,\n                        attribution=\" \",\n                        **left_args,\n                    )\n                elif left_layer.startswith(\"http\") and left_layer.endswith(\".json\"):\n                    left_tile_url = stac_tile(left_layer, **left_args)\n                    bbox = stac_bounds(left_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    left_layer = ipyleaflet.TileLayer(\n                        url=left_tile_url,\n                        name=left_name,\n                        attribution=\" \",\n                        **left_args,\n                    )\n                elif left_layer.startswith(\"http\") and left_layer.endswith(\".geojson\"):\n                    if \"max_zoom\" in left_args:\n                        del left_args[\"max_zoom\"]\n                    if \"max_native_zoom\" in left_args:\n                        del left_args[\"max_native_zoom\"]\n                    left_layer = geojson_layer(left_layer, **left_args)\n                elif os.path.exists(left_layer):\n                    if left_layer.endswith(\".geojson\"):\n                        if \"max_zoom\" in left_args:\n                            del left_args[\"max_zoom\"]\n                        if \"max_native_zoom\" in left_args:\n                            del left_args[\"max_native_zoom\"]\n                        left_layer = geojson_layer(left_layer, **left_args)\n                    else:\n                        left_layer, left_client = get_local_tile_layer(\n                            left_layer,\n                            tile_format=\"ipyleaflet\",\n                            return_client=True,\n                            **left_args,\n                        )\n                        bounds = image_bounds(left_client)\n                else:\n                    left_layer = ipyleaflet.TileLayer(\n                        url=left_layer,\n                        name=left_name,\n                        attribution=\" \",\n                        **left_args,\n                    )\n            elif isinstance(left_layer, ipyleaflet.TileLayer) or isinstance(\n                left_layer, ipyleaflet.GeoJSON\n            ):\n                pass\n            elif is_array(left_layer):\n                left_layer = array_to_image(left_layer, **left_array_args)\n                left_layer, _ = get_local_tile_layer(\n                    left_layer,\n                    return_client=True,\n                    **left_args,\n                )\n            else:\n                raise ValueError(\n                    f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            if isinstance(right_layer, str):\n                if right_layer in basemaps.keys():\n                    right_layer = get_basemap(right_layer)\n                elif right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                    url = cog_tile(\n                        right_layer,\n                        **right_args,\n                    )\n                    bbox = cog_bounds(right_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    right_layer = ipyleaflet.TileLayer(\n                        url=url,\n                        name=right_name,\n                        attribution=\" \",\n                        **right_args,\n                    )\n\n                elif right_layer.startswith(\"http\") and right_layer.endswith(\".json\"):\n                    right_tile_url = stac_tile(right_layer, **left_args)\n                    bbox = stac_bounds(right_layer)\n                    bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                    right_layer = ipyleaflet.TileLayer(\n                        url=right_tile_url,\n                        name=right_name,\n                        attribution=\" \",\n                        **right_args,\n                    )\n                elif right_layer.startswith(\"http\") and right_layer.endswith(\n                    \".geojson\"\n                ):\n                    if \"max_zoom\" in right_args:\n                        del right_args[\"max_zoom\"]\n                    if \"max_native_zoom\" in right_args:\n                        del right_args[\"max_native_zoom\"]\n                    right_layer = geojson_layer(right_layer, **right_args)\n                elif os.path.exists(right_layer):\n                    if \"max_zoom\" in right_args:\n                        del right_args[\"max_zoom\"]\n                    if \"max_native_zoom\" in right_args:\n                        del right_args[\"max_native_zoom\"]\n                    if right_layer.endswith(\".geojson\"):\n                        right_layer = geojson_layer(right_layer, **right_args)\n                    else:\n                        right_layer, right_client = get_local_tile_layer(\n                            right_layer,\n                            tile_format=\"ipyleaflet\",\n                            return_client=True,\n                            **right_args,\n                        )\n                        bounds = image_bounds(right_client)\n                else:\n                    right_layer = ipyleaflet.TileLayer(\n                        url=right_layer,\n                        name=right_name,\n                        attribution=\" \",\n                        **right_args,\n                    )\n            elif isinstance(right_layer, ipyleaflet.TileLayer) or isinstance(\n                right_layer, ipyleaflet.GeoJSON\n            ):\n                pass\n            elif is_array(right_layer):\n                right_layer = array_to_image(right_layer, **right_array_args)\n                right_layer, _ = get_local_tile_layer(\n                    right_layer,\n                    return_client=True,\n                    **right_args,\n                )\n            else:\n                raise ValueError(\n                    f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n            control = ipyleaflet.SplitMapControl(\n                left_layer=left_layer, right_layer=right_layer\n            )\n            self.add(control)\n\n            if left_label is not None:\n                if widget_layout is None:\n                    widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n                left_widget = widgets.HTML(value=left_label, layout=widget_layout)\n\n                left_control = ipyleaflet.WidgetControl(\n                    widget=left_widget, position=left_position\n                )\n                self.add(left_control)\n\n            if right_label is not None:\n                if widget_layout is None:\n                    widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n                right_widget = widgets.HTML(value=right_label, layout=widget_layout)\n                right_control = ipyleaflet.WidgetControl(\n                    widget=right_widget, position=right_position\n                )\n                self.add(right_control)\n\n            if bounds is not None:\n                self.fit_bounds(bounds)\n\n            self.dragging = draggable\n\n            close_button = widgets.ToggleButton(\n                value=False,\n                tooltip=\"Close split-panel map\",\n                icon=\"times\",\n                layout=widgets.Layout(\n                    height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n                ),\n            )\n\n            def close_btn_click(change):\n                if change[\"new\"]:\n                    self.controls = controls\n                    self.layers = layers[:-1]\n                    self.add(layers[-1])\n\n                if left_label in self.controls:\n                    self.remove_control(left_control)\n\n                if right_label in self.controls:\n                    self.remove_control(right_control)\n\n                self.dragging = True\n\n            close_button.observe(close_btn_click, \"value\")\n            close_control = ipyleaflet.WidgetControl(\n                widget=close_button, position=\"topright\"\n            )\n\n            if add_close_button:\n                self.add(close_control)\n\n            if layer_control:\n                self.add_layer_control()\n\n        except Exception as e:\n            print(\"The provided layers are invalid!\")\n            raise ValueError(e)\n\n    def basemap_demo(self):\n        \"\"\"A demo for using leafmap basemaps.\"\"\"\n        dropdown = widgets.Dropdown(\n            options=list(basemaps.keys()),\n            value=\"Esri.WorldImagery\",\n            description=\"Basemaps\",\n        )\n\n        def on_click(change):\n            basemap_name = change[\"new\"]\n            old_basemap = self.layers[-1]\n            self.substitute_layer(old_basemap, get_basemap(basemap_name))\n\n        dropdown.observe(on_click, \"value\")\n        basemap_control = ipyleaflet.WidgetControl(widget=dropdown, position=\"topright\")\n        self.add(basemap_control)\n\n    def add_legend(\n        self,\n        title=\"Legend\",\n        legend_dict=None,\n        labels=None,\n        colors=None,\n        position=\"bottomright\",\n        builtin_legend=None,\n        layer_name=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a customized basemap to the map.\n\n        Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'.\n            legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n            labels (list, optional): A list of legend keys. Defaults to None.\n            colors (list, optional): A list of legend colors. Defaults to None.\n            position (str, optional): Position of the legend. Defaults to 'bottomright'.\n            builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n            layer_name (str, optional): Layer name of the legend to be associated with. Defaults to None.\n\n        \"\"\"\n        import pkg_resources\n        from IPython.display import display\n\n        pkg_dir = os.path.dirname(\n            pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\")\n        )\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n        if \"min_width\" not in kwargs.keys():\n            min_width = None\n        if \"max_width\" not in kwargs.keys():\n            max_width = None\n        else:\n            max_width = kwargs[\"max_width\"]\n        if \"min_height\" not in kwargs.keys():\n            min_height = None\n        else:\n            min_height = kwargs[\"min_height\"]\n        if \"max_height\" not in kwargs.keys():\n            max_height = None\n        else:\n            max_height = kwargs[\"max_height\"]\n        if \"height\" not in kwargs.keys():\n            height = None\n        else:\n            height = kwargs[\"height\"]\n        if \"width\" not in kwargs.keys():\n            width = None\n        else:\n            width = kwargs[\"width\"]\n\n        if width is None:\n            max_width = \"300px\"\n        if height is None:\n            max_height = \"400px\"\n\n        if not os.path.exists(legend_template):\n            print(\"The legend template does not exist.\")\n            return\n\n        if labels is not None:\n            if not isinstance(labels, list):\n                print(\"The legend keys must be a list.\")\n                return\n        else:\n            labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n        if colors is not None:\n            if not isinstance(colors, list):\n                print(\"The legend colors must be a list.\")\n                return\n            elif all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n            elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n                pass\n            elif all((len(item) == 6) for item in colors):\n                pass\n            else:\n                print(\"The legend colors must be a list of tuples.\")\n                return\n        else:\n            colors = [\n                \"#8DD3C7\",\n                \"#FFFFB3\",\n                \"#BEBADA\",\n                \"#FB8072\",\n                \"#80B1D3\",\n            ]\n\n        if len(labels) != len(colors):\n            print(\"The legend keys and values must be the same length.\")\n            return\n\n        allowed_builtin_legends = builtin_legends.keys()\n        if builtin_legend is not None:\n            if builtin_legend not in allowed_builtin_legends:\n                print(\n                    \"The builtin legend must be one of the following: {}\".format(\n                        \", \".join(allowed_builtin_legends)\n                    )\n                )\n                return\n            else:\n                legend_dict = builtin_legends[builtin_legend]\n                labels = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n\n        if legend_dict is not None:\n            if not isinstance(legend_dict, dict):\n                print(\"The legend dict must be a dictionary.\")\n                return\n            else:\n                labels = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n                if all(isinstance(item, tuple) for item in colors):\n                    try:\n                        colors = [rgb_to_hex(x) for x in colors]\n                    except Exception as e:\n                        print(e)\n\n        allowed_positions = [\n            \"topleft\",\n            \"topright\",\n            \"bottomleft\",\n            \"bottomright\",\n        ]\n        if position not in allowed_positions:\n            print(\n                \"The position must be one of the following: {}\".format(\n                    \", \".join(allowed_positions)\n                )\n            )\n            return\n\n        header = []\n        content = []\n        footer = []\n\n        with open(legend_template) as f:\n            lines = f.readlines()\n            lines[3] = lines[3].replace(\"Legend\", title)\n            header = lines[:6]\n            footer = lines[11:]\n\n        for index, key in enumerate(labels):\n            color = colors[index]\n            if not color.startswith(\"#\"):\n                color = \"#\" + color\n            item = \"      &lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                color, key\n            )\n            content.append(item)\n\n        legend_html = header + content + footer\n        legend_text = \"\".join(legend_html)\n\n        try:\n            legend_output_widget = widgets.Output(\n                layout={\n                    # \"border\": \"1px solid black\",\n                    \"max_width\": max_width,\n                    \"min_width\": min_width,\n                    \"max_height\": max_height,\n                    \"min_height\": min_height,\n                    \"height\": height,\n                    \"width\": width,\n                    \"overflow\": \"scroll\",\n                }\n            )\n            legend_control = ipyleaflet.WidgetControl(\n                widget=legend_output_widget, position=position\n            )\n            legend_widget = widgets.HTML(value=legend_text)\n            with legend_output_widget:\n                display(legend_widget)\n\n            self.legend_widget = legend_output_widget\n            self.legend_control = legend_control\n            self.add(legend_control)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_colorbar(\n        self,\n        colors,\n        vmin=0,\n        vmax=1.0,\n        index=None,\n        caption=\"\",\n        categorical=False,\n        step=None,\n        height=\"45px\",\n        transparent_bg=False,\n        position=\"bottomright\",\n        **kwargs,\n    ):\n        \"\"\"Add a branca colorbar to the map.\n\n        Args:\n            colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n            vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n            vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n            index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n            caption (str, optional): The caption for the colormap. Defaults to \"\".\n            categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n            step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n            height (str, optional): The height of the colormap widget. Defaults to \"45px\".\n            transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n            position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n\n        \"\"\"\n        from box import Box\n        from branca.colormap import LinearColormap\n\n        output = widgets.Output()\n        output.layout.height = height\n\n        if \"width\" in kwargs.keys():\n            output.layout.width = kwargs[\"width\"]\n\n        if isinstance(colors, Box):\n            try:\n                colors = list(colors[\"default\"])\n            except Exception as e:\n                print(\"The provided color list is invalid.\")\n                raise Exception(e)\n\n        if all(len(color) == 6 for color in colors):\n            colors = [\"#\" + color for color in colors]\n\n        colormap = LinearColormap(\n            colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n        )\n\n        if categorical:\n            if step is not None:\n                colormap = colormap.to_step(step)\n            elif index is not None:\n                colormap = colormap.to_step(len(index) - 1)\n            else:\n                colormap = colormap.to_step(3)\n\n        colormap_ctrl = ipyleaflet.WidgetControl(\n            widget=output,\n            position=position,\n            transparent_bg=transparent_bg,\n            **kwargs,\n        )\n        with output:\n            output.outputs = ()\n            display(colormap)\n\n        self.colorbar = colormap_ctrl\n        self.add(colormap_ctrl)\n\n    def add_colormap(\n        self,\n        cmap=\"gray\",\n        colors=None,\n        discrete=False,\n        label=None,\n        width=3,\n        height=0.25,\n        orientation=\"horizontal\",\n        vmin=0,\n        vmax=1.0,\n        axis_off=False,\n        show_name=False,\n        font_size=8,\n        transparent_bg=False,\n        position=\"bottomright\",\n        **kwargs,\n    ):\n        \"\"\"Adds a matplotlib colormap to the map.\n\n        Args:\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n            colors (list, optional): A list of custom colors to create a colormap. Defaults to None.\n            discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            width (float, optional): The width of the colormap. Defaults to 8.0.\n            height (float, optional): The height of the colormap. Defaults to 0.4.\n            orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n            vmin (float, optional): The minimum value range. Defaults to 0.\n            vmax (float, optional): The maximum value range. Defaults to 1.0.\n            axis_off (bool, optional): Whether to turn axis off. Defaults to False.\n            show_name (bool, optional): Whether to show the colormap name. Defaults to False.\n            font_size (int, optional): Font size of the text. Defaults to 12.\n            transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n            position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n        \"\"\"\n        from .colormaps import plot_colormap\n\n        output = widgets.Output()\n\n        colormap_ctrl = ipyleaflet.WidgetControl(\n            widget=output,\n            position=position,\n            transparent_bg=transparent_bg,\n        )\n        with output:\n            output.outputs = ()\n            plot_colormap(\n                cmap,\n                colors,\n                discrete,\n                label,\n                width,\n                height,\n                orientation,\n                vmin,\n                vmax,\n                axis_off,\n                show_name,\n                font_size,\n                **kwargs,\n            )\n\n        self.colorbar = colormap_ctrl\n        self.add(colormap_ctrl)\n\n    def image_overlay(self, url, bounds, name):\n        \"\"\"Overlays an image from the Internet or locally on the map.\n\n        Args:\n            url (str): http URL or local file path to the image.\n            bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n            name (str): name of the layer to show on the layer control.\n        \"\"\"\n        from base64 import b64encode\n        from PIL import Image, ImageSequence\n        from io import BytesIO\n\n        try:\n            if not url.startswith(\"http\"):\n                if not os.path.exists(url):\n                    print(\"The provided file does not exist.\")\n                    return\n\n                ext = os.path.splitext(url)[1][1:]  # file extension\n                image = Image.open(url)\n\n                f = BytesIO()\n                if ext.lower() == \"gif\":\n                    frames = []\n                    # Loop over each frame in the animated image\n                    for frame in ImageSequence.Iterator(image):\n                        frame = frame.convert(\"RGBA\")\n                        b = BytesIO()\n                        frame.save(b, format=\"gif\")\n                        frame = Image.open(b)\n                        frames.append(frame)\n                    frames[0].save(\n                        f,\n                        format=\"GIF\",\n                        save_all=True,\n                        append_images=frames[1:],\n                        loop=0,\n                    )\n                else:\n                    image.save(f, ext)\n\n                data = b64encode(f.getvalue())\n                data = data.decode(\"ascii\")\n                url = \"data:image/{};base64,\".format(ext) + data\n            img = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name)\n            self.add(img)\n        except Exception as e:\n            raise Exception(e)\n\n    def video_overlay(self, url, bounds, layer_name=None, **kwargs):\n        \"\"\"Overlays a video from the Internet on the map.\n\n        Args:\n            url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\n            bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n            layer_name (str): name of the layer to show on the layer control.\n        \"\"\"\n        if layer_name is None and \"name\" in kwargs:\n            layer_name = kwargs.pop(\"name\")\n        try:\n            video = ipyleaflet.VideoOverlay(url=url, bounds=bounds, name=layer_name)\n            self.add(video)\n        except Exception as e:\n            raise Exception(e)\n\n    def to_html(\n        self,\n        outfile=None,\n        title=\"My Map\",\n        width=\"100%\",\n        height=\"880px\",\n        add_layer_control=True,\n        **kwargs,\n    ):\n        \"\"\"Saves the map as an HTML file.\n\n        Args:\n            outfile (str, optional): The output file path to the HTML file.\n            title (str, optional): The title of the HTML file. Defaults to 'My Map'.\n            width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'.\n            height (str, optional): The height of the map in pixels. Defaults to '880px'.\n            add_layer_control (bool, optional): Whether to add the LayersControl. Defaults to True.\n\n        \"\"\"\n        try:\n            save = True\n            if outfile is not None:\n                if not outfile.endswith(\".html\"):\n                    raise ValueError(\"The output file extension must be html.\")\n                outfile = os.path.abspath(outfile)\n                out_dir = os.path.dirname(outfile)\n                if not os.path.exists(out_dir):\n                    os.makedirs(out_dir)\n            else:\n                outfile = os.path.abspath(random_string() + \".html\")\n                save = False\n\n            if add_layer_control and self.layer_control is None:\n                layer_control = ipyleaflet.LayersControl(position=\"topright\")\n                self.layer_control = layer_control\n                self.add(layer_control)\n\n            before_width = self.layout.width\n            before_height = self.layout.height\n\n            if not isinstance(width, str):\n                print(\"width must be a string.\")\n                return\n            elif width.endswith(\"px\") or width.endswith(\"%\"):\n                pass\n            else:\n                print(\"width must end with px or %\")\n                return\n\n            if not isinstance(height, str):\n                print(\"height must be a string.\")\n                return\n            elif not height.endswith(\"px\"):\n                print(\"height must end with px\")\n                return\n\n            self.layout.width = width\n            self.layout.height = height\n\n            self.save(outfile, title=title, **kwargs)\n\n            self.layout.width = before_width\n            self.layout.height = before_height\n\n            if not save:\n                out_html = \"\"\n                with open(outfile) as f:\n                    lines = f.readlines()\n                    out_html = \"\".join(lines)\n                os.remove(outfile)\n                return out_html\n\n        except Exception as e:\n            raise Exception(e)\n\n    def to_image(self, outfile=None, monitor=1):\n        \"\"\"Saves the map as a PNG or JPG image.\n\n        Args:\n            outfile (str, optional): The output file path to the image. Defaults to None.\n            monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n        \"\"\"\n        if outfile is None:\n            outfile = os.path.join(os.getcwd(), \"my_map.png\")\n\n        if outfile.endswith(\".png\") or outfile.endswith(\".jpg\"):\n            pass\n        else:\n            print(\"The output file must be a PNG or JPG image.\")\n            return\n\n        work_dir = os.path.dirname(outfile)\n        if not os.path.exists(work_dir):\n            os.makedirs(work_dir)\n\n        screenshot = screen_capture(outfile, monitor)\n        self.screenshot = screenshot\n\n    def to_streamlit(self, width=None, height=600, scrolling=False, **kwargs):\n        \"\"\"Renders map figure in a Streamlit app.\n\n        Args:\n            width (int, optional): Width of the map. Defaults to None.\n            height (int, optional): Height of the map. Defaults to 600.\n            responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n            scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n        Returns:\n            streamlit.components: components.html object.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n\n            # if responsive:\n            #     make_map_responsive = \"\"\"\n            #     &lt;style&gt;\n            #     [title~=\"st.iframe\"] { width: 100%}\n            #     &lt;/style&gt;\n            #     \"\"\"\n            #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n            return components.html(\n                self.to_html(), width=width, height=height, scrolling=scrolling\n            )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def toolbar_reset(self):\n        \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n        toolbar_grid = self.toolbar\n        for tool in toolbar_grid.children:\n            tool.value = False\n\n    def add_raster(\n        self,\n        source,\n        indexes=None,\n        colormap=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"Raster\",\n        layer_index=None,\n        zoom_to_layer=True,\n        visible=True,\n        opacity=1.0,\n        array_args={},\n        client_args={\"cors_all\": False},\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n            if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n            then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n            layer_index (int, optional): The index of the layer. Defaults to None.\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to True.\n            visible (bool, optional): Whether the layer is visible. Defaults to True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            array_args (dict, optional): Additional arguments to pass to `array_to_memory_file` when reading the raster. Defaults to {}.\n            client_args (dict, optional): Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n        \"\"\"\n        import numpy as np\n        import xarray as xr\n\n        if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n            source = array_to_image(source, **array_args)\n\n        tile_layer, tile_client = get_local_tile_layer(\n            source,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            opacity=opacity,\n            attribution=attribution,\n            layer_name=layer_name,\n            client_args=client_args,\n            return_client=True,\n            **kwargs,\n        )\n        tile_layer.visible = visible\n\n        self.add(tile_layer, index=layer_index)\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = (\n            bounds[2],\n            bounds[0],\n            bounds[3],\n            bounds[1],\n        )  # [minx, miny, maxx, maxy]\n        if zoom_to_layer:\n            self.zoom_to_bounds(bounds)\n\n        arc_add_layer(tile_layer.url, layer_name, True, 1.0)\n        if zoom_to_layer:\n            arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n        if not hasattr(self, \"cog_layer_dict\"):\n            self.cog_layer_dict = {}\n\n        if indexes is None:\n            if len(tile_client.band_names) == 1:\n                indexes = [1]\n            else:\n                indexes = [1, 2, 3]\n\n        vis_bands = [tile_client.band_names[i - 1] for i in indexes]\n\n        params = {\n            \"tile_layer\": tile_layer,\n            \"tile_client\": tile_client,\n            \"indexes\": indexes,\n            \"vis_bands\": vis_bands,\n            \"band_names\": tile_client.band_names,\n            \"bounds\": bounds,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"nodata\": nodata,\n            \"colormap\": colormap,\n            \"opacity\": opacity,\n            \"layer_name\": layer_name,\n            \"filename\": tile_client.filename,\n            \"type\": \"LOCAL\",\n        }\n        self.cog_layer_dict[layer_name] = params\n\n    add_local_tile = add_raster\n\n    def add_remote_tile(\n        self,\n        source,\n        band=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=None,\n        **kwargs,\n    ):\n        \"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n        Args:\n            source (str): The path to the remote Cloud Optimized GeoTIFF.\n            band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n        \"\"\"\n        if isinstance(source, str) and source.startswith(\"http\"):\n            self.add_raster(\n                source,\n                band=band,\n                palette=palette,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                layer_name=layer_name,\n                **kwargs,\n            )\n        else:\n            raise Exception(\"The source must be a URL.\")\n\n    def add_netcdf(\n        self,\n        filename,\n        variables=None,\n        palette=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=None,\n        layer_name=\"NetCDF layer\",\n        shift_lon=True,\n        lat=\"lat\",\n        lon=\"lon\",\n        lev=\"lev\",\n        level_index=0,\n        time=0,\n        **kwargs,\n    ):\n        \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n            If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n            try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n        Args:\n            filename (str): File path or HTTP URL to the netCDF file.\n            variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n            port (str, optional): The port to use for the server. Defaults to \"default\".\n            palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n            vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n            shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n            lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n            lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n            lev (str, optional): Name of the level variable. Defaults to 'lev'.\n            level_index (int, optional): Index of level to use. Defaults to 0'.\n            time (int, optional): Index of time to use. Defaults to 0'.\n        \"\"\"\n\n        tif, vars = netcdf_to_tif(\n            filename,\n            shift_lon=shift_lon,\n            lat=lat,\n            lon=lon,\n            lev=lev,\n            level_index=level_index,\n            time=time,\n            return_vars=True,\n        )\n\n        if variables is None:\n            if len(vars) &gt;= 3:\n                band_idx = [1, 2, 3]\n            else:\n                band_idx = [1]\n        else:\n            if not set(variables).issubset(set(vars)):\n                raise ValueError(f\"The variables must be a subset of {vars}.\")\n            else:\n                band_idx = [vars.index(v) + 1 for v in variables]\n\n        self.add_raster(\n            tif,\n            band=band_idx,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n\n    def add_raster_legacy(\n        self,\n        image,\n        bands=None,\n        layer_name=None,\n        colormap=None,\n        x_dim=\"x\",\n        y_dim=\"y\",\n        fit_bounds=True,\n    ):\n        \"\"\"Adds a local raster dataset to the map.\n\n        Args:\n            image (str): The image file path.\n            bands (int or list, optional): The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.\n            layer_name (str, optional): The layer name to use for the raster. Defaults to None.\n            colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.\n            x_dim (str, optional): The x dimension. Defaults to 'x'.\n            y_dim (str, optional): The y dimension. Defaults to 'y'.\n            fit_bounds (bool, optional): Whether to fit map bounds to raster bounds.  Defaults to True.\n        \"\"\"\n        try:\n            import xarray_leaflet\n\n        except Exception:\n            # import platform\n            # if platform.system() != \"Windows\":\n            #     # install_from_github(\n            #     #     url='https://github.com/davidbrochart/xarray_leaflet')\n            #     check_install('xarray_leaflet')\n            #     import xarray_leaflet\n            # else:\n            raise ImportError(\n                \"You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet\"\n            )\n\n        import warnings\n        import numpy as np\n        import rioxarray\n\n        # import xarray as xr\n        import matplotlib.pyplot as plt\n        import matplotlib as mpl\n\n        warnings.simplefilter(\"ignore\")\n\n        if isinstance(image, str):\n            if not os.path.exists(image):\n                print(\"The image file does not exist.\")\n                return\n\n        if colormap is None:\n            colormap = plt.cm.inferno\n\n        if layer_name is None:\n            layer_name = \"Layer_\" + random_string()\n\n        if isinstance(colormap, str):\n            colormap = mpl.colormaps[colormap]\n\n        if isinstance(image, str):\n            da = rioxarray.open_rasterio(image, masked=True)\n        else:\n            da = image\n\n        # print(da.rio.nodata)\n\n        multi_band = False\n        if len(da.band) &gt; 1:\n            multi_band = True\n            if bands is None:\n                bands = [3, 2, 1]\n        else:\n            bands = 1\n\n        if multi_band:\n            da = da.rio.write_nodata(0)\n        else:\n            da = da.rio.write_nodata(np.nan)\n        da = da.sel(band=bands)\n\n        # crs = da.rio.crs\n        # nan = da.attrs['nodatavals'][0]\n        # da = da / da.max()\n        # # if multi_band:\n        # da = xr.where(da == nan, np.nan, da)\n        # da = da.rio.write_nodata(0)\n        # da = da.rio.write_crs(crs)\n\n        if multi_band and type(bands) == list:\n            layer = da.leaflet.plot(\n                self, x_dim=x_dim, y_dim=y_dim, rgb_dim=\"band\", fit_bounds=fit_bounds\n            )\n        else:\n            layer = da.leaflet.plot(\n                self, x_dim=x_dim, y_dim=y_dim, colormap=colormap, fit_bounds=fit_bounds\n            )\n\n        layer.name = layer_name\n\n    def add_shp(\n        self,\n        in_shp,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=False,\n        encoding=\"utf-8\",\n    ):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            in_shp (str): The input file path or HTTP URL (*.zip) to the shapefile.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it to the map. Defaults to False.\n            encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n\n        Raises:\n            FileNotFoundError: The provided shapefile could not be found.\n        \"\"\"\n\n        import glob\n\n        if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n            out_dir = os.path.dirname(temp_file_path(\".shp\"))\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            basename = os.path.basename(in_shp)\n            filename = os.path.join(out_dir, basename)\n            download_file(in_shp, filename)\n            files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n            if len(files) &gt; 0:\n                in_shp = files[0]\n            else:\n                raise FileNotFoundError(\n                    \"The downloaded zip file does not contain any shapefile in the root directory.\"\n                )\n        else:\n            in_shp = os.path.abspath(in_shp)\n            if not os.path.exists(in_shp):\n                raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n        geojson = shp_to_geojson(in_shp, encoding=encoding)\n        self.add_geojson(\n            geojson,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n            encoding,\n        )\n\n    def add_geojson(\n        self,\n        in_geojson,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=False,\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON file to the map.\n\n        Args:\n            in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it to the map. Defaults to False.\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n\n        Raises:\n            FileNotFoundError: The provided GeoJSON file could not be found.\n        \"\"\"\n        import json\n        import random\n        import requests\n\n        style_callback_only = False\n\n        if len(style) == 0 and style_callback is not None:\n            style_callback_only = True\n\n        try:\n            if isinstance(in_geojson, str):\n                if in_geojson.startswith(\"http\"):\n                    if is_jupyterlite():\n                        import pyodide\n\n                        output = os.path.basename(in_geojson)\n\n                        output = os.path.abspath(output)\n                        obj = pyodide.http.open_url(in_geojson)\n                        with open(output, \"w\") as fd:\n                            shutil.copyfileobj(obj, fd)\n                        with open(output, \"r\") as fd:\n                            data = json.load(fd)\n                    else:\n                        in_geojson = github_raw_url(in_geojson)\n                        data = requests.get(in_geojson).json()\n                else:\n                    in_geojson = os.path.abspath(in_geojson)\n                    if not os.path.exists(in_geojson):\n                        raise FileNotFoundError(\n                            \"The provided GeoJSON file could not be found.\"\n                        )\n\n                    with open(in_geojson, encoding=encoding) as f:\n                        data = json.load(f)\n            elif isinstance(in_geojson, dict):\n                data = in_geojson\n            else:\n                raise TypeError(\"The input geojson must be a type of str or dict.\")\n        except Exception as e:\n            raise Exception(e)\n\n        geom_type = get_geometry_type(data)\n\n        if not style:\n            style = {\n                # \"stroke\": True,\n                \"color\": \"#3388ff\",\n                \"weight\": 2,\n                \"opacity\": 1,\n                \"fill\": True,\n                \"fillColor\": \"#3388ff\",\n                \"fillOpacity\": 0.2,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n\n            if geom_type in [\"LineString\", \"MultiLineString\"]:\n                style[\"fill\"] = False\n\n        elif \"weight\" not in style:\n            style[\"weight\"] = 1\n\n        if not hover_style:\n            hover_style = {\"weight\": style[\"weight\"] + 2, \"fillOpacity\": 0}\n\n        def random_color(feature):\n            return {\n                \"color\": \"black\",\n                \"fillColor\": random.choice(fill_colors),\n            }\n\n        toolbar_button = widgets.ToggleButton(\n            value=True,\n            tooltip=\"Toolbar\",\n            icon=\"info\",\n            layout=widgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close the tool\",\n            icon=\"times\",\n            # button_style=\"primary\",\n            layout=widgets.Layout(\n                height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        html = widgets.HTML()\n        html.layout.margin = \"0px 10px 0px 10px\"\n        html.layout.max_height = \"250px\"\n        html.layout.max_width = \"250px\"\n\n        output_widget = widgets.VBox(\n            [widgets.HBox([toolbar_button, close_button]), html]\n        )\n        info_control = ipyleaflet.WidgetControl(\n            widget=output_widget, position=\"bottomright\"\n        )\n\n        if info_mode in [\"on_hover\", \"on_click\"]:\n            self.add(info_control)\n\n        def toolbar_btn_click(change):\n            if change[\"new\"]:\n                close_button.value = False\n                output_widget.children = [\n                    widgets.VBox([widgets.HBox([toolbar_button, close_button]), html])\n                ]\n            else:\n                output_widget.children = [widgets.HBox([toolbar_button, close_button])]\n\n        toolbar_button.observe(toolbar_btn_click, \"value\")\n\n        def close_btn_click(change):\n            if change[\"new\"]:\n                toolbar_button.value = False\n                if info_control in self.controls:\n                    self.remove_control(info_control)\n                output_widget.close()\n\n        close_button.observe(close_btn_click, \"value\")\n\n        if \"fields\" in kwargs:\n            fields = kwargs[\"fields\"]\n            kwargs.pop(\"fields\")\n        else:\n            fields = None\n\n        def update_html(feature, fields=fields, **kwargs):\n            if fields is None:\n                fields = list(feature[\"properties\"].keys())\n                if \"style\" in fields:\n                    fields.remove(\"style\")\n\n            value = [\n                \"&lt;b&gt;{}: &lt;/b&gt;{}&lt;br&gt;\".format(prop, feature[\"properties\"][prop])\n                for prop in fields\n            ]\n\n            value = \"\"\"{}\"\"\".format(\"\".join(value))\n            html.value = value\n\n        if style_callback is None:\n            style_callback = random_color\n\n        if style_callback_only:\n            geojson = ipyleaflet.GeoJSON(\n                data=data,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                name=layer_name,\n            )\n        else:\n            geojson = ipyleaflet.GeoJSON(\n                data=data,\n                style=style,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                name=layer_name,\n            )\n\n        if info_mode == \"on_hover\":\n            geojson.on_hover(update_html)\n        elif info_mode == \"on_click\":\n            geojson.on_click(update_html)\n\n        self.add(geojson)\n        self.geojson_layers.append(geojson)\n\n        if not hasattr(self, \"json_layer_dict\"):\n            self.json_layer_dict = {}\n\n        params = {\n            \"data\": geojson,\n            \"style\": style,\n            \"hover_style\": hover_style,\n            \"style_callback\": style_callback,\n        }\n        self.json_layer_dict[layer_name] = params\n\n        if zoom_to_layer:\n            try:\n                import numpy as np\n                import geopandas as gpd\n\n                gdf = gpd.GeoDataFrame.from_features(data)\n                if gdf.crs is None:\n                    gdf.crs = \"EPSG:4326\"\n                bounds = gdf.to_crs(epsg=\"4326\").bounds\n                west = np.min(bounds[\"minx\"])\n                south = np.min(bounds[\"miny\"])\n                east = np.max(bounds[\"maxx\"])\n                north = np.max(bounds[\"maxy\"])\n                self.fit_bounds([[south, east], [north, west]])\n            except Exception as e:\n                print(e)\n\n    def add_search_control(\n        self, url, marker=None, zoom=None, position=\"topleft\", **kwargs\n    ):\n        \"\"\"Adds a search control to the map.\n\n        Args:\n            url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n            marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n            zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n            position (str, optional): The position of the search control. Defaults to \"topleft\".\n            kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n        \"\"\"\n        if marker is None:\n            marker = ipyleaflet.Marker(\n                icon=ipyleaflet.AwesomeIcon(\n                    name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n                )\n            )\n        search_control = ipyleaflet.SearchControl(\n            position=position,\n            url=url,\n            zoom=zoom,\n            marker=marker,\n        )\n        self.add(search_control)\n        self.search_control = search_control\n\n    def add_gdf(\n        self,\n        gdf,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=False,\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to False.\n            encoding (str, optional): The encoding of the GeoDataFrame. Defaults to \"utf-8\".\n        \"\"\"\n        for col in gdf.columns:\n            try:\n                if gdf[col].dtype in [\"datetime64[ns]\", \"datetime64[ns, UTC]\"]:\n                    gdf[col] = gdf[col].astype(str)\n            except:\n                pass\n\n        data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n        self.add_geojson(\n            data,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n            encoding,\n            **kwargs,\n        )\n\n        if zoom_to_layer:\n            import numpy as np\n\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n\n    def add_gdf_from_postgis(\n        self,\n        sql,\n        con,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=True,\n        **kwargs,\n    ):\n        \"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n        Args:\n            sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n            con (sqlalchemy.engine.Engine): Active connection to the database to query.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            zoom_to_layer (bool, optional): Whether to zoom to the layer.\n        \"\"\"\n        gdf = read_postgis(sql, con, **kwargs)\n        gdf = gdf.to_crs(\"epsg:4326\")\n        self.add_gdf(\n            gdf,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n        )\n\n    def add_kml(\n        self,\n        in_kml,\n        layer_name=\"Untitled\",\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n    ):\n        \"\"\"Adds a KML file to the map.\n\n        Args:\n            in_kml (str): The input file path or HTTP URL to the KML.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n        Raises:\n            FileNotFoundError: The provided KML file could not be found.\n        \"\"\"\n\n        if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n            out_dir = os.path.abspath(\"./cache\")\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n            in_kml = download_file(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n        else:\n            in_kml = os.path.abspath(in_kml)\n            if not os.path.exists(in_kml):\n                raise FileNotFoundError(\"The provided KML could not be found.\")\n\n        self.add_vector(\n            in_kml,\n            layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            fill_colors=fill_colors,\n            info_mode=info_mode,\n        )\n\n    def add_vector(\n        self,\n        filename,\n        layer_name=\"Untitled\",\n        bbox=None,\n        mask=None,\n        rows=None,\n        style={},\n        hover_style={},\n        style_callback=None,\n        fill_colors=[\"black\"],\n        info_mode=\"on_hover\",\n        zoom_to_layer=False,\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n        Args:\n            filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n            layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n            bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n            mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n            rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding to use to read the file. Defaults to \"utf-8\".\n\n        \"\"\"\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n        else:\n            filename = github_raw_url(filename)\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".shp\":\n            self.add_shp(\n                filename,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                encoding,\n            )\n        elif ext in [\".json\", \".geojson\"]:\n            self.add_geojson(\n                filename,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                zoom_to_layer,\n                encoding,\n            )\n        else:\n            geojson = vector_to_geojson(\n                filename,\n                bbox=bbox,\n                mask=mask,\n                rows=rows,\n                epsg=\"4326\",\n                **kwargs,\n            )\n\n            self.add_geojson(\n                geojson,\n                layer_name,\n                style,\n                hover_style,\n                style_callback,\n                fill_colors,\n                info_mode,\n                zoom_to_layer,\n                encoding,\n            )\n\n    def add_xy_data(\n        self,\n        in_csv,\n        x=\"longitude\",\n        y=\"latitude\",\n        label=None,\n        layer_name=\"Marker cluster\",\n    ):\n        \"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\n\n        Args:\n            in_csv (str): The file path to the input CSV file.\n            x (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n            y (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n            label (str, optional): The name of the column containing label information to used for marker popup. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to \"Marker cluster\".\n\n        Raises:\n            FileNotFoundError: The specified input csv does not exist.\n            ValueError: The specified x column does not exist.\n            ValueError: The specified y column does not exist.\n            ValueError: The specified label column does not exist.\n        \"\"\"\n        import pandas as pd\n\n        if isinstance(in_csv, pd.DataFrame):\n            df = in_csv\n        elif not in_csv.startswith(\"http\") and (not os.path.exists(in_csv)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(in_csv)\n\n        col_names = df.columns.values.tolist()\n\n        if x not in col_names:\n            raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n        if y not in col_names:\n            raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n        if label is not None and (label not in col_names):\n            raise ValueError(\n                f\"label must be one of the following: {', '.join(col_names)}\"\n            )\n\n        self.default_style = {\"cursor\": \"wait\"}\n\n        points = list(zip(df[y], df[x]))\n\n        if label is not None:\n            labels = df[label]\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                )\n                for index, point in enumerate(points)\n            ]\n        else:\n            markers = [\n                ipyleaflet.Marker(location=point, draggable=False) for point in points\n            ]\n\n        marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n        self.add(marker_cluster)\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    def add_point_layer(\n        self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n    ):\n        \"\"\"Adds a point layer to the map with a popup attribute.\n\n        Args:\n            filename (str): str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)\n            popup (str | list, optional): Column name(s) to be used for popup. Defaults to None.\n            layer_name (str, optional): A layer name to use. Defaults to \"Marker Cluster\".\n\n        Raises:\n            ValueError: If the specified column name does not exist.\n            ValueError: If the specified column names do not exist.\n        \"\"\"\n        import warnings\n\n        warnings.filterwarnings(\"ignore\")\n        check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n        import geopandas as gpd\n        import fiona\n\n        self.default_style = {\"cursor\": \"wait\"}\n\n        if isinstance(filename, gpd.GeoDataFrame):\n            gdf = filename\n        else:\n            if not filename.startswith(\"http\"):\n                filename = os.path.abspath(filename)\n            ext = os.path.splitext(filename)[1].lower()\n            if ext == \".kml\":\n                fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n                gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n            else:\n                gdf = gpd.read_file(filename, **kwargs)\n        df = gdf.to_crs(epsg=\"4326\")\n        col_names = df.columns.values.tolist()\n        if popup is not None:\n            if isinstance(popup, str) and (popup not in col_names):\n                raise ValueError(\n                    f\"popup must be one of the following: {', '.join(col_names)}\"\n                )\n            elif isinstance(popup, list) and (\n                not all(item in col_names for item in popup)\n            ):\n                raise ValueError(\n                    f\"All popup items must be select from: {', '.join(col_names)}\"\n                )\n\n        df[\"x\"] = df.geometry.x\n        df[\"y\"] = df.geometry.y\n\n        points = list(zip(df[\"y\"], df[\"x\"]))\n\n        if popup is not None:\n            if isinstance(popup, str):\n                labels = df[popup]\n                markers = [\n                    ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(str(labels[index])),\n                    )\n                    for index, point in enumerate(points)\n                ]\n            elif isinstance(popup, list):\n                labels = []\n                for i in range(len(points)):\n                    label = \"\"\n                    for item in popup:\n                        label = label + str(item) + \": \" + str(df[item][i]) + \"&lt;br&gt;\"\n                    labels.append(label)\n                df[\"popup\"] = labels\n\n                markers = [\n                    ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(labels[index]),\n                    )\n                    for index, point in enumerate(points)\n                ]\n\n        else:\n            markers = [\n                ipyleaflet.Marker(location=point, draggable=False) for point in points\n            ]\n\n        marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n        self.add(marker_cluster)\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    def add_points_from_xy(\n        self,\n        data,\n        x=\"longitude\",\n        y=\"latitude\",\n        popup=None,\n        layer_name=\"Marker Cluster\",\n        color_column=None,\n        marker_colors=None,\n        icon_colors=[\"white\"],\n        icon_names=[\"info\"],\n        spin=False,\n        add_legend=True,\n        max_cluster_radius=80,\n        **kwargs,\n    ):\n        \"\"\"Adds a marker cluster to the map.\n\n        Args:\n            data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n            x (str, optional): The column name for the x values. Defaults to \"longitude\".\n            y (str, optional): The column name for the y values. Defaults to \"latitude\".\n            popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n            layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n            color_column (str, optional): The column name for the color values. Defaults to None.\n            marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n            icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n            icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].\n            spin (bool, optional): If True, the icon will spin. Defaults to False.\n            add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n            max_cluster_radius (int, optional): The maximum cluster radius. Defaults to 80.\n            **kwargs: Other keyword arguments to pass to ipyleaflet.MarkerCluster(). For a list of available options,\n                see https://github.com/Leaflet/Leaflet.markercluster.\n\n        \"\"\"\n        import pandas as pd\n\n        color_options = [\n            \"red\",\n            \"blue\",\n            \"green\",\n            \"purple\",\n            \"orange\",\n            \"darkred\",\n            \"lightred\",\n            \"beige\",\n            \"darkblue\",\n            \"darkgreen\",\n            \"cadetblue\",\n            \"darkpurple\",\n            \"white\",\n            \"pink\",\n            \"lightblue\",\n            \"lightgreen\",\n            \"gray\",\n            \"black\",\n            \"lightgray\",\n        ]\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n        elif not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        elif data.endswith(\".csv\"):\n            df = pd.read_csv(data)\n        else:\n            import geopandas as gpd\n\n            gdf = gpd.read_file(data)\n            df = gdf_to_df(gdf)\n\n        df = points_from_xy(df, x, y)\n\n        col_names = df.columns.values.tolist()\n\n        if color_column is not None and color_column not in col_names:\n            raise ValueError(\n                f\"The color column {color_column} does not exist in the dataframe.\"\n            )\n\n        if color_column is not None:\n            items = list(set(df[color_column]))\n\n        else:\n            items = None\n\n        if color_column is not None and marker_colors is None:\n            if len(items) &gt; len(color_options):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n                )\n            else:\n                marker_colors = color_options[: len(items)]\n        elif color_column is not None and marker_colors is not None:\n            if len(items) != len(marker_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if items is not None:\n            if len(icon_colors) == 1:\n                icon_colors = icon_colors * len(items)\n            elif len(items) != len(icon_colors):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n            if len(icon_names) == 1:\n                icon_names = icon_names * len(items)\n            elif len(items) != len(icon_names):\n                raise ValueError(\n                    f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n                )\n\n        if \"geometry\" in col_names:\n            col_names.remove(\"geometry\")\n\n        if popup is not None:\n            if isinstance(popup, str) and (popup not in col_names):\n                raise ValueError(\n                    f\"popup must be one of the following: {', '.join(col_names)}\"\n                )\n            elif isinstance(popup, list) and (\n                not all(item in col_names for item in popup)\n            ):\n                raise ValueError(\n                    f\"All popup items must be select from: {', '.join(col_names)}\"\n                )\n        else:\n            popup = col_names\n\n        df[\"x\"] = df.geometry.x\n        df[\"y\"] = df.geometry.y\n\n        points = list(zip(df[\"y\"], df[\"x\"]))\n\n        if popup is not None:\n            if isinstance(popup, str):\n                labels = df[popup]\n\n                markers = []\n                for index, point in enumerate(points):\n                    if items is not None:\n                        marker_color = marker_colors[\n                            items.index(df[color_column][index])\n                        ]\n                        icon_name = icon_names[items.index(df[color_column][index])]\n                        icon_color = icon_colors[items.index(df[color_column][index])]\n                        marker_icon = ipyleaflet.AwesomeIcon(\n                            name=icon_name,\n                            marker_color=marker_color,\n                            icon_color=icon_color,\n                            spin=spin,\n                        )\n                    else:\n                        marker_icon = None\n\n                    marker = ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(str(labels[index])),\n                        icon=marker_icon,\n                    )\n                    markers.append(marker)\n\n            elif isinstance(popup, list):\n                labels = []\n                for i in range(len(points)):\n                    label = \"\"\n                    for item in popup:\n                        label = (\n                            label\n                            + \"&lt;b&gt;\"\n                            + str(item)\n                            + \"&lt;/b&gt;\"\n                            + \": \"\n                            + str(df[item][i])\n                            + \"&lt;br&gt;\"\n                        )\n                    labels.append(label)\n                df[\"popup\"] = labels\n\n                markers = []\n                for index, point in enumerate(points):\n                    if items is not None:\n                        marker_color = marker_colors[\n                            items.index(df[color_column][index])\n                        ]\n                        icon_name = icon_names[items.index(df[color_column][index])]\n                        icon_color = icon_colors[items.index(df[color_column][index])]\n                        marker_icon = ipyleaflet.AwesomeIcon(\n                            name=icon_name,\n                            marker_color=marker_color,\n                            icon_color=icon_color,\n                            spin=spin,\n                        )\n                    else:\n                        marker_icon = None\n\n                    marker = ipyleaflet.Marker(\n                        location=point,\n                        draggable=False,\n                        popup=widgets.HTML(labels[index]),\n                        icon=marker_icon,\n                    )\n                    markers.append(marker)\n\n        else:\n            markers = []\n            for point in points:\n                if items is not None:\n                    marker_color = marker_colors[items.index(df[color_column][index])]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point, draggable=False, icon=marker_icon\n                )\n                markers.append(marker)\n\n        marker_cluster = ipyleaflet.MarkerCluster(\n            markers=markers,\n            name=layer_name,\n            max_cluster_radius=max_cluster_radius,\n            **kwargs,\n        )\n        self.add(marker_cluster)\n\n        if items is not None and add_legend:\n            marker_colors = [check_color(c) for c in marker_colors]\n            self.add_legend(\n                title=color_column.title(), colors=marker_colors, labels=items\n            )\n\n        self.default_style = {\"cursor\": \"default\"}\n\n    add_marker_cluster = add_points_from_xy\n\n    def add_heatmap(\n        self,\n        data,\n        latitude=\"latitude\",\n        longitude=\"longitude\",\n        value=\"value\",\n        name=\"Heat map\",\n        radius=25,\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n        from ipyleaflet import Heatmap\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n            self.add(heatmap)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_labels(\n        self,\n        data,\n        column,\n        font_size=\"12pt\",\n        font_color=\"black\",\n        font_family=\"arial\",\n        font_weight=\"normal\",\n        x=\"longitude\",\n        y=\"latitude\",\n        draggable=True,\n        layer_name=\"Labels\",\n        **kwargs,\n    ):\n        \"\"\"Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html\n\n        Args:\n            data (pd.DataFrame | gpd.GeoDataFrame | str): The input data to label.\n            column (str): The column name of the data to label.\n            font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n            font_color (str, optional): The font color of the labels. Defaults to \"black\".\n            font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n            font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n            x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n            y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n            draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n            layer_name (str, optional): Layer name to use. Defaults to \"Labels\".\n\n        \"\"\"\n        import warnings\n        import pandas as pd\n\n        warnings.filterwarnings(\"ignore\")\n\n        if isinstance(data, pd.DataFrame):\n            df = data\n            if \"geometry\" in data.columns or (\"geom\" in data.columns):\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n\n        elif isinstance(data, str):\n            ext = os.path.splitext(data)[1]\n            if ext == \".csv\":\n                df = pd.read_csv(data)\n            elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n                try:\n                    import geopandas as gpd\n\n                    df = gpd.read_file(data)\n                    df[x] = df.centroid.x\n                    df[y] = df.centroid.y\n                except Exception as _:\n                    print(\"geopandas is required to read geojson.\")\n                    return\n\n        else:\n            raise ValueError(\n                \"data must be a pd.DataFrame, gpd.GeoDataFrame, or an ee.FeatureCollection.\"\n            )\n\n        if column not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if x not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n        if y not in df.columns:\n            raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n        try:\n            size = int(font_size.replace(\"pt\", \"\"))\n        except:\n            raise ValueError(\"font_size must be something like '10pt'\")\n\n        labels = []\n        for index in df.index:\n            html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n            marker = ipyleaflet.Marker(\n                location=[df[y][index], df[x][index]],\n                icon=ipyleaflet.DivIcon(\n                    icon_size=(1, 1),\n                    icon_anchor=(size, size),\n                    html=html,\n                    **kwargs,\n                ),\n                draggable=draggable,\n            )\n            labels.append(marker)\n        layer_group = ipyleaflet.LayerGroup(layers=labels, name=layer_name)\n        self.add(layer_group)\n        self.labels = layer_group\n\n    def remove_labels(self):\n        \"\"\"Removes all labels from the map.\"\"\"\n        if hasattr(self, \"labels\"):\n            self.remove_layer(self.labels)\n            delattr(self, \"labels\")\n\n    def add_planet_by_month(\n        self,\n        year=2016,\n        month=1,\n        layer_name=None,\n        api_key=None,\n        token_name=\"PLANET_API_KEY\",\n        **kwargs,\n    ):\n        \"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        if layer_name is None and \"name\" in kwargs:\n            layer_name = kwargs.pop(\"name\")\n        layer = planet_tile_by_month(year, month, layer_name, api_key, token_name)\n        self.add(layer)\n\n    def add_planet_by_quarter(\n        self,\n        year=2016,\n        quarter=1,\n        layer_name=None,\n        api_key=None,\n        token_name=\"PLANET_API_KEY\",\n        **kwargs,\n    ):\n        \"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n            layer_name (str, optional): The layer name to use. Defaults to None.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        \"\"\"\n        if layer_name is None and \"name\" in kwargs:\n            layer_name = kwargs.pop(\"name\")\n        layer = planet_tile_by_quarter(year, quarter, layer_name, api_key, token_name)\n        self.add(layer)\n\n    def add_time_slider(\n        self,\n        layers={},\n        labels=None,\n        time_interval=1,\n        position=\"bottomright\",\n        slider_length=\"150px\",\n        zoom_to_layer=False,\n        **kwargs,\n    ):\n        \"\"\"Adds a time slider to the map.\n\n        Args:\n            layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n            labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n            time_interval (int, optional): Time interval in seconds. Defaults to 1.\n            position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n            slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n        \"\"\"\n        from .toolbar import time_slider\n\n        time_slider(\n            self,\n            layers,\n            labels,\n            time_interval,\n            position,\n            slider_length,\n            zoom_to_layer,\n            **kwargs,\n        )\n\n    def static_map(self, width=950, height=600, out_file=None, **kwargs):\n        \"\"\"Display an ipyleaflet static map in a Jupyter Notebook.\n\n        Args\n            m (ipyleaflet.Map): An ipyleaflet map.\n            width (int, optional): Width of the map. Defaults to 950.\n            height (int, optional): Height of the map. Defaults to 600.\n            read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n            out_file (str, optional): Output html file path. Defaults to None.\n        \"\"\"\n        if isinstance(self, ipyleaflet.Map):\n            if out_file is None:\n                out_file = \"./cache/\" + \"leafmap_\" + random_string(3) + \".html\"\n            out_dir = os.path.abspath(os.path.dirname(out_file))\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            self.to_html(out_file)\n            display_html(src=out_file, width=width, height=height)\n        else:\n            raise TypeError(\"The provided map is not an ipyleaflet map.\")\n\n    def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n        \"\"\"Adds a census data layer to the map.\n\n        Args:\n            wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n            layer (str): The layer name to add to the map.\n            census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n        \"\"\"\n\n        try:\n            if census_dict is None:\n                census_dict = get_census_dict()\n\n            if wms not in census_dict.keys():\n                raise ValueError(\n                    f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n                )\n\n            layers = census_dict[wms][\"layers\"]\n            if layer not in layers:\n                raise ValueError(\n                    f\"The layer name is not valid. It must be one of {layers}\"\n                )\n\n            url = census_dict[wms][\"url\"]\n            if \"name\" not in kwargs:\n                kwargs[\"name\"] = layer\n            if \"attribution\" not in kwargs:\n                kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n            if \"format\" not in kwargs:\n                kwargs[\"format\"] = \"image/png\"\n            if \"transparent\" not in kwargs:\n                kwargs[\"transparent\"] = True\n\n            self.add_wms_layer(url, layer, **kwargs)\n\n        except Exception as e:\n            raise Exception(e)\n\n    def add_xyz_service(self, provider, **kwargs):\n        \"\"\"Add a XYZ tile layer to the map.\n\n        Args:\n            provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n        Raises:\n            ValueError: The provider is not valid. It must start with xyz or qms.\n        \"\"\"\n        import xyzservices\n        import xyzservices.providers as xyz\n\n        if provider.startswith(\"xyz\"):\n            name = provider[4:]\n            xyz_provider = xyz.flatten()[name]\n            url = xyz_provider.build_url()\n            attribution = xyz_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        elif provider.startswith(\"qms\"):\n            name = provider[4:]\n            qms_provider = xyzservices.TileProvider.from_qms(name)\n            url = qms_provider.build_url()\n            attribution = qms_provider.attribution\n            if attribution.strip() == \"\":\n                attribution = \" \"\n            self.add_tile_layer(url, name, attribution)\n        else:\n            raise ValueError(\n                f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n            )\n\n    def add_title(self, title, align=\"center\", font_size=\"16px\", style=None, **kwargs):\n        print(\"The ipyleaflet map does not support titles.\")\n\n    def get_pc_collections(self):\n        \"\"\"Get the list of Microsoft Planetary Computer collections.\"\"\"\n        if not hasattr(self, \"pc_collections\"):\n            setattr(self, \"pc_collections\", get_pc_collections())\n\n    def save_draw_features(self, out_file, indent=4, crs=\"epsg:4326\", **kwargs):\n        \"\"\"Save the draw features to a file.\n\n        Args:\n            out_file (str): The output file path.\n            indent (int, optional): The indentation level when saving data as a GeoJSON. Defaults to 4.\n            crs (str, optional): The CRS of the output GeoJSON. Defaults to \"epsg:4326\".\n        \"\"\"\n        import geopandas as gpd\n\n        out_file = check_file_path(out_file)\n\n        self.update_draw_features()\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": self.draw_features,\n        }\n\n        gdf = gpd.GeoDataFrame.from_features(geojson)\n        gdf.crs = \"epsg:4326\"\n        gdf.to_crs(crs).to_file(out_file, **kwargs)\n\n    def update_draw_features(self):\n        \"\"\"Update the draw features by removing features that have been edited and no longer exist.\"\"\"\n\n        geometries = [feature[\"geometry\"] for feature in self.draw_control.data]\n\n        for feature in self.draw_features:\n            if feature[\"geometry\"] not in geometries:\n                self.draw_features.remove(feature)\n\n    def get_draw_props(self, n=None, return_df=False):\n        \"\"\"Get the properties of the draw features.\n\n        Args:\n            n (int, optional): The maximum number of attributes to return. Defaults to None.\n            return_df (bool, optional): If True, return a pandas dataframe. Defaults to False.\n\n        Returns:\n            pd.DataFrame: A pandas dataframe containing the properties of the draw features.\n        \"\"\"\n\n        import pandas as pd\n\n        props = self.edit_props[:]\n\n        for feature in self.draw_features:\n            for prop in feature[\"properties\"]:\n                if prop not in self.edit_props:\n                    self.edit_props.append(prop)\n                    props.append(prop)\n\n        if return_df:\n            if isinstance(n, int) and n &gt; len(props):\n                props = props + [\"\"] * (n - len(props))\n\n            df = pd.DataFrame({\"Key\": props, \"Value\": [\"\"] * len(props)})\n            df.index += 1\n            return df\n        else:\n            return props\n\n    def update_draw_props(self, df):\n        \"\"\"Update the draw features properties.\n\n        Args:\n            df (pd.DataFrame): A pandas dataframe containing the properties of the draw features.\n        \"\"\"\n\n        df.dropna(inplace=True)\n        df = df[df[\"Key\"].astype(bool)]\n        if len(df) &gt; 0:\n            props = df.set_index(\"Key\").to_dict()[\"Value\"]\n            if self.draw_control.last_action == \"edited\":\n                self.update_draw_features()\n            if len(self.draw_features) &gt; 0:\n                if self.draw_control.last_action == \"created\":\n                    self.draw_features[-1][\"properties\"] = props\n                elif self.draw_control.last_action == \"edited\":\n                    for feature in self.draw_features:\n                        if (\n                            self.draw_control.last_draw[\"geometry\"]\n                            == feature[\"geometry\"]\n                        ):\n                            feature[\"properties\"] = props\n            for prop in list(props.keys()):\n                if prop not in self.edit_props:\n                    self.edit_props.append(prop)\n\n    def edit_vector(self, data, **kwargs):\n        \"\"\"Edit a vector layer.\n\n        Args:\n            data (dict | str): The data to edit. It can be a GeoJSON dictionary or a file path.\n        \"\"\"\n        if isinstance(data, str):\n            check_package(\"geopandas\", \"https://geopandas.org\")\n            import geopandas as gpd\n\n            gdf = gpd.read_file(data, **kwargs)\n            geojson = gdf_to_geojson(gdf, epsg=4326, tuple_to_list=True)\n        elif isinstance(data, dict):\n            geojson = data\n        else:\n            raise ValueError(\n                \"The data must be a GeoJSON dictionary or a file path to a vector dataset.\"\n            )\n        self.draw_control.data = self.draw_control.data + (geojson[\"features\"])\n        self.draw_features = self.draw_features + (geojson[\"features\"])\n\n    def add_velocity(\n        self,\n        data,\n        zonal_speed,\n        meridional_speed,\n        latitude_dimension=\"lat\",\n        longitude_dimension=\"lon\",\n        level_dimension=\"lev\",\n        level_index=0,\n        time_index=0,\n        velocity_scale=0.01,\n        max_velocity=20,\n        display_options={},\n        name=\"Velocity\",\n        color_scale=None,\n    ):\n        \"\"\"Add a velocity layer to the map.\n\n        Args:\n            data (str | xr.Dataset): The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.\n            zonal_speed (str): Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n            meridional_speed (str): Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n            latitude_dimension (str, optional): Name of the latitude dimension in the dataset. Defaults to 'lat'.\n            longitude_dimension (str, optional): Name of the longitude dimension in the dataset. Defaults to 'lon'.\n            level_dimension (str, optional): Name of the level dimension in the dataset. Defaults to 'lev'.\n            level_index (int, optional): The index of the level dimension to display. Defaults to 0.\n            time_index (int, optional): The index of the time dimension to display. Defaults to 0.\n            velocity_scale (float, optional): The scale of the velocity. Defaults to 0.01.\n            max_velocity (int, optional): The maximum velocity to display. Defaults to 20.\n            display_options (dict, optional): The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.\n            name (str, optional): Layer name to use . Defaults to 'Velocity'.\n            color_scale (list, optional): List of RGB color values for the velocity vector color scale. Defaults to []. See https://bit.ly/3uf8t6w.\n\n        Raises:\n            ImportError: If the xarray package is not installed.\n            ValueError: If the data is not a NetCDF file or an xarray Dataset.\n        \"\"\"\n        try:\n            import xarray as xr\n            from ipyleaflet.velocity import Velocity\n        except ImportError:\n            raise ImportError(\n                \"The xarray package is required to add a velocity layer. \"\n                \"Please install it with `pip install xarray`.\"\n            )\n\n        if isinstance(data, str):\n            if data.startswith(\"http\"):\n                data = download_file(data)\n            ds = xr.open_dataset(data)\n\n        elif isinstance(data, xr.Dataset):\n            ds = data\n        else:\n            raise ValueError(\"The data must be a file path or xarray dataset.\")\n\n        coords = list(ds.coords.keys())\n\n        # Rasterio does not handle time or levels. So we must drop them\n        if \"time\" in coords:\n            ds = ds.isel(time=time_index, drop=True)\n\n        params = {level_dimension: level_index}\n        if level_dimension in coords:\n            ds = ds.isel(drop=True, **params)\n\n        if color_scale is None:\n            color_scale = [\n                \"rgb(36,104, 180)\",\n                \"rgb(60,157, 194)\",\n                \"rgb(128,205,193)\",\n                \"rgb(151,218,168)\",\n                \"rgb(198,231,181)\",\n                \"rgb(238,247,217)\",\n                \"rgb(255,238,159)\",\n                \"rgb(252,217,125)\",\n                \"rgb(255,182,100)\",\n                \"rgb(252,150,75)\",\n                \"rgb(250,112,52)\",\n                \"rgb(245,64,32)\",\n                \"rgb(237,45,28)\",\n                \"rgb(220,24,32)\",\n                \"rgb(180,0,35)\",\n            ]\n\n        wind = Velocity(\n            data=ds,\n            zonal_speed=zonal_speed,\n            meridional_speed=meridional_speed,\n            latitude_dimension=latitude_dimension,\n            longitude_dimension=longitude_dimension,\n            velocity_scale=velocity_scale,\n            max_velocity=max_velocity,\n            display_options=display_options,\n            name=name,\n            color_scale=color_scale,\n        )\n        self.add(wind)\n\n    def add_data(\n        self,\n        data,\n        column,\n        colors=None,\n        labels=None,\n        cmap=None,\n        scheme=\"Quantiles\",\n        k=5,\n        add_legend=True,\n        legend_title=None,\n        legend_position=\"bottomright\",\n        legend_kwds=None,\n        classification_kwds=None,\n        layer_name=\"Untitled\",\n        style=None,\n        hover_style=None,\n        style_callback=None,\n        marker_radius=10,\n        marker_args=None,\n        info_mode=\"on_hover\",\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"Add vector data to the map with a variety of classification schemes.\n\n        Args:\n            data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n            column (str): The column to classify.\n            cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n            colors (list, optional): A list of colors to use for the classification. Defaults to None.\n            labels (list, optional): A list of labels to use for the legend. Defaults to None.\n            scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n                Name of a choropleth classification scheme (requires mapclassify).\n                A mapclassify.MapClassifier object will be used\n                under the hood. Supported are all schemes provided by mapclassify (e.g.\n                'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n                'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n                'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n                'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n                'UserDefined'). Arguments can be passed in classification_kwds.\n            k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n            add_legend (bool, optional): Whether to add a legend to the map. Defaults to True.\n            legend_title (str, optional): The title of the legend. Defaults to None.\n            legend_position (str, optional): The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.\n            legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n                Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n                Additional accepted keywords when `scheme` is specified:\n                fmt : string\n                    A formatting specification for the bin edges of the classes in the\n                    legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n                labels : list-like\n                    A list of legend labels to override the auto-generated labblels.\n                    Needs to have the same number of elements as the number of\n                    classes (`k`).\n                interval : boolean (default False)\n                    An option to control brackets from mapclassify legend.\n                    If True, open/closed interval brackets are shown in the legend.\n            classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n            layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n            style (dict, optional): A dictionary specifying the style to be used. Defaults to None.\n                style is a dictionary of the following form:\n                    style = {\n                    \"stroke\": False,\n                    \"color\": \"#ff0000\",\n                    \"weight\": 1,\n                    \"opacity\": 1,\n                    \"fill\": True,\n                    \"fillColor\": \"#ffffff\",\n                    \"fillOpacity\": 1.0,\n                    \"dashArray\": \"9\"\n                    \"clickable\": True,\n                }\n            hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n                hover_style is a dictionary of the following form:\n                    hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n            style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n                style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n                style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n            info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n            encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n            **kwargs: Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.\n\n        \"\"\"\n\n        gdf, legend_dict = classify(\n            data=data,\n            column=column,\n            cmap=cmap,\n            colors=colors,\n            labels=labels,\n            scheme=scheme,\n            k=k,\n            legend_kwds=legend_kwds,\n            classification_kwds=classification_kwds,\n        )\n\n        if legend_title is None:\n            legend_title = column\n\n        if style is None:\n            style = {\n                # \"stroke\": False,\n                # \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n            if colors is not None:\n                style[\"color\"] = \"#000000\"\n\n        if hover_style is None:\n            hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n        if style_callback is None:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n\n        if gdf.geometry.geom_type.unique().tolist()[0] == \"Point\":\n            columns = gdf.columns.tolist()\n            if \"category\" in columns:\n                columns.remove(\"category\")\n            if \"color\" in columns:\n                columns.remove(\"color\")\n            if marker_args is None:\n                marker_args = {}\n            if \"fill_color\" not in marker_args:\n                marker_args[\"fill_color\"] = gdf[\"color\"].tolist()\n            if \"stroke\" not in marker_args:\n                marker_args[\"stroke\"] = False\n            if \"fill_opacity\" not in marker_args:\n                marker_args[\"fill_opacity\"] = 0.8\n\n            marker_args[\"radius\"] = marker_radius\n\n            self.add_markers(gdf[columns], layer_name=layer_name, **marker_args)\n        else:\n            self.add_gdf(\n                gdf,\n                layer_name=layer_name,\n                style=style,\n                hover_style=hover_style,\n                style_callback=style_callback,\n                info_mode=info_mode,\n                encoding=encoding,\n                **kwargs,\n            )\n        if add_legend:\n            self.add_legend(\n                title=legend_title, legend_dict=legend_dict, position=legend_position\n            )\n\n    def user_roi_bounds(self, decimals=4):\n        \"\"\"Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n\n        Args:\n            decimals (int, optional): The number of decimals to round the coordinates to. Defaults to 4.\n\n        Returns:\n            list: The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n        \"\"\"\n        if self.user_roi is not None:\n            return geometry_bounds(self.user_roi, decimals=decimals)\n        else:\n            return None\n\n    def add_widget(\n        self,\n        content,\n        position=\"bottomright\",\n        add_header=False,\n        opened=True,\n        show_close_button=True,\n        widget_icon=\"gear\",\n        close_button_icon=\"times\",\n        widget_args={},\n        close_button_args={},\n        display_widget=None,\n        **kwargs,\n    ):\n        \"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n        Args:\n            content (str | ipywidgets.Widget | object): The widget to add.\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n            add_header (bool, optional): Whether to add a header with close buttons to the widget. Defaults to False.\n            opened (bool, optional): Whether to open the toolbar. Defaults to True.\n            show_close_button (bool, optional): Whether to show the close button. Defaults to True.\n            widget_icon (str, optional): The icon name for the toolbar button. Defaults to 'gear'.\n            close_button_icon (str, optional): The icon name for the close button. Defaults to \"times\".\n            widget_args (dict, optional): Additional arguments to pass to the toolbar button. Defaults to {}.\n            close_button_args (dict, optional): Additional arguments to pass to the close button. Defaults to {}.\n            display_widget (ipywidgets.Widget, optional): The widget to be displayed when the toolbar is clicked.\n            **kwargs: Additional arguments to pass to the HTML or Output widgets\n        \"\"\"\n\n        allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n        if position not in allowed_positions:\n            raise Exception(f\"position must be one of {allowed_positions}\")\n\n        if \"layout\" not in kwargs:\n            kwargs[\"layout\"] = widgets.Layout(padding=\"0px 4px 0px 4px\")\n        try:\n            if add_header:\n                if isinstance(content, str):\n                    widget = widgets.HTML(value=content, **kwargs)\n                else:\n                    widget = content\n\n                widget_template(\n                    widget,\n                    opened,\n                    show_close_button,\n                    widget_icon,\n                    close_button_icon,\n                    widget_args,\n                    close_button_args,\n                    display_widget,\n                    self,\n                    position,\n                )\n            else:\n                if isinstance(content, str):\n                    widget = widgets.HTML(value=content, **kwargs)\n                else:\n                    widget = widgets.Output(**kwargs)\n                    with widget:\n                        display(content)\n                control = ipyleaflet.WidgetControl(widget=widget, position=position)\n                self.add(control)\n\n        except Exception as e:\n            raise Exception(f\"Error adding widget: {e}\")\n\n    def add_image(self, image, position=\"bottomright\", **kwargs):\n        \"\"\"Add an image to the map.\n\n        Args:\n            image (str | ipywidgets.Image): The image to add.\n            position (str, optional): The position of the image, can be one of \"topleft\",\n                \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n\n        \"\"\"\n\n        if isinstance(image, str):\n            if image.startswith(\"http\"):\n                image = widgets.Image(value=requests.get(image).content, **kwargs)\n            elif os.path.exists(image):\n                with open(image, \"rb\") as f:\n                    image = widgets.Image(value=f.read(), **kwargs)\n        elif isinstance(image, widgets.Image):\n            pass\n        else:\n            raise Exception(\"Invalid image\")\n\n        self.add_widget(image, position=position)\n\n    def add_html(self, html, position=\"bottomright\", **kwargs):\n        \"\"\"Add HTML to the map.\n\n        Args:\n            html (str): The HTML to add.\n            position (str, optional): The position of the HTML, can be one of \"topleft\",\n                \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        \"\"\"\n        # Check if an HTML string contains local images and convert them to base64.\n        html = check_html_string(html)\n        self.add_widget(html, position=position, **kwargs)\n\n    def add_text(\n        self,\n        text,\n        fontsize=20,\n        fontcolor=\"black\",\n        bold=False,\n        padding=\"5px\",\n        background=True,\n        bg_color=\"white\",\n        border_radius=\"5px\",\n        position=\"bottomright\",\n        **kwargs,\n    ):\n        \"\"\"Add text to the map.\n\n        Args:\n            text (str): The text to add.\n            fontsize (int, optional): The font size. Defaults to 20.\n            fontcolor (str, optional): The font color. Defaults to \"black\".\n            bold (bool, optional): Whether to use bold font. Defaults to False.\n            padding (str, optional): The padding. Defaults to \"5px\".\n            background (bool, optional): Whether to use background. Defaults to True.\n            bg_color (str, optional): The background color. Defaults to \"white\".\n            border_radius (str, optional): The border radius. Defaults to \"5px\".\n            position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        \"\"\"\n\n        if background:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n            padding: {padding}; background-color: {bg_color};\n            border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n        else:\n            text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n            padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n        self.add_html(text, position=position, **kwargs)\n\n    def get_bbox(self):\n        \"\"\"Get the bounds of the map as a list of [(]minx, miny, maxx, maxy].\n\n        Returns:\n            list: The bounds of the map as a list of [(]minx, miny, maxx, maxy].\n        \"\"\"\n        bounds = self.bounds\n        bbox = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n        return bbox\n\n    def oam_search(\n        self,\n        bbox=None,\n        start_date=None,\n        end_date=None,\n        limit=100,\n        info_mode=\"on_click\",\n        layer_args={},\n        add_image=True,\n        **kwargs,\n    ):\n        \"\"\"Search OpenAerialMap for images within a bounding box and time range.\n\n        Args:\n            bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n            start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n            end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n            limit (int, optional): The maximum number of results to return. Defaults to 100.\n            info_mode (str, optional): The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.\n            layer_args (dict, optional): The layer arguments for add_gdf() function. Defaults to {}.\n            add_image (bool, optional): Whether to add the first 10 images to the map. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n        \"\"\"\n\n        bounds = self.bounds\n        if bbox is None:\n            if self.user_roi is not None:\n                bbox = self.user_roi_bounds()\n            else:\n                bbox = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n        if self.zoom &lt;= 4:\n            print(\"Zoom in to search for images\")\n            return None\n\n        gdf = oam_search(\n            bbox=bbox, start_date=start_date, end_date=end_date, limit=limit, **kwargs\n        )\n\n        if \"layer_name\" not in layer_args:\n            layer_args[\"layer_name\"] = \"Footprints\"\n\n        if \"style\" not in layer_args:\n            layer_args[\"style\"] = {\n                # \"stroke\": True,\n                \"color\": \"#3388ff\",\n                \"weight\": 2,\n                \"opacity\": 1,\n                # \"fill\": True,\n                # \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 0,\n                # \"dashArray\": \"9\"\n                # \"clickable\": True,\n            }\n\n        if \"hover_style\" not in layer_args:\n            layer_args[\"hover_style\"] = {\"weight\": layer_args[\"style\"][\"weight\"] + 2}\n\n        if gdf is not None:\n            setattr(self, \"oam_gdf\", gdf)\n            self.add_gdf(gdf, info_mode=info_mode, **layer_args)\n\n            if add_image:\n                ids = gdf[\"_id\"].tolist()\n                images = gdf[\"tms\"].tolist()\n\n                if len(images) &gt; 5:\n                    print(f\"Found {len(images)} images. \\nShowing the first 5.\")\n\n                for index, image in enumerate(images):\n                    if index == 5:\n                        break\n                    self.add_tile_layer(\n                        url=image, name=ids[index], attribution=\"OpenAerialMap\"\n                    )\n        else:\n            print(\"No images found.\")\n\n    def set_catalog_source(self, source):\n        \"\"\"Set the catalog source.\n\n        Args:\n            catalog_source (str, optional): The catalog source. Defaults to \"landsat\".\n        \"\"\"\n        if not isinstance(source, dict):\n            raise TypeError(\n                \"The source must be a dictionary in the format of {label: url, label2:url2}, \\\n                such as {'Element84': 'https://earth-search.aws.element84.com/v1'}\"\n            )\n        if not hasattr(self, \"_STAC_CATALOGS\"):\n            self.catalog_source = {}\n\n        self._STAC_CATALOGS = source\n\n    def clear_drawings(self):\n        \"\"\"Clear drawings on the map.\"\"\"\n        self.draw_control.clear()\n        self.draw_features = []\n        self.user_rois = None\n        self.user_roi = None\n\n    def add_layer_manager(self, position=\"topright\", opened=True):\n        \"\"\"Add the Layer Manager to the map.\n\n        Args:\n            position (str, optional): The position of the Layer Manager. Defaults to \"topright\".\n        \"\"\"\n        from .toolbar import layer_manager_gui\n\n        layer_manager_gui(self, position, opened)\n\n    def update_layer_manager(self):\n        \"\"\"Update the Layer Manager.\"\"\"\n        from .toolbar import layer_manager_gui\n\n        self.layer_manager_widget.children = layer_manager_gui(self, return_widget=True)\n\n    def add_oam_gui(self, position=\"topright\", opened=True):\n        \"\"\"Add the OpenAerialMap search widget to the map.\n\n        Args:\n            position (str, optional): The position of the widget. Defaults to \"topright\".\n            opened (bool, optional): Whether the widget is open. Defaults to True.\n        \"\"\"\n        from .toolbar import oam_search_gui\n\n        oam_search_gui(self, position, opened)\n\n    def add_stac_gui(self, position=\"topright\", opened=True):\n        \"\"\"Add the STAC search widget to the map.\n\n        Args:\n            position (str, optional): The position of the widget. Defaults to \"topright\".\n            opened (bool, optional): Whether the widget is open. Defaults to True.\n        \"\"\"\n        from .toolbar import stac_gui\n\n        stac_gui(self, position, opened)\n\n    def add_inspector_gui(self, position=\"topright\", opened=True):\n        \"\"\"Add the Inspector widget to the map.\n\n        Args:\n            position (str, optional): The position of the widget. Defaults to \"topright\".\n            opened (bool, optional): Whether the widget is open. Defaults to True.\n        \"\"\"\n\n        from .toolbar import inspector_gui\n\n        inspector_gui(self, position, opened)\n\n    def add_basemap_gui(self, position=\"topright\"):\n        \"\"\"Add the basemap widget to the map.\n\n        Args:\n            position (str, optional): The position of the widget. Defaults to \"topright\".\n        \"\"\"\n        from .toolbar import change_basemap\n\n        change_basemap(self, position)\n\n    def _add_layer_editor(self, position: str, **kwargs) -&gt; None:\n        if self._layer_editor:\n            return\n\n        widget = map_widgets.LayerEditor(self, **kwargs)\n        widget.on_close = lambda: self.remove(\"layer_editor\")\n        control = ipyleaflet.WidgetControl(widget=widget, position=position)\n        super().add(control)\n\n    def _find_widget_of_type(\n        self, widget_type: Type, return_control: bool = False\n    ) -&gt; Optional[Any]:\n        \"\"\"Finds a widget in the controls with the passed in type.\"\"\"\n        for widget in self.controls:\n            if isinstance(widget, ipyleaflet.WidgetControl):\n                if isinstance(widget.widget, widget_type):\n                    return widget if return_control else widget.widget\n            elif isinstance(widget, widget_type):\n                return widget\n        return None\n\n    def remove(self, widget: Any) -&gt; None:\n        \"\"\"Removes a widget to the map.\"\"\"\n\n        basic_controls: Dict[str, ipyleaflet.Control] = {\n            \"layer_editor\": map_widgets.LayerEditor,\n        }\n        if widget_type := basic_controls.get(widget, None):\n            if control := self._find_widget_of_type(widget_type, return_control=True):\n                self.remove(control)\n                control.close()\n            return\n\n        super().remove(widget)\n        if isinstance(widget, ipywidgets.Widget):\n            widget.close()\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add","title":"<code>add(self, object, index=None, **kwargs)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>object</code> <p>The layer to add to the map.</p> required <code>index</code> <code>int</code> <p>The index at which to add the layer. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add(self, object, index=None, **kwargs):\n    \"\"\"Adds a layer to the map.\n\n    Args:\n        layer (object): The layer to add to the map.\n        index (int, optional): The index at which to add the layer. Defaults to None.\n    \"\"\"\n    if isinstance(object, str):\n        if object in basemaps.keys():\n            object = get_basemap(object)\n        else:\n            if object == \"nasa_earth_data\":\n                from .toolbar import nasa_data_gui\n\n                nasa_data_gui(self, **kwargs)\n            elif object == \"inspector\":\n                from .toolbar import inspector_gui\n\n                inspector_gui(self, **kwargs)\n\n            elif object == \"stac\":\n                self.add_stac_gui(**kwargs)\n            elif object == \"basemap\":\n                self.add_basemap_gui(**kwargs)\n            elif object == \"inspector\":\n                self.add_inspector_gui(**kwargs)\n            elif object == \"layer_manager\":\n                self.add_layer_manager(**kwargs)\n            elif object == \"oam\":\n                self.add_oam_gui(**kwargs)\n            return\n\n    super().add(object, index=index)\n\n    if hasattr(self, \"layer_manager_widget\"):\n        self.update_layer_manager()\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_basemap","title":"<code>add_basemap(self, basemap='HYBRID', show=True, **kwargs)</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from basemaps. Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>visible</code> <code>bool</code> <p>Whether the basemap is visible or not. Defaults to True.</p> required <code>**kwargs</code> <p>Keyword arguments for the TileLayer.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_basemap(self, basemap=\"HYBRID\", show=True, **kwargs):\n    \"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from basemaps. Defaults to 'HYBRID'.\n        visible (bool, optional): Whether the basemap is visible or not. Defaults to True.\n        **kwargs: Keyword arguments for the TileLayer.\n    \"\"\"\n    import xyzservices\n\n    try:\n        layer_names = self.get_layer_names()\n\n        map_dict = {\n            \"ROADMAP\": \"Google Maps\",\n            \"SATELLITE\": \"Google Satellite\",\n            \"TERRAIN\": \"Google Terrain\",\n            \"HYBRID\": \"Google Hybrid\",\n        }\n\n        if isinstance(basemap, str):\n            if basemap.upper() in map_dict:\n                layer = get_google_map(basemap.upper(), **kwargs)\n                layer.visible = show\n                self.add(layer)\n                return\n\n        if isinstance(basemap, xyzservices.TileProvider):\n            name = basemap.name\n            url = basemap.build_url()\n            attribution = basemap.attribution\n            if \"max_zoom\" in basemap.keys():\n                max_zoom = basemap[\"max_zoom\"]\n            else:\n                max_zoom = 22\n            layer = ipyleaflet.TileLayer(\n                url=url,\n                name=name,\n                max_zoom=max_zoom,\n                attribution=attribution,\n                visible=show,\n                **kwargs,\n            )\n            self.add(layer)\n            arc_add_layer(url, name)\n        elif basemap in basemaps and basemaps[basemap].name not in layer_names:\n            self.add(basemap)\n            self.layers[-1].visible = show\n            arc_add_layer(basemaps[basemap].url, basemap)\n        elif basemap in basemaps and basemaps[basemap].name in layer_names:\n            print(f\"{basemap} has been already added before.\")\n        else:\n            print(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n\n    except Exception as e:\n        raise ValueError(\n            \"Basemap can only be one of the following:\\n  {}\".format(\n                \"\\n  \".join(basemaps.keys())\n            )\n        )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_basemap_gui","title":"<code>add_basemap_gui(self, position='topright')</code>","text":"<p>Add the basemap widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_basemap_gui(self, position=\"topright\"):\n    \"\"\"Add the basemap widget to the map.\n\n    Args:\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n    \"\"\"\n    from .toolbar import change_basemap\n\n    change_basemap(self, position)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_census_data","title":"<code>add_census_data(self, wms, layer, census_dict=None, **kwargs)</code>","text":"<p>Adds a census data layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>wms</code> <code>str</code> <p>The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html</p> required <code>layer</code> <code>str</code> <p>The layer name to add to the map.</p> required <code>census_dict</code> <code>dict</code> <p>A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_census_data(self, wms, layer, census_dict=None, **kwargs):\n    \"\"\"Adds a census data layer to the map.\n\n    Args:\n        wms (str): The wms to use. For example, \"Current\", \"ACS 2021\", \"Census 2020\".  See the complete list at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html\n        layer (str): The layer name to add to the map.\n        census_dict (dict, optional): A dictionary containing census data. Defaults to None. It can be obtained from the get_census_dict() function.\n    \"\"\"\n\n    try:\n        if census_dict is None:\n            census_dict = get_census_dict()\n\n        if wms not in census_dict.keys():\n            raise ValueError(\n                f\"The provided WMS is invalid. It must be one of {census_dict.keys()}\"\n            )\n\n        layers = census_dict[wms][\"layers\"]\n        if layer not in layers:\n            raise ValueError(\n                f\"The layer name is not valid. It must be one of {layers}\"\n            )\n\n        url = census_dict[wms][\"url\"]\n        if \"name\" not in kwargs:\n            kwargs[\"name\"] = layer\n        if \"attribution\" not in kwargs:\n            kwargs[\"attribution\"] = \"U.S. Census Bureau\"\n        if \"format\" not in kwargs:\n            kwargs[\"format\"] = \"image/png\"\n        if \"transparent\" not in kwargs:\n            kwargs[\"transparent\"] = True\n\n        self.add_wms_layer(url, layer, **kwargs)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_circle_markers_from_xy","title":"<code>add_circle_markers_from_xy(self, data, x='lon', y='lat', radius=10, popup=None, font_size=2, stroke=True, color='#0033FF', weight=2, fill=True, fill_color=None, fill_opacity=0.2, opacity=1.0, layer_name='Circle Markers', **kwargs)</code>","text":"<p>Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/_modules/ipyleaflet/leaflet.html#Path</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"lon\".</p> <code>'lon'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"lat\".</p> <code>'lat'</code> <code>radius</code> <code>int</code> <p>The radius of the circle. Defaults to 10.</p> <code>10</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>font_size</code> <code>int</code> <p>The font size of the popup. Defaults to 2.</p> <code>2</code> <code>stroke</code> <code>bool</code> <p>Whether to stroke the path. Defaults to True.</p> <code>True</code> <code>color</code> <code>str</code> <p>The color of the path. Defaults to \"#0033FF\".</p> <code>'#0033FF'</code> <code>weight</code> <code>int</code> <p>The weight of the path. Defaults to 2.</p> <code>2</code> <code>fill</code> <code>bool</code> <p>Whether to fill the path with color. Defaults to True.</p> <code>True</code> <code>fill_color</code> <code>str</code> <p>The fill color of the path. Defaults to None.</p> <code>None</code> <code>fill_opacity</code> <code>float</code> <p>The fill opacity of the path. Defaults to 0.2.</p> <code>0.2</code> <code>opacity</code> <code>float</code> <p>The opacity of the path. Defaults to 1.0.</p> <code>1.0</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the marker cluster. Defaults to \"Circle Markers\".</p> <code>'Circle Markers'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_circle_markers_from_xy(\n    self,\n    data,\n    x=\"lon\",\n    y=\"lat\",\n    radius=10,\n    popup=None,\n    font_size=2,\n    stroke=True,\n    color=\"#0033FF\",\n    weight=2,\n    fill=True,\n    fill_color=None,\n    fill_opacity=0.2,\n    opacity=1.0,\n    layer_name=\"Circle Markers\",\n    **kwargs,\n):\n    \"\"\"Adds a marker cluster to the map. For a list of options, see https://ipyleaflet.readthedocs.io/en/latest/_modules/ipyleaflet/leaflet.html#Path\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"lon\".\n        y (str, optional): The column name for the y values. Defaults to \"lat\".\n        radius (int, optional): The radius of the circle. Defaults to 10.\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        font_size (int, optional): The font size of the popup. Defaults to 2.\n        stroke (bool, optional): Whether to stroke the path. Defaults to True.\n        color (str, optional): The color of the path. Defaults to \"#0033FF\".\n        weight (int, optional): The weight of the path. Defaults to 2.\n        fill (bool, optional): Whether to fill the path with color. Defaults to True.\n        fill_color (str, optional): The fill color of the path. Defaults to None.\n        fill_opacity (float, optional): The fill opacity of the path. Defaults to 0.2.\n        opacity (float, optional): The opacity of the path. Defaults to 1.0.\n        layer_name (str, optional): The layer name to use for the marker cluster. Defaults to \"Circle Markers\".\n\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(data, pd.DataFrame) or isinstance(data, gpd.GeoDataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    elif isinstance(data, str) and data.endswith(\".csv\"):\n        df = pd.read_csv(data)\n    else:\n        df = gpd.read_file(data)\n\n    col_names = df.columns.values.tolist()\n    if \"geometry\" in col_names:\n        col_names.remove(\"geometry\")\n\n    if popup is None:\n        popup = col_names\n\n    if not isinstance(popup, list):\n        popup = [popup]\n\n    if x not in col_names:\n        if isinstance(df, gpd.GeoDataFrame):\n            df[x] = df.geometry.x\n        else:\n            raise ValueError(\n                f\"x must be one of the following: {', '.join(col_names)}\"\n            )\n\n    if y not in col_names:\n        if isinstance(df, gpd.GeoDataFrame):\n            df[y] = df.geometry.y\n        else:\n            raise ValueError(\n                f\"y must be one of the following: {', '.join(col_names)}\"\n            )\n\n    if fill_color is None:\n        fill_color = color\n\n    if isinstance(color, str):\n        colors = [color] * len(df)\n    elif isinstance(color, list):\n        colors = color\n    else:\n        raise ValueError(\"color must be either a string or a list.\")\n\n    if isinstance(fill_color, str):\n        fill_colors = [fill_color] * len(df)\n    elif isinstance(fill_color, list):\n        fill_colors = fill_color\n    else:\n        raise ValueError(\"fill_color must be either a string or a list.\")\n\n    if isinstance(radius, int):\n        radius = [radius] * len(df)\n    elif isinstance(radius, list):\n        radius = radius\n    else:\n        raise ValueError(\"radius must be either an integer or a list.\")\n\n    index = 0\n\n    layers = []\n    for idx, row in df.iterrows():\n        html = \"\"\n        for p in popup:\n            html = (\n                html\n                + f\"&lt;font size='{font_size}'&gt;&lt;b&gt;\"\n                + p\n                + \"&lt;/b&gt;\"\n                + \": \"\n                + str(row[p])\n                + \"&lt;br&gt;&lt;/font&gt;\"\n            )\n        popup_html = widgets.HTML(html)\n\n        marker = ipyleaflet.CircleMarker(\n            location=[row[y], row[x]],\n            radius=radius[index],\n            popup=popup_html,\n            stroke=stroke,\n            color=colors[index],\n            weight=weight,\n            fill=fill,\n            fill_color=fill_colors[index],\n            fill_opacity=fill_opacity,\n            opacity=opacity,\n            **kwargs,\n        )\n        layers.append(marker)\n        index += 1\n\n    group = ipyleaflet.LayerGroup(layers=tuple(layers), name=layer_name)\n    self.add(group)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='', opacity=1.0, shown=True, bands=None, titiler_endpoint=None, zoom_to_layer=True, layer_index=None, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>bands</code> <code>list</code> <p>A list of bands to use for the layer. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>layer_index</code> <code>int</code> <p>The index at which to add the layer. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url,\n    name=\"Untitled\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    bands=None,\n    titiler_endpoint=None,\n    zoom_to_layer=True,\n    layer_index=None,\n    **kwargs,\n):\n    \"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        bands (list, optional): A list of bands to use for the layer. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        layer_index (int, optional): The index at which to add the layer. Defaults to None.\n        **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n            color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n            apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n    \"\"\"\n    band_names = cog_bands(url, titiler_endpoint)\n\n    if bands is not None:\n        if not isinstance(bands, list):\n            bands = [bands]\n\n        if all(isinstance(x, str) for x in bands):\n            kwargs[\"bidx\"] = [band_names.index(x) + 1 for x in bands]\n\n        elif all(isinstance(x, int) for x in bands):\n            kwargs[\"bidx\"] = bands\n        else:\n            raise ValueError(\"Bands must be a list of integers or strings.\")\n    elif \"bidx\" not in kwargs:\n        if len(band_names) == 1:\n            kwargs[\"bidx\"] = [1]\n        else:\n            kwargs[\"bidx\"] = [1, 2, 3]\n\n    vis_bands = [band_names[idx - 1] for idx in kwargs[\"bidx\"]]\n\n    if len(kwargs[\"bidx\"]) &gt; 1:\n        if \"colormap_name\" in kwargs:\n            kwargs.pop(\"colormap_name\")\n        if \"colormap\" in kwargs:\n            kwargs.pop(\"colormap\")\n\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    bounds = cog_bounds(url, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity, shown, layer_index)\n    if zoom_to_layer:\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    vmin, vmax = cog_tile_vmin_vmax(url, bands=bands)\n\n    if \"colormap_name\" in kwargs:\n        colormap = kwargs[\"colormap_name\"]\n    else:\n        colormap = None\n\n    if \"nodata\" in kwargs:\n        nodata = kwargs[\"nodata\"]\n    else:\n        nodata = None\n\n    params = {\n        \"url\": url,\n        \"titiler_endpoint\": titiler_endpoint,\n        \"tile_layer\": self.find_layer(name),\n        \"bounds\": bounds,\n        \"indexes\": kwargs[\"bidx\"],\n        \"vis_bands\": vis_bands,\n        \"band_names\": band_names,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"nodata\": nodata,\n        \"colormap\": colormap,\n        \"opacity\": opacity,\n        \"layer_name\": name,\n        \"type\": \"COG\",\n    }\n    self.cog_layer_dict[name] = params\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_colorbar","title":"<code>add_colorbar(self, colors, vmin=0, vmax=1.0, index=None, caption='', categorical=False, step=None, height='45px', transparent_bg=False, position='bottomright', **kwargs)</code>","text":"<p>Add a branca colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)</p> required <code>vmin</code> <code>int</code> <p>The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.</p> <code>1.0</code> <code>index</code> <code>list</code> <p>The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.</p> <code>None</code> <code>caption</code> <code>str</code> <p>The caption for the colormap. Defaults to \"\".</p> <code>''</code> <code>categorical</code> <code>bool</code> <p>Whether or not to create a categorical colormap. Defaults to False.</p> <code>False</code> <code>step</code> <code>int</code> <p>The step to split the LinearColormap into a StepColormap. Defaults to None.</p> <code>None</code> <code>height</code> <code>str</code> <p>The height of the colormap widget. Defaults to \"45px\".</p> <code>'45px'</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background for the colormap widget. Defaults to True.</p> <code>False</code> <code>position</code> <code>str</code> <p>The position for the colormap widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_colorbar(\n    self,\n    colors,\n    vmin=0,\n    vmax=1.0,\n    index=None,\n    caption=\"\",\n    categorical=False,\n    step=None,\n    height=\"45px\",\n    transparent_bg=False,\n    position=\"bottomright\",\n    **kwargs,\n):\n    \"\"\"Add a branca colorbar to the map.\n\n    Args:\n        colors (list): The set of colors to be used for interpolation. Colors can be provided in the form: * tuples of RGBA ints between 0 and 255 (e.g: (255, 255, 0) or (255, 255, 0, 255)) * tuples of RGBA floats between 0. and 1. (e.g: (1.,1.,0.) or (1., 1., 0., 1.)) * HTML-like string (e.g: \u201c#ffff00) * a color name or shortcut (e.g: \u201cy\u201d or \u201cyellow\u201d)\n        vmin (int, optional): The minimal value for the colormap. Values lower than vmin will be bound directly to colors[0].. Defaults to 0.\n        vmax (float, optional): The maximal value for the colormap. Values higher than vmax will be bound directly to colors[-1]. Defaults to 1.0.\n        index (list, optional):The values corresponding to each color. It has to be sorted, and have the same length as colors. If None, a regular grid between vmin and vmax is created.. Defaults to None.\n        caption (str, optional): The caption for the colormap. Defaults to \"\".\n        categorical (bool, optional): Whether or not to create a categorical colormap. Defaults to False.\n        step (int, optional): The step to split the LinearColormap into a StepColormap. Defaults to None.\n        height (str, optional): The height of the colormap widget. Defaults to \"45px\".\n        transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n        position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n\n    \"\"\"\n    from box import Box\n    from branca.colormap import LinearColormap\n\n    output = widgets.Output()\n    output.layout.height = height\n\n    if \"width\" in kwargs.keys():\n        output.layout.width = kwargs[\"width\"]\n\n    if isinstance(colors, Box):\n        try:\n            colors = list(colors[\"default\"])\n        except Exception as e:\n            print(\"The provided color list is invalid.\")\n            raise Exception(e)\n\n    if all(len(color) == 6 for color in colors):\n        colors = [\"#\" + color for color in colors]\n\n    colormap = LinearColormap(\n        colors=colors, index=index, vmin=vmin, vmax=vmax, caption=caption\n    )\n\n    if categorical:\n        if step is not None:\n            colormap = colormap.to_step(step)\n        elif index is not None:\n            colormap = colormap.to_step(len(index) - 1)\n        else:\n            colormap = colormap.to_step(3)\n\n    colormap_ctrl = ipyleaflet.WidgetControl(\n        widget=output,\n        position=position,\n        transparent_bg=transparent_bg,\n        **kwargs,\n    )\n    with output:\n        output.outputs = ()\n        display(colormap)\n\n    self.colorbar = colormap_ctrl\n    self.add(colormap_ctrl)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_colormap","title":"<code>add_colormap(self, cmap='gray', colors=None, discrete=False, label=None, width=3, height=0.25, orientation='horizontal', vmin=0, vmax=1.0, axis_off=False, show_name=False, font_size=8, transparent_bg=False, position='bottomright', **kwargs)</code>","text":"<p>Adds a matplotlib colormap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>colors</code> <code>list</code> <p>A list of custom colors to create a colormap. Defaults to None.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>width</code> <code>float</code> <p>The width of the colormap. Defaults to 8.0.</p> <code>3</code> <code>height</code> <code>float</code> <p>The height of the colormap. Defaults to 0.4.</p> <code>0.25</code> <code>orientation</code> <code>str</code> <p>The orientation of the colormap. Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>vmin</code> <code>float</code> <p>The minimum value range. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The maximum value range. Defaults to 1.0.</p> <code>1.0</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn axis off. Defaults to False.</p> <code>False</code> <code>show_name</code> <code>bool</code> <p>Whether to show the colormap name. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size of the text. Defaults to 12.</p> <code>8</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background for the colormap widget. Defaults to True.</p> <code>False</code> <code>position</code> <code>str</code> <p>The position for the colormap widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_colormap(\n    self,\n    cmap=\"gray\",\n    colors=None,\n    discrete=False,\n    label=None,\n    width=3,\n    height=0.25,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1.0,\n    axis_off=False,\n    show_name=False,\n    font_size=8,\n    transparent_bg=False,\n    position=\"bottomright\",\n    **kwargs,\n):\n    \"\"\"Adds a matplotlib colormap to the map.\n\n    Args:\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        colors (list, optional): A list of custom colors to create a colormap. Defaults to None.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        width (float, optional): The width of the colormap. Defaults to 8.0.\n        height (float, optional): The height of the colormap. Defaults to 0.4.\n        orientation (str, optional): The orientation of the colormap. Defaults to \"horizontal\".\n        vmin (float, optional): The minimum value range. Defaults to 0.\n        vmax (float, optional): The maximum value range. Defaults to 1.0.\n        axis_off (bool, optional): Whether to turn axis off. Defaults to False.\n        show_name (bool, optional): Whether to show the colormap name. Defaults to False.\n        font_size (int, optional): Font size of the text. Defaults to 12.\n        transparent_bg (bool, optional): Whether to use transparent background for the colormap widget. Defaults to True.\n        position (str, optional): The position for the colormap widget. Defaults to \"bottomright\".\n    \"\"\"\n    from .colormaps import plot_colormap\n\n    output = widgets.Output()\n\n    colormap_ctrl = ipyleaflet.WidgetControl(\n        widget=output,\n        position=position,\n        transparent_bg=transparent_bg,\n    )\n    with output:\n        output.outputs = ()\n        plot_colormap(\n            cmap,\n            colors,\n            discrete,\n            label,\n            width,\n            height,\n            orientation,\n            vmin,\n            vmax,\n            axis_off,\n            show_name,\n            font_size,\n            **kwargs,\n        )\n\n    self.colorbar = colormap_ctrl\n    self.add(colormap_ctrl)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_data","title":"<code>add_data(self, data, column, colors=None, labels=None, cmap=None, scheme='Quantiles', k=5, add_legend=True, legend_title=None, legend_position='bottomright', legend_kwds=None, classification_kwds=None, layer_name='Untitled', style=None, hover_style=None, style_callback=None, marker_radius=10, marker_args=None, info_mode='on_hover', encoding='utf-8', **kwargs)</code>","text":"<p>Add vector data to the map with a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>add_legend</code> <code>bool</code> <p>Whether to add a legend to the map. Defaults to True.</p> <code>True</code> <code>legend_title</code> <code>str</code> <p>The title of the legend. Defaults to None.</p> <code>None</code> <code>legend_position</code> <code>str</code> <p>The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to None. style is a dictionary of the following form:     style = {     \"stroke\": False,     \"color\": \"#ff0000\",     \"weight\": 1,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#ffffff\",     \"fillOpacity\": 1.0,     \"dashArray\": \"9\"     \"clickable\": True, }</p> <code>None</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}. hover_style is a dictionary of the following form:     hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}</p> <code>None</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None. style_callback is a function that takes the feature as argument and should return a dictionary of the following form: style_callback = lambda feat: {\"fillColor\": feat\"properties\"}</p> <code>None</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_data(\n    self,\n    data,\n    column,\n    colors=None,\n    labels=None,\n    cmap=None,\n    scheme=\"Quantiles\",\n    k=5,\n    add_legend=True,\n    legend_title=None,\n    legend_position=\"bottomright\",\n    legend_kwds=None,\n    classification_kwds=None,\n    layer_name=\"Untitled\",\n    style=None,\n    hover_style=None,\n    style_callback=None,\n    marker_radius=10,\n    marker_args=None,\n    info_mode=\"on_hover\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Add vector data to the map with a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        add_legend (bool, optional): Whether to add a legend to the map. Defaults to True.\n        legend_title (str, optional): The title of the legend. Defaults to None.\n        legend_position (str, optional): The position of the legend. Can be 'topleft', 'topright', 'bottomleft', or 'bottomright'. Defaults to 'bottomright'.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to None.\n            style is a dictionary of the following form:\n                style = {\n                \"stroke\": False,\n                \"color\": \"#ff0000\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fill\": True,\n                \"fillColor\": \"#ffffff\",\n                \"fillOpacity\": 1.0,\n                \"dashArray\": \"9\"\n                \"clickable\": True,\n            }\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n            hover_style is a dictionary of the following form:\n                hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n            style_callback is a function that takes the feature as argument and should return a dictionary of the following form:\n            style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n        **kwargs: Additional keyword arguments to pass to the GeoJSON class, such as fields, which can be a list of column names to be included in the popup.\n\n    \"\"\"\n\n    gdf, legend_dict = classify(\n        data=data,\n        column=column,\n        cmap=cmap,\n        colors=colors,\n        labels=labels,\n        scheme=scheme,\n        k=k,\n        legend_kwds=legend_kwds,\n        classification_kwds=classification_kwds,\n    )\n\n    if legend_title is None:\n        legend_title = column\n\n    if style is None:\n        style = {\n            # \"stroke\": False,\n            # \"color\": \"#ff0000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 1.0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n        if colors is not None:\n            style[\"color\"] = \"#000000\"\n\n    if hover_style is None:\n        hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n    if style_callback is None:\n        style_callback = lambda feat: {\"fillColor\": feat[\"properties\"][\"color\"]}\n\n    if gdf.geometry.geom_type.unique().tolist()[0] == \"Point\":\n        columns = gdf.columns.tolist()\n        if \"category\" in columns:\n            columns.remove(\"category\")\n        if \"color\" in columns:\n            columns.remove(\"color\")\n        if marker_args is None:\n            marker_args = {}\n        if \"fill_color\" not in marker_args:\n            marker_args[\"fill_color\"] = gdf[\"color\"].tolist()\n        if \"stroke\" not in marker_args:\n            marker_args[\"stroke\"] = False\n        if \"fill_opacity\" not in marker_args:\n            marker_args[\"fill_opacity\"] = 0.8\n\n        marker_args[\"radius\"] = marker_radius\n\n        self.add_markers(gdf[columns], layer_name=layer_name, **marker_args)\n    else:\n        self.add_gdf(\n            gdf,\n            layer_name=layer_name,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            info_mode=info_mode,\n            encoding=encoding,\n            **kwargs,\n        )\n    if add_legend:\n        self.add_legend(\n            title=legend_title, legend_dict=legend_dict, position=legend_position\n        )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_ee_layer","title":"<code>add_ee_layer(self, asset_id, name=None, attribution='Google Earth Engine', shown=True, opacity=1.0, **kwargs)</code>","text":"<p>Adds a Google Earth Engine tile layer to the map based on the tile layer URL from     https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The ID of the Earth Engine asset.</p> required <code>name</code> <code>str</code> <p>The name of the tile layer. If not provided, the asset ID will be used. Default is None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution text to be displayed. Default is \"Google Earth Engine\".</p> <code>'Google Earth Engine'</code> <code>shown</code> <code>bool</code> <p>Whether the tile layer should be shown on the map. Default is True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the tile layer. Default is 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying <code>add_tile_layer</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_ee_layer(\n    self,\n    asset_id: str,\n    name: str = None,\n    attribution: str = \"Google Earth Engine\",\n    shown: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n        https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n    Args:\n        asset_id (str): The ID of the Earth Engine asset.\n        name (str, optional): The name of the tile layer. If not provided, the asset ID will be used. Default is None.\n        attribution (str, optional): The attribution text to be displayed. Default is \"Google Earth Engine\".\n        shown (bool, optional): Whether the tile layer should be shown on the map. Default is True.\n        opacity (float, optional): The opacity of the tile layer. Default is 1.0.\n        **kwargs: Additional keyword arguments to be passed to the underlying `add_tile_layer` method.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n\n    df = pd.read_csv(\n        \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n        sep=\"\\t\",\n    )\n\n    asset_id = asset_id.strip()\n    if name is None:\n        name = asset_id\n\n    if asset_id in df[\"id\"].values:\n        url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n        self.add_tile_layer(\n            url,\n            name,\n            attribution=attribution,\n            shown=shown,\n            opacity=opacity,\n            **kwargs,\n        )\n    else:\n        print(f\"The provided EE tile layer {asset_id} does not exist.\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=False, encoding='utf-8', **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoDataFrame. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=False,\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer. Defaults to False.\n        encoding (str, optional): The encoding of the GeoDataFrame. Defaults to \"utf-8\".\n    \"\"\"\n    for col in gdf.columns:\n        try:\n            if gdf[col].dtype in [\"datetime64[ns]\", \"datetime64[ns, UTC]\"]:\n                gdf[col] = gdf[col].astype(str)\n        except:\n            pass\n\n    data = gdf_to_geojson(gdf, epsg=\"4326\")\n\n    self.add_geojson(\n        data,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        zoom_to_layer,\n        encoding,\n        **kwargs,\n    )\n\n    if zoom_to_layer:\n        import numpy as np\n\n        bounds = gdf.to_crs(epsg=\"4326\").bounds\n        west = np.min(bounds[\"minx\"])\n        south = np.min(bounds[\"miny\"])\n        east = np.max(bounds[\"maxx\"])\n        north = np.max(bounds[\"maxy\"])\n        self.fit_bounds([[south, east], [north, west]])\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_gdf_from_postgis","title":"<code>add_gdf_from_postgis(self, sql, con, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=True, **kwargs)</code>","text":"<p>Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_gdf_from_postgis(\n    self,\n    sql,\n    con,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=True,\n    **kwargs,\n):\n    \"\"\"Reads a PostGIS database and returns data as a GeoDataFrame to be added to the map.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer.\n    \"\"\"\n    gdf = read_postgis(sql, con, **kwargs)\n    gdf = gdf.to_crs(\"epsg:4326\")\n    self.add_gdf(\n        gdf,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        zoom_to_layer,\n    )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_geojson","title":"<code>add_geojson(self, in_geojson, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=False, encoding='utf-8', **kwargs)</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer after adding it to the map. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_geojson(\n    self,\n    in_geojson,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=False,\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it to the map. Defaults to False.\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import random\n    import requests\n\n    style_callback_only = False\n\n    if len(style) == 0 and style_callback is not None:\n        style_callback_only = True\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                if is_jupyterlite():\n                    import pyodide\n\n                    output = os.path.basename(in_geojson)\n\n                    output = os.path.abspath(output)\n                    obj = pyodide.http.open_url(in_geojson)\n                    with open(output, \"w\") as fd:\n                        shutil.copyfileobj(obj, fd)\n                    with open(output, \"r\") as fd:\n                        data = json.load(fd)\n                else:\n                    in_geojson = github_raw_url(in_geojson)\n                    data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    geom_type = get_geometry_type(data)\n\n    if not style:\n        style = {\n            # \"stroke\": True,\n            \"color\": \"#3388ff\",\n            \"weight\": 2,\n            \"opacity\": 1,\n            \"fill\": True,\n            \"fillColor\": \"#3388ff\",\n            \"fillOpacity\": 0.2,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n\n        if geom_type in [\"LineString\", \"MultiLineString\"]:\n            style[\"fill\"] = False\n\n    elif \"weight\" not in style:\n        style[\"weight\"] = 1\n\n    if not hover_style:\n        hover_style = {\"weight\": style[\"weight\"] + 2, \"fillOpacity\": 0}\n\n    def random_color(feature):\n        return {\n            \"color\": \"black\",\n            \"fillColor\": random.choice(fill_colors),\n        }\n\n    toolbar_button = widgets.ToggleButton(\n        value=True,\n        tooltip=\"Toolbar\",\n        icon=\"info\",\n        layout=widgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n        ),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        # button_style=\"primary\",\n        layout=widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        ),\n    )\n\n    html = widgets.HTML()\n    html.layout.margin = \"0px 10px 0px 10px\"\n    html.layout.max_height = \"250px\"\n    html.layout.max_width = \"250px\"\n\n    output_widget = widgets.VBox(\n        [widgets.HBox([toolbar_button, close_button]), html]\n    )\n    info_control = ipyleaflet.WidgetControl(\n        widget=output_widget, position=\"bottomright\"\n    )\n\n    if info_mode in [\"on_hover\", \"on_click\"]:\n        self.add(info_control)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            output_widget.children = [\n                widgets.VBox([widgets.HBox([toolbar_button, close_button]), html])\n            ]\n        else:\n            output_widget.children = [widgets.HBox([toolbar_button, close_button])]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if info_control in self.controls:\n                self.remove_control(info_control)\n            output_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    if \"fields\" in kwargs:\n        fields = kwargs[\"fields\"]\n        kwargs.pop(\"fields\")\n    else:\n        fields = None\n\n    def update_html(feature, fields=fields, **kwargs):\n        if fields is None:\n            fields = list(feature[\"properties\"].keys())\n            if \"style\" in fields:\n                fields.remove(\"style\")\n\n        value = [\n            \"&lt;b&gt;{}: &lt;/b&gt;{}&lt;br&gt;\".format(prop, feature[\"properties\"][prop])\n            for prop in fields\n        ]\n\n        value = \"\"\"{}\"\"\".format(\"\".join(value))\n        html.value = value\n\n    if style_callback is None:\n        style_callback = random_color\n\n    if style_callback_only:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n    else:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n\n    if info_mode == \"on_hover\":\n        geojson.on_hover(update_html)\n    elif info_mode == \"on_click\":\n        geojson.on_click(update_html)\n\n    self.add(geojson)\n    self.geojson_layers.append(geojson)\n\n    if not hasattr(self, \"json_layer_dict\"):\n        self.json_layer_dict = {}\n\n    params = {\n        \"data\": geojson,\n        \"style\": style,\n        \"hover_style\": hover_style,\n        \"style_callback\": style_callback,\n    }\n    self.json_layer_dict[layer_name] = params\n\n    if zoom_to_layer:\n        try:\n            import numpy as np\n            import geopandas as gpd\n\n            gdf = gpd.GeoDataFrame.from_features(data)\n            if gdf.crs is None:\n                gdf.crs = \"EPSG:4326\"\n            bounds = gdf.to_crs(epsg=\"4326\").bounds\n            west = np.min(bounds[\"minx\"])\n            south = np.min(bounds[\"miny\"])\n            east = np.max(bounds[\"maxx\"])\n            north = np.max(bounds[\"maxy\"])\n            self.fit_bounds([[south, east], [north, west]])\n        except Exception as e:\n            print(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_heatmap(\n    self,\n    data,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"value\",\n    name=\"Heat map\",\n    radius=25,\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n    from ipyleaflet import Heatmap\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n        self.add(heatmap)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_html","title":"<code>add_html(self, html, position='bottomright', **kwargs)</code>","text":"<p>Add HTML to the map.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML to add.</p> required <code>position</code> <code>str</code> <p>The position of the HTML, can be one of \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_html(self, html, position=\"bottomright\", **kwargs):\n    \"\"\"Add HTML to the map.\n\n    Args:\n        html (str): The HTML to add.\n        position (str, optional): The position of the HTML, can be one of \"topleft\",\n            \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n    \"\"\"\n    # Check if an HTML string contains local images and convert them to base64.\n    html = check_html_string(html)\n    self.add_widget(html, position=position, **kwargs)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_image","title":"<code>add_image(self, image, position='bottomright', **kwargs)</code>","text":"<p>Add an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | ipywidgets.Image</code> <p>The image to add.</p> required <code>position</code> <code>str</code> <p>The position of the image, can be one of \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_image(self, image, position=\"bottomright\", **kwargs):\n    \"\"\"Add an image to the map.\n\n    Args:\n        image (str | ipywidgets.Image): The image to add.\n        position (str, optional): The position of the image, can be one of \"topleft\",\n            \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n\n    \"\"\"\n\n    if isinstance(image, str):\n        if image.startswith(\"http\"):\n            image = widgets.Image(value=requests.get(image).content, **kwargs)\n        elif os.path.exists(image):\n            with open(image, \"rb\") as f:\n                image = widgets.Image(value=f.read(), **kwargs)\n    elif isinstance(image, widgets.Image):\n        pass\n    else:\n        raise Exception(\"Invalid image\")\n\n    self.add_widget(image, position=position)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_inspector_gui","title":"<code>add_inspector_gui(self, position='topright', opened=True)</code>","text":"<p>Add the Inspector widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether the widget is open. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_inspector_gui(self, position=\"topright\", opened=True):\n    \"\"\"Add the Inspector widget to the map.\n\n    Args:\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether the widget is open. Defaults to True.\n    \"\"\"\n\n    from .toolbar import inspector_gui\n\n    inspector_gui(self, position, opened)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_kml","title":"<code>add_kml(self, in_kml, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds a KML file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The input file path or HTTP URL to the KML.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided KML file could not be found.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_kml(\n    self,\n    in_kml,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds a KML file to the map.\n\n    Args:\n        in_kml (str): The input file path or HTTP URL to the KML.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    Raises:\n        FileNotFoundError: The provided KML file could not be found.\n    \"\"\"\n\n    if in_kml.startswith(\"http\") and in_kml.endswith(\".kml\"):\n        out_dir = os.path.abspath(\"./cache\")\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        in_kml = download_file(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The downloaded kml file could not be found.\")\n    else:\n        in_kml = os.path.abspath(in_kml)\n        if not os.path.exists(in_kml):\n            raise FileNotFoundError(\"The provided KML could not be found.\")\n\n    self.add_vector(\n        in_kml,\n        layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_labels","title":"<code>add_labels(self, data, column, font_size='12pt', font_color='black', font_family='arial', font_weight='normal', x='longitude', y='latitude', draggable=True, layer_name='Labels', **kwargs)</code>","text":"<p>Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame | gpd.GeoDataFrame | str</code> <p>The input data to label.</p> required <code>column</code> <code>str</code> <p>The column name of the data to label.</p> required <code>font_size</code> <code>str</code> <p>The font size of the labels. Defaults to \"12pt\".</p> <code>'12pt'</code> <code>font_color</code> <code>str</code> <p>The font color of the labels. Defaults to \"black\".</p> <code>'black'</code> <code>font_family</code> <code>str</code> <p>The font family of the labels. Defaults to \"arial\".</p> <code>'arial'</code> <code>font_weight</code> <code>str</code> <p>The font weight of the labels, can be normal, bold. Defaults to \"normal\".</p> <code>'normal'</code> <code>x</code> <code>str</code> <p>The column name of the longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name of the latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>draggable</code> <code>bool</code> <p>Whether the labels are draggable. Defaults to True.</p> <code>True</code> <code>layer_name</code> <code>str</code> <p>Layer name to use. Defaults to \"Labels\".</p> <code>'Labels'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_labels(\n    self,\n    data,\n    column,\n    font_size=\"12pt\",\n    font_color=\"black\",\n    font_family=\"arial\",\n    font_weight=\"normal\",\n    x=\"longitude\",\n    y=\"latitude\",\n    draggable=True,\n    layer_name=\"Labels\",\n    **kwargs,\n):\n    \"\"\"Adds a label layer to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/divicon.html\n\n    Args:\n        data (pd.DataFrame | gpd.GeoDataFrame | str): The input data to label.\n        column (str): The column name of the data to label.\n        font_size (str, optional): The font size of the labels. Defaults to \"12pt\".\n        font_color (str, optional): The font color of the labels. Defaults to \"black\".\n        font_family (str, optional): The font family of the labels. Defaults to \"arial\".\n        font_weight (str, optional): The font weight of the labels, can be normal, bold. Defaults to \"normal\".\n        x (str, optional): The column name of the longitude. Defaults to \"longitude\".\n        y (str, optional): The column name of the latitude. Defaults to \"latitude\".\n        draggable (bool, optional): Whether the labels are draggable. Defaults to True.\n        layer_name (str, optional): Layer name to use. Defaults to \"Labels\".\n\n    \"\"\"\n    import warnings\n    import pandas as pd\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n        if \"geometry\" in data.columns or (\"geom\" in data.columns):\n            df[x] = df.centroid.x\n            df[y] = df.centroid.y\n\n    elif isinstance(data, str):\n        ext = os.path.splitext(data)[1]\n        if ext == \".csv\":\n            df = pd.read_csv(data)\n        elif ext in [\".geojson\", \".json\", \".shp\", \".gpkg\"]:\n            try:\n                import geopandas as gpd\n\n                df = gpd.read_file(data)\n                df[x] = df.centroid.x\n                df[y] = df.centroid.y\n            except Exception as _:\n                print(\"geopandas is required to read geojson.\")\n                return\n\n    else:\n        raise ValueError(\n            \"data must be a pd.DataFrame, gpd.GeoDataFrame, or an ee.FeatureCollection.\"\n        )\n\n    if column not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if x not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n    if y not in df.columns:\n        raise ValueError(f\"column must be one of {', '.join(df.columns)}.\")\n\n    try:\n        size = int(font_size.replace(\"pt\", \"\"))\n    except:\n        raise ValueError(\"font_size must be something like '10pt'\")\n\n    labels = []\n    for index in df.index:\n        html = f'&lt;div style=\"font-size: {font_size};color:{font_color};font-family:{font_family};font-weight: {font_weight}\"&gt;{df[column][index]}&lt;/div&gt;'\n        marker = ipyleaflet.Marker(\n            location=[df[y][index], df[x][index]],\n            icon=ipyleaflet.DivIcon(\n                icon_size=(1, 1),\n                icon_anchor=(size, size),\n                html=html,\n                **kwargs,\n            ),\n            draggable=draggable,\n        )\n        labels.append(marker)\n    layer_group = ipyleaflet.LayerGroup(layers=labels, name=layer_name)\n    self.add(layer_group)\n    self.labels = layer_group\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_layer","title":"<code>add_layer(self, layer)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>ipyleaflet layer</code> <p>The layer to be added.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_layer(self, layer):\n    \"\"\"Adds a layer to the map.\n\n    Args:\n        layer (ipyleaflet layer): The layer to be added.\n    \"\"\"\n    existing_layer = self.find_layer(layer.name)\n    if existing_layer is not None:\n        self.remove_layer(existing_layer)\n    super().add(layer)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_layer_control","title":"<code>add_layer_control(self, position='topright')</code>","text":"<p>Adds a layer control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the layer control. Defaults to 'topright'.</p> <code>'topright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_layer_control(self, position=\"topright\"):\n    \"\"\"Adds a layer control to the map.\n\n    Args:\n        position (str, optional): The position of the layer control. Defaults to 'topright'.\n    \"\"\"\n\n    self.add(ipyleaflet.LayersControl(position=position))\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_layer_manager","title":"<code>add_layer_manager(self, position='topright', opened=True)</code>","text":"<p>Add the Layer Manager to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the Layer Manager. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_layer_manager(self, position=\"topright\", opened=True):\n    \"\"\"Add the Layer Manager to the map.\n\n    Args:\n        position (str, optional): The position of the Layer Manager. Defaults to \"topright\".\n    \"\"\"\n    from .toolbar import layer_manager_gui\n\n    layer_manager_gui(self, position, opened)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_legend","title":"<code>add_legend(self, title='Legend', legend_dict=None, labels=None, colors=None, position='bottomright', builtin_legend=None, layer_name=None, **kwargs)</code>","text":"<p>Adds a customized basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'.</p> <code>'Legend'</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend keys. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>Position of the legend. Defaults to 'bottomright'.</p> <code>'bottomright'</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>Layer name of the legend to be associated with. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_legend(\n    self,\n    title=\"Legend\",\n    legend_dict=None,\n    labels=None,\n    colors=None,\n    position=\"bottomright\",\n    builtin_legend=None,\n    layer_name=None,\n    **kwargs,\n):\n    \"\"\"Adds a customized basemap to the map.\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        labels (list, optional): A list of legend keys. Defaults to None.\n        colors (list, optional): A list of legend colors. Defaults to None.\n        position (str, optional): Position of the legend. Defaults to 'bottomright'.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        layer_name (str, optional): Layer name of the legend to be associated with. Defaults to None.\n\n    \"\"\"\n    import pkg_resources\n    from IPython.display import display\n\n    pkg_dir = os.path.dirname(\n        pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\")\n    )\n    legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n    if \"min_width\" not in kwargs.keys():\n        min_width = None\n    if \"max_width\" not in kwargs.keys():\n        max_width = None\n    else:\n        max_width = kwargs[\"max_width\"]\n    if \"min_height\" not in kwargs.keys():\n        min_height = None\n    else:\n        min_height = kwargs[\"min_height\"]\n    if \"max_height\" not in kwargs.keys():\n        max_height = None\n    else:\n        max_height = kwargs[\"max_height\"]\n    if \"height\" not in kwargs.keys():\n        height = None\n    else:\n        height = kwargs[\"height\"]\n    if \"width\" not in kwargs.keys():\n        width = None\n    else:\n        width = kwargs[\"width\"]\n\n    if width is None:\n        max_width = \"300px\"\n    if height is None:\n        max_height = \"400px\"\n\n    if not os.path.exists(legend_template):\n        print(\"The legend template does not exist.\")\n        return\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        print(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n        return\n\n    header = []\n    content = []\n    footer = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n        lines[3] = lines[3].replace(\"Legend\", title)\n        header = lines[:6]\n        footer = lines[11:]\n\n    for index, key in enumerate(labels):\n        color = colors[index]\n        if not color.startswith(\"#\"):\n            color = \"#\" + color\n        item = \"      &lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n            color, key\n        )\n        content.append(item)\n\n    legend_html = header + content + footer\n    legend_text = \"\".join(legend_html)\n\n    try:\n        legend_output_widget = widgets.Output(\n            layout={\n                # \"border\": \"1px solid black\",\n                \"max_width\": max_width,\n                \"min_width\": min_width,\n                \"max_height\": max_height,\n                \"min_height\": min_height,\n                \"height\": height,\n                \"width\": width,\n                \"overflow\": \"scroll\",\n            }\n        )\n        legend_control = ipyleaflet.WidgetControl(\n            widget=legend_output_widget, position=position\n        )\n        legend_widget = widgets.HTML(value=legend_text)\n        with legend_output_widget:\n            display(legend_widget)\n\n        self.legend_widget = legend_output_widget\n        self.legend_control = legend_control\n        self.add(legend_control)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_local_tile","title":"<code>add_local_tile(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', layer_index=None, zoom_to_layer=True, visible=True, opacity=1.0, array_args={}, client_args={'cors_all': False}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>layer_index</code> <code>int</code> <p>The index of the layer. Defaults to None.</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>{}</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.</p> <code>{'cors_all': False}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Raster\",\n    layer_index=None,\n    zoom_to_layer=True,\n    visible=True,\n    opacity=1.0,\n    array_args={},\n    client_args={\"cors_all\": False},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        layer_index (int, optional): The index of the layer. Defaults to None.\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to True.\n        visible (bool, optional): Whether the layer is visible. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        array_args (dict, optional): Additional arguments to pass to `array_to_memory_file` when reading the raster. Defaults to {}.\n        client_args (dict, optional): Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n    \"\"\"\n    import numpy as np\n    import xarray as xr\n\n    if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n        source = array_to_image(source, **array_args)\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        opacity=opacity,\n        attribution=attribution,\n        layer_name=layer_name,\n        client_args=client_args,\n        return_client=True,\n        **kwargs,\n    )\n    tile_layer.visible = visible\n\n    self.add(tile_layer, index=layer_index)\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    if zoom_to_layer:\n        self.zoom_to_bounds(bounds)\n\n    arc_add_layer(tile_layer.url, layer_name, True, 1.0)\n    if zoom_to_layer:\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    if indexes is None:\n        if len(tile_client.band_names) == 1:\n            indexes = [1]\n        else:\n            indexes = [1, 2, 3]\n\n    vis_bands = [tile_client.band_names[i - 1] for i in indexes]\n\n    params = {\n        \"tile_layer\": tile_layer,\n        \"tile_client\": tile_client,\n        \"indexes\": indexes,\n        \"vis_bands\": vis_bands,\n        \"band_names\": tile_client.band_names,\n        \"bounds\": bounds,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"nodata\": nodata,\n        \"colormap\": colormap,\n        \"opacity\": opacity,\n        \"layer_name\": layer_name,\n        \"filename\": tile_client.filename,\n        \"type\": \"LOCAL\",\n    }\n    self.cog_layer_dict[layer_name] = params\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_marker","title":"<code>add_marker(self, location, **kwargs)</code>","text":"<p>Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>list | tuple</code> <p>The location of the marker in the format of [lat, lng].</p> required <code>**kwargs</code> <p>Keyword arguments for the marker.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_marker(self, location, **kwargs):\n    \"\"\"Adds a marker to the map. More info about marker at https://ipyleaflet.readthedocs.io/en/latest/api_reference/marker.html.\n\n    Args:\n        location (list | tuple): The location of the marker in the format of [lat, lng].\n\n        **kwargs: Keyword arguments for the marker.\n    \"\"\"\n    if isinstance(location, list):\n        location = tuple(location)\n    if isinstance(location, tuple):\n        marker = ipyleaflet.Marker(location=location, **kwargs)\n        self.add(marker)\n    else:\n        raise TypeError(\"The location must be a list or a tuple.\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_marker_cluster","title":"<code>add_marker_cluster(self, data, x='longitude', y='latitude', popup=None, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], spin=False, add_legend=True, max_cluster_radius=80, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].</p> <code>['info']</code> <code>spin</code> <code>bool</code> <p>If True, the icon will spin. Defaults to False.</p> <code>False</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> <code>max_cluster_radius</code> <code>int</code> <p>The maximum cluster radius. Defaults to 80.</p> <code>80</code> <code>**kwargs</code> <p>Other keyword arguments to pass to ipyleaflet.MarkerCluster(). For a list of available options, see https://github.com/Leaflet/Leaflet.markercluster.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_points_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    popup=None,\n    layer_name=\"Marker Cluster\",\n    color_column=None,\n    marker_colors=None,\n    icon_colors=[\"white\"],\n    icon_names=[\"info\"],\n    spin=False,\n    add_legend=True,\n    max_cluster_radius=80,\n    **kwargs,\n):\n    \"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].\n        spin (bool, optional): If True, the icon will spin. Defaults to False.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n        max_cluster_radius (int, optional): The maximum cluster radius. Defaults to 80.\n        **kwargs: Other keyword arguments to pass to ipyleaflet.MarkerCluster(). For a list of available options,\n            see https://github.com/Leaflet/Leaflet.markercluster.\n\n    \"\"\"\n    import pandas as pd\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    elif data.endswith(\".csv\"):\n        df = pd.read_csv(data)\n    else:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        df = gdf_to_df(gdf)\n\n    df = points_from_xy(df, x, y)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if \"geometry\" in col_names:\n        col_names.remove(\"geometry\")\n\n    if popup is not None:\n        if isinstance(popup, str) and (popup not in col_names):\n            raise ValueError(\n                f\"popup must be one of the following: {', '.join(col_names)}\"\n            )\n        elif isinstance(popup, list) and (\n            not all(item in col_names for item in popup)\n        ):\n            raise ValueError(\n                f\"All popup items must be select from: {', '.join(col_names)}\"\n            )\n    else:\n        popup = col_names\n\n    df[\"x\"] = df.geometry.x\n    df[\"y\"] = df.geometry.y\n\n    points = list(zip(df[\"y\"], df[\"x\"]))\n\n    if popup is not None:\n        if isinstance(popup, str):\n            labels = df[popup]\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n        elif isinstance(popup, list):\n            labels = []\n            for i in range(len(points)):\n                label = \"\"\n                for item in popup:\n                    label = (\n                        label\n                        + \"&lt;b&gt;\"\n                        + str(item)\n                        + \"&lt;/b&gt;\"\n                        + \": \"\n                        + str(df[item][i])\n                        + \"&lt;br&gt;\"\n                    )\n                labels.append(label)\n            df[\"popup\"] = labels\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(labels[index]),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n    else:\n        markers = []\n        for point in points:\n            if items is not None:\n                marker_color = marker_colors[items.index(df[color_column][index])]\n                icon_name = icon_names[items.index(df[color_column][index])]\n                icon_color = icon_colors[items.index(df[color_column][index])]\n                marker_icon = ipyleaflet.AwesomeIcon(\n                    name=icon_name,\n                    marker_color=marker_color,\n                    icon_color=icon_color,\n                    spin=spin,\n                )\n            else:\n                marker_icon = None\n\n            marker = ipyleaflet.Marker(\n                location=point, draggable=False, icon=marker_icon\n            )\n            markers.append(marker)\n\n    marker_cluster = ipyleaflet.MarkerCluster(\n        markers=markers,\n        name=layer_name,\n        max_cluster_radius=max_cluster_radius,\n        **kwargs,\n    )\n    self.add(marker_cluster)\n\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_markers","title":"<code>add_markers(self, markers, x='lon', y='lat', radius=10, popup=None, font_size=2, stroke=True, color='#0033FF', weight=2, fill=True, fill_color=None, fill_opacity=0.2, opacity=1.0, shape='circle', layer_name='Markers', **kwargs)</code>","text":"<p>Adds markers to the map.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>Union[List[List[Union[int, float]]], List[Union[int, float]]]</code> <p>List of markers. Each marker can be defined as a list of [x, y] coordinates or as a single [x, y] coordinate.</p> required <code>x</code> <code>str</code> <p>Name of the x-coordinate column in the marker data. Defaults to \"lon\".</p> <code>'lon'</code> <code>y</code> <code>str</code> <p>Name of the y-coordinate column in the marker data. Defaults to \"lat\".</p> <code>'lat'</code> <code>radius</code> <code>int</code> <p>Radius of the markers. Defaults to 10.</p> <code>10</code> <code>popup</code> <code>str</code> <p>Popup text for the markers. Defaults to None.</p> <code>None</code> <code>font_size</code> <code>int</code> <p>Font size of the popup text. Defaults to 2.</p> <code>2</code> <code>stroke</code> <code>bool</code> <p>Whether to display marker stroke. Defaults to True.</p> <code>True</code> <code>color</code> <code>str</code> <p>Color of the marker stroke. Defaults to \"#0033FF\".</p> <code>'#0033FF'</code> <code>weight</code> <code>int</code> <p>Weight of the marker stroke. Defaults to 2.</p> <code>2</code> <code>fill</code> <code>bool</code> <p>Whether to fill markers. Defaults to True.</p> <code>True</code> <code>fill_color</code> <code>str</code> <p>Fill color of the markers. Defaults to None.</p> <code>None</code> <code>fill_opacity</code> <code>float</code> <p>Opacity of the marker fill. Defaults to 0.2.</p> <code>0.2</code> <code>opacity</code> <code>float</code> <p>Opacity of the markers. Defaults to 1.0.</p> <code>1.0</code> <code>shape</code> <code>str</code> <p>Shape of the markers. Options are \"circle\" or \"marker\". Defaults to \"circle\".</p> <code>'circle'</code> <code>layer_name</code> <code>str</code> <p>Name of the marker layer. Defaults to \"Markers\".</p> <code>'Markers'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the marker plotting function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any value.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_markers(\n    self,\n    markers: Union[List[List[Union[int, float]]], List[Union[int, float]]],\n    x: str = \"lon\",\n    y: str = \"lat\",\n    radius: int = 10,\n    popup: Optional[str] = None,\n    font_size: int = 2,\n    stroke: bool = True,\n    color: str = \"#0033FF\",\n    weight: int = 2,\n    fill: bool = True,\n    fill_color: Optional[str] = None,\n    fill_opacity: float = 0.2,\n    opacity: float = 1.0,\n    shape: str = \"circle\",\n    layer_name: str = \"Markers\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Adds markers to the map.\n\n    Args:\n        markers (Union[List[List[Union[int, float]]], List[Union[int, float]]]): List of markers.\n            Each marker can be defined as a list of [x, y] coordinates or as a single [x, y] coordinate.\n        x (str, optional): Name of the x-coordinate column in the marker data. Defaults to \"lon\".\n        y (str, optional): Name of the y-coordinate column in the marker data. Defaults to \"lat\".\n        radius (int, optional): Radius of the markers. Defaults to 10.\n        popup (str, optional): Popup text for the markers. Defaults to None.\n        font_size (int, optional): Font size of the popup text. Defaults to 2.\n        stroke (bool, optional): Whether to display marker stroke. Defaults to True.\n        color (str, optional): Color of the marker stroke. Defaults to \"#0033FF\".\n        weight (int, optional): Weight of the marker stroke. Defaults to 2.\n        fill (bool, optional): Whether to fill markers. Defaults to True.\n        fill_color (str, optional): Fill color of the markers. Defaults to None.\n        fill_opacity (float, optional): Opacity of the marker fill. Defaults to 0.2.\n        opacity (float, optional): Opacity of the markers. Defaults to 1.0.\n        shape (str, optional): Shape of the markers. Options are \"circle\" or \"marker\". Defaults to \"circle\".\n        layer_name (str, optional): Name of the marker layer. Defaults to \"Markers\".\n        **kwargs: Additional keyword arguments to pass to the marker plotting function.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n    import geopandas as gpd\n\n    if (\n        isinstance(markers, list)\n        and len(markers) == 2\n        and isinstance(markers[0], (int, float))\n        and isinstance(markers[1], (int, float))\n    ):\n        markers = [markers]\n\n    if isinstance(markers, list) and all(\n        isinstance(item, list) and len(item) == 2 for item in markers\n    ):\n        df = pd.DataFrame(markers, columns=[y, x])\n        markers = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y]))\n\n    if shape == \"circle\":\n        self.add_circle_markers_from_xy(\n            markers,\n            x,\n            y,\n            radius,\n            popup,\n            font_size,\n            stroke,\n            color,\n            weight,\n            fill,\n            fill_color,\n            fill_opacity,\n            opacity,\n            layer_name,\n            **kwargs,\n        )\n\n    elif shape == \"marker\":\n        self.add_gdf(markers, **kwargs)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_minimap","title":"<code>add_minimap(self, zoom=5, position='bottomright')</code>","text":"<p>Adds a minimap (overview) to the ipyleaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>Initial map zoom level. Defaults to 5.</p> <code>5</code> <code>position</code> <code>str</code> <p>Position of the minimap. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_minimap(self, zoom=5, position=\"bottomright\"):\n    \"\"\"Adds a minimap (overview) to the ipyleaflet map.\n\n    Args:\n        zoom (int, optional): Initial map zoom level. Defaults to 5.\n        position (str, optional): Position of the minimap. Defaults to \"bottomright\".\n    \"\"\"\n    layers = [get_basemap(\"Esri.WorldImagery\")]\n    minimap = ipyleaflet.Map(\n        zoom_control=False,\n        attribution_control=False,\n        zoom=zoom,\n        center=self.center,\n        layers=layers,\n    )\n    minimap.layout.width = \"150px\"\n    minimap.layout.height = \"150px\"\n    ipyleaflet.link((minimap, \"center\"), (self, \"center\"))\n    minimap_control = ipyleaflet.WidgetControl(widget=minimap, position=position)\n    self.add(minimap_control)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_mosaic_layer","title":"<code>add_mosaic_layer(self, url=None, titiler_endpoint=None, name='Mosaic Layer', attribution='', opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Mosaic Layer'.</p> <code>'Mosaic Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_mosaic_layer(\n    self,\n    url=None,\n    titiler_endpoint=None,\n    name=\"Mosaic Layer\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n    tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n\n    bounds = mosaic_bounds(url, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity, shown)\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_netcdf","title":"<code>add_netcdf(self, filename, variables=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='NetCDF layer', shift_lon=True, lat='lat', lon='lon', lev='lev', level_index=0, time=0, **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> required <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"netCDF layer\".</p> <code>'NetCDF layer'</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <code>lev</code> <code>str</code> <p>Name of the level variable. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>Index of level to use. Defaults to 0'.</p> <code>0</code> <code>time</code> <code>int</code> <p>Index of time to use. Defaults to 0'.</p> <code>0</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_netcdf(\n    self,\n    filename,\n    variables=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"NetCDF layer\",\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    lev=\"lev\",\n    level_index=0,\n    time=0,\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"netCDF layer\".\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        lev (str, optional): Name of the level variable. Defaults to 'lev'.\n        level_index (int, optional): Index of level to use. Defaults to 0'.\n        time (int, optional): Index of time to use. Defaults to 0'.\n    \"\"\"\n\n    tif, vars = netcdf_to_tif(\n        filename,\n        shift_lon=shift_lon,\n        lat=lat,\n        lon=lon,\n        lev=lev,\n        level_index=level_index,\n        time=time,\n        return_vars=True,\n    )\n\n    if variables is None:\n        if len(vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        if not set(variables).issubset(set(vars)):\n            raise ValueError(f\"The variables must be a subset of {vars}.\")\n        else:\n            band_idx = [vars.index(v) + 1 for v in variables]\n\n    self.add_raster(\n        tif,\n        band=band_idx,\n        palette=palette,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        layer_name=layer_name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_oam_gui","title":"<code>add_oam_gui(self, position='topright', opened=True)</code>","text":"<p>Add the OpenAerialMap search widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether the widget is open. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_oam_gui(self, position=\"topright\", opened=True):\n    \"\"\"Add the OpenAerialMap search widget to the map.\n\n    Args:\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether the widget is open. Defaults to True.\n    \"\"\"\n    from .toolbar import oam_search_gui\n\n    oam_search_gui(self, position, opened)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_address","title":"<code>add_osm_from_address(self, address, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of address to the map.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_address(\n    self,\n    address,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within some distance N, S, E, W of address to the map.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_bbox","title":"<code>add_osm_from_bbox(self, north, south, east, west, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within a N, S, E, W bounding box to the map.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_bbox(\n    self,\n    north,\n    south,\n    east,\n    west,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within a N, S, E, W bounding box to the map.\n\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_geocode","title":"<code>add_osm_from_geocode(self, query, which_result=None, by_osmid=False, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM data of place(s) by name or ID to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_geocode(\n    self,\n    query,\n    which_result=None,\n    by_osmid=False,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM data of place(s) by name or ID to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n\n    gdf = osm_gdf_from_geocode(\n        query, which_result=which_result, by_osmid=by_osmid, buffer_dist=buffer_dist\n    )\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_place","title":"<code>add_osm_from_place(self, query, tags, which_result=None, buffer_dist=None, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of geocodable place(s) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_place(\n    self,\n    query,\n    tags,\n    which_result=None,\n    buffer_dist=None,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within boundaries of geocodable place(s) to the map.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_point","title":"<code>add_osm_from_point(self, center_point, tags, dist=1000, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within some distance N, S, E, W of a point to the map.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_point(\n    self,\n    center_point,\n    tags,\n    dist=1000,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within some distance N, S, E, W of a point to the map.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_polygon","title":"<code>add_osm_from_polygon(self, polygon, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within boundaries of a (multi)polygon to the map.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_polygon(\n    self,\n    polygon,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within boundaries of a (multi)polygon to the map.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_osm_from_view","title":"<code>add_osm_from_view(self, tags, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover')</code>","text":"<p>Adds OSM entities within the current map view to the map.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_osm_from_view(\n    self,\n    tags,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n):\n    \"\"\"Adds OSM entities within the current map view to the map.\n\n    Args:\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n\n    \"\"\"\n    bounds = self.bounds\n    if len(bounds) == 0:\n        bounds = (\n            (40.74824858675827, -73.98933637940563),\n            (40.75068694343106, -73.98364473187601),\n        )\n    north, south, east, west = (\n        bounds[1][0],\n        bounds[0][0],\n        bounds[1][1],\n        bounds[0][1],\n    )\n\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    geojson = gdf.__geo_interface__\n\n    self.add_geojson(\n        geojson,\n        layer_name=layer_name,\n        style=style,\n        hover_style=hover_style,\n        style_callback=style_callback,\n        fill_colors=fill_colors,\n        info_mode=info_mode,\n    )\n    self.zoom_to_gdf(gdf)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, layer_name=None, api_key=None, token_name='PLANET_API_KEY', **kwargs)</code>","text":"<p>Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_planet_by_month(\n    self,\n    year=2016,\n    month=1,\n    layer_name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    **kwargs,\n):\n    \"\"\"Adds a Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    if layer_name is None and \"name\" in kwargs:\n        layer_name = kwargs.pop(\"name\")\n    layer = planet_tile_by_month(year, month, layer_name, api_key, token_name)\n    self.add(layer)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, layer_name=None, api_key=None, token_name='PLANET_API_KEY', **kwargs)</code>","text":"<p>Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_planet_by_quarter(\n    self,\n    year=2016,\n    quarter=1,\n    layer_name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    **kwargs,\n):\n    \"\"\"Adds a Planet global mosaic by quarter to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-12. Defaults to 1.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n    \"\"\"\n    if layer_name is None and \"name\" in kwargs:\n        layer_name = kwargs.pop(\"name\")\n    layer = planet_tile_by_quarter(year, quarter, layer_name, api_key, token_name)\n    self.add(layer)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_pmtiles","title":"<code>add_pmtiles(self, url, style=None, name='PMTiles', show=True, zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a PMTiles layer to the map. This function is not officially supported yet by ipyleaflet yet. Install it with the following command: pip install git+https://github.com/giswqs/ipyleaflet.git@pmtiles</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>style</code> <code>str</code> <p>The CSS style to apply to the layer. Defaults to None. See https://docs.mapbox.com/style-spec/reference/layers/ for more info.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>'PMTiles'</code> <code>show</code> <code>bool</code> <p>Whether the layer should be shown initially. Defaults to True.</p> <code>True</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the PMTilesLayer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_pmtiles(\n    self,\n    url,\n    style=None,\n    name=\"PMTiles\",\n    show=True,\n    zoom_to_layer=True,\n    **kwargs,\n):\n    \"\"\"\n    Adds a PMTiles layer to the map. This function is not officially supported yet by ipyleaflet yet.\n    Install it with the following command:\n    pip install git+https://github.com/giswqs/ipyleaflet.git@pmtiles\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        style (str, optional): The CSS style to apply to the layer. Defaults to None.\n            See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n        name (str, optional): The name of the layer. Defaults to None.\n        show (bool, optional): Whether the layer should be shown initially. Defaults to True.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n    Returns:\n        None\n    \"\"\"\n\n    try:\n        if \"sources\" in kwargs:\n            del kwargs[\"sources\"]\n\n        if \"version\" in kwargs:\n            del kwargs[\"version\"]\n\n        if style is None:\n            style = pmtiles_style(url)\n\n        layer = ipyleaflet.PMTilesLayer(\n            url=url,\n            style=style,\n            name=name,\n            visible=show,\n            **kwargs,\n        )\n        self.add(layer)\n\n        if zoom_to_layer:\n            metadata = pmtiles_metadata(url)\n            bounds = metadata[\"bounds\"]\n            self.zoom_to_bounds(bounds)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_point_layer","title":"<code>add_point_layer(self, filename, popup=None, layer_name='Marker Cluster', **kwargs)</code>","text":"<p>Adds a point layer to the map with a popup attribute.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)</p> required <code>popup</code> <code>str | list</code> <p>Column name(s) to be used for popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>A layer name to use. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the specified column name does not exist.</p> <code>ValueError</code> <p>If the specified column names do not exist.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_point_layer(\n    self, filename, popup=None, layer_name=\"Marker Cluster\", **kwargs\n):\n    \"\"\"Adds a point layer to the map with a popup attribute.\n\n    Args:\n        filename (str): str, http url, path object or file-like object. Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO)\n        popup (str | list, optional): Column name(s) to be used for popup. Defaults to None.\n        layer_name (str, optional): A layer name to use. Defaults to \"Marker Cluster\".\n\n    Raises:\n        ValueError: If the specified column name does not exist.\n        ValueError: If the specified column names do not exist.\n    \"\"\"\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    self.default_style = {\"cursor\": \"wait\"}\n\n    if isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        if not filename.startswith(\"http\"):\n            filename = os.path.abspath(filename)\n        ext = os.path.splitext(filename)[1].lower()\n        if ext == \".kml\":\n            fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n            gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n        else:\n            gdf = gpd.read_file(filename, **kwargs)\n    df = gdf.to_crs(epsg=\"4326\")\n    col_names = df.columns.values.tolist()\n    if popup is not None:\n        if isinstance(popup, str) and (popup not in col_names):\n            raise ValueError(\n                f\"popup must be one of the following: {', '.join(col_names)}\"\n            )\n        elif isinstance(popup, list) and (\n            not all(item in col_names for item in popup)\n        ):\n            raise ValueError(\n                f\"All popup items must be select from: {', '.join(col_names)}\"\n            )\n\n    df[\"x\"] = df.geometry.x\n    df[\"y\"] = df.geometry.y\n\n    points = list(zip(df[\"y\"], df[\"x\"]))\n\n    if popup is not None:\n        if isinstance(popup, str):\n            labels = df[popup]\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                )\n                for index, point in enumerate(points)\n            ]\n        elif isinstance(popup, list):\n            labels = []\n            for i in range(len(points)):\n                label = \"\"\n                for item in popup:\n                    label = label + str(item) + \": \" + str(df[item][i]) + \"&lt;br&gt;\"\n                labels.append(label)\n            df[\"popup\"] = labels\n\n            markers = [\n                ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(labels[index]),\n                )\n                for index, point in enumerate(points)\n            ]\n\n    else:\n        markers = [\n            ipyleaflet.Marker(location=point, draggable=False) for point in points\n        ]\n\n    marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n    self.add(marker_cluster)\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_points_from_xy","title":"<code>add_points_from_xy(self, data, x='longitude', y='latitude', popup=None, layer_name='Marker Cluster', color_column=None, marker_colors=None, icon_colors=['white'], icon_names=['info'], spin=False, add_legend=True, max_cluster_radius=80, **kwargs)</code>","text":"<p>Adds a marker cluster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>popup</code> <code>list</code> <p>A list of column names to be used as the popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"Marker Cluster\".</p> <code>'Marker Cluster'</code> <code>color_column</code> <code>str</code> <p>The column name for the color values. Defaults to None.</p> <code>None</code> <code>marker_colors</code> <code>list</code> <p>A list of colors to be used for the markers. Defaults to None.</p> <code>None</code> <code>icon_colors</code> <code>list</code> <p>A list of colors to be used for the icons. Defaults to ['white'].</p> <code>['white']</code> <code>icon_names</code> <code>list</code> <p>A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].</p> <code>['info']</code> <code>spin</code> <code>bool</code> <p>If True, the icon will spin. Defaults to False.</p> <code>False</code> <code>add_legend</code> <code>bool</code> <p>If True, a legend will be added to the map. Defaults to True.</p> <code>True</code> <code>max_cluster_radius</code> <code>int</code> <p>The maximum cluster radius. Defaults to 80.</p> <code>80</code> <code>**kwargs</code> <p>Other keyword arguments to pass to ipyleaflet.MarkerCluster(). For a list of available options, see https://github.com/Leaflet/Leaflet.markercluster.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_points_from_xy(\n    self,\n    data,\n    x=\"longitude\",\n    y=\"latitude\",\n    popup=None,\n    layer_name=\"Marker Cluster\",\n    color_column=None,\n    marker_colors=None,\n    icon_colors=[\"white\"],\n    icon_names=[\"info\"],\n    spin=False,\n    add_legend=True,\n    max_cluster_radius=80,\n    **kwargs,\n):\n    \"\"\"Adds a marker cluster to the map.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        popup (list, optional): A list of column names to be used as the popup. Defaults to None.\n        layer_name (str, optional): The name of the layer. Defaults to \"Marker Cluster\".\n        color_column (str, optional): The column name for the color values. Defaults to None.\n        marker_colors (list, optional): A list of colors to be used for the markers. Defaults to None.\n        icon_colors (list, optional): A list of colors to be used for the icons. Defaults to ['white'].\n        icon_names (list, optional): A list of names to be used for the icons. More icons can be found at https://fontawesome.com/v4/icons. Defaults to ['info'].\n        spin (bool, optional): If True, the icon will spin. Defaults to False.\n        add_legend (bool, optional): If True, a legend will be added to the map. Defaults to True.\n        max_cluster_radius (int, optional): The maximum cluster radius. Defaults to 80.\n        **kwargs: Other keyword arguments to pass to ipyleaflet.MarkerCluster(). For a list of available options,\n            see https://github.com/Leaflet/Leaflet.markercluster.\n\n    \"\"\"\n    import pandas as pd\n\n    color_options = [\n        \"red\",\n        \"blue\",\n        \"green\",\n        \"purple\",\n        \"orange\",\n        \"darkred\",\n        \"lightred\",\n        \"beige\",\n        \"darkblue\",\n        \"darkgreen\",\n        \"cadetblue\",\n        \"darkpurple\",\n        \"white\",\n        \"pink\",\n        \"lightblue\",\n        \"lightgreen\",\n        \"gray\",\n        \"black\",\n        \"lightgray\",\n    ]\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif not data.startswith(\"http\") and (not os.path.exists(data)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    elif data.endswith(\".csv\"):\n        df = pd.read_csv(data)\n    else:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        df = gdf_to_df(gdf)\n\n    df = points_from_xy(df, x, y)\n\n    col_names = df.columns.values.tolist()\n\n    if color_column is not None and color_column not in col_names:\n        raise ValueError(\n            f\"The color column {color_column} does not exist in the dataframe.\"\n        )\n\n    if color_column is not None:\n        items = list(set(df[color_column]))\n\n    else:\n        items = None\n\n    if color_column is not None and marker_colors is None:\n        if len(items) &gt; len(color_options):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is greater than the number of available colors.\"\n            )\n        else:\n            marker_colors = color_options[: len(items)]\n    elif color_column is not None and marker_colors is not None:\n        if len(items) != len(marker_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if items is not None:\n        if len(icon_colors) == 1:\n            icon_colors = icon_colors * len(items)\n        elif len(items) != len(icon_colors):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n        if len(icon_names) == 1:\n            icon_names = icon_names * len(items)\n        elif len(items) != len(icon_names):\n            raise ValueError(\n                f\"The number of unique values in the color column {color_column} is not equal to the number of available colors.\"\n            )\n\n    if \"geometry\" in col_names:\n        col_names.remove(\"geometry\")\n\n    if popup is not None:\n        if isinstance(popup, str) and (popup not in col_names):\n            raise ValueError(\n                f\"popup must be one of the following: {', '.join(col_names)}\"\n            )\n        elif isinstance(popup, list) and (\n            not all(item in col_names for item in popup)\n        ):\n            raise ValueError(\n                f\"All popup items must be select from: {', '.join(col_names)}\"\n            )\n    else:\n        popup = col_names\n\n    df[\"x\"] = df.geometry.x\n    df[\"y\"] = df.geometry.y\n\n    points = list(zip(df[\"y\"], df[\"x\"]))\n\n    if popup is not None:\n        if isinstance(popup, str):\n            labels = df[popup]\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(str(labels[index])),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n        elif isinstance(popup, list):\n            labels = []\n            for i in range(len(points)):\n                label = \"\"\n                for item in popup:\n                    label = (\n                        label\n                        + \"&lt;b&gt;\"\n                        + str(item)\n                        + \"&lt;/b&gt;\"\n                        + \": \"\n                        + str(df[item][i])\n                        + \"&lt;br&gt;\"\n                    )\n                labels.append(label)\n            df[\"popup\"] = labels\n\n            markers = []\n            for index, point in enumerate(points):\n                if items is not None:\n                    marker_color = marker_colors[\n                        items.index(df[color_column][index])\n                    ]\n                    icon_name = icon_names[items.index(df[color_column][index])]\n                    icon_color = icon_colors[items.index(df[color_column][index])]\n                    marker_icon = ipyleaflet.AwesomeIcon(\n                        name=icon_name,\n                        marker_color=marker_color,\n                        icon_color=icon_color,\n                        spin=spin,\n                    )\n                else:\n                    marker_icon = None\n\n                marker = ipyleaflet.Marker(\n                    location=point,\n                    draggable=False,\n                    popup=widgets.HTML(labels[index]),\n                    icon=marker_icon,\n                )\n                markers.append(marker)\n\n    else:\n        markers = []\n        for point in points:\n            if items is not None:\n                marker_color = marker_colors[items.index(df[color_column][index])]\n                icon_name = icon_names[items.index(df[color_column][index])]\n                icon_color = icon_colors[items.index(df[color_column][index])]\n                marker_icon = ipyleaflet.AwesomeIcon(\n                    name=icon_name,\n                    marker_color=marker_color,\n                    icon_color=icon_color,\n                    spin=spin,\n                )\n            else:\n                marker_icon = None\n\n            marker = ipyleaflet.Marker(\n                location=point, draggable=False, icon=marker_icon\n            )\n            markers.append(marker)\n\n    marker_cluster = ipyleaflet.MarkerCluster(\n        markers=markers,\n        name=layer_name,\n        max_cluster_radius=max_cluster_radius,\n        **kwargs,\n    )\n    self.add(marker_cluster)\n\n    if items is not None and add_legend:\n        marker_colors = [check_color(c) for c in marker_colors]\n        self.add_legend(\n            title=color_column.title(), colors=marker_colors, labels=items\n        )\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name='Raster', layer_index=None, zoom_to_layer=True, visible=True, opacity=1.0, array_args={}, client_args={'cors_all': False}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and     if the raster does not render properly, try installing jupyter-server-proxy using <code>pip install jupyter-server-proxy</code>,     then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> <code>'Raster'</code> <code>layer_index</code> <code>int</code> <p>The index of the layer. Defaults to None.</p> <code>None</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>{}</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.</p> <code>{'cors_all': False}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=\"Raster\",\n    layer_index=None,\n    zoom_to_layer=True,\n    visible=True,\n    opacity=1.0,\n    array_args={},\n    client_args={\"cors_all\": False},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer) and\n        if the raster does not render properly, try installing jupyter-server-proxy using `pip install jupyter-server-proxy`,\n        then running the following code before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        layer_index (int, optional): The index of the layer. Defaults to None.\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to True.\n        visible (bool, optional): Whether the layer is visible. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        array_args (dict, optional): Additional arguments to pass to `array_to_memory_file` when reading the raster. Defaults to {}.\n        client_args (dict, optional): Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n    \"\"\"\n    import numpy as np\n    import xarray as xr\n\n    if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n        source = array_to_image(source, **array_args)\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        opacity=opacity,\n        attribution=attribution,\n        layer_name=layer_name,\n        client_args=client_args,\n        return_client=True,\n        **kwargs,\n    )\n    tile_layer.visible = visible\n\n    self.add(tile_layer, index=layer_index)\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = (\n        bounds[2],\n        bounds[0],\n        bounds[3],\n        bounds[1],\n    )  # [minx, miny, maxx, maxy]\n    if zoom_to_layer:\n        self.zoom_to_bounds(bounds)\n\n    arc_add_layer(tile_layer.url, layer_name, True, 1.0)\n    if zoom_to_layer:\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    if indexes is None:\n        if len(tile_client.band_names) == 1:\n            indexes = [1]\n        else:\n            indexes = [1, 2, 3]\n\n    vis_bands = [tile_client.band_names[i - 1] for i in indexes]\n\n    params = {\n        \"tile_layer\": tile_layer,\n        \"tile_client\": tile_client,\n        \"indexes\": indexes,\n        \"vis_bands\": vis_bands,\n        \"band_names\": tile_client.band_names,\n        \"bounds\": bounds,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"nodata\": nodata,\n        \"colormap\": colormap,\n        \"opacity\": opacity,\n        \"layer_name\": layer_name,\n        \"filename\": tile_client.filename,\n        \"type\": \"LOCAL\",\n    }\n    self.cog_layer_dict[layer_name] = params\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_raster_legacy","title":"<code>add_raster_legacy(self, image, bands=None, layer_name=None, colormap=None, x_dim='x', y_dim='y', fit_bounds=True)</code>","text":"<p>Adds a local raster dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image file path.</p> required <code>bands</code> <code>int or list</code> <p>The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the raster. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.</p> <code>None</code> <code>x_dim</code> <code>str</code> <p>The x dimension. Defaults to 'x'.</p> <code>'x'</code> <code>y_dim</code> <code>str</code> <p>The y dimension. Defaults to 'y'.</p> <code>'y'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map bounds to raster bounds.  Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_raster_legacy(\n    self,\n    image,\n    bands=None,\n    layer_name=None,\n    colormap=None,\n    x_dim=\"x\",\n    y_dim=\"y\",\n    fit_bounds=True,\n):\n    \"\"\"Adds a local raster dataset to the map.\n\n    Args:\n        image (str): The image file path.\n        bands (int or list, optional): The image bands to use. It can be either a number (e.g., 1) or a list (e.g., [3, 2, 1]). Defaults to None.\n        layer_name (str, optional): The layer name to use for the raster. Defaults to None.\n        colormap (str, optional): The name of the colormap to use for the raster, such as 'gray' and 'terrain'. More can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html. Defaults to None.\n        x_dim (str, optional): The x dimension. Defaults to 'x'.\n        y_dim (str, optional): The y dimension. Defaults to 'y'.\n        fit_bounds (bool, optional): Whether to fit map bounds to raster bounds.  Defaults to True.\n    \"\"\"\n    try:\n        import xarray_leaflet\n\n    except Exception:\n        # import platform\n        # if platform.system() != \"Windows\":\n        #     # install_from_github(\n        #     #     url='https://github.com/davidbrochart/xarray_leaflet')\n        #     check_install('xarray_leaflet')\n        #     import xarray_leaflet\n        # else:\n        raise ImportError(\n            \"You need to install xarray_leaflet first. See https://github.com/davidbrochart/xarray_leaflet\"\n        )\n\n    import warnings\n    import numpy as np\n    import rioxarray\n\n    # import xarray as xr\n    import matplotlib.pyplot as plt\n    import matplotlib as mpl\n\n    warnings.simplefilter(\"ignore\")\n\n    if isinstance(image, str):\n        if not os.path.exists(image):\n            print(\"The image file does not exist.\")\n            return\n\n    if colormap is None:\n        colormap = plt.cm.inferno\n\n    if layer_name is None:\n        layer_name = \"Layer_\" + random_string()\n\n    if isinstance(colormap, str):\n        colormap = mpl.colormaps[colormap]\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, masked=True)\n    else:\n        da = image\n\n    # print(da.rio.nodata)\n\n    multi_band = False\n    if len(da.band) &gt; 1:\n        multi_band = True\n        if bands is None:\n            bands = [3, 2, 1]\n    else:\n        bands = 1\n\n    if multi_band:\n        da = da.rio.write_nodata(0)\n    else:\n        da = da.rio.write_nodata(np.nan)\n    da = da.sel(band=bands)\n\n    # crs = da.rio.crs\n    # nan = da.attrs['nodatavals'][0]\n    # da = da / da.max()\n    # # if multi_band:\n    # da = xr.where(da == nan, np.nan, da)\n    # da = da.rio.write_nodata(0)\n    # da = da.rio.write_crs(crs)\n\n    if multi_band and type(bands) == list:\n        layer = da.leaflet.plot(\n            self, x_dim=x_dim, y_dim=y_dim, rgb_dim=\"band\", fit_bounds=fit_bounds\n        )\n    else:\n        layer = da.leaflet.plot(\n            self, x_dim=x_dim, y_dim=y_dim, colormap=colormap, fit_bounds=fit_bounds\n        )\n\n    layer.name = layer_name\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_remote_tile","title":"<code>add_remote_tile(self, source, band=None, palette=None, vmin=None, vmax=None, nodata=None, attribution=None, layer_name=None, **kwargs)</code>","text":"<p>Add a remote Cloud Optimized GeoTIFF (COG) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the remote Cloud Optimized GeoTIFF.</p> required <code>band</code> <code>int</code> <p>The band to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>palette</code> <code>str</code> <p>The name of the color palette from <code>palettable</code> to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_remote_tile(\n    self,\n    source,\n    band=None,\n    palette=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    layer_name=None,\n    **kwargs,\n):\n    \"\"\"Add a remote Cloud Optimized GeoTIFF (COG) to the map.\n\n    Args:\n        source (str): The path to the remote Cloud Optimized GeoTIFF.\n        band (int, optional): The band to use. Band indexing starts at 1. Defaults to None.\n        palette (str, optional): The name of the color palette from `palettable` to use when plotting a single band. See https://jiffyclub.github.io/palettable. Default is greyscale\n        vmin (float, optional): The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to None.\n    \"\"\"\n    if isinstance(source, str) and source.startswith(\"http\"):\n        self.add_raster(\n            source,\n            band=band,\n            palette=palette,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            attribution=attribution,\n            layer_name=layer_name,\n            **kwargs,\n        )\n    else:\n        raise Exception(\"The source must be a URL.\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_search_control","title":"<code>add_search_control(self, url, marker=None, zoom=None, position='topleft', **kwargs)</code>","text":"<p>Adds a search control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".</p> required <code>marker</code> <code>ipyleaflet.Marker</code> <p>The marker to be used for the search result. Defaults to None.</p> <code>None</code> <code>zoom</code> <code>int</code> <p>The zoom level to be used for the search result. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the search control. Defaults to \"topleft\".</p> <code>'topleft'</code> <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_search_control(\n    self, url, marker=None, zoom=None, position=\"topleft\", **kwargs\n):\n    \"\"\"Adds a search control to the map.\n\n    Args:\n        url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n        marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n        zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n        position (str, optional): The position of the search control. Defaults to \"topleft\".\n        kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n    \"\"\"\n    if marker is None:\n        marker = ipyleaflet.Marker(\n            icon=ipyleaflet.AwesomeIcon(\n                name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n            )\n        )\n    search_control = ipyleaflet.SearchControl(\n        position=position,\n        url=url,\n        zoom=zoom,\n        marker=marker,\n    )\n    self.add(search_control)\n    self.search_control = search_control\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_shp","title":"<code>add_shp(self, in_shp, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=False, encoding='utf-8')</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input file path or HTTP URL (*.zip) to the shapefile.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer after adding it to the map. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding of the shapefile. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shapefile could not be found.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_shp(\n    self,\n    in_shp,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=False,\n    encoding=\"utf-8\",\n):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        in_shp (str): The input file path or HTTP URL (*.zip) to the shapefile.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        zoom_to_layer (bool, optional): Whether to zoom to the layer after adding it to the map. Defaults to False.\n        encoding (str, optional): The encoding of the shapefile. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided shapefile could not be found.\n    \"\"\"\n\n    import glob\n\n    if in_shp.startswith(\"http\") and in_shp.endswith(\".zip\"):\n        out_dir = os.path.dirname(temp_file_path(\".shp\"))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        basename = os.path.basename(in_shp)\n        filename = os.path.join(out_dir, basename)\n        download_file(in_shp, filename)\n        files = list(glob.glob(os.path.join(out_dir, \"*.shp\")))\n        if len(files) &gt; 0:\n            in_shp = files[0]\n        else:\n            raise FileNotFoundError(\n                \"The downloaded zip file does not contain any shapefile in the root directory.\"\n            )\n    else:\n        in_shp = os.path.abspath(in_shp)\n        if not os.path.exists(in_shp):\n            raise FileNotFoundError(\"The provided shapefile could not be found.\")\n\n    geojson = shp_to_geojson(in_shp, encoding=encoding)\n    self.add_geojson(\n        geojson,\n        layer_name,\n        style,\n        hover_style,\n        style_callback,\n        fill_colors,\n        info_mode,\n        zoom_to_layer,\n        encoding,\n    )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_stac_gui","title":"<code>add_stac_gui(self, position='topright', opened=True)</code>","text":"<p>Add the STAC search widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether the widget is open. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_stac_gui(self, position=\"topright\", opened=True):\n    \"\"\"Add the STAC search widget to the map.\n\n    Args:\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether the widget is open. Defaults to True.\n    \"\"\"\n    from .toolbar import stac_gui\n\n    stac_gui(self, position, opened)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='', opacity=1.0, shown=True, fit_bounds=True, layer_index=None, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.</p> <code>True</code> <code>layer_index</code> <code>int</code> <p>The index at which to add the layer. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url=None,\n    collection=None,\n    item=None,\n    assets=None,\n    bands=None,\n    titiler_endpoint=None,\n    name=\"STAC Layer\",\n    attribution=\"\",\n    opacity=1.0,\n    shown=True,\n    fit_bounds=True,\n    layer_index=None,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        fit_bounds (bool, optional): A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.\n        layer_index (int, optional): The index at which to add the layer. Defaults to None.\n    \"\"\"\n    if \"colormap_name\" in kwargs and kwargs[\"colormap_name\"] is None:\n        kwargs.pop(\"colormap_name\")\n\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    bounds = stac_bounds(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity, shown, layer_index)\n    if fit_bounds:\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n        arc_zoom_to_extent(bounds[0], bounds[1], bounds[2], bounds[3])\n\n    if not hasattr(self, \"cog_layer_dict\"):\n        self.cog_layer_dict = {}\n\n    if assets is None and bands is not None:\n        assets = bands\n\n    if isinstance(assets, str) and \",\" in assets:\n        assets = assets.split(\",\")\n\n    if \"rescale\" in kwargs:\n        rescale = kwargs[\"rescale\"]\n        vmin, vmax = [float(v) for v in rescale.split(\",\")]\n    else:\n        vmin, vmax = stac_min_max(url, collection, item, assets, titiler_endpoint)\n\n    if \"nodata\" in kwargs:\n        nodata = kwargs[\"nodata\"]\n    else:\n        nodata = None\n\n    band_names = stac_bands(url, collection, item, titiler_endpoint)\n    indexes = [band_names.index(band) + 1 for band in assets]\n\n    params = {\n        \"url\": url,\n        \"titiler_endpoint\": titiler_endpoint,\n        \"collection\": collection,\n        \"item\": item,\n        \"assets\": assets,\n        \"tile_layer\": self.find_layer(name),\n        \"indexes\": indexes,\n        \"vis_bands\": assets,\n        \"band_names\": band_names,\n        \"bounds\": bounds,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"nodata\": nodata,\n        \"opacity\": opacity,\n        \"layer_name\": name,\n        \"type\": \"STAC\",\n    }\n\n    self.cog_layer_dict[name] = params\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_text","title":"<code>add_text(self, text, fontsize=20, fontcolor='black', bold=False, padding='5px', background=True, bg_color='white', border_radius='5px', position='bottomright', **kwargs)</code>","text":"<p>Add text to the map.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add.</p> required <code>fontsize</code> <code>int</code> <p>The font size. Defaults to 20.</p> <code>20</code> <code>fontcolor</code> <code>str</code> <p>The font color. Defaults to \"black\".</p> <code>'black'</code> <code>bold</code> <code>bool</code> <p>Whether to use bold font. Defaults to False.</p> <code>False</code> <code>padding</code> <code>str</code> <p>The padding. Defaults to \"5px\".</p> <code>'5px'</code> <code>background</code> <code>bool</code> <p>Whether to use background. Defaults to True.</p> <code>True</code> <code>bg_color</code> <code>str</code> <p>The background color. Defaults to \"white\".</p> <code>'white'</code> <code>border_radius</code> <code>str</code> <p>The border radius. Defaults to \"5px\".</p> <code>'5px'</code> <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_text(\n    self,\n    text,\n    fontsize=20,\n    fontcolor=\"black\",\n    bold=False,\n    padding=\"5px\",\n    background=True,\n    bg_color=\"white\",\n    border_radius=\"5px\",\n    position=\"bottomright\",\n    **kwargs,\n):\n    \"\"\"Add text to the map.\n\n    Args:\n        text (str): The text to add.\n        fontsize (int, optional): The font size. Defaults to 20.\n        fontcolor (str, optional): The font color. Defaults to \"black\".\n        bold (bool, optional): Whether to use bold font. Defaults to False.\n        padding (str, optional): The padding. Defaults to \"5px\".\n        background (bool, optional): Whether to use background. Defaults to True.\n        bg_color (str, optional): The background color. Defaults to \"white\".\n        border_radius (str, optional): The border radius. Defaults to \"5px\".\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n    \"\"\"\n\n    if background:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n        padding: {padding}; background-color: {bg_color};\n        border-radius: {border_radius};\"&gt;{text}&lt;/div&gt;\"\"\"\n    else:\n        text = f\"\"\"&lt;div style=\"font-size: {fontsize}px; color: {fontcolor}; font-weight: {'bold' if bold else 'normal'};\n        padding: {padding};\"&gt;{text}&lt;/div&gt;\"\"\"\n\n    self.add_html(text, position=position, **kwargs)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_tile_layer","title":"<code>add_tile_layer(self, url, name, attribution, opacity=1.0, shown=True, layer_index=None, **kwargs)</code>","text":"<p>Adds a TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer.</p> required <code>attribution</code> <code>str</code> <p>The attribution to use.</p> required <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>layer_index</code> <code>int</code> <p>The index at which to add the layer. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_tile_layer(\n    self,\n    url,\n    name,\n    attribution,\n    opacity=1.0,\n    shown=True,\n    layer_index=None,\n    **kwargs,\n):\n    \"\"\"Adds a TileLayer to the map.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str): The layer name to use for the layer.\n        attribution (str): The attribution to use.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n        layer_index (int, optional): The index at which to add the layer. Defaults to None.\n    \"\"\"\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 30\n    try:\n        tile_layer = ipyleaflet.TileLayer(\n            url=url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            visible=shown,\n            **kwargs,\n        )\n        self.add(tile_layer, index=layer_index)\n\n        arc_add_layer(url, name, shown, opacity)\n\n    except Exception as e:\n        print(\"Failed to add the specified TileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_time_slider","title":"<code>add_time_slider(self, layers={}, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary containing a set of XYZ tile layers.</p> <code>{}</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the selected layer. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_time_slider(\n    self,\n    layers={},\n    labels=None,\n    time_interval=1,\n    position=\"bottomright\",\n    slider_length=\"150px\",\n    zoom_to_layer=False,\n    **kwargs,\n):\n    \"\"\"Adds a time slider to the map.\n\n    Args:\n        layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n        labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n    \"\"\"\n    from .toolbar import time_slider\n\n    time_slider(\n        self,\n        layers,\n        labels,\n        time_interval,\n        position,\n        slider_length,\n        zoom_to_layer,\n        **kwargs,\n    )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_vector","title":"<code>add_vector(self, filename, layer_name='Untitled', bbox=None, mask=None, rows=None, style={}, hover_style={}, style_callback=None, fill_colors=['black'], info_mode='on_hover', zoom_to_layer=False, encoding='utf-8', **kwargs)</code>","text":"<p>Adds any geopandas-supported vector dataset to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> <code>'on_hover'</code> <code>encoding</code> <code>str</code> <p>The encoding to use to read the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_vector(\n    self,\n    filename,\n    layer_name=\"Untitled\",\n    bbox=None,\n    mask=None,\n    rows=None,\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    info_mode=\"on_hover\",\n    zoom_to_layer=False,\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Adds any geopandas-supported vector dataset to the map.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        layer_name (str, optional): The layer name to use. Defaults to \"Untitled\".\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding to use to read the file. Defaults to \"utf-8\".\n\n    \"\"\"\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    else:\n        filename = github_raw_url(filename)\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".shp\":\n        self.add_shp(\n            filename,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            encoding,\n        )\n    elif ext in [\".json\", \".geojson\"]:\n        self.add_geojson(\n            filename,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n            encoding,\n        )\n    else:\n        geojson = vector_to_geojson(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            epsg=\"4326\",\n            **kwargs,\n        )\n\n        self.add_geojson(\n            geojson,\n            layer_name,\n            style,\n            hover_style,\n            style_callback,\n            fill_colors,\n            info_mode,\n            zoom_to_layer,\n            encoding,\n        )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_vector_tile","title":"<code>add_vector_tile(self, url, styles={}, layer_name='Vector Tile', **kwargs)</code>","text":"<p>Adds a VectorTileLayer to the map. It wraps the ipyleaflet.VectorTileLayer class. See     https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer</p> required <code>styles</code> <code>dict,optional</code> <p>Style dict, specific to the vector tile source.</p> <code>{}</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Vector Tile'.</p> <code>'Vector Tile'</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the ipyleaflet.VectorTileLayer class.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_vector_tile(\n    self,\n    url,\n    styles: Optional[dict] = {},\n    layer_name: Optional[str] = \"Vector Tile\",\n    **kwargs,\n):\n    \"\"\"Adds a VectorTileLayer to the map. It wraps the ipyleaflet.VectorTileLayer class. See\n        https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html\n\n    Args:\n        url (str, optional): The URL of the tile layer\n        styles (dict,optional): Style dict, specific to the vector tile source.\n        layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n        kwargs: Additional keyword arguments to pass to the ipyleaflet.VectorTileLayer class.\n    \"\"\"\n    if \"vector_tile_layer_styles\" in kwargs:\n        styles = kwargs[\"vector_tile_layer_styles\"]\n        del kwargs[\"vector_tile_layer_styles\"]\n    try:\n        vector_tile_layer = ipyleaflet.VectorTileLayer(\n            url=url,\n            vector_tile_layer_styles=styles,\n            **kwargs,\n        )\n        vector_tile_layer.name = layer_name\n        self.add(vector_tile_layer)\n\n    except Exception as e:\n        print(\"Failed to add the specified VectorTileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_vector_tile_layer","title":"<code>add_vector_tile_layer(self, url, styles={}, layer_name='Vector Tile', **kwargs)</code>","text":"<p>Adds a VectorTileLayer to the map. It wraps the ipyleaflet.VectorTileLayer class. See     https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer</p> required <code>styles</code> <code>dict,optional</code> <p>Style dict, specific to the vector tile source.</p> <code>{}</code> <code>layer_name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Vector Tile'.</p> <code>'Vector Tile'</code> <code>kwargs</code> <p>Additional keyword arguments to pass to the ipyleaflet.VectorTileLayer class.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_vector_tile(\n    self,\n    url,\n    styles: Optional[dict] = {},\n    layer_name: Optional[str] = \"Vector Tile\",\n    **kwargs,\n):\n    \"\"\"Adds a VectorTileLayer to the map. It wraps the ipyleaflet.VectorTileLayer class. See\n        https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html\n\n    Args:\n        url (str, optional): The URL of the tile layer\n        styles (dict,optional): Style dict, specific to the vector tile source.\n        layer_name (str, optional): The layer name to use for the layer. Defaults to 'Vector Tile'.\n        kwargs: Additional keyword arguments to pass to the ipyleaflet.VectorTileLayer class.\n    \"\"\"\n    if \"vector_tile_layer_styles\" in kwargs:\n        styles = kwargs[\"vector_tile_layer_styles\"]\n        del kwargs[\"vector_tile_layer_styles\"]\n    try:\n        vector_tile_layer = ipyleaflet.VectorTileLayer(\n            url=url,\n            vector_tile_layer_styles=styles,\n            **kwargs,\n        )\n        vector_tile_layer.name = layer_name\n        self.add(vector_tile_layer)\n\n    except Exception as e:\n        print(\"Failed to add the specified VectorTileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_velocity","title":"<code>add_velocity(self, data, zonal_speed, meridional_speed, latitude_dimension='lat', longitude_dimension='lon', level_dimension='lev', level_index=0, time_index=0, velocity_scale=0.01, max_velocity=20, display_options={}, name='Velocity', color_scale=None)</code>","text":"<p>Add a velocity layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | xr.Dataset</code> <p>The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.</p> required <code>zonal_speed</code> <code>str</code> <p>Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.</p> required <code>meridional_speed</code> <code>str</code> <p>Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.</p> required <code>latitude_dimension</code> <code>str</code> <p>Name of the latitude dimension in the dataset. Defaults to 'lat'.</p> <code>'lat'</code> <code>longitude_dimension</code> <code>str</code> <p>Name of the longitude dimension in the dataset. Defaults to 'lon'.</p> <code>'lon'</code> <code>level_dimension</code> <code>str</code> <p>Name of the level dimension in the dataset. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>The index of the level dimension to display. Defaults to 0.</p> <code>0</code> <code>time_index</code> <code>int</code> <p>The index of the time dimension to display. Defaults to 0.</p> <code>0</code> <code>velocity_scale</code> <code>float</code> <p>The scale of the velocity. Defaults to 0.01.</p> <code>0.01</code> <code>max_velocity</code> <code>int</code> <p>The maximum velocity to display. Defaults to 20.</p> <code>20</code> <code>display_options</code> <code>dict</code> <p>The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.</p> <code>{}</code> <code>name</code> <code>str</code> <p>Layer name to use . Defaults to 'Velocity'.</p> <code>'Velocity'</code> <code>color_scale</code> <code>list</code> <p>List of RGB color values for the velocity vector color scale. Defaults to []. See https://bit.ly/3uf8t6w.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray package is not installed.</p> <code>ValueError</code> <p>If the data is not a NetCDF file or an xarray Dataset.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_velocity(\n    self,\n    data,\n    zonal_speed,\n    meridional_speed,\n    latitude_dimension=\"lat\",\n    longitude_dimension=\"lon\",\n    level_dimension=\"lev\",\n    level_index=0,\n    time_index=0,\n    velocity_scale=0.01,\n    max_velocity=20,\n    display_options={},\n    name=\"Velocity\",\n    color_scale=None,\n):\n    \"\"\"Add a velocity layer to the map.\n\n    Args:\n        data (str | xr.Dataset): The data to use for the velocity layer. It can be a file path to a NetCDF file or an xarray Dataset.\n        zonal_speed (str): Name of the zonal speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n        meridional_speed (str): Name of the meridional speed in the dataset. See https://en.wikipedia.org/wiki/Zonal_and_meridional_flow.\n        latitude_dimension (str, optional): Name of the latitude dimension in the dataset. Defaults to 'lat'.\n        longitude_dimension (str, optional): Name of the longitude dimension in the dataset. Defaults to 'lon'.\n        level_dimension (str, optional): Name of the level dimension in the dataset. Defaults to 'lev'.\n        level_index (int, optional): The index of the level dimension to display. Defaults to 0.\n        time_index (int, optional): The index of the time dimension to display. Defaults to 0.\n        velocity_scale (float, optional): The scale of the velocity. Defaults to 0.01.\n        max_velocity (int, optional): The maximum velocity to display. Defaults to 20.\n        display_options (dict, optional): The display options for the velocity layer. Defaults to {}. See https://bit.ly/3uf8t6w.\n        name (str, optional): Layer name to use . Defaults to 'Velocity'.\n        color_scale (list, optional): List of RGB color values for the velocity vector color scale. Defaults to []. See https://bit.ly/3uf8t6w.\n\n    Raises:\n        ImportError: If the xarray package is not installed.\n        ValueError: If the data is not a NetCDF file or an xarray Dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n        from ipyleaflet.velocity import Velocity\n    except ImportError:\n        raise ImportError(\n            \"The xarray package is required to add a velocity layer. \"\n            \"Please install it with `pip install xarray`.\"\n        )\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = download_file(data)\n        ds = xr.open_dataset(data)\n\n    elif isinstance(data, xr.Dataset):\n        ds = data\n    else:\n        raise ValueError(\"The data must be a file path or xarray dataset.\")\n\n    coords = list(ds.coords.keys())\n\n    # Rasterio does not handle time or levels. So we must drop them\n    if \"time\" in coords:\n        ds = ds.isel(time=time_index, drop=True)\n\n    params = {level_dimension: level_index}\n    if level_dimension in coords:\n        ds = ds.isel(drop=True, **params)\n\n    if color_scale is None:\n        color_scale = [\n            \"rgb(36,104, 180)\",\n            \"rgb(60,157, 194)\",\n            \"rgb(128,205,193)\",\n            \"rgb(151,218,168)\",\n            \"rgb(198,231,181)\",\n            \"rgb(238,247,217)\",\n            \"rgb(255,238,159)\",\n            \"rgb(252,217,125)\",\n            \"rgb(255,182,100)\",\n            \"rgb(252,150,75)\",\n            \"rgb(250,112,52)\",\n            \"rgb(245,64,32)\",\n            \"rgb(237,45,28)\",\n            \"rgb(220,24,32)\",\n            \"rgb(180,0,35)\",\n        ]\n\n    wind = Velocity(\n        data=ds,\n        zonal_speed=zonal_speed,\n        meridional_speed=meridional_speed,\n        latitude_dimension=latitude_dimension,\n        longitude_dimension=longitude_dimension,\n        velocity_scale=velocity_scale,\n        max_velocity=max_velocity,\n        display_options=display_options,\n        name=name,\n        color_scale=color_scale,\n    )\n    self.add(wind)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_widget","title":"<code>add_widget(self, content, position='bottomright', add_header=False, opened=True, show_close_button=True, widget_icon='gear', close_button_icon='times', widget_args={}, close_button_args={}, display_widget=None, **kwargs)</code>","text":"<p>Add a widget (e.g., text, HTML, figure) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str | ipywidgets.Widget | object</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>add_header</code> <code>bool</code> <p>Whether to add a header with close buttons to the widget. Defaults to False.</p> <code>False</code> <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <code>show_close_button</code> <code>bool</code> <p>Whether to show the close button. Defaults to True.</p> <code>True</code> <code>widget_icon</code> <code>str</code> <p>The icon name for the toolbar button. Defaults to 'gear'.</p> <code>'gear'</code> <code>close_button_icon</code> <code>str</code> <p>The icon name for the close button. Defaults to \"times\".</p> <code>'times'</code> <code>widget_args</code> <code>dict</code> <p>Additional arguments to pass to the toolbar button. Defaults to {}.</p> <code>{}</code> <code>close_button_args</code> <code>dict</code> <p>Additional arguments to pass to the close button. Defaults to {}.</p> <code>{}</code> <code>display_widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed when the toolbar is clicked.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the HTML or Output widgets</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_widget(\n    self,\n    content,\n    position=\"bottomright\",\n    add_header=False,\n    opened=True,\n    show_close_button=True,\n    widget_icon=\"gear\",\n    close_button_icon=\"times\",\n    widget_args={},\n    close_button_args={},\n    display_widget=None,\n    **kwargs,\n):\n    \"\"\"Add a widget (e.g., text, HTML, figure) to the map.\n\n    Args:\n        content (str | ipywidgets.Widget | object): The widget to add.\n        position (str, optional): The position of the widget. Defaults to \"bottomright\".\n        add_header (bool, optional): Whether to add a header with close buttons to the widget. Defaults to False.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n        show_close_button (bool, optional): Whether to show the close button. Defaults to True.\n        widget_icon (str, optional): The icon name for the toolbar button. Defaults to 'gear'.\n        close_button_icon (str, optional): The icon name for the close button. Defaults to \"times\".\n        widget_args (dict, optional): Additional arguments to pass to the toolbar button. Defaults to {}.\n        close_button_args (dict, optional): Additional arguments to pass to the close button. Defaults to {}.\n        display_widget (ipywidgets.Widget, optional): The widget to be displayed when the toolbar is clicked.\n        **kwargs: Additional arguments to pass to the HTML or Output widgets\n    \"\"\"\n\n    allowed_positions = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n\n    if position not in allowed_positions:\n        raise Exception(f\"position must be one of {allowed_positions}\")\n\n    if \"layout\" not in kwargs:\n        kwargs[\"layout\"] = widgets.Layout(padding=\"0px 4px 0px 4px\")\n    try:\n        if add_header:\n            if isinstance(content, str):\n                widget = widgets.HTML(value=content, **kwargs)\n            else:\n                widget = content\n\n            widget_template(\n                widget,\n                opened,\n                show_close_button,\n                widget_icon,\n                close_button_icon,\n                widget_args,\n                close_button_args,\n                display_widget,\n                self,\n                position,\n            )\n        else:\n            if isinstance(content, str):\n                widget = widgets.HTML(value=content, **kwargs)\n            else:\n                widget = widgets.Output(**kwargs)\n                with widget:\n                    display(content)\n            control = ipyleaflet.WidgetControl(widget=widget, position=position)\n            self.add(control)\n\n    except Exception as e:\n        raise Exception(f\"Error adding widget: {e}\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, attribution='', format='image/png', transparent=True, opacity=1.0, shown=True, **kwargs)</code>","text":"<p>Add a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS web service.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of WMS layers to show.</p> required <code>name</code> <code>str</code> <p>The layer name to use on the layer control. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution of the data layer. Defaults to ''.</p> <code>''</code> <code>format</code> <code>str</code> <p>WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>If True, the WMS service will return images with transparency. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>shown</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_wms_layer(\n    self,\n    url,\n    layers,\n    name=None,\n    attribution=\"\",\n    format=\"image/png\",\n    transparent=True,\n    opacity=1.0,\n    shown=True,\n    **kwargs,\n):\n    \"\"\"Add a WMS layer to the map.\n\n    Args:\n        url (str): The URL of the WMS web service.\n        layers (str): Comma-separated list of WMS layers to show.\n        name (str, optional): The layer name to use on the layer control. Defaults to None.\n        attribution (str, optional): The attribution of the data layer. Defaults to ''.\n        format (str, optional): WMS image format (use \u2018image/png\u2019 for layers with transparency). Defaults to 'image/png'.\n        transparent (bool, optional): If True, the WMS service will return images with transparency. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        shown (bool, optional): A flag indicating whether the layer should be on by default. Defaults to True.\n    \"\"\"\n\n    if name is None:\n        name = str(layers)\n\n    try:\n        wms_layer = ipyleaflet.WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            attribution=attribution,\n            format=format,\n            transparent=transparent,\n            opacity=opacity,\n            visible=shown,\n            **kwargs,\n        )\n        self.add(wms_layer)\n\n    except Exception as e:\n        print(\"Failed to add the specified WMS TileLayer.\")\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_xy_data","title":"<code>add_xy_data(self, in_csv, x='longitude', y='latitude', label=None, layer_name='Marker cluster')</code>","text":"<p>Adds points from a CSV file containing lat/lon information and display data on the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>x</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>label</code> <code>str</code> <p>The name of the column containing label information to used for marker popup. Defaults to None.</p> <code>None</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"Marker cluster\".</p> <code>'Marker cluster'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The specified input csv does not exist.</p> <code>ValueError</code> <p>The specified x column does not exist.</p> <code>ValueError</code> <p>The specified y column does not exist.</p> <code>ValueError</code> <p>The specified label column does not exist.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_xy_data(\n    self,\n    in_csv,\n    x=\"longitude\",\n    y=\"latitude\",\n    label=None,\n    layer_name=\"Marker cluster\",\n):\n    \"\"\"Adds points from a CSV file containing lat/lon information and display data on the map.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        x (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        y (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        label (str, optional): The name of the column containing label information to used for marker popup. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to \"Marker cluster\".\n\n    Raises:\n        FileNotFoundError: The specified input csv does not exist.\n        ValueError: The specified x column does not exist.\n        ValueError: The specified y column does not exist.\n        ValueError: The specified label column does not exist.\n    \"\"\"\n    import pandas as pd\n\n    if isinstance(in_csv, pd.DataFrame):\n        df = in_csv\n    elif not in_csv.startswith(\"http\") and (not os.path.exists(in_csv)):\n        raise FileNotFoundError(\"The specified input csv does not exist.\")\n    else:\n        df = pd.read_csv(in_csv)\n\n    col_names = df.columns.values.tolist()\n\n    if x not in col_names:\n        raise ValueError(f\"x must be one of the following: {', '.join(col_names)}\")\n\n    if y not in col_names:\n        raise ValueError(f\"y must be one of the following: {', '.join(col_names)}\")\n\n    if label is not None and (label not in col_names):\n        raise ValueError(\n            f\"label must be one of the following: {', '.join(col_names)}\"\n        )\n\n    self.default_style = {\"cursor\": \"wait\"}\n\n    points = list(zip(df[y], df[x]))\n\n    if label is not None:\n        labels = df[label]\n        markers = [\n            ipyleaflet.Marker(\n                location=point,\n                draggable=False,\n                popup=widgets.HTML(str(labels[index])),\n            )\n            for index, point in enumerate(points)\n        ]\n    else:\n        markers = [\n            ipyleaflet.Marker(location=point, draggable=False) for point in points\n        ]\n\n    marker_cluster = ipyleaflet.MarkerCluster(markers=markers, name=layer_name)\n    self.add(marker_cluster)\n\n    self.default_style = {\"cursor\": \"default\"}\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.add_xyz_service","title":"<code>add_xyz_service(self, provider, **kwargs)</code>","text":"<p>Add a XYZ tile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The provider is not valid. It must start with xyz or qms.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def add_xyz_service(self, provider, **kwargs):\n    \"\"\"Add a XYZ tile layer to the map.\n\n    Args:\n        provider (str): A tile layer name starts with xyz or qms. For example, xyz.OpenTopoMap,\n\n    Raises:\n        ValueError: The provider is not valid. It must start with xyz or qms.\n    \"\"\"\n    import xyzservices\n    import xyzservices.providers as xyz\n\n    if provider.startswith(\"xyz\"):\n        name = provider[4:]\n        xyz_provider = xyz.flatten()[name]\n        url = xyz_provider.build_url()\n        attribution = xyz_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    elif provider.startswith(\"qms\"):\n        name = provider[4:]\n        qms_provider = xyzservices.TileProvider.from_qms(name)\n        url = qms_provider.build_url()\n        attribution = qms_provider.attribution\n        if attribution.strip() == \"\":\n            attribution = \" \"\n        self.add_tile_layer(url, name, attribution)\n    else:\n        raise ValueError(\n            f\"The provider {provider} is not valid. It must start with xyz or qms.\"\n        )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.basemap_demo","title":"<code>basemap_demo(self)</code>","text":"<p>A demo for using leafmap basemaps.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def basemap_demo(self):\n    \"\"\"A demo for using leafmap basemaps.\"\"\"\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=\"Esri.WorldImagery\",\n        description=\"Basemaps\",\n    )\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n        old_basemap = self.layers[-1]\n        self.substitute_layer(old_basemap, get_basemap(basemap_name))\n\n    dropdown.observe(on_click, \"value\")\n    basemap_control = ipyleaflet.WidgetControl(widget=dropdown, position=\"topright\")\n    self.add(basemap_control)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.clear_drawings","title":"<code>clear_drawings(self)</code>","text":"<p>Clear drawings on the map.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def clear_drawings(self):\n    \"\"\"Clear drawings on the map.\"\"\"\n    self.draw_control.clear()\n    self.draw_features = []\n    self.user_rois = None\n    self.user_roi = None\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.edit_vector","title":"<code>edit_vector(self, data, **kwargs)</code>","text":"<p>Edit a vector layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | str</code> <p>The data to edit. It can be a GeoJSON dictionary or a file path.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def edit_vector(self, data, **kwargs):\n    \"\"\"Edit a vector layer.\n\n    Args:\n        data (dict | str): The data to edit. It can be a GeoJSON dictionary or a file path.\n    \"\"\"\n    if isinstance(data, str):\n        check_package(\"geopandas\", \"https://geopandas.org\")\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data, **kwargs)\n        geojson = gdf_to_geojson(gdf, epsg=4326, tuple_to_list=True)\n    elif isinstance(data, dict):\n        geojson = data\n    else:\n        raise ValueError(\n            \"The data must be a GeoJSON dictionary or a file path to a vector dataset.\"\n        )\n    self.draw_control.data = self.draw_control.data + (geojson[\"features\"])\n    self.draw_features = self.draw_features + (geojson[\"features\"])\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.find_layer","title":"<code>find_layer(self, name)</code>","text":"<p>Finds layer by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>object</code> <p>ipyleaflet layer object.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def find_layer(self, name):\n    \"\"\"Finds layer by name\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        object: ipyleaflet layer object.\n    \"\"\"\n    layers = self.layers\n\n    for layer in layers:\n        if layer.name == name:\n            return layer\n    return None\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.find_layer_index","title":"<code>find_layer_index(self, name)</code>","text":"<p>Finds layer index by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the layer with the specified name</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def find_layer_index(self, name):\n    \"\"\"Finds layer index by name\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        int: Index of the layer with the specified name\n    \"\"\"\n    layers = self.layers\n\n    for index, layer in enumerate(layers):\n        if layer.name == name:\n            return index\n\n    return -1\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.get_bbox","title":"<code>get_bbox(self)</code>","text":"<p>Get the bounds of the map as a list of [(]minx, miny, maxx, maxy].</p> <p>Returns:</p> Type Description <code>list</code> <p>The bounds of the map as a list of [(]minx, miny, maxx, maxy].</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_bbox(self):\n    \"\"\"Get the bounds of the map as a list of [(]minx, miny, maxx, maxy].\n\n    Returns:\n        list: The bounds of the map as a list of [(]minx, miny, maxx, maxy].\n    \"\"\"\n    bounds = self.bounds\n    bbox = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n    return bbox\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.get_draw_props","title":"<code>get_draw_props(self, n=None, return_df=False)</code>","text":"<p>Get the properties of the draw features.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The maximum number of attributes to return. Defaults to None.</p> <code>None</code> <code>return_df</code> <code>bool</code> <p>If True, return a pandas dataframe. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas dataframe containing the properties of the draw features.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_draw_props(self, n=None, return_df=False):\n    \"\"\"Get the properties of the draw features.\n\n    Args:\n        n (int, optional): The maximum number of attributes to return. Defaults to None.\n        return_df (bool, optional): If True, return a pandas dataframe. Defaults to False.\n\n    Returns:\n        pd.DataFrame: A pandas dataframe containing the properties of the draw features.\n    \"\"\"\n\n    import pandas as pd\n\n    props = self.edit_props[:]\n\n    for feature in self.draw_features:\n        for prop in feature[\"properties\"]:\n            if prop not in self.edit_props:\n                self.edit_props.append(prop)\n                props.append(prop)\n\n    if return_df:\n        if isinstance(n, int) and n &gt; len(props):\n            props = props + [\"\"] * (n - len(props))\n\n        df = pd.DataFrame({\"Key\": props, \"Value\": [\"\"] * len(props)})\n        df.index += 1\n        return df\n    else:\n        return props\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.get_layer_names","title":"<code>get_layer_names(self)</code>","text":"<p>Gets layer names as a list.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of layer names.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_layer_names(self):\n    \"\"\"Gets layer names as a list.\n\n    Returns:\n        list: A list of layer names.\n    \"\"\"\n    layer_names = []\n\n    for layer in list(self.layers):\n        if len(layer.name) &gt; 0:\n            layer_names.append(layer.name)\n\n    return layer_names\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.get_pc_collections","title":"<code>get_pc_collections(self)</code>","text":"<p>Get the list of Microsoft Planetary Computer collections.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_pc_collections(self):\n    \"\"\"Get the list of Microsoft Planetary Computer collections.\"\"\"\n    if not hasattr(self, \"pc_collections\"):\n        setattr(self, \"pc_collections\", get_pc_collections())\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.get_scale","title":"<code>get_scale(self)</code>","text":"<p>Returns the approximate pixel scale of the current map view, in meters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_scale(self):\n    \"\"\"Returns the approximate pixel scale of the current map view, in meters.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    import math\n\n    zoom_level = self.zoom\n    # Reference: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n    resolution = 156543.04 * math.cos(0) / math.pow(2, zoom_level)\n    return resolution\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.image_overlay","title":"<code>image_overlay(self, url, bounds, name)</code>","text":"<p>Overlays an image from the Internet or locally on the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL or local file path to the image.</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>name</code> <code>str</code> <p>name of the layer to show on the layer control.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def image_overlay(self, url, bounds, name):\n    \"\"\"Overlays an image from the Internet or locally on the map.\n\n    Args:\n        url (str): http URL or local file path to the image.\n        bounds (tuple): bounding box of the image in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        name (str): name of the layer to show on the layer control.\n    \"\"\"\n    from base64 import b64encode\n    from PIL import Image, ImageSequence\n    from io import BytesIO\n\n    try:\n        if not url.startswith(\"http\"):\n            if not os.path.exists(url):\n                print(\"The provided file does not exist.\")\n                return\n\n            ext = os.path.splitext(url)[1][1:]  # file extension\n            image = Image.open(url)\n\n            f = BytesIO()\n            if ext.lower() == \"gif\":\n                frames = []\n                # Loop over each frame in the animated image\n                for frame in ImageSequence.Iterator(image):\n                    frame = frame.convert(\"RGBA\")\n                    b = BytesIO()\n                    frame.save(b, format=\"gif\")\n                    frame = Image.open(b)\n                    frames.append(frame)\n                frames[0].save(\n                    f,\n                    format=\"GIF\",\n                    save_all=True,\n                    append_images=frames[1:],\n                    loop=0,\n                )\n            else:\n                image.save(f, ext)\n\n            data = b64encode(f.getvalue())\n            data = data.decode(\"ascii\")\n            url = \"data:image/{};base64,\".format(ext) + data\n        img = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name)\n        self.add(img)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.layer_opacity","title":"<code>layer_opacity(self, name, value=1.0)</code>","text":"<p>Changes layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer to change opacity.</p> required <code>value</code> <code>float</code> <p>The opacity value to set. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def layer_opacity(self, name, value=1.0):\n    \"\"\"Changes layer opacity.\n\n    Args:\n        name (str): The name of the layer to change opacity.\n        value (float, optional): The opacity value to set. Defaults to 1.0.\n    \"\"\"\n    layer = self.find_layer(name)\n    try:\n        layer.opacity = value\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.marker_cluster","title":"<code>marker_cluster(self, event='click', add_marker=True)</code>","text":"<p>Captures user inputs and add markers to the map.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>[description]. Defaults to 'click'.</p> <code>'click'</code> <code>add_marker</code> <code>bool</code> <p>If True, add markers to the map. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>object</code> <p>a marker cluster.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def marker_cluster(self, event=\"click\", add_marker=True):\n    \"\"\"Captures user inputs and add markers to the map.\n\n    Args:\n        event (str, optional): [description]. Defaults to 'click'.\n        add_marker (bool, optional): If True, add markers to the map. Defaults to True.\n\n    Returns:\n        object: a marker cluster.\n    \"\"\"\n    coordinates = []\n    markers = []\n    marker_cluster = ipyleaflet.MarkerCluster(name=\"Marker Cluster\")\n    self.last_click = []\n    self.all_clicks = []\n    if add_marker:\n        self.add(marker_cluster)\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n\n        if event == \"click\" and kwargs.get(\"type\") == \"click\":\n            coordinates.append(latlon)\n            self.last_click = latlon\n            self.all_clicks = coordinates\n            if add_marker:\n                markers.append(ipyleaflet.Marker(location=latlon))\n                marker_cluster.markers = markers\n        elif kwargs.get(\"type\") == \"mousemove\":\n            pass\n\n    # cursor style: https://www.w3schools.com/cssref/pr_class_cursor.asp\n    self.default_style = {\"cursor\": \"crosshair\"}\n    self.on_interaction(handle_interaction)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.oam_search","title":"<code>oam_search(self, bbox=None, start_date=None, end_date=None, limit=100, info_mode='on_click', layer_args={}, add_image=True, **kwargs)</code>","text":"<p>Search OpenAerialMap for images within a bounding box and time range.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | str</code> <p>The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 100.</p> <code>100</code> <code>info_mode</code> <code>str</code> <p>The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.</p> <code>'on_click'</code> <code>layer_args</code> <code>dict</code> <p>The layer arguments for add_gdf() function. Defaults to {}.</p> <code>{}</code> <code>add_image</code> <code>bool</code> <p>Whether to add the first 10 images to the map. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def oam_search(\n    self,\n    bbox=None,\n    start_date=None,\n    end_date=None,\n    limit=100,\n    info_mode=\"on_click\",\n    layer_args={},\n    add_image=True,\n    **kwargs,\n):\n    \"\"\"Search OpenAerialMap for images within a bounding box and time range.\n\n    Args:\n        bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n        start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n        end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n        limit (int, optional): The maximum number of results to return. Defaults to 100.\n        info_mode (str, optional): The mode to use for the info popup. Can be 'on_hover' or 'on_click'. Defaults to 'on_click'.\n        layer_args (dict, optional): The layer arguments for add_gdf() function. Defaults to {}.\n        add_image (bool, optional): Whether to add the first 10 images to the map. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n    \"\"\"\n\n    bounds = self.bounds\n    if bbox is None:\n        if self.user_roi is not None:\n            bbox = self.user_roi_bounds()\n        else:\n            bbox = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    if self.zoom &lt;= 4:\n        print(\"Zoom in to search for images\")\n        return None\n\n    gdf = oam_search(\n        bbox=bbox, start_date=start_date, end_date=end_date, limit=limit, **kwargs\n    )\n\n    if \"layer_name\" not in layer_args:\n        layer_args[\"layer_name\"] = \"Footprints\"\n\n    if \"style\" not in layer_args:\n        layer_args[\"style\"] = {\n            # \"stroke\": True,\n            \"color\": \"#3388ff\",\n            \"weight\": 2,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 0,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n\n    if \"hover_style\" not in layer_args:\n        layer_args[\"hover_style\"] = {\"weight\": layer_args[\"style\"][\"weight\"] + 2}\n\n    if gdf is not None:\n        setattr(self, \"oam_gdf\", gdf)\n        self.add_gdf(gdf, info_mode=info_mode, **layer_args)\n\n        if add_image:\n            ids = gdf[\"_id\"].tolist()\n            images = gdf[\"tms\"].tolist()\n\n            if len(images) &gt; 5:\n                print(f\"Found {len(images)} images. \\nShowing the first 5.\")\n\n            for index, image in enumerate(images):\n                if index == 5:\n                    break\n                self.add_tile_layer(\n                    url=image, name=ids[index], attribution=\"OpenAerialMap\"\n                )\n    else:\n        print(\"No images found.\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.remove","title":"<code>remove(self, widget)</code>","text":"<p>Removes a widget to the map.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def remove(self, widget: Any) -&gt; None:\n    \"\"\"Removes a widget to the map.\"\"\"\n\n    basic_controls: Dict[str, ipyleaflet.Control] = {\n        \"layer_editor\": map_widgets.LayerEditor,\n    }\n    if widget_type := basic_controls.get(widget, None):\n        if control := self._find_widget_of_type(widget_type, return_control=True):\n            self.remove(control)\n            control.close()\n        return\n\n    super().remove(widget)\n    if isinstance(widget, ipywidgets.Widget):\n        widget.close()\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.remove_labels","title":"<code>remove_labels(self)</code>","text":"<p>Removes all labels from the map.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def remove_labels(self):\n    \"\"\"Removes all labels from the map.\"\"\"\n    if hasattr(self, \"labels\"):\n        self.remove_layer(self.labels)\n        delattr(self, \"labels\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.save_draw_features","title":"<code>save_draw_features(self, out_file, indent=4, crs='epsg:4326', **kwargs)</code>","text":"<p>Save the draw features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <code>str</code> <p>The output file path.</p> required <code>indent</code> <code>int</code> <p>The indentation level when saving data as a GeoJSON. Defaults to 4.</p> <code>4</code> <code>crs</code> <code>str</code> <p>The CRS of the output GeoJSON. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def save_draw_features(self, out_file, indent=4, crs=\"epsg:4326\", **kwargs):\n    \"\"\"Save the draw features to a file.\n\n    Args:\n        out_file (str): The output file path.\n        indent (int, optional): The indentation level when saving data as a GeoJSON. Defaults to 4.\n        crs (str, optional): The CRS of the output GeoJSON. Defaults to \"epsg:4326\".\n    \"\"\"\n    import geopandas as gpd\n\n    out_file = check_file_path(out_file)\n\n    self.update_draw_features()\n    geojson = {\n        \"type\": \"FeatureCollection\",\n        \"features\": self.draw_features,\n    }\n\n    gdf = gpd.GeoDataFrame.from_features(geojson)\n    gdf.crs = \"epsg:4326\"\n    gdf.to_crs(crs).to_file(out_file, **kwargs)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.set_catalog_source","title":"<code>set_catalog_source(self, source)</code>","text":"<p>Set the catalog source.</p> <p>Parameters:</p> Name Type Description Default <code>catalog_source</code> <code>str</code> <p>The catalog source. Defaults to \"landsat\".</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def set_catalog_source(self, source):\n    \"\"\"Set the catalog source.\n\n    Args:\n        catalog_source (str, optional): The catalog source. Defaults to \"landsat\".\n    \"\"\"\n    if not isinstance(source, dict):\n        raise TypeError(\n            \"The source must be a dictionary in the format of {label: url, label2:url2}, \\\n            such as {'Element84': 'https://earth-search.aws.element84.com/v1'}\"\n        )\n    if not hasattr(self, \"_STAC_CATALOGS\"):\n        self.catalog_source = {}\n\n    self._STAC_CATALOGS = source\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.set_center","title":"<code>set_center(self, lon, lat, zoom=None)</code>","text":"<p>Centers the map view at a given coordinates with the given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center, in degrees.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center, in degrees.</p> required <code>zoom</code> <code>int</code> <p>The zoom level, from 1 to 24. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def set_center(self, lon, lat, zoom=None):\n    \"\"\"Centers the map view at a given coordinates with the given zoom level.\n\n    Args:\n        lon (float): The longitude of the center, in degrees.\n        lat (float): The latitude of the center, in degrees.\n        zoom (int, optional): The zoom level, from 1 to 24. Defaults to None.\n    \"\"\"\n    self.center = (lat, lon)\n    if zoom is not None:\n        self.zoom = zoom\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.split_map","title":"<code>split_map(self, left_layer='TERRAIN', right_layer='OpenTopoMap', left_args={}, right_args={}, left_array_args={}, right_array_args={}, zoom_control=True, fullscreen_control=True, layer_control=True, add_close_button=False, left_label=None, right_label=None, left_position='bottomleft', right_position='bottomright', widget_layout=None, draggable=True)</code>","text":"<p>Adds split map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.</p> <code>'TERRAIN'</code> <code>right_layer</code> <code>str</code> <p>The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.</p> <code>'OpenTopoMap'</code> <code>left_args</code> <code>dict</code> <p>The arguments for the left tile layer. Defaults to {}.</p> <code>{}</code> <code>right_args</code> <code>dict</code> <p>The arguments for the right tile layer. Defaults to {}.</p> <code>{}</code> <code>left_array_args</code> <code>dict</code> <p>The arguments for array_to_image for the left layer. Defaults to {}.</p> <code>{}</code> <code>right_array_args</code> <code>dict</code> <p>The arguments for array_to_image for the right layer. Defaults to {}.</p> <code>{}</code> <code>zoom_control</code> <code>bool</code> <p>Whether to add zoom control. Defaults to True.</p> <code>True</code> <code>fullscreen_control</code> <code>bool</code> <p>Whether to add fullscreen control. Defaults to True.</p> <code>True</code> <code>layer_control</code> <code>bool</code> <p>Whether to add layer control. Defaults to True.</p> <code>True</code> <code>add_close_button</code> <code>bool</code> <p>Whether to add a close button. Defaults to False.</p> <code>False</code> <code>left_label</code> <code>str</code> <p>The label for the left layer. Defaults to None.</p> <code>None</code> <code>right_label</code> <code>str</code> <p>The label for the right layer. Defaults to None.</p> <code>None</code> <code>left_position</code> <code>str</code> <p>The position for the left label. Defaults to \"bottomleft\".</p> <code>'bottomleft'</code> <code>right_position</code> <code>str</code> <p>The position for the right label. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>widget_layout</code> <code>dict</code> <p>The layout for the widget. Defaults to None.</p> <code>None</code> <code>draggable</code> <code>bool</code> <p>Whether the split map is draggable. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def split_map(\n    self,\n    left_layer=\"TERRAIN\",\n    right_layer=\"OpenTopoMap\",\n    left_args={},\n    right_args={},\n    left_array_args={},\n    right_array_args={},\n    zoom_control=True,\n    fullscreen_control=True,\n    layer_control=True,\n    add_close_button=False,\n    left_label=None,\n    right_label=None,\n    left_position=\"bottomleft\",\n    right_position=\"bottomright\",\n    widget_layout=None,\n    draggable=True,\n):\n    \"\"\"Adds split map.\n\n    Args:\n        left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n        right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n        left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n        right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n        left_array_args (dict, optional): The arguments for array_to_image for the left layer. Defaults to {}.\n        right_array_args (dict, optional): The arguments for array_to_image for the right layer. Defaults to {}.\n        zoom_control (bool, optional): Whether to add zoom control. Defaults to True.\n        fullscreen_control (bool, optional): Whether to add fullscreen control. Defaults to True.\n        layer_control (bool, optional): Whether to add layer control. Defaults to True.\n        add_close_button (bool, optional): Whether to add a close button. Defaults to False.\n        left_label (str, optional): The label for the left layer. Defaults to None.\n        right_label (str, optional): The label for the right layer. Defaults to None.\n        left_position (str, optional): The position for the left label. Defaults to \"bottomleft\".\n        right_position (str, optional): The position for the right label. Defaults to \"bottomright\".\n        widget_layout (dict, optional): The layout for the widget. Defaults to None.\n        draggable (bool, optional): Whether the split map is draggable. Defaults to True.\n    \"\"\"\n    if \"max_zoom\" not in left_args:\n        left_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in left_args:\n        left_args[\"max_native_zoom\"] = 30\n\n    if \"max_zoom\" not in right_args:\n        right_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in right_args:\n        right_args[\"max_native_zoom\"] = 30\n\n    if \"layer_name\" not in left_args:\n        left_args[\"layer_name\"] = \"Left Layer\"\n\n    if \"layer_name\" not in right_args:\n        right_args[\"layer_name\"] = \"Right Layer\"\n\n    bounds = None\n\n    try:\n        controls = self.controls\n        layers = self.layers\n        self.clear_controls()\n\n        if zoom_control:\n            self.add(ipyleaflet.ZoomControl())\n        if fullscreen_control:\n            self.add(ipyleaflet.FullScreenControl())\n\n        if left_label is not None:\n            left_name = left_label\n        else:\n            left_name = \"Left Layer\"\n\n        if right_label is not None:\n            right_name = right_label\n        else:\n            right_name = \"Right Layer\"\n\n        if isinstance(left_layer, str):\n            if left_layer in basemaps.keys():\n                left_layer = get_basemap(left_layer)\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                url = cog_tile(left_layer, **left_args)\n                bbox = cog_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=left_name,\n                    attribution=\" \",\n                    **left_args,\n                )\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".json\"):\n                left_tile_url = stac_tile(left_layer, **left_args)\n                bbox = stac_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = ipyleaflet.TileLayer(\n                    url=left_tile_url,\n                    name=left_name,\n                    attribution=\" \",\n                    **left_args,\n                )\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".geojson\"):\n                if \"max_zoom\" in left_args:\n                    del left_args[\"max_zoom\"]\n                if \"max_native_zoom\" in left_args:\n                    del left_args[\"max_native_zoom\"]\n                left_layer = geojson_layer(left_layer, **left_args)\n            elif os.path.exists(left_layer):\n                if left_layer.endswith(\".geojson\"):\n                    if \"max_zoom\" in left_args:\n                        del left_args[\"max_zoom\"]\n                    if \"max_native_zoom\" in left_args:\n                        del left_args[\"max_native_zoom\"]\n                    left_layer = geojson_layer(left_layer, **left_args)\n                else:\n                    left_layer, left_client = get_local_tile_layer(\n                        left_layer,\n                        tile_format=\"ipyleaflet\",\n                        return_client=True,\n                        **left_args,\n                    )\n                    bounds = image_bounds(left_client)\n            else:\n                left_layer = ipyleaflet.TileLayer(\n                    url=left_layer,\n                    name=left_name,\n                    attribution=\" \",\n                    **left_args,\n                )\n        elif isinstance(left_layer, ipyleaflet.TileLayer) or isinstance(\n            left_layer, ipyleaflet.GeoJSON\n        ):\n            pass\n        elif is_array(left_layer):\n            left_layer = array_to_image(left_layer, **left_array_args)\n            left_layer, _ = get_local_tile_layer(\n                left_layer,\n                return_client=True,\n                **left_args,\n            )\n        else:\n            raise ValueError(\n                f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        if isinstance(right_layer, str):\n            if right_layer in basemaps.keys():\n                right_layer = get_basemap(right_layer)\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                url = cog_tile(\n                    right_layer,\n                    **right_args,\n                )\n                bbox = cog_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=right_name,\n                    attribution=\" \",\n                    **right_args,\n                )\n\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\".json\"):\n                right_tile_url = stac_tile(right_layer, **left_args)\n                bbox = stac_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = ipyleaflet.TileLayer(\n                    url=right_tile_url,\n                    name=right_name,\n                    attribution=\" \",\n                    **right_args,\n                )\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\n                \".geojson\"\n            ):\n                if \"max_zoom\" in right_args:\n                    del right_args[\"max_zoom\"]\n                if \"max_native_zoom\" in right_args:\n                    del right_args[\"max_native_zoom\"]\n                right_layer = geojson_layer(right_layer, **right_args)\n            elif os.path.exists(right_layer):\n                if \"max_zoom\" in right_args:\n                    del right_args[\"max_zoom\"]\n                if \"max_native_zoom\" in right_args:\n                    del right_args[\"max_native_zoom\"]\n                if right_layer.endswith(\".geojson\"):\n                    right_layer = geojson_layer(right_layer, **right_args)\n                else:\n                    right_layer, right_client = get_local_tile_layer(\n                        right_layer,\n                        tile_format=\"ipyleaflet\",\n                        return_client=True,\n                        **right_args,\n                    )\n                    bounds = image_bounds(right_client)\n            else:\n                right_layer = ipyleaflet.TileLayer(\n                    url=right_layer,\n                    name=right_name,\n                    attribution=\" \",\n                    **right_args,\n                )\n        elif isinstance(right_layer, ipyleaflet.TileLayer) or isinstance(\n            right_layer, ipyleaflet.GeoJSON\n        ):\n            pass\n        elif is_array(right_layer):\n            right_layer = array_to_image(right_layer, **right_array_args)\n            right_layer, _ = get_local_tile_layer(\n                right_layer,\n                return_client=True,\n                **right_args,\n            )\n        else:\n            raise ValueError(\n                f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n        control = ipyleaflet.SplitMapControl(\n            left_layer=left_layer, right_layer=right_layer\n        )\n        self.add(control)\n\n        if left_label is not None:\n            if widget_layout is None:\n                widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n            left_widget = widgets.HTML(value=left_label, layout=widget_layout)\n\n            left_control = ipyleaflet.WidgetControl(\n                widget=left_widget, position=left_position\n            )\n            self.add(left_control)\n\n        if right_label is not None:\n            if widget_layout is None:\n                widget_layout = widgets.Layout(padding=\"0px 4px 0px 4px\")\n            right_widget = widgets.HTML(value=right_label, layout=widget_layout)\n            right_control = ipyleaflet.WidgetControl(\n                widget=right_widget, position=right_position\n            )\n            self.add(right_control)\n\n        if bounds is not None:\n            self.fit_bounds(bounds)\n\n        self.dragging = draggable\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close split-panel map\",\n            icon=\"times\",\n            layout=widgets.Layout(\n                height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n            ),\n        )\n\n        def close_btn_click(change):\n            if change[\"new\"]:\n                self.controls = controls\n                self.layers = layers[:-1]\n                self.add(layers[-1])\n\n            if left_label in self.controls:\n                self.remove_control(left_control)\n\n            if right_label in self.controls:\n                self.remove_control(right_control)\n\n            self.dragging = True\n\n        close_button.observe(close_btn_click, \"value\")\n        close_control = ipyleaflet.WidgetControl(\n            widget=close_button, position=\"topright\"\n        )\n\n        if add_close_button:\n            self.add(close_control)\n\n        if layer_control:\n            self.add_layer_control()\n\n    except Exception as e:\n        print(\"The provided layers are invalid!\")\n        raise ValueError(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.static_map","title":"<code>static_map(self, width=950, height=600, out_file=None, **kwargs)</code>","text":"<p>Display an ipyleaflet static map in a Jupyter Notebook.</p> <p>Args     m (ipyleaflet.Map): An ipyleaflet map.     width (int, optional): Width of the map. Defaults to 950.     height (int, optional): Height of the map. Defaults to 600.     read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.     out_file (str, optional): Output html file path. Defaults to None.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def static_map(self, width=950, height=600, out_file=None, **kwargs):\n    \"\"\"Display an ipyleaflet static map in a Jupyter Notebook.\n\n    Args\n        m (ipyleaflet.Map): An ipyleaflet map.\n        width (int, optional): Width of the map. Defaults to 950.\n        height (int, optional): Height of the map. Defaults to 600.\n        read_only (bool, optional): Whether to hide the side panel to disable map customization. Defaults to False.\n        out_file (str, optional): Output html file path. Defaults to None.\n    \"\"\"\n    if isinstance(self, ipyleaflet.Map):\n        if out_file is None:\n            out_file = \"./cache/\" + \"leafmap_\" + random_string(3) + \".html\"\n        out_dir = os.path.abspath(os.path.dirname(out_file))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        self.to_html(out_file)\n        display_html(src=out_file, width=width, height=height)\n    else:\n        raise TypeError(\"The provided map is not an ipyleaflet map.\")\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.to_html","title":"<code>to_html(self, outfile=None, title='My Map', width='100%', height='880px', add_layer_control=True, **kwargs)</code>","text":"<p>Saves the map as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the HTML file.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the HTML file. Defaults to 'My Map'.</p> <code>'My Map'</code> <code>width</code> <code>str</code> <p>The width of the map in pixels or percentage. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map in pixels. Defaults to '880px'.</p> <code>'880px'</code> <code>add_layer_control</code> <code>bool</code> <p>Whether to add the LayersControl. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def to_html(\n    self,\n    outfile=None,\n    title=\"My Map\",\n    width=\"100%\",\n    height=\"880px\",\n    add_layer_control=True,\n    **kwargs,\n):\n    \"\"\"Saves the map as an HTML file.\n\n    Args:\n        outfile (str, optional): The output file path to the HTML file.\n        title (str, optional): The title of the HTML file. Defaults to 'My Map'.\n        width (str, optional): The width of the map in pixels or percentage. Defaults to '100%'.\n        height (str, optional): The height of the map in pixels. Defaults to '880px'.\n        add_layer_control (bool, optional): Whether to add the LayersControl. Defaults to True.\n\n    \"\"\"\n    try:\n        save = True\n        if outfile is not None:\n            if not outfile.endswith(\".html\"):\n                raise ValueError(\"The output file extension must be html.\")\n            outfile = os.path.abspath(outfile)\n            out_dir = os.path.dirname(outfile)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n        else:\n            outfile = os.path.abspath(random_string() + \".html\")\n            save = False\n\n        if add_layer_control and self.layer_control is None:\n            layer_control = ipyleaflet.LayersControl(position=\"topright\")\n            self.layer_control = layer_control\n            self.add(layer_control)\n\n        before_width = self.layout.width\n        before_height = self.layout.height\n\n        if not isinstance(width, str):\n            print(\"width must be a string.\")\n            return\n        elif width.endswith(\"px\") or width.endswith(\"%\"):\n            pass\n        else:\n            print(\"width must end with px or %\")\n            return\n\n        if not isinstance(height, str):\n            print(\"height must be a string.\")\n            return\n        elif not height.endswith(\"px\"):\n            print(\"height must end with px\")\n            return\n\n        self.layout.width = width\n        self.layout.height = height\n\n        self.save(outfile, title=title, **kwargs)\n\n        self.layout.width = before_width\n        self.layout.height = before_height\n\n        if not save:\n            out_html = \"\"\n            with open(outfile) as f:\n                lines = f.readlines()\n                out_html = \"\".join(lines)\n            os.remove(outfile)\n            return out_html\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.to_image","title":"<code>to_image(self, outfile=None, monitor=1)</code>","text":"<p>Saves the map as a PNG or JPG image.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the image. Defaults to None.</p> <code>None</code> <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def to_image(self, outfile=None, monitor=1):\n    \"\"\"Saves the map as a PNG or JPG image.\n\n    Args:\n        outfile (str, optional): The output file path to the image. Defaults to None.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    if outfile is None:\n        outfile = os.path.join(os.getcwd(), \"my_map.png\")\n\n    if outfile.endswith(\".png\") or outfile.endswith(\".jpg\"):\n        pass\n    else:\n        print(\"The output file must be a PNG or JPG image.\")\n        return\n\n    work_dir = os.path.dirname(outfile)\n    if not os.path.exists(work_dir):\n        os.makedirs(work_dir)\n\n    screenshot = screen_capture(outfile, monitor)\n    self.screenshot = screenshot\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, **kwargs)</code>","text":"<p>Renders map figure in a Streamlit app.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> required <code>scrolling</code> <code>bool</code> <p>If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def to_streamlit(self, width=None, height=600, scrolling=False, **kwargs):\n    \"\"\"Renders map figure in a Streamlit app.\n\n    Args:\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): If True, show a scrollbar when the content is larger than the iframe. Otherwise, do not show a scrollbar. Defaults to False.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        # if responsive:\n        #     make_map_responsive = \"\"\"\n        #     &lt;style&gt;\n        #     [title~=\"st.iframe\"] { width: 100%}\n        #     &lt;/style&gt;\n        #     \"\"\"\n        #     st.markdown(make_map_responsive, unsafe_allow_html=True)\n        return components.html(\n            self.to_html(), width=width, height=height, scrolling=scrolling\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.toolbar_reset","title":"<code>toolbar_reset(self)</code>","text":"<p>Reset the toolbar so that no tool is selected.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def toolbar_reset(self):\n    \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n    toolbar_grid = self.toolbar\n    for tool in toolbar_grid.children:\n        tool.value = False\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.update_draw_features","title":"<code>update_draw_features(self)</code>","text":"<p>Update the draw features by removing features that have been edited and no longer exist.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def update_draw_features(self):\n    \"\"\"Update the draw features by removing features that have been edited and no longer exist.\"\"\"\n\n    geometries = [feature[\"geometry\"] for feature in self.draw_control.data]\n\n    for feature in self.draw_features:\n        if feature[\"geometry\"] not in geometries:\n            self.draw_features.remove(feature)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.update_draw_props","title":"<code>update_draw_props(self, df)</code>","text":"<p>Update the draw features properties.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>A pandas dataframe containing the properties of the draw features.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def update_draw_props(self, df):\n    \"\"\"Update the draw features properties.\n\n    Args:\n        df (pd.DataFrame): A pandas dataframe containing the properties of the draw features.\n    \"\"\"\n\n    df.dropna(inplace=True)\n    df = df[df[\"Key\"].astype(bool)]\n    if len(df) &gt; 0:\n        props = df.set_index(\"Key\").to_dict()[\"Value\"]\n        if self.draw_control.last_action == \"edited\":\n            self.update_draw_features()\n        if len(self.draw_features) &gt; 0:\n            if self.draw_control.last_action == \"created\":\n                self.draw_features[-1][\"properties\"] = props\n            elif self.draw_control.last_action == \"edited\":\n                for feature in self.draw_features:\n                    if (\n                        self.draw_control.last_draw[\"geometry\"]\n                        == feature[\"geometry\"]\n                    ):\n                        feature[\"properties\"] = props\n        for prop in list(props.keys()):\n            if prop not in self.edit_props:\n                self.edit_props.append(prop)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.update_layer_manager","title":"<code>update_layer_manager(self)</code>","text":"<p>Update the Layer Manager.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def update_layer_manager(self):\n    \"\"\"Update the Layer Manager.\"\"\"\n    from .toolbar import layer_manager_gui\n\n    self.layer_manager_widget.children = layer_manager_gui(self, return_widget=True)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.user_roi_bounds","title":"<code>user_roi_bounds(self, decimals=4)</code>","text":"<p>Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>The number of decimals to round the coordinates to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def user_roi_bounds(self, decimals=4):\n    \"\"\"Get the bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n\n    Args:\n        decimals (int, optional): The number of decimals to round the coordinates to. Defaults to 4.\n\n    Returns:\n        list: The bounds of the user drawn ROI as a tuple of (minx, miny, maxx, maxy).\n    \"\"\"\n    if self.user_roi is not None:\n        return geometry_bounds(self.user_roi, decimals=decimals)\n    else:\n        return None\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.video_overlay","title":"<code>video_overlay(self, url, bounds, layer_name=None, **kwargs)</code>","text":"<p>Overlays a video from the Internet on the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"</p> required <code>bounds</code> <code>tuple</code> <p>bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).</p> required <code>layer_name</code> <code>str</code> <p>name of the layer to show on the layer control.</p> <code>None</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def video_overlay(self, url, bounds, layer_name=None, **kwargs):\n    \"\"\"Overlays a video from the Internet on the map.\n\n    Args:\n        url (str): http URL of the video, such as \"https://www.mapbox.com/bites/00188/patricia_nasa.webm\"\n        bounds (tuple): bounding box of the video in the format of (lower_left(lat, lon), upper_right(lat, lon)), such as ((13, -130), (32, -100)).\n        layer_name (str): name of the layer to show on the layer control.\n    \"\"\"\n    if layer_name is None and \"name\" in kwargs:\n        layer_name = kwargs.pop(\"name\")\n    try:\n        video = ipyleaflet.VideoOverlay(url=url, bounds=bounds, name=layer_name)\n        self.add(video)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.zoom_to_bounds","title":"<code>zoom_to_bounds(self, bounds)</code>","text":"<p>Zooms to a bounding box in the form of [minx, miny, maxx, maxy].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list/tuple containing minx, miny, maxx, maxy values for the bounds.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def zoom_to_bounds(self, bounds):\n    \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n    Args:\n        bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n    \"\"\"\n    #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.Map.zoom_to_gdf","title":"<code>zoom_to_gdf(self, gdf)</code>","text":"<p>Zooms to the bounding box of a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required Source code in <code>leafmap/leafmap.py</code> <pre><code>def zoom_to_gdf(self, gdf):\n    \"\"\"Zooms to the bounding box of a GeoPandas GeoDataFrame.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    self.zoom_to_bounds(bounds)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.geojson_layer","title":"<code>geojson_layer(in_geojson, layer_name='Untitled', style={}, hover_style={}, style_callback=None, fill_colors=['black'], encoding='utf-8')</code>","text":"<p>Adds a GeoJSON file to the map.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>layer_name</code> <code>str</code> <p>The layer name to be used.. Defaults to \"Untitled\".</p> <code>'Untitled'</code> <code>style</code> <code>dict</code> <p>A dictionary specifying the style to be used. Defaults to {}.</p> <code>{}</code> <code>hover_style</code> <code>dict</code> <p>Hover style dictionary. Defaults to {}.</p> <code>{}</code> <code>style_callback</code> <code>function</code> <p>Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.</p> <code>None</code> <code>fill_colors</code> <code>list</code> <p>The random colors to use for filling polygons. Defaults to [\"black\"].</p> <code>['black']</code> <code>info_mode</code> <code>str</code> <p>Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided GeoJSON file could not be found.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def geojson_layer(\n    in_geojson,\n    layer_name=\"Untitled\",\n    style={},\n    hover_style={},\n    style_callback=None,\n    fill_colors=[\"black\"],\n    encoding=\"utf-8\",\n):\n    \"\"\"Adds a GeoJSON file to the map.\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        layer_name (str, optional): The layer name to be used.. Defaults to \"Untitled\".\n        style (dict, optional): A dictionary specifying the style to be used. Defaults to {}.\n        hover_style (dict, optional): Hover style dictionary. Defaults to {}.\n        style_callback (function, optional): Styling function that is called for each feature, and should return the feature style. This styling function takes the feature as argument. Defaults to None.\n        fill_colors (list, optional): The random colors to use for filling polygons. Defaults to [\"black\"].\n        info_mode (str, optional): Displays the attributes by either on_hover or on_click. Any value other than \"on_hover\" or \"on_click\" will be treated as None. Defaults to \"on_hover\".\n        encoding (str, optional): The encoding of the GeoJSON file. Defaults to \"utf-8\".\n\n    Raises:\n        FileNotFoundError: The provided GeoJSON file could not be found.\n    \"\"\"\n    import json\n    import random\n    import requests\n\n    style_callback_only = False\n\n    if len(style) == 0 and style_callback is not None:\n        style_callback_only = True\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                in_geojson = github_raw_url(in_geojson)\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n    except Exception as e:\n        raise Exception(e)\n\n    if not style:\n        style = {\n            # \"stroke\": True,\n            \"color\": \"#000000\",\n            \"weight\": 1,\n            \"opacity\": 1,\n            # \"fill\": True,\n            # \"fillColor\": \"#ffffff\",\n            \"fillOpacity\": 0.1,\n            # \"dashArray\": \"9\"\n            # \"clickable\": True,\n        }\n    elif \"weight\" not in style:\n        style[\"weight\"] = 1\n\n    if not hover_style:\n        hover_style = {\"weight\": style[\"weight\"] + 1, \"fillOpacity\": 0.5}\n\n    def random_color(feature):\n        return {\n            \"color\": \"black\",\n            \"fillColor\": random.choice(fill_colors),\n        }\n\n    if style_callback is None:\n        style_callback = random_color\n\n    if style_callback_only:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n    else:\n        geojson = ipyleaflet.GeoJSON(\n            data=data,\n            style=style,\n            hover_style=hover_style,\n            style_callback=style_callback,\n            name=layer_name,\n        )\n\n    return geojson\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.get_basemap","title":"<code>get_basemap(name)</code>","text":"<p>Gets a basemap tile layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the basemap.</p> required <p>Returns:</p> Type Description <code>ipylealfet.TileLayer | ipyleaflet.WMSLayer</code> <p>The basemap layer.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def get_basemap(name):\n    \"\"\"Gets a basemap tile layer by name.\n\n    Args:\n        name (str): The name of the basemap.\n\n    Returns:\n        ipylealfet.TileLayer | ipyleaflet.WMSLayer: The basemap layer.\n    \"\"\"\n\n    if isinstance(name, str):\n        if name in basemaps.keys():\n            basemap = basemaps[name]\n            if basemap[\"type\"] == \"xyz\":\n                layer = ipyleaflet.TileLayer(\n                    url=basemap[\"url\"],\n                    name=basemap[\"name\"],\n                    max_zoom=24,\n                    attribution=basemap[\"attribution\"],\n                )\n            elif basemap[\"type\"] == \"wms\":\n                layer = ipyleaflet.WMSLayer(\n                    url=basemap[\"url\"],\n                    layers=basemap[\"layers\"],\n                    name=basemap[\"name\"],\n                    attribution=basemap[\"attribution\"],\n                    format=basemap[\"format\"],\n                    transparent=basemap[\"transparent\"],\n                )\n            return layer\n        else:\n            raise ValueError(\n                \"Basemap must be a string. Please choose from: \"\n                + str(list(basemaps.keys()))\n            )\n    else:\n        raise ValueError(\n            \"Basemap must be a string. Please choose from: \"\n            + str(list(basemaps.keys()))\n        )\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.linked_maps","title":"<code>linked_maps(rows=2, cols=2, height='400px', layers=[], labels=[], label_position='topright', layer_args=[], **kwargs)</code>","text":"<p>Create linked maps of XYZ tile layers.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows of maps to create. Defaults to 2.</p> <code>2</code> <code>cols</code> <code>int</code> <p>The number of columns of maps to create. Defaults to 2.</p> <code>2</code> <code>height</code> <code>str</code> <p>The height of each map in pixels. Defaults to \"400px\".</p> <code>'400px'</code> <code>layers</code> <code>list</code> <p>The list of layers to use for each map. Defaults to [].</p> <code>[]</code> <code>labels</code> <code>list</code> <p>The list of labels to show on the map. Defaults to [].</p> <code>[]</code> <code>label_position</code> <code>str</code> <p>The position of the label, can be [topleft, topright, bottomleft, bottomright]. Defaults to \"topright\".</p> <code>'topright'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the length of ee_objects is not equal to rows*cols.</p> <code>ValueError</code> <p>If the length of labels is not equal to rows*cols.</p> <p>Returns:</p> Type Description <code>ipywidget</code> <p>A GridspecLayout widget.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def linked_maps(\n    rows=2,\n    cols=2,\n    height=\"400px\",\n    layers=[],\n    labels=[],\n    label_position=\"topright\",\n    layer_args=[],\n    **kwargs,\n):\n    \"\"\"Create linked maps of XYZ tile layers.\n\n    Args:\n        rows (int, optional): The number of rows of maps to create. Defaults to 2.\n        cols (int, optional): The number of columns of maps to create. Defaults to 2.\n        height (str, optional): The height of each map in pixels. Defaults to \"400px\".\n        layers (list, optional): The list of layers to use for each map. Defaults to [].\n        labels (list, optional): The list of labels to show on the map. Defaults to [].\n        label_position (str, optional): The position of the label, can be [topleft, topright, bottomleft, bottomright]. Defaults to \"topright\".\n\n    Raises:\n        ValueError: If the length of ee_objects is not equal to rows*cols.\n        ValueError: If the length of labels is not equal to rows*cols.\n\n    Returns:\n        ipywidget: A GridspecLayout widget.\n    \"\"\"\n\n    if skip_mkdocs_build():\n        return\n\n    grid = widgets.GridspecLayout(rows, cols, grid_gap=\"0px\")\n    count = rows * cols\n\n    maps = []\n\n    if len(layers) &gt; 0:\n        if len(layers) == 1:\n            layers = layers * count\n        elif len(layers) &lt; count:\n            raise ValueError(f\"The length of layers must be equal to {count}.\")\n\n    if len(labels) &gt; 0:\n        labels = labels.copy()\n        if len(labels) == 1:\n            labels = labels * count\n        elif len(labels) &lt; count:\n            raise ValueError(f\"The length of labels must be equal to {count}.\")\n\n    if len(layer_args) &gt; 0:\n        if len(layer_args) == 1:\n            layer_args = layer_args * count\n        elif len(layer_args) &lt; count:\n            raise ValueError(f\"The length of layer_args must be equal to {count}.\")\n    else:\n        layer_args = [{}] * count\n\n    for i in range(rows):\n        for j in range(cols):\n            index = i * cols + j\n\n            if \"draw_control\" not in kwargs:\n                kwargs[\"draw_control\"] = False\n            if \"toolbar_control\" not in kwargs:\n                kwargs[\"toolbar_control\"] = False\n            if \"measure_control\" not in kwargs:\n                kwargs[\"measure_control\"] = False\n            if \"fullscreen_control\" not in kwargs:\n                kwargs[\"fullscreen_control\"] = False\n\n            m = Map(\n                height=height,\n                layout=widgets.Layout(margin=\"0px\", padding=\"0px\"),\n                **kwargs,\n            )\n\n            if layers[index] in basemaps.keys():\n                layers[index] = get_basemap(layers[index])\n            elif isinstance(layers[index], str):\n                if layers[index].startswith(\"http\") and layers[index].endswith(\".tif\"):\n                    url = cog_tile(layers[index], **layer_args[index])\n                    layers[index] = ipyleaflet.TileLayer(\n                        url=url,\n                        name=\"Left Layer\",\n                        attribution=\" \",\n                    )\n                elif os.path.exists(layers[index]):\n                    layers[index], left_client = get_local_tile_layer(\n                        layers[index],\n                        tile_format=\"ipyleaflet\",\n                        return_client=True,\n                        **layer_args[index],\n                    )\n                else:\n                    layers[index] = ipyleaflet.TileLayer(\n                        url=layers[index],\n                        name=\"Left Layer\",\n                        attribution=\" \",\n                        **layer_args[index],\n                    )\n            elif isinstance(layers[index], ipyleaflet.TileLayer):\n                pass\n            else:\n                raise ValueError(\n                    f\"layers[index] must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n                )\n\n            m.add(layers[index])\n\n            if len(labels) &gt; 0:\n                label = widgets.Label(\n                    labels[index], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n                )\n                control = ipyleaflet.WidgetControl(\n                    widget=label, position=label_position\n                )\n                m.add(control)\n\n            maps.append(m)\n            widgets.jslink((maps[0], \"center\"), (m, \"center\"))\n            widgets.jslink((maps[0], \"zoom\"), (m, \"zoom\"))\n\n            output = widgets.Output()\n            with output:\n                display(m)\n            grid[i, j] = output\n\n    return grid\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.split_map","title":"<code>split_map(left_layer='TERRAIN', right_layer='OpenTopoMap', left_args={}, right_args={}, **kwargs)</code>","text":"<p>Adds split map.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.</p> <code>'TERRAIN'</code> <code>right_layer</code> <code>str</code> <p>The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.</p> <code>'OpenTopoMap'</code> <code>left_args</code> <code>dict</code> <p>The arguments for the left tile layer. Defaults to {}.</p> <code>{}</code> <code>right_args</code> <code>dict</code> <p>The arguments for the right tile layer. Defaults to {}.</p> <code>{}</code> <code>kwargs</code> <code>dict</code> <p>The arguments for the Map widget. Defaults to {}.</p> <code>{}</code> Source code in <code>leafmap/leafmap.py</code> <pre><code>def split_map(\n    left_layer=\"TERRAIN\",\n    right_layer=\"OpenTopoMap\",\n    left_args={},\n    right_args={},\n    **kwargs,\n):\n    \"\"\"Adds split map.\n\n    Args:\n        left_layer (str, optional): The left tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'TERRAIN'.\n        right_layer (str, optional): The right tile layer. Can be a local file path, HTTP URL, or a basemap name. Defaults to 'OpenTopoMap'.\n        left_args (dict, optional): The arguments for the left tile layer. Defaults to {}.\n        right_args (dict, optional): The arguments for the right tile layer. Defaults to {}.\n        kwargs (dict, optional): The arguments for the Map widget. Defaults to {}.\n    \"\"\"\n\n    if \"draw_control\" not in kwargs:\n        kwargs[\"draw_control\"] = False\n    if \"toolbar_control\" not in kwargs:\n        kwargs[\"toolbar_control\"] = False\n    if \"measure_control\" not in kwargs:\n        kwargs[\"measure_control\"] = False\n    if \"fullscreen_control\" not in kwargs:\n        kwargs[\"fullscreen_control\"] = False\n    if \"scale_control\" not in kwargs:\n        kwargs[\"scale_control\"] = False\n    if \"search_control\" not in kwargs:\n        kwargs[\"search_control\"] = False\n\n    m = Map(**kwargs)\n\n    if \"max_zoom\" not in left_args:\n        left_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in left_args:\n        left_args[\"max_native_zoom\"] = 30\n\n    if \"max_zoom\" not in right_args:\n        right_args[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in right_args:\n        right_args[\"max_native_zoom\"] = 30\n\n    if \"layer_name\" not in left_args:\n        left_args[\"layer_name\"] = \"Left Layer\"\n\n    if \"layer_name\" not in right_args:\n        right_args[\"layer_name\"] = \"Right Layer\"\n\n    bounds = None\n\n    try:\n        if left_layer in basemaps.keys():\n            left_layer = get_basemap(left_layer)\n        elif isinstance(left_layer, str):\n            if left_layer.startswith(\"http\") and left_layer.endswith(\".tif\"):\n                url = cog_tile(left_layer, **left_args)\n                bbox = cog_bounds(left_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                left_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=\"Left Layer\",\n                    attribution=\" \",\n                )\n            elif left_layer.startswith(\"http\") and left_layer.endswith(\".geojson\"):\n                if \"max_zoom\" in left_args:\n                    del left_args[\"max_zoom\"]\n                if \"max_native_zoom\" in left_args:\n                    del left_args[\"max_native_zoom\"]\n                left_layer = geojson_layer(left_layer, **left_args)\n            elif os.path.exists(left_layer):\n                if left_layer.endswith(\".geojson\"):\n                    if \"max_zoom\" in left_args:\n                        del left_args[\"max_zoom\"]\n                    if \"max_native_zoom\" in left_args:\n                        del left_args[\"max_native_zoom\"]\n                    left_layer = geojson_layer(left_layer, **left_args)\n                else:\n                    left_layer, left_client = get_local_tile_layer(\n                        left_layer,\n                        tile_format=\"ipyleaflet\",\n                        return_client=True,\n                        **left_args,\n                    )\n                    bounds = image_bounds(left_client)\n            else:\n                left_layer = ipyleaflet.TileLayer(\n                    url=left_layer,\n                    name=\"Left Layer\",\n                    attribution=\" \",\n                    **left_args,\n                )\n        elif isinstance(left_layer, ipyleaflet.TileLayer) or isinstance(\n            left_layer, ipyleaflet.GeoJSON\n        ):\n            pass\n        else:\n            raise ValueError(\n                f\"left_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n\n        if right_layer in basemaps.keys():\n            right_layer = get_basemap(right_layer)\n        elif isinstance(right_layer, str):\n            if right_layer.startswith(\"http\") and right_layer.endswith(\".tif\"):\n                url = cog_tile(\n                    right_layer,\n                    **right_args,\n                )\n                bbox = cog_bounds(right_layer)\n                bounds = [(bbox[1], bbox[0]), (bbox[3], bbox[2])]\n                right_layer = ipyleaflet.TileLayer(\n                    url=url,\n                    name=\"Right Layer\",\n                    attribution=\" \",\n                )\n            elif right_layer.startswith(\"http\") and right_layer.endswith(\".geojson\"):\n                if \"max_zoom\" in right_args:\n                    del right_args[\"max_zoom\"]\n                if \"max_native_zoom\" in right_args:\n                    del right_args[\"max_native_zoom\"]\n                right_layer = geojson_layer(right_layer, **right_args)\n            elif os.path.exists(right_layer):\n                if \"max_zoom\" in right_args:\n                    del right_args[\"max_zoom\"]\n                if \"max_native_zoom\" in right_args:\n                    del right_args[\"max_native_zoom\"]\n                if right_layer.endswith(\".geojson\"):\n                    right_layer = geojson_layer(right_layer, **right_args)\n                else:\n                    right_layer, right_client = get_local_tile_layer(\n                        right_layer,\n                        tile_format=\"ipyleaflet\",\n                        return_client=True,\n                        **right_args,\n                    )\n                    bounds = image_bounds(right_client)\n            else:\n                right_layer = ipyleaflet.TileLayer(\n                    url=right_layer,\n                    name=\"Right Layer\",\n                    attribution=\" \",\n                    **right_args,\n                )\n        elif isinstance(right_layer, ipyleaflet.TileLayer) or isinstance(\n            right_layer, ipyleaflet.GeoJSON\n        ):\n            pass\n        else:\n            raise ValueError(\n                f\"right_layer must be one of the following: {', '.join(basemaps.keys())} or a string url to a tif file.\"\n            )\n        control = ipyleaflet.SplitMapControl(\n            left_layer=left_layer, right_layer=right_layer\n        )\n        m.add(control)\n        if bounds is not None:\n            m.fit_bounds(bounds)\n        m.dragging = False\n        return m\n\n    except Exception as e:\n        print(\"The provided layers are invalid!\")\n        raise ValueError(e)\n</code></pre>"},{"location":"leafmap/#leafmap.leafmap.ts_inspector","title":"<code>ts_inspector(layers_dict=None, left_name=None, right_name=None, width='120px', center=[40, -100], zoom=4, **kwargs)</code>","text":"<p>Creates a time series inspector.</p> <p>Parameters:</p> Name Type Description Default <code>layers_dict</code> <code>dict</code> <p>A dictionary of layers to be shown on the map. Defaults to None.</p> <code>None</code> <code>left_name</code> <code>str</code> <p>A name for the left layer. Defaults to None.</p> <code>None</code> <code>right_name</code> <code>str</code> <p>A name for the right layer. Defaults to None.</p> <code>None</code> <code>width</code> <code>str</code> <p>Width of the dropdown list. Defaults to \"120px\".</p> <code>'120px'</code> <code>center</code> <code>list</code> <p>Center of the map. Defaults to [40, -100].</p> <code>[40, -100]</code> <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>leafmap.Map</code> <p>The Map instance.</p> Source code in <code>leafmap/leafmap.py</code> <pre><code>def ts_inspector(\n    layers_dict=None,\n    left_name=None,\n    right_name=None,\n    width=\"120px\",\n    center=[40, -100],\n    zoom=4,\n    **kwargs,\n):\n    \"\"\"Creates a time series inspector.\n\n    Args:\n        layers_dict (dict, optional): A dictionary of layers to be shown on the map. Defaults to None.\n        left_name (str, optional): A name for the left layer. Defaults to None.\n        right_name (str, optional): A name for the right layer. Defaults to None.\n        width (str, optional): Width of the dropdown list. Defaults to \"120px\".\n        center (list, optional): Center of the map. Defaults to [40, -100].\n        zoom (int, optional): Zoom level of the map. Defaults to 4.\n\n    Returns:\n        leafmap.Map: The Map instance.\n    \"\"\"\n    import ipywidgets as widgets\n\n    add_zoom = True\n    add_fullscreen = True\n\n    if \"toolbar_control\" not in kwargs:\n        kwargs[\"toolbar_control\"] = False\n    if \"draw_control\" not in kwargs:\n        kwargs[\"draw_control\"] = False\n    if \"measure_control\" not in kwargs:\n        kwargs[\"measure_control\"] = False\n    if \"zoom_control\" not in kwargs:\n        kwargs[\"zoom_control\"] = False\n    else:\n        add_zoom = kwargs[\"zoom_control\"]\n    if \"fullscreen_control\" not in kwargs:\n        kwargs[\"fullscreen_control\"] = False\n    else:\n        add_fullscreen = kwargs[\"fullscreen_control\"]\n\n    if layers_dict is None:\n        layers_dict = {}\n        keys = dict(basemaps).keys()\n        for key in keys:\n            if basemaps[key][\"type\"] == \"wms\":\n                pass\n            else:\n                layers_dict[key] = get_basemap(key)\n\n    keys = list(layers_dict.keys())\n    if left_name is None:\n        left_name = keys[0]\n    if right_name is None:\n        right_name = keys[-1]\n\n    left_layer = layers_dict[left_name]\n    right_layer = layers_dict[right_name]\n\n    m = Map(center=center, zoom=zoom, **kwargs)\n    control = ipyleaflet.SplitMapControl(left_layer=left_layer, right_layer=right_layer)\n    m.add(control)\n\n    left_dropdown = widgets.Dropdown(\n        options=keys, value=left_name, layout=widgets.Layout(width=width)\n    )\n\n    left_control = ipyleaflet.WidgetControl(widget=left_dropdown, position=\"topleft\")\n    m.add(left_control)\n\n    right_dropdown = widgets.Dropdown(\n        options=keys, value=right_name, layout=widgets.Layout(width=width)\n    )\n\n    right_control = ipyleaflet.WidgetControl(widget=right_dropdown, position=\"topright\")\n    m.add(right_control)\n\n    if add_zoom:\n        m.add(ipyleaflet.ZoomControl())\n    if add_fullscreen:\n        m.add(ipyleaflet.FullScreenControl())\n\n    split_control = None\n    for ctrl in m.controls:\n        if isinstance(ctrl, ipyleaflet.SplitMapControl):\n            split_control = ctrl\n            break\n\n    def left_change(change):\n        split_control.left_layer.url = layers_dict[left_dropdown.value].url\n\n    left_dropdown.observe(left_change, \"value\")\n\n    def right_change(change):\n        split_control.right_layer.url = layers_dict[right_dropdown.value].url\n\n    right_dropdown.observe(right_change, \"value\")\n\n    m.dragging = False\n\n    return m\n</code></pre>"},{"location":"legends/","title":"legends module","text":"<p>Module of sample legends for some commonly used geospatial datasets.</p>"},{"location":"map_widgets/","title":"map_widgets module","text":""},{"location":"map_widgets/#leafmap.map_widgets.Colorbar","title":"<code> Colorbar            (Output)         </code>","text":"<p>A matplotlib colorbar widget that can be added to the map.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>class Colorbar(ipywidgets.Output):\n    \"\"\"A matplotlib colorbar widget that can be added to the map.\"\"\"\n\n    def __init__(\n        self,\n        vmin=0,\n        vmax=1,\n        cmap=\"gray\",\n        discrete=False,\n        label=None,\n        orientation=\"horizontal\",\n        transparent_bg=False,\n        font_size=9,\n        axis_off=False,\n        max_width=None,\n        **kwargs,\n    ):\n        \"\"\"Add a matplotlib colorbar to the map.\n\n        Args:\n            vis_params (dict): Visualization parameters as a dictionary. See\n                https://developers.google.com/earth-engine/guides/image_visualization # noqa\n                for options.\n            cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See\n                https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa\n                for options.\n            discrete (bool, optional): Whether to create a discrete colorbar.\n                Defaults to False.\n            label (str, optional): Label for the colorbar. Defaults to None.\n            orientation (str, optional): Orientation of the colorbar, such as\n                \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n            transparent_bg (bool, optional): Whether to use transparent\n                background. Defaults to False.\n            font_size (int, optional): Font size for the colorbar. Defaults\n                to 9.\n            axis_off (bool, optional): Whether to turn off the axis. Defaults\n                to False.\n            max_width (str, optional): Maximum width of the colorbar in pixels.\n                Defaults to None.\n\n        Raises:\n            TypeError: If the vis_params is not a dictionary.\n            ValueError: If the orientation is not either horizontal or vertical.\n            ValueError: If the provided min value is not convertible to float.\n            ValueError: If the provided max value is not convertible to float.\n            ValueError: If the provided opacity value is not convertible to float.\n            ValueError: If cmap or palette is not provided.\n        \"\"\"\n\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        import numpy  # pylint: disable=import-outside-toplevel\n\n        if max_width is None:\n            if orientation == \"horizontal\":\n                max_width = \"270px\"\n            else:\n                max_width = \"100px\"\n\n        vis_params = {\n            \"min\": vmin,\n            \"max\": vmax,\n        }\n\n        if not isinstance(vis_params, dict):\n            raise TypeError(\"The vis_params must be a dictionary.\")\n\n        if isinstance(kwargs.get(\"colors\"), (list, tuple)):\n            vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n        width, height = self._get_dimensions(orientation, kwargs)\n\n        vmin = vis_params.get(\"min\", kwargs.pop(\"vmin\", 0))\n        try:\n            vmin = float(vmin)\n        except ValueError as err:\n            raise ValueError(\"The provided min value must be scalar type.\")\n\n        vmax = vis_params.get(\"max\", kwargs.pop(\"vmax\", 1))\n        try:\n            vmax = float(vmax)\n        except ValueError as err:\n            raise ValueError(\"The provided max value must be scalar type.\")\n\n        alpha = vis_params.get(\"opacity\", kwargs.pop(\"alpha\", 1))\n        try:\n            alpha = float(alpha)\n        except ValueError as err:\n            raise ValueError(\"opacity or alpha value must be scalar type.\")\n\n        if \"palette\" in vis_params.keys():\n            hexcodes = common.to_hex_colors(common.check_cmap(vis_params[\"palette\"]))\n            if discrete:\n                cmap = matplotlib.colors.ListedColormap(hexcodes)\n                linspace = numpy.linspace(vmin, vmax, cmap.N + 1)\n                norm = matplotlib.colors.BoundaryNorm(linspace, cmap.N)\n            else:\n                cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n                    \"custom\", hexcodes, N=256\n                )\n                norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n        elif cmap:\n            cmap = matplotlib.colormaps[cmap]\n            norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n        else:\n            raise ValueError(\n                'cmap keyword or \"palette\" key in vis_params must be provided.'\n            )\n\n        fig, ax = matplotlib.pyplot.subplots(figsize=(width, height))\n        cb = matplotlib.colorbar.ColorbarBase(\n            ax,\n            norm=norm,\n            alpha=alpha,\n            cmap=cmap,\n            orientation=orientation,\n            **kwargs,\n        )\n\n        label = label or vis_params.get(\"bands\") or kwargs.pop(\"caption\", None)\n        if label:\n            cb.set_label(label, fontsize=font_size)\n\n        if axis_off:\n            ax.set_axis_off()\n        ax.tick_params(labelsize=font_size)\n\n        # Set the background color to transparent.\n        if transparent_bg:\n            fig.patch.set_alpha(0.0)\n\n        super().__init__(layout=ipywidgets.Layout(width=max_width))\n        with self:\n            self.outputs = ()\n            matplotlib.pyplot.show()\n\n    def _get_dimensions(self, orientation, kwargs):\n        default_dims = {\"horizontal\": (3.0, 0.3), \"vertical\": (0.3, 3.0)}\n        if orientation in default_dims:\n            default = default_dims[orientation]\n            return (\n                kwargs.get(\"width\", default[0]),\n                kwargs.get(\"height\", default[1]),\n            )\n        raise ValueError(\n            f\"orientation must be one of [{', '.join(default_dims.keys())}].\"\n        )\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.Colorbar.__init__","title":"<code>__init__(self, vmin=0, vmax=1, cmap='gray', discrete=False, label=None, orientation='horizontal', transparent_bg=False, font_size=9, axis_off=False, max_width=None, **kwargs)</code>  <code>special</code>","text":"<p>Add a matplotlib colorbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization # noqa for options.</p> required <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>transparent_bg</code> <code>bool</code> <p>Whether to use transparent background. Defaults to False.</p> <code>False</code> <code>font_size</code> <code>int</code> <p>Font size for the colorbar. Defaults to 9.</p> <code>9</code> <code>axis_off</code> <code>bool</code> <p>Whether to turn off the axis. Defaults to False.</p> <code>False</code> <code>max_width</code> <code>str</code> <p>Maximum width of the colorbar in pixels. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the vis_params is not a dictionary.</p> <code>ValueError</code> <p>If the orientation is not either horizontal or vertical.</p> <code>ValueError</code> <p>If the provided min value is not convertible to float.</p> <code>ValueError</code> <p>If the provided max value is not convertible to float.</p> <code>ValueError</code> <p>If the provided opacity value is not convertible to float.</p> <code>ValueError</code> <p>If cmap or palette is not provided.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>def __init__(\n    self,\n    vmin=0,\n    vmax=1,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    orientation=\"horizontal\",\n    transparent_bg=False,\n    font_size=9,\n    axis_off=False,\n    max_width=None,\n    **kwargs,\n):\n    \"\"\"Add a matplotlib colorbar to the map.\n\n    Args:\n        vis_params (dict): Visualization parameters as a dictionary. See\n            https://developers.google.com/earth-engine/guides/image_visualization # noqa\n            for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See\n            https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py # noqa\n            for options.\n        discrete (bool, optional): Whether to create a discrete colorbar.\n            Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        orientation (str, optional): Orientation of the colorbar, such as\n            \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        transparent_bg (bool, optional): Whether to use transparent\n            background. Defaults to False.\n        font_size (int, optional): Font size for the colorbar. Defaults\n            to 9.\n        axis_off (bool, optional): Whether to turn off the axis. Defaults\n            to False.\n        max_width (str, optional): Maximum width of the colorbar in pixels.\n            Defaults to None.\n\n    Raises:\n        TypeError: If the vis_params is not a dictionary.\n        ValueError: If the orientation is not either horizontal or vertical.\n        ValueError: If the provided min value is not convertible to float.\n        ValueError: If the provided max value is not convertible to float.\n        ValueError: If the provided opacity value is not convertible to float.\n        ValueError: If cmap or palette is not provided.\n    \"\"\"\n\n    import matplotlib  # pylint: disable=import-outside-toplevel\n    import numpy  # pylint: disable=import-outside-toplevel\n\n    if max_width is None:\n        if orientation == \"horizontal\":\n            max_width = \"270px\"\n        else:\n            max_width = \"100px\"\n\n    vis_params = {\n        \"min\": vmin,\n        \"max\": vmax,\n    }\n\n    if not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if isinstance(kwargs.get(\"colors\"), (list, tuple)):\n        vis_params[\"palette\"] = list(kwargs[\"colors\"])\n\n    width, height = self._get_dimensions(orientation, kwargs)\n\n    vmin = vis_params.get(\"min\", kwargs.pop(\"vmin\", 0))\n    try:\n        vmin = float(vmin)\n    except ValueError as err:\n        raise ValueError(\"The provided min value must be scalar type.\")\n\n    vmax = vis_params.get(\"max\", kwargs.pop(\"vmax\", 1))\n    try:\n        vmax = float(vmax)\n    except ValueError as err:\n        raise ValueError(\"The provided max value must be scalar type.\")\n\n    alpha = vis_params.get(\"opacity\", kwargs.pop(\"alpha\", 1))\n    try:\n        alpha = float(alpha)\n    except ValueError as err:\n        raise ValueError(\"opacity or alpha value must be scalar type.\")\n\n    if \"palette\" in vis_params.keys():\n        hexcodes = common.to_hex_colors(common.check_cmap(vis_params[\"palette\"]))\n        if discrete:\n            cmap = matplotlib.colors.ListedColormap(hexcodes)\n            linspace = numpy.linspace(vmin, vmax, cmap.N + 1)\n            norm = matplotlib.colors.BoundaryNorm(linspace, cmap.N)\n        else:\n            cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n    elif cmap:\n        cmap = matplotlib.colormaps[cmap]\n        norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = matplotlib.pyplot.subplots(figsize=(width, height))\n    cb = matplotlib.colorbar.ColorbarBase(\n        ax,\n        norm=norm,\n        alpha=alpha,\n        cmap=cmap,\n        orientation=orientation,\n        **kwargs,\n    )\n\n    label = label or vis_params.get(\"bands\") or kwargs.pop(\"caption\", None)\n    if label:\n        cb.set_label(label, fontsize=font_size)\n\n    if axis_off:\n        ax.set_axis_off()\n    ax.tick_params(labelsize=font_size)\n\n    # Set the background color to transparent.\n    if transparent_bg:\n        fig.patch.set_alpha(0.0)\n\n    super().__init__(layout=ipywidgets.Layout(width=max_width))\n    with self:\n        self.outputs = ()\n        matplotlib.pyplot.show()\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.LayerEditor","title":"<code> LayerEditor            (VBox)         </code>","text":"<p>Widget for displaying and editing layer visualization properties.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>class LayerEditor(ipywidgets.VBox):\n    \"\"\"Widget for displaying and editing layer visualization properties.\"\"\"\n\n    def __init__(self, host_map, layer_dict):\n        \"\"\"Initializes a layer editor widget.\n\n        Args:\n            host_map (geemap.Map): The geemap.Map object.\n            layer_dict (dict): The layer object to edit.\n        \"\"\"\n\n        # self.on_close = None\n\n        self._host_map = host_map\n        self._layer_dict = layer_dict\n        if not host_map:\n            raise ValueError(\n                f\"Must pass a valid map when creating a {self.__class__.__name__} widget.\"\n            )\n\n        self._toggle_button = ipywidgets.ToggleButton(\n            value=True,\n            tooltip=\"Layer editor\",\n            icon=\"gear\",\n            layout=ipywidgets.Layout(\n                width=\"28px\", height=\"28px\", padding=\"0px 0 0 3px\"\n            ),\n        )\n        self._toggle_button.observe(self._on_toggle_click, \"value\")\n\n        self._close_button = ipywidgets.Button(\n            tooltip=\"Close the vis params dialog\",\n            icon=\"times\",\n            button_style=\"primary\",\n            layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0\"),\n        )\n        self._close_button.on_click(self._on_close_click)\n\n        layout = ipywidgets.Layout(width=\"95px\")\n        self._import_button = ipywidgets.Button(\n            description=\"Import\",\n            # button_style=\"primary\",\n            tooltip=\"Import vis params to notebook\",\n            layout=layout,\n        )\n        self._apply_button = ipywidgets.Button(\n            description=\"Apply\", tooltip=\"Apply vis params to the layer\", layout=layout\n        )\n\n        self._layer_spinner = ipywidgets.Button(\n            icon=\"check\",\n            layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px\"),\n            tooltip=\"Loaded\",\n        )\n\n        def loading_change(change):\n            if change[\"new\"]:\n                self._layer_spinner.tooltip = \"Loading ...\"\n                self._layer_spinner.icon = \"spinner spin lg\"\n            else:\n                self._layer_spinner.tooltip = \"Loaded\"\n                self._layer_spinner.icon = \"check\"\n\n        self._import_button.on_click(self._on_import_click)\n        self._apply_button.on_click(self._on_apply_click)\n\n        self._label = ipywidgets.Label(\n            value=layer_dict[\"layer_name\"],\n            layout=ipywidgets.Layout(max_width=\"200px\", padding=\"1px 4px 0 4px\"),\n        )\n        self._embedded_widget = ipywidgets.Label(value=\"Vis params are uneditable\")\n        if layer_dict is not None:\n            if layer_dict[\"type\"] in [\"LOCAL\", \"COG\", \"STAC\"]:\n                self._embedded_widget = RasterLayerEditor(\n                    host_map=host_map, layer_dict=layer_dict\n                )\n\n                layer_dict[\"tile_layer\"].observe(loading_change, \"loading\")\n\n        super().__init__(children=[])\n        self._on_toggle_click({\"new\": True})\n\n    def _on_toggle_click(self, change):\n        if change[\"new\"]:\n            self.children = [\n                ipywidgets.HBox([self._close_button, self._toggle_button, self._label]),\n                self._embedded_widget,\n                ipywidgets.HBox(\n                    [self._import_button, self._apply_button, self._layer_spinner]\n                ),\n            ]\n        else:\n            self.children = [\n                ipywidgets.HBox([self._close_button, self._toggle_button, self._label]),\n            ]\n\n    def _on_import_click(self, _):\n        self._embedded_widget.on_import_click()\n\n    def _on_apply_click(self, _):\n\n        def loading_change(change):\n            if change[\"new\"]:\n                self._layer_spinner.tooltip = \"Loading ...\"\n                self._layer_spinner.icon = \"spinner spin lg\"\n            else:\n                self._layer_spinner.tooltip = \"Loaded\"\n                self._layer_spinner.icon = \"check\"\n\n        self._layer_spinner.icon = \"spinner spin lg\"\n        self._layer_spinner.unobserve(loading_change, \"loading\")\n        self._embedded_widget.on_apply_click()\n        self._host_map.cog_layer_dict[self._layer_dict[\"layer_name\"]][\n            \"tile_layer\"\n        ].observe(loading_change, \"loading\")\n\n    def _on_close_click(self, _):\n        # if self.on_close:\n        self._layer_editor = None\n        self.on_close()\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.LayerEditor.__init__","title":"<code>__init__(self, host_map, layer_dict)</code>  <code>special</code>","text":"<p>Initializes a layer editor widget.</p> <p>Parameters:</p> Name Type Description Default <code>host_map</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>layer_dict</code> <code>dict</code> <p>The layer object to edit.</p> required Source code in <code>leafmap/map_widgets.py</code> <pre><code>def __init__(self, host_map, layer_dict):\n    \"\"\"Initializes a layer editor widget.\n\n    Args:\n        host_map (geemap.Map): The geemap.Map object.\n        layer_dict (dict): The layer object to edit.\n    \"\"\"\n\n    # self.on_close = None\n\n    self._host_map = host_map\n    self._layer_dict = layer_dict\n    if not host_map:\n        raise ValueError(\n            f\"Must pass a valid map when creating a {self.__class__.__name__} widget.\"\n        )\n\n    self._toggle_button = ipywidgets.ToggleButton(\n        value=True,\n        tooltip=\"Layer editor\",\n        icon=\"gear\",\n        layout=ipywidgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0 0 3px\"\n        ),\n    )\n    self._toggle_button.observe(self._on_toggle_click, \"value\")\n\n    self._close_button = ipywidgets.Button(\n        tooltip=\"Close the vis params dialog\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0\"),\n    )\n    self._close_button.on_click(self._on_close_click)\n\n    layout = ipywidgets.Layout(width=\"95px\")\n    self._import_button = ipywidgets.Button(\n        description=\"Import\",\n        # button_style=\"primary\",\n        tooltip=\"Import vis params to notebook\",\n        layout=layout,\n    )\n    self._apply_button = ipywidgets.Button(\n        description=\"Apply\", tooltip=\"Apply vis params to the layer\", layout=layout\n    )\n\n    self._layer_spinner = ipywidgets.Button(\n        icon=\"check\",\n        layout=ipywidgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px\"),\n        tooltip=\"Loaded\",\n    )\n\n    def loading_change(change):\n        if change[\"new\"]:\n            self._layer_spinner.tooltip = \"Loading ...\"\n            self._layer_spinner.icon = \"spinner spin lg\"\n        else:\n            self._layer_spinner.tooltip = \"Loaded\"\n            self._layer_spinner.icon = \"check\"\n\n    self._import_button.on_click(self._on_import_click)\n    self._apply_button.on_click(self._on_apply_click)\n\n    self._label = ipywidgets.Label(\n        value=layer_dict[\"layer_name\"],\n        layout=ipywidgets.Layout(max_width=\"200px\", padding=\"1px 4px 0 4px\"),\n    )\n    self._embedded_widget = ipywidgets.Label(value=\"Vis params are uneditable\")\n    if layer_dict is not None:\n        if layer_dict[\"type\"] in [\"LOCAL\", \"COG\", \"STAC\"]:\n            self._embedded_widget = RasterLayerEditor(\n                host_map=host_map, layer_dict=layer_dict\n            )\n\n            layer_dict[\"tile_layer\"].observe(loading_change, \"loading\")\n\n    super().__init__(children=[])\n    self._on_toggle_click({\"new\": True})\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.Legend","title":"<code> Legend            (VBox)         </code>","text":"<p>A legend widget that can be added to the map.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>class Legend(ipywidgets.VBox):\n    \"\"\"A legend widget that can be added to the map.\"\"\"\n\n    ALLOWED_POSITIONS = [\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"]\n    DEFAULT_COLORS = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n    DEFAULT_KEYS = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n    DEFAULT_MAX_HEIGHT = \"400px\"\n    DEFAULT_MAX_WIDTH = \"300px\"\n\n    def __init__(\n        self,\n        title=\"Legend\",\n        legend_dict=None,\n        keys=None,\n        colors=None,\n        position=\"bottomright\",\n        builtin_legend=None,\n        add_header=True,\n        widget_args={},\n        **kwargs,\n    ):\n        \"\"\"Adds a customized legend to the map.\n\n         Args:\n            title (str, optional): Title of the legend. Defaults to 'Legend'.\n            legend_dict (dict, optional): A dictionary containing legend items\n                as keys and color as values. If provided, keys and colors will\n                be ignored. Defaults to None.\n            keys (list, optional): A list of legend keys. Defaults to None.\n            colors (list, optional): A list of legend colors. Defaults to None.\n            position (str, optional): Position of the legend. Defaults to\n                'bottomright'.\n            builtin_legend (str, optional): Name of the builtin legend to add\n                to the map. Defaults to None.\n            add_header (bool, optional): Whether the legend can be closed or\n                not. Defaults to True.\n            widget_args (dict, optional): Additional arguments passed to the\n                widget_template() function. Defaults to {}.\n\n        Raises:\n            TypeError: If the keys are not a list.\n            TypeError: If the colors are not list.\n            TypeError: If the colors are not a list of tuples.\n            TypeError: If the legend_dict is not a dictionary.\n            ValueError: If the legend template does not exist.\n            ValueError: If a rgb value cannot to be converted to hex.\n            ValueError: If the keys and colors are not the same length.\n            ValueError: If the builtin_legend is not allowed.\n            ValueError: If the position is not allowed.\n\n        \"\"\"\n        import os  # pylint: disable=import-outside-toplevel\n        from IPython.display import display  # pylint: disable=import-outside-toplevel\n        import pkg_resources  # pylint: disable=import-outside-toplevel\n        from .legends import builtin_legends  # pylint: disable=import-outside-toplevel\n\n        pkg_dir = os.path.dirname(\n            pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\")\n        )\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n        if not os.path.exists(legend_template):\n            raise ValueError(\"The legend template does not exist.\")\n\n        if \"labels\" in kwargs:\n            keys = kwargs[\"labels\"]\n            kwargs.pop(\"labels\")\n\n        if keys is not None:\n            if not isinstance(keys, list):\n                raise TypeError(\"The legend keys must be a list.\")\n        else:\n            keys = Legend.DEFAULT_KEYS\n\n        if colors is not None:\n            if not isinstance(colors, list):\n                raise TypeError(\"The legend colors must be a list.\")\n            elif all(isinstance(item, tuple) for item in colors):\n                colors = Legend.__convert_rgb_colors_to_hex(colors)\n            elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n                pass\n            elif all((len(item) == 6) for item in colors):\n                pass\n            else:\n                raise TypeError(\"The legend colors must be a list of tuples.\")\n        else:\n            colors = Legend.DEFAULT_COLORS\n\n        if len(keys) != len(colors):\n            raise ValueError(\"The legend keys and colors must be the same length.\")\n\n        allowed_builtin_legends = builtin_legends.keys()\n        if builtin_legend is not None:\n            builtin_legend_allowed = Legend.__check_if_allowed(\n                builtin_legend, \"builtin legend\", allowed_builtin_legends\n            )\n            if builtin_legend_allowed:\n                legend_dict = builtin_legends[builtin_legend]\n                keys = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n\n        if legend_dict is not None:\n            if not isinstance(legend_dict, dict):\n                raise TypeError(\"The legend dict must be a dictionary.\")\n            else:\n                keys = list(legend_dict.keys())\n                colors = list(legend_dict.values())\n                if all(isinstance(item, tuple) for item in colors):\n                    colors = Legend.__convert_rgb_colors_to_hex(colors)\n\n        Legend.__check_if_allowed(position, \"position\", Legend.ALLOWED_POSITIONS)\n\n        header = []\n        footer = []\n        content = Legend.__create_legend_items(keys, colors)\n\n        with open(legend_template) as f:\n            lines = f.readlines()\n            lines[3] = lines[3].replace(\"Legend\", title)\n            header = lines[:6]\n            footer = lines[11:]\n\n        legend_html = header + content + footer\n        legend_text = \"\".join(legend_html)\n        legend_output = ipywidgets.Output(layout=Legend.__create_layout(**kwargs))\n        legend_widget = ipywidgets.HTML(value=legend_text)\n\n        if add_header:\n            if \"show_close_button\" not in widget_args:\n                widget_args[\"show_close_button\"] = False\n            if \"widget_icon\" not in widget_args:\n                widget_args[\"widget_icon\"] = \"bars\"\n\n            legend_output_widget = common.widget_template(\n                legend_output,\n                position=position,\n                display_widget=legend_widget,\n                **widget_args,\n            )\n        else:\n            legend_output_widget = legend_widget\n\n        super().__init__(children=[legend_output_widget])\n\n        legend_output.clear_output()\n        with legend_output:\n            display(legend_widget)\n\n    def __check_if_allowed(value, value_name, allowed_list):\n        if value not in allowed_list:\n            raise ValueError(\n                \"The \"\n                + value_name\n                + \" must be one of the following: {}.\".format(\", \".join(allowed_list))\n            )\n        return True\n\n    def __convert_rgb_colors_to_hex(colors):\n        try:\n            return [common.rgb_to_hex(x) for x in colors]\n        except:\n            raise ValueError(\"Unable to convert rgb value to hex.\")\n\n    def __create_legend_items(keys, colors):\n        legend_items = []\n        for index, key in enumerate(keys):\n            color = colors[index]\n            if not color.startswith(\"#\"):\n                color = \"#\" + color\n            item = \"&lt;li&gt;&lt;span style='background:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                color, key\n            )\n            legend_items.append(item)\n        return legend_items\n\n    def __create_layout(**kwargs):\n        height = Legend.__create_layout_property(\"height\", None, **kwargs)\n\n        min_height = Legend.__create_layout_property(\"min_height\", None, **kwargs)\n\n        if height is None:\n            max_height = Legend.DEFAULT_MAX_HEIGHT\n        else:\n            max_height = Legend.__create_layout_property(\"max_height\", None, **kwargs)\n\n        width = Legend.__create_layout_property(\"width\", None, **kwargs)\n\n        if \"min_width\" not in kwargs:\n            min_width = None\n\n        if width is None:\n            max_width = Legend.DEFAULT_MAX_WIDTH\n        else:\n            max_width = Legend.__create_layout_property(\n                \"max_width\", Legend.DEFAULT_MAX_WIDTH, **kwargs\n            )\n\n        return {\n            \"height\": height,\n            \"max_height\": max_height,\n            \"max_width\": max_width,\n            \"min_height\": min_height,\n            \"min_width\": min_width,\n            \"overflow\": \"scroll\",\n            \"width\": width,\n        }\n\n    def __create_layout_property(name, default_value, **kwargs):\n        return default_value if name not in kwargs else kwargs[name]\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.Legend.__init__","title":"<code>__init__(self, title='Legend', legend_dict=None, keys=None, colors=None, position='bottomright', builtin_legend=None, add_header=True, widget_args={}, **kwargs)</code>  <code>special</code>","text":"<p>Adds a customized legend to the map.</p> <p>Args:     title (str, optional): Title of the legend. Defaults to 'Legend'.     legend_dict (dict, optional): A dictionary containing legend items         as keys and color as values. If provided, keys and colors will         be ignored. Defaults to None.     keys (list, optional): A list of legend keys. Defaults to None.     colors (list, optional): A list of legend colors. Defaults to None.     position (str, optional): Position of the legend. Defaults to         'bottomright'.     builtin_legend (str, optional): Name of the builtin legend to add         to the map. Defaults to None.     add_header (bool, optional): Whether the legend can be closed or         not. Defaults to True.     widget_args (dict, optional): Additional arguments passed to the         widget_template() function. Defaults to {}.</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the keys are not a list.</p> <code>TypeError</code> <p>If the colors are not list.</p> <code>TypeError</code> <p>If the colors are not a list of tuples.</p> <code>TypeError</code> <p>If the legend_dict is not a dictionary.</p> <code>ValueError</code> <p>If the legend template does not exist.</p> <code>ValueError</code> <p>If a rgb value cannot to be converted to hex.</p> <code>ValueError</code> <p>If the keys and colors are not the same length.</p> <code>ValueError</code> <p>If the builtin_legend is not allowed.</p> <code>ValueError</code> <p>If the position is not allowed.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>def __init__(\n    self,\n    title=\"Legend\",\n    legend_dict=None,\n    keys=None,\n    colors=None,\n    position=\"bottomright\",\n    builtin_legend=None,\n    add_header=True,\n    widget_args={},\n    **kwargs,\n):\n    \"\"\"Adds a customized legend to the map.\n\n     Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'.\n        legend_dict (dict, optional): A dictionary containing legend items\n            as keys and color as values. If provided, keys and colors will\n            be ignored. Defaults to None.\n        keys (list, optional): A list of legend keys. Defaults to None.\n        colors (list, optional): A list of legend colors. Defaults to None.\n        position (str, optional): Position of the legend. Defaults to\n            'bottomright'.\n        builtin_legend (str, optional): Name of the builtin legend to add\n            to the map. Defaults to None.\n        add_header (bool, optional): Whether the legend can be closed or\n            not. Defaults to True.\n        widget_args (dict, optional): Additional arguments passed to the\n            widget_template() function. Defaults to {}.\n\n    Raises:\n        TypeError: If the keys are not a list.\n        TypeError: If the colors are not list.\n        TypeError: If the colors are not a list of tuples.\n        TypeError: If the legend_dict is not a dictionary.\n        ValueError: If the legend template does not exist.\n        ValueError: If a rgb value cannot to be converted to hex.\n        ValueError: If the keys and colors are not the same length.\n        ValueError: If the builtin_legend is not allowed.\n        ValueError: If the position is not allowed.\n\n    \"\"\"\n    import os  # pylint: disable=import-outside-toplevel\n    from IPython.display import display  # pylint: disable=import-outside-toplevel\n    import pkg_resources  # pylint: disable=import-outside-toplevel\n    from .legends import builtin_legends  # pylint: disable=import-outside-toplevel\n\n    pkg_dir = os.path.dirname(\n        pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\")\n    )\n    legend_template = os.path.join(pkg_dir, \"data/template/legend.html\")\n\n    if not os.path.exists(legend_template):\n        raise ValueError(\"The legend template does not exist.\")\n\n    if \"labels\" in kwargs:\n        keys = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n\n    if keys is not None:\n        if not isinstance(keys, list):\n            raise TypeError(\"The legend keys must be a list.\")\n    else:\n        keys = Legend.DEFAULT_KEYS\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            raise TypeError(\"The legend colors must be a list.\")\n        elif all(isinstance(item, tuple) for item in colors):\n            colors = Legend.__convert_rgb_colors_to_hex(colors)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            raise TypeError(\"The legend colors must be a list of tuples.\")\n    else:\n        colors = Legend.DEFAULT_COLORS\n\n    if len(keys) != len(colors):\n        raise ValueError(\"The legend keys and colors must be the same length.\")\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        builtin_legend_allowed = Legend.__check_if_allowed(\n            builtin_legend, \"builtin legend\", allowed_builtin_legends\n        )\n        if builtin_legend_allowed:\n            legend_dict = builtin_legends[builtin_legend]\n            keys = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            raise TypeError(\"The legend dict must be a dictionary.\")\n        else:\n            keys = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                colors = Legend.__convert_rgb_colors_to_hex(colors)\n\n    Legend.__check_if_allowed(position, \"position\", Legend.ALLOWED_POSITIONS)\n\n    header = []\n    footer = []\n    content = Legend.__create_legend_items(keys, colors)\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n        lines[3] = lines[3].replace(\"Legend\", title)\n        header = lines[:6]\n        footer = lines[11:]\n\n    legend_html = header + content + footer\n    legend_text = \"\".join(legend_html)\n    legend_output = ipywidgets.Output(layout=Legend.__create_layout(**kwargs))\n    legend_widget = ipywidgets.HTML(value=legend_text)\n\n    if add_header:\n        if \"show_close_button\" not in widget_args:\n            widget_args[\"show_close_button\"] = False\n        if \"widget_icon\" not in widget_args:\n            widget_args[\"widget_icon\"] = \"bars\"\n\n        legend_output_widget = common.widget_template(\n            legend_output,\n            position=position,\n            display_widget=legend_widget,\n            **widget_args,\n        )\n    else:\n        legend_output_widget = legend_widget\n\n    super().__init__(children=[legend_output_widget])\n\n    legend_output.clear_output()\n    with legend_output:\n        display(legend_widget)\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.RasterLayerEditor","title":"<code> RasterLayerEditor            (VBox)         </code>","text":"<p>Widget for displaying and editing layer visualization properties for raster layers.</p> Source code in <code>leafmap/map_widgets.py</code> <pre><code>class RasterLayerEditor(ipywidgets.VBox):\n    \"\"\"Widget for displaying and editing layer visualization properties for raster layers.\"\"\"\n\n    def __init__(self, host_map, layer_dict):\n        \"\"\"Initializes a raster layer editor widget.\n\n        Args:\n            host_map (geemap.Map): The geemap.Map object.\n            layer_dict (dict): The layer object to edit.\n        \"\"\"\n        self._host_map = host_map\n        self._layer_dict = layer_dict\n\n        self._layer_name = self._layer_dict[\"layer_name\"]\n        self._layer_opacity = self._layer_dict[\"opacity\"]\n        self._min_value = self._layer_dict[\"vmin\"]\n        self._max_value = self._layer_dict[\"vmax\"]\n        self._band_indexes = self._layer_dict[\"indexes\"]\n        self._nodata = self._layer_dict[\"nodata\"]\n\n        if self._layer_dict[\"type\"] == \"LOCAL\":\n            self._tile_client = self._layer_dict[\"tile_client\"]\n            self._filename = self._layer_dict[\"filename\"]\n        if \"xds\" in self._layer_dict:\n            self._xds = self._layer_dict[\"xds\"]\n        else:\n            self._xds = None\n\n        if self._min_value is None or self._max_value is None:\n            try:\n                self._min_value, self._max_value = common.image_min_max(\n                    self._filename, self._band_indexes\n                )\n            except Exception as e:\n                self._min_value = 0\n                self._max_value = 1\n\n        self._sel_bands = self._layer_dict[\"vis_bands\"]\n        self._layer_palette = []\n        self._layer_gamma = 1\n        self._left_value = min(self._min_value, 0)\n        self._right_value = self._max_value * 1.5\n\n        band_names = self._layer_dict[\"band_names\"]\n        self._band_count = len(band_names)\n\n        self._greyscale_radio_button = ipywidgets.RadioButtons(\n            options=[\"1 band (Grayscale)\"],\n            layout={\"width\": \"max-content\", \"margin\": \"0 15px 0 0\"},\n        )\n        self._rgb_radio_button = ipywidgets.RadioButtons(\n            options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n        )\n        self._greyscale_radio_button.index = None\n        self._rgb_radio_button.index = None\n\n        band_dropdown_layout = ipywidgets.Layout(width=\"98px\")\n        self._band_1_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._band_2_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._band_3_dropdown = ipywidgets.Dropdown(\n            options=band_names, value=band_names[0], layout=band_dropdown_layout\n        )\n        self._bands_hbox = ipywidgets.HBox(layout=ipywidgets.Layout(margin=\"0 0 6px 0\"))\n\n        self._color_picker = ipywidgets.ColorPicker(\n            concise=False,\n            value=\"#000000\",\n            layout=ipywidgets.Layout(width=\"116px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        self._add_color_button = ipywidgets.Button(\n            icon=\"plus\",\n            tooltip=\"Add a hex color string to the palette\",\n            layout=ipywidgets.Layout(width=\"32px\"),\n        )\n        self._del_color_button = ipywidgets.Button(\n            icon=\"minus\",\n            tooltip=\"Remove a hex color string from the palette\",\n            layout=ipywidgets.Layout(width=\"32px\"),\n        )\n        self._reset_color_button = ipywidgets.Button(\n            icon=\"eraser\",\n            tooltip=\"Remove all color strings from the palette\",\n            layout=ipywidgets.Layout(width=\"34px\"),\n        )\n        self._add_color_button.on_click(self._add_color_clicked)\n        self._del_color_button.on_click(self._del_color_clicked)\n        self._reset_color_button.on_click(self._reset_color_clicked)\n\n        self._classes_dropdown = ipywidgets.Dropdown(\n            options=[\"Any\"] + [str(i) for i in range(3, 13)],\n            description=\"Classes:\",\n            layout=ipywidgets.Layout(width=\"115px\"),\n            style={\"description_width\": \"initial\"},\n        )\n        self._classes_dropdown.observe(self._classes_changed, \"value\")\n\n        self._colormap_dropdown = ipywidgets.Dropdown(\n            options=self._get_colormaps(),\n            value=None,\n            description=\"Colormap:\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n        self._colormap_dropdown.observe(self._colormap_changed, \"value\")\n\n        self._palette_label = ipywidgets.Text(\n            value=\", \".join(self._layer_palette),\n            placeholder=\"List of hex color code (RRGGBB)\",\n            description=\"Palette:\",\n            tooltip=\"Enter a list of hex color code (RRGGBB)\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"initial\"},\n        )\n\n        self._value_range_slider = ipywidgets.FloatRangeSlider(\n            value=[self._min_value, self._max_value],\n            min=self._left_value,\n            max=self._right_value,\n            step=(self._right_value - self._left_value) / 100,\n            description=\"Range:\",\n            disabled=False,\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=ipywidgets.Layout(width=\"300px\"),\n            style={\"description_width\": \"45px\"},\n        )\n\n        self._opacity_slider = ipywidgets.FloatSlider(\n            value=self._layer_opacity,\n            min=0,\n            max=1,\n            step=0.01,\n            description=\"Opacity:\",\n            continuous_update=False,\n            readout=True,\n            readout_format=\".2f\",\n            layout=ipywidgets.Layout(width=\"310px\"),\n            style={\"description_width\": \"50px\"},\n        )\n\n        self._colorbar_output = ipywidgets.Output(\n            layout=ipywidgets.Layout(height=\"60px\", max_width=\"300px\")\n        )\n\n        children = []\n        if self._band_count &lt; 3:\n            self._greyscale_radio_button.index = 0\n            self._band_1_dropdown.layout.width = \"300px\"\n            self._bands_hbox.children = [self._band_1_dropdown]\n            children = self._get_tool_layout(grayscale=True)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                colors = common.to_hex_colors(\n                    [color.strip() for color in self._palette_label.value.split(\",\")]\n                )\n                self._render_colorbar(colors)\n        else:\n            self._rgb_radio_button.index = 0\n            sel_bands = self._sel_bands\n            if (sel_bands is None) or (len(sel_bands) &lt; 2):\n                sel_bands = band_names[0:3]\n            self._band_1_dropdown.value = sel_bands[0]\n            self._band_2_dropdown.value = sel_bands[1]\n            self._band_3_dropdown.value = sel_bands[2]\n            self._bands_hbox.children = [\n                self._band_1_dropdown,\n                self._band_2_dropdown,\n                self._band_3_dropdown,\n            ]\n            children = self._get_tool_layout(grayscale=False)\n\n        self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n        self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n\n        super().__init__(\n            layout=ipywidgets.Layout(\n                padding=\"5px 0px 5px 8px\",  # top, right, bottom, left\n                # width=\"330px\",\n                max_height=\"305px\",\n                overflow=\"auto\",\n                display=\"block\",\n            ),\n            children=children,\n        )\n\n    def _get_tool_layout(self, grayscale):\n        return [\n            ipywidgets.HBox([self._greyscale_radio_button, self._rgb_radio_button]),\n            self._bands_hbox,\n            self._value_range_slider,\n            self._opacity_slider,\n        ] + (\n            [\n                self._colormap_dropdown,\n                # self._palette_label,\n                self._colorbar_output,\n                # ipywidgets.HBox(\n                #     [\n                #         self._color_picker,\n                #         self._add_color_button,\n                #         self._del_color_button,\n                #         self._reset_color_button,\n                #     ]\n                # ),\n            ]\n            if grayscale\n            else []\n        )\n\n    def _get_colormaps(self):\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        colormap_options = pyplot.colormaps()\n        colormap_options = [\n            item\n            for item in colormap_options\n            if not (item[0].isupper() or \"cet\" in item.lower())\n        ]\n        colormap_options.sort()\n        return colormap_options\n\n    def _render_colorbar(self, colors):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        colors = common.to_hex_colors(colors)\n\n        _, ax = pyplot.subplots(figsize=(4, 0.3))\n        cmap = matplotlib.colors.LinearSegmentedColormap.from_list(\n            \"custom\", colors, N=256\n        )\n        norm = matplotlib.colors.Normalize(\n            vmin=self._value_range_slider.value[0],\n            vmax=self._value_range_slider.value[1],\n        )\n        matplotlib.colorbar.ColorbarBase(\n            ax, norm=norm, cmap=cmap, orientation=\"horizontal\"\n        )\n\n        self._palette_label.value = \", \".join(colors)\n\n        self._colorbar_output.clear_output()\n        with self._colorbar_output:\n            pyplot.show()\n\n    def _classes_changed(self, change):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        if not change[\"new\"]:\n            return\n\n        selected = change[\"owner\"].value\n        if self._colormap_dropdown.value is not None:\n            n_class = None\n            if selected != \"Any\":\n                n_class = int(self._classes_dropdown.value)\n\n            colors = pyplot.get_cmap(self._colormap_dropdown.value, n_class)\n            cmap_colors = [\n                matplotlib.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n            ]\n            self._render_colorbar(cmap_colors)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                labels = [\n                    f\"Class {i+1}\"\n                    for i in range(len(self._palette_label.value.split(\",\")))\n                ]\n\n    def _add_color_clicked(self, _):\n        if self._color_picker.value is not None:\n            if len(self._palette_label.value) == 0:\n                self._palette_label.value = self._color_picker.value\n            else:\n                self._palette_label.value += \", \" + self._color_picker.value\n\n    def _del_color_clicked(self, _):\n        if \",\" in self._palette_label.value:\n            items = [item.strip() for item in self._palette_label.value.split(\",\")]\n            self._palette_label.value = \", \".join(items[:-1])\n        else:\n            self._palette_label.value = \"\"\n\n    def _reset_color_clicked(self, _):\n        self._palette_label.value = \"\"\n\n    def _colormap_changed(self, change):\n        import matplotlib  # pylint: disable=import-outside-toplevel\n        from matplotlib import pyplot  # pylint: disable=import-outside-toplevel\n\n        if change[\"new\"]:\n            n_class = None\n            if self._classes_dropdown.value != \"Any\":\n                n_class = int(self._classes_dropdown.value)\n\n            colors = pyplot.get_cmap(self._colormap_dropdown.value, n_class)\n            cmap_colors = [\n                matplotlib.colors.rgb2hex(colors(i))[1:] for i in range(colors.N)\n            ]\n            self._render_colorbar(cmap_colors)\n\n            if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n                labels = [\n                    f\"Class {i+1}\"\n                    for i in range(len(self._palette_label.value.split(\",\")))\n                ]\n\n    def on_import_click(self):\n        vis = {}\n        if self._greyscale_radio_button.index == 0:\n            vis[\"indexes\"] = [self._band_1_dropdown.index + 1]\n        else:\n            vis[\"indexes\"] = [\n                self._band_1_dropdown.index + 1,\n                self._band_2_dropdown.index + 1,\n                self._band_3_dropdown.index + 1,\n            ]\n            self._colormap_dropdown.value = None\n\n        vis[\"vmin\"] = self._value_range_slider.value[0]\n        vis[\"vmax\"] = self._value_range_slider.value[1]\n        vis[\"opacity\"] = self._opacity_slider.value\n        vis[\"colormap\"] = self._colormap_dropdown.value\n\n        if self._layer_dict[\"type\"] in [\"COG\", \"STAC\"]:\n            if self._layer_dict[\"type\"] == \"COG\":\n                vis[\"bidx\"] = vis[\"indexes\"]\n                if len(vis[\"bidx\"]) == 1:\n                    vis[\"colormap_name\"] = vis[\"colormap\"]\n            elif self._layer_dict[\"type\"] == \"STAC\":\n                vis[\"assets\"] = self._layer_dict[\"assets\"]\n                if len(vis[\"assets\"]) == 1:\n                    vis[\"colormap_name\"] = vis[\"colormap\"]\n            vis[\"rescale\"] = f'{vis[\"vmin\"]},{vis[\"vmax\"]}'\n            vis.pop(\"vmin\", None)\n            vis.pop(\"vmax\", None)\n            vis.pop(\"indexes\", None)\n            vis.pop(\"colormap\", None)\n\n        if \"colormap\" in vis and vis[\"colormap\"] is None:\n            vis.pop(\"colormap\", None)\n        common.create_code_cell(f\"vis_params = {str(vis)}\")\n        print(f\"vis_params = {str(vis)}\")\n\n    def on_apply_click(self):\n        from rio_tiler.colormap import cmap\n\n        vis = {}\n        if self._greyscale_radio_button.index == 0:\n            vis[\"indexes\"] = [self._band_1_dropdown.index + 1]\n        else:\n            vis[\"indexes\"] = [\n                self._band_1_dropdown.index + 1,\n                self._band_2_dropdown.index + 1,\n                self._band_3_dropdown.index + 1,\n            ]\n            self._colormap_dropdown.value = None\n\n        vis[\"vmin\"] = self._value_range_slider.value[0]\n        vis[\"vmax\"] = self._value_range_slider.value[1]\n        vis[\"opacity\"] = self._opacity_slider.value\n        vis[\"colormap\"] = self._colormap_dropdown.value\n\n        if vis[\"colormap\"] is not None:\n            try:\n                cmap.get(vis[\"colormap\"])\n            except:\n                vis[\"colormap\"] = \"gray\"\n                self._colormap_dropdown.value = \"gray\"\n\n        old_layer = self._host_map.find_layer(self._layer_name)\n        layer_index = self._host_map.find_layer_index(self._layer_name)\n\n        self._host_map.remove(old_layer)\n\n        # Add support for hyperspectral data via HyperCoast\n        if self._xds is not None:\n            self._host_map.add_hyper(\n                self._xds,\n                type=self._layer_dict[\"hyper\"],\n                wvl_indexes=[index - 1 for index in vis[\"indexes\"]],\n                colormap=vis[\"colormap\"],\n                vmin=vis[\"vmin\"],\n                vmax=vis[\"vmax\"],\n                opacity=vis[\"opacity\"],\n                nodata=self._nodata,\n                layer_name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n        elif self._layer_dict[\"type\"] == \"COG\":\n            self._host_map.add_cog_layer(\n                self._layer_dict[\"url\"],\n                bidx=vis[\"indexes\"],\n                colormap_name=vis[\"colormap\"],\n                rescale=f'{vis[\"vmin\"]},{vis[\"vmax\"]}',\n                opacity=vis[\"opacity\"],\n                name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n        elif self._layer_dict[\"type\"] == \"STAC\":\n            self._host_map.add_stac_layer(\n                self._layer_dict[\"url\"],\n                titiler_endpoint=self._layer_dict[\"titiler_endpoint\"],\n                collection=self._layer_dict[\"collection\"],\n                item=self._layer_dict[\"item\"],\n                assets=[self._layer_dict[\"band_names\"][i - 1] for i in vis[\"indexes\"]],\n                colormap_name=vis[\"colormap\"],\n                rescale=f'{vis[\"vmin\"]},{vis[\"vmax\"]}',\n                opacity=vis[\"opacity\"],\n                name=self._layer_name,\n                fit_bounds=False,\n                layer_index=layer_index,\n            )\n        else:\n            self._host_map.add_raster(\n                self._filename,\n                indexes=vis[\"indexes\"],\n                colormap=vis[\"colormap\"],\n                vmin=vis[\"vmin\"],\n                vmax=vis[\"vmax\"],\n                opacity=vis[\"opacity\"],\n                nodata=self._nodata,\n                layer_name=self._layer_name,\n                zoom_to_layer=False,\n                layer_index=layer_index,\n            )\n\n        def _remove_control(key):\n            if widget := self._layer_dict.get(key, None):\n                if widget in self._host_map.controls:\n                    self._host_map.remove(widget)\n                del self._layer_dict[key]\n\n    def _radio1_observer(self, _):\n        self._rgb_radio_button.unobserve(self._radio2_observer, names=[\"value\"])\n        self._rgb_radio_button.index = None\n        self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n        self._band_1_dropdown.layout.width = \"300px\"\n        self._colormap_dropdown.value = \"gray\"\n        self._bands_hbox.children = [self._band_1_dropdown]\n        self._palette_label.value = \", \".join(self._layer_palette)\n        self._palette_label.disabled = False\n        self._color_picker.disabled = False\n        self._add_color_button.disabled = False\n        self._del_color_button.disabled = False\n        self._reset_color_button.disabled = False\n        self.children = self._get_tool_layout(grayscale=True)\n\n        if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n            colors = [color.strip() for color in self._palette_label.value.split(\",\")]\n            self._render_colorbar(colors)\n\n    def _radio2_observer(self, _):\n        dropdown_width = \"98px\"\n        self._greyscale_radio_button.unobserve(self._radio1_observer, names=[\"value\"])\n        self._greyscale_radio_button.index = None\n        self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n        self._band_1_dropdown.layout.width = dropdown_width\n        self._colormap_dropdown.value = None\n        self._bands_hbox.children = [\n            self._band_1_dropdown,\n            self._band_2_dropdown,\n            self._band_3_dropdown,\n        ]\n        self._palette_label.value = \"\"\n        self._palette_label.disabled = True\n        self._color_picker.disabled = True\n        self._add_color_button.disabled = True\n        self._del_color_button.disabled = True\n        self._reset_color_button.disabled = True\n        self.children = self._get_tool_layout(grayscale=False)\n        self._colorbar_output.clear_output()\n</code></pre>"},{"location":"map_widgets/#leafmap.map_widgets.RasterLayerEditor.__init__","title":"<code>__init__(self, host_map, layer_dict)</code>  <code>special</code>","text":"<p>Initializes a raster layer editor widget.</p> <p>Parameters:</p> Name Type Description Default <code>host_map</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>layer_dict</code> <code>dict</code> <p>The layer object to edit.</p> required Source code in <code>leafmap/map_widgets.py</code> <pre><code>def __init__(self, host_map, layer_dict):\n    \"\"\"Initializes a raster layer editor widget.\n\n    Args:\n        host_map (geemap.Map): The geemap.Map object.\n        layer_dict (dict): The layer object to edit.\n    \"\"\"\n    self._host_map = host_map\n    self._layer_dict = layer_dict\n\n    self._layer_name = self._layer_dict[\"layer_name\"]\n    self._layer_opacity = self._layer_dict[\"opacity\"]\n    self._min_value = self._layer_dict[\"vmin\"]\n    self._max_value = self._layer_dict[\"vmax\"]\n    self._band_indexes = self._layer_dict[\"indexes\"]\n    self._nodata = self._layer_dict[\"nodata\"]\n\n    if self._layer_dict[\"type\"] == \"LOCAL\":\n        self._tile_client = self._layer_dict[\"tile_client\"]\n        self._filename = self._layer_dict[\"filename\"]\n    if \"xds\" in self._layer_dict:\n        self._xds = self._layer_dict[\"xds\"]\n    else:\n        self._xds = None\n\n    if self._min_value is None or self._max_value is None:\n        try:\n            self._min_value, self._max_value = common.image_min_max(\n                self._filename, self._band_indexes\n            )\n        except Exception as e:\n            self._min_value = 0\n            self._max_value = 1\n\n    self._sel_bands = self._layer_dict[\"vis_bands\"]\n    self._layer_palette = []\n    self._layer_gamma = 1\n    self._left_value = min(self._min_value, 0)\n    self._right_value = self._max_value * 1.5\n\n    band_names = self._layer_dict[\"band_names\"]\n    self._band_count = len(band_names)\n\n    self._greyscale_radio_button = ipywidgets.RadioButtons(\n        options=[\"1 band (Grayscale)\"],\n        layout={\"width\": \"max-content\", \"margin\": \"0 15px 0 0\"},\n    )\n    self._rgb_radio_button = ipywidgets.RadioButtons(\n        options=[\"3 bands (RGB)\"], layout={\"width\": \"max-content\"}\n    )\n    self._greyscale_radio_button.index = None\n    self._rgb_radio_button.index = None\n\n    band_dropdown_layout = ipywidgets.Layout(width=\"98px\")\n    self._band_1_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._band_2_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._band_3_dropdown = ipywidgets.Dropdown(\n        options=band_names, value=band_names[0], layout=band_dropdown_layout\n    )\n    self._bands_hbox = ipywidgets.HBox(layout=ipywidgets.Layout(margin=\"0 0 6px 0\"))\n\n    self._color_picker = ipywidgets.ColorPicker(\n        concise=False,\n        value=\"#000000\",\n        layout=ipywidgets.Layout(width=\"116px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    self._add_color_button = ipywidgets.Button(\n        icon=\"plus\",\n        tooltip=\"Add a hex color string to the palette\",\n        layout=ipywidgets.Layout(width=\"32px\"),\n    )\n    self._del_color_button = ipywidgets.Button(\n        icon=\"minus\",\n        tooltip=\"Remove a hex color string from the palette\",\n        layout=ipywidgets.Layout(width=\"32px\"),\n    )\n    self._reset_color_button = ipywidgets.Button(\n        icon=\"eraser\",\n        tooltip=\"Remove all color strings from the palette\",\n        layout=ipywidgets.Layout(width=\"34px\"),\n    )\n    self._add_color_button.on_click(self._add_color_clicked)\n    self._del_color_button.on_click(self._del_color_clicked)\n    self._reset_color_button.on_click(self._reset_color_clicked)\n\n    self._classes_dropdown = ipywidgets.Dropdown(\n        options=[\"Any\"] + [str(i) for i in range(3, 13)],\n        description=\"Classes:\",\n        layout=ipywidgets.Layout(width=\"115px\"),\n        style={\"description_width\": \"initial\"},\n    )\n    self._classes_dropdown.observe(self._classes_changed, \"value\")\n\n    self._colormap_dropdown = ipywidgets.Dropdown(\n        options=self._get_colormaps(),\n        value=None,\n        description=\"Colormap:\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"initial\"},\n    )\n    self._colormap_dropdown.observe(self._colormap_changed, \"value\")\n\n    self._palette_label = ipywidgets.Text(\n        value=\", \".join(self._layer_palette),\n        placeholder=\"List of hex color code (RRGGBB)\",\n        description=\"Palette:\",\n        tooltip=\"Enter a list of hex color code (RRGGBB)\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"initial\"},\n    )\n\n    self._value_range_slider = ipywidgets.FloatRangeSlider(\n        value=[self._min_value, self._max_value],\n        min=self._left_value,\n        max=self._right_value,\n        step=(self._right_value - self._left_value) / 100,\n        description=\"Range:\",\n        disabled=False,\n        continuous_update=False,\n        readout=True,\n        readout_format=\".2f\",\n        layout=ipywidgets.Layout(width=\"300px\"),\n        style={\"description_width\": \"45px\"},\n    )\n\n    self._opacity_slider = ipywidgets.FloatSlider(\n        value=self._layer_opacity,\n        min=0,\n        max=1,\n        step=0.01,\n        description=\"Opacity:\",\n        continuous_update=False,\n        readout=True,\n        readout_format=\".2f\",\n        layout=ipywidgets.Layout(width=\"310px\"),\n        style={\"description_width\": \"50px\"},\n    )\n\n    self._colorbar_output = ipywidgets.Output(\n        layout=ipywidgets.Layout(height=\"60px\", max_width=\"300px\")\n    )\n\n    children = []\n    if self._band_count &lt; 3:\n        self._greyscale_radio_button.index = 0\n        self._band_1_dropdown.layout.width = \"300px\"\n        self._bands_hbox.children = [self._band_1_dropdown]\n        children = self._get_tool_layout(grayscale=True)\n\n        if len(self._palette_label.value) &gt; 0 and \",\" in self._palette_label.value:\n            colors = common.to_hex_colors(\n                [color.strip() for color in self._palette_label.value.split(\",\")]\n            )\n            self._render_colorbar(colors)\n    else:\n        self._rgb_radio_button.index = 0\n        sel_bands = self._sel_bands\n        if (sel_bands is None) or (len(sel_bands) &lt; 2):\n            sel_bands = band_names[0:3]\n        self._band_1_dropdown.value = sel_bands[0]\n        self._band_2_dropdown.value = sel_bands[1]\n        self._band_3_dropdown.value = sel_bands[2]\n        self._bands_hbox.children = [\n            self._band_1_dropdown,\n            self._band_2_dropdown,\n            self._band_3_dropdown,\n        ]\n        children = self._get_tool_layout(grayscale=False)\n\n    self._greyscale_radio_button.observe(self._radio1_observer, names=[\"value\"])\n    self._rgb_radio_button.observe(self._radio2_observer, names=[\"value\"])\n\n    super().__init__(\n        layout=ipywidgets.Layout(\n            padding=\"5px 0px 5px 8px\",  # top, right, bottom, left\n            # width=\"330px\",\n            max_height=\"305px\",\n            overflow=\"auto\",\n            display=\"block\",\n        ),\n        children=children,\n    )\n</code></pre>"},{"location":"maplibregl/","title":"maplibregl module","text":"<p>The maplibregl module provides the Map class for creating interactive maps using the maplibre.ipywidget module.</p>"},{"location":"maplibregl/#leafmap.maplibregl.Map","title":"<code> Map            (MapWidget)         </code>","text":"<p>The Map class inherits from the MapWidget class of the maplibre.ipywidget module.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>class Map(MapWidget):\n    \"\"\"The Map class inherits from the MapWidget class of the maplibre.ipywidget module.\"\"\"\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0, 20),\n        zoom: float = 1,\n        pitch: float = 0,\n        bearing: float = 0,\n        style: str = \"dark-matter\",\n        height: str = \"600px\",\n        controls: Dict[str, str] = {\n            \"navigation\": \"top-right\",\n            \"fullscreen\": \"top-right\",\n            \"scale\": \"bottom-left\",\n        },\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Create a Map object.\n\n        Args:\n            center (tuple, optional): The center of the map (lon, lat). Defaults\n                to (0, 20).\n            zoom (float, optional): The zoom level of the map. Defaults to 1.\n            pitch (float, optional): The pitch of the map. Measured in degrees\n                away from the plane of the screen (0-85) Defaults to 0.\n            bearing (float, optional): The bearing of the map. Measured in degrees\n                counter-clockwise from north. Defaults to 0.\n            style (str, optional): The style of the map. It can be a string or a URL.\n                If it is a string, it must be one of the following: \"dark-matter\",\n                \"positron\", \"voyager\", \"positron-nolabels\", \"dark-matter-nolabels\",\n                \"voyager-nolabels\", or \"demotiles\". If it is a URL, it must point to\n                a MapLibre style JSON. Defaults to \"dark-matter\".\n            height (str, optional): The height of the map. Defaults to \"600px\".\n            controls (dict, optional): The controls and their positions on the\n                map. Defaults to {\"fullscreen\": \"top-right\", \"scale\": \"bottom-left\"}.\n            **kwargs: Additional keyword arguments that are passed to the MapOptions class.\n                See https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/MapOptions/\n                for more information.\n\n        Returns:\n            None\n        \"\"\"\n        carto_basemaps = [\n            \"dark-matter\",\n            \"positron\",\n            \"voyager\",\n            \"positron-nolabels\",\n            \"dark-matter-nolabels\",\n            \"voyager-nolabels\",\n        ]\n        if isinstance(style, str):\n\n            if style.startswith(\"https\"):\n                response = requests.get(style)\n                if response.status_code != 200:\n                    style = \"dark-matter\"\n\n            if style == \"3d-terrain\":\n                style = self._get_3d_terrain_style()\n\n            if isinstance(style, str) and (style.lower() in carto_basemaps):\n                style = construct_carto_basemap_url(style.lower())\n            elif style == \"demotiles\":\n                style = \"https://demotiles.maplibre.org/style.json\"\n            elif \"background-\" in style:\n                color = style.split(\"-\")[1]\n                style = background(color)\n\n        if style is not None:\n            kwargs[\"style\"] = style\n\n        if len(controls) == 0:\n            kwargs[\"attribution_control\"] = False\n\n        map_options = MapOptions(\n            center=center, zoom=zoom, pitch=pitch, bearing=bearing, **kwargs\n        )\n\n        super().__init__(map_options, height=height)\n        super().use_message_queue()\n\n        for control, position in controls.items():\n            self.add_control(control, position)\n\n        self.layer_dict = {}\n        self.layer_dict[\"background\"] = {\n            \"layer\": Layer(id=\"background\", type=LayerType.BACKGROUND),\n            \"opacity\": 1.0,\n            \"visible\": True,\n            \"type\": \"background\",\n            \"color\": None,\n        }\n        self._style = style\n        self.style_dict = {}\n        for layer in self.get_style_layers():\n            self.style_dict[layer[\"id\"]] = layer\n        self.source_dict = {}\n\n    def add_layer(\n        self,\n        layer: \"Layer\",\n        before_id: Optional[str] = None,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Adds a layer to the map.\n\n        This method adds a layer to the map. If a name is provided, it is used\n            as the key to store the layer in the layer dictionary. Otherwise,\n            the layer's ID is used as the key. If a before_id is provided, the\n            layer is inserted before the layer with that ID.\n\n        Args:\n            layer (Layer): The layer object to add to the map.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            name (str, optional): The name to use as the key to store the layer\n                in the layer dictionary. If None, the layer's ID is used as the key.\n\n        Returns:\n            None\n        \"\"\"\n        if isinstance(layer, dict):\n            if \"minzoom\" in layer:\n                layer[\"min-zoom\"] = layer.pop(\"minzoom\")\n            if \"maxzoom\" in layer:\n                layer[\"max-zoom\"] = layer.pop(\"maxzoom\")\n            layer = replace_top_level_hyphens(layer)\n            layer = Layer(**layer)\n\n        if name is None:\n            name = layer.id\n\n        if (\n            \"paint\" in layer.to_dict()\n            and f\"{layer.type}-color\" in layer.paint\n            and isinstance(layer.paint[f\"{layer.type}-color\"], str)\n        ):\n            color = check_color(layer.paint[f\"{layer.type}-color\"])\n        else:\n            color = None\n\n        self.layer_dict[name] = {\n            \"layer\": layer,\n            \"opacity\": 1.0,\n            \"visible\": True,\n            \"type\": layer.type,\n            \"color\": color,\n        }\n        super().add_layer(layer, before_id=before_id)\n\n    def remove_layer(self, name: str) -&gt; None:\n        \"\"\"\n        Removes a layer from the map.\n\n        This method removes a layer from the map using the layer's name.\n\n        Args:\n            name (str): The name of the layer to remove.\n\n        Returns:\n            None\n        \"\"\"\n\n        super().add_call(\"removeLayer\", name)\n        if name in self.layer_dict:\n            self.layer_dict.pop(name)\n\n    def add_control(\n        self, control: Union[str, Any], position: str = \"top-right\", **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Adds a control to the map.\n\n        This method adds a control to the map. The control can be one of the\n            following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\". If the\n            control is a string, it is converted to the corresponding control object.\n            If the control is not a string, it is assumed to be a control object.\n\n        Args:\n            control (str or object): The control to add to the map. Can be one\n                of the following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\".\n            position (str, optional): The position of the control. Defaults to \"top-right\".\n            **kwargs: Additional keyword arguments that are passed to the control object.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the control is a string and is not one of the\n                following: 'scale', 'fullscreen', 'geolocate', 'navigation', \"attribution\".\n        \"\"\"\n\n        if isinstance(control, str):\n            control = control.lower()\n            if control == \"scale\":\n                control = ScaleControl(**kwargs)\n            elif control == \"fullscreen\":\n                control = FullscreenControl(**kwargs)\n            elif control == \"geolocate\":\n                control = GeolocateControl(**kwargs)\n            elif control == \"navigation\":\n                control = NavigationControl(**kwargs)\n            elif control == \"attribution\":\n                control = AttributionControl(**kwargs)\n            else:\n                print(\n                    \"Control can only be one of the following: 'scale', 'fullscreen', 'geolocate', 'navigation'\"\n                )\n                return\n\n        super().add_control(control, position)\n\n    def add_source(self, id: str, source: Union[str, Dict]) -&gt; None:\n        \"\"\"\n        Adds a source to the map.\n\n        Args:\n            id (str): The ID of the source.\n            source (str or dict): The source data. .\n\n        Returns:\n            None\n        \"\"\"\n        super().add_source(id, source)\n        self.source_dict[id] = source\n\n    def set_center(self, lon: float, lat: float, zoom: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Sets the center of the map.\n\n        This method sets the center of the map to the specified longitude and latitude.\n        If a zoom level is provided, it also sets the zoom level of the map.\n\n        Args:\n            lon (float): The longitude of the center of the map.\n            lat (float): The latitude of the center of the map.\n            zoom (int, optional): The zoom level of the map. If None, the zoom\n                level is not changed.\n\n        Returns:\n            None\n        \"\"\"\n        center = [lon, lat]\n        self.add_call(\"setCenter\", center)\n\n        if zoom is not None:\n            self.add_call(\"setZoom\", zoom)\n\n    def set_zoom(self, zoom: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Sets the zoom level of the map.\n\n        This method sets the zoom level of the map to the specified value.\n\n        Args:\n            zoom (int): The zoom level of the map.\n\n        Returns:\n            None\n        \"\"\"\n        self.add_call(\"setZoom\", zoom)\n\n    def fit_bounds(self, bounds: List[Tuple[float, float]]) -&gt; None:\n        \"\"\"\n        Adjusts the viewport of the map to fit the specified geographical bounds\n            in the format of [[lon_min, lat_min], [lon_max, lat_max]] or\n            [lon_min, lat_min, lon_max, lat_max].\n\n        This method adjusts the viewport of the map so that the specified geographical bounds\n        are visible in the viewport. The bounds are specified as a list of two points,\n        where each point is a list of two numbers representing the longitude and latitude.\n\n        Args:\n            bounds (list): A list of two points representing the geographical bounds that\n                        should be visible in the viewport. Each point is a list of two\n                        numbers representing the longitude and latitude. For example,\n                        [[32.958984, -5.353521],[43.50585, 5.615985]]\n\n        Returns:\n            None\n        \"\"\"\n\n        if isinstance(bounds, list):\n            if len(bounds) == 4 and all(isinstance(i, (int, float)) for i in bounds):\n                bounds = [[bounds[0], bounds[1]], [bounds[2], bounds[3]]]\n\n        self.add_call(\"fitBounds\", bounds)\n\n    def add_basemap(\n        self,\n        basemap: Union[str, xyzservices.TileProvider] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        attribution: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a basemap to the map.\n\n        This method adds a basemap to the map. The basemap can be a string from\n        predefined basemaps, an instance of xyzservices.TileProvider, or a key\n        from the basemaps dictionary.\n\n        Args:\n            basemap (str or TileProvider, optional): The basemap to add. Can be\n                one of the predefined strings, an instance of xyzservices.TileProvider,\n                or a key from the basemaps dictionary. Defaults to None, which adds\n                the basemap widget.\n            opacity (float, optional): The opacity of the basemap. Defaults to 1.0.\n            visible (bool, optional): Whether the basemap is visible or not.\n                Defaults to True.\n            attribution (str, optional): The attribution text to display for the\n                basemap. If None, the attribution text is taken from the basemap\n                or the TileProvider. Defaults to None.\n            **kwargs: Additional keyword arguments that are passed to the\n                RasterTileSource class. See https://bit.ly/4erD2MQ for more information.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the basemap is not one of the predefined strings,\n                not an instance of TileProvider, and not a key from the basemaps dictionary.\n        \"\"\"\n\n        if basemap is None:\n            return self._basemap_widget()\n\n        map_dict = {\n            \"ROADMAP\": \"Google Maps\",\n            \"SATELLITE\": \"Google Satellite\",\n            \"TERRAIN\": \"Google Terrain\",\n            \"HYBRID\": \"Google Hybrid\",\n        }\n\n        name = basemap\n        url = None\n        max_zoom = 30\n        min_zoom = 0\n\n        if isinstance(basemap, str) and basemap.upper() in map_dict:\n            layer = get_google_map(basemap.upper(), **kwargs)\n            url = layer.url\n            name = layer.name\n            attribution = layer.attribution\n\n        elif isinstance(basemap, xyzservices.TileProvider):\n            name = basemap.name\n            url = basemap.build_url()\n            if attribution is None:\n                attribution = basemap.attribution\n            if \"max_zoom\" in basemap.keys():\n                max_zoom = basemap[\"max_zoom\"]\n            if \"min_zoom\" in basemap.keys():\n                min_zoom = basemap[\"min_zoom\"]\n\n        elif basemap in basemaps:\n            url = basemaps[basemap][\"url\"]\n            if attribution is None:\n                attribution = basemaps[basemap][\"attribution\"]\n            if \"max_zoom\" in basemaps[basemap]:\n                max_zoom = basemaps[basemap][\"max_zoom\"]\n            if \"min_zoom\" in basemaps[basemap]:\n                min_zoom = basemaps[basemap][\"min_zoom\"]\n        else:\n            print(\n                \"Basemap can only be one of the following:\\n  {}\".format(\n                    \"\\n  \".join(basemaps.keys())\n                )\n            )\n            return\n\n        raster_source = RasterTileSource(\n            tiles=[url],\n            attribution=attribution,\n            max_zoom=max_zoom,\n            min_zoom=min_zoom,\n            tile_size=256,\n            **kwargs,\n        )\n        layer = Layer(id=name, source=raster_source, type=LayerType.RASTER)\n        self.add_layer(layer)\n        self.set_opacity(name, opacity)\n        self.set_visibility(name, visible)\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        filter: Optional[Dict] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        visible: bool = True,\n        before_id: Optional[str] = None,\n        source_args: Dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a GeoJSON layer to the map.\n\n        This method adds a GeoJSON layer to the map. The GeoJSON data can be a\n        URL to a GeoJSON file or a GeoJSON dictionary. If a name is provided, it\n        is used as the key to store the layer in the layer dictionary. Otherwise,\n        a random name is generated.\n\n        Args:\n            data (str | dict): The GeoJSON data. This can be a URL to a GeoJSON\n                file or a GeoJSON dictionary.\n            layer_type (str, optional): The type of the layer. It can be one of\n                the following: 'circle', 'fill', 'fill-extrusion', 'line', 'symbol',\n                'raster', 'background', 'heatmap', 'hillshade'. If None, the type\n                is inferred from the GeoJSON data.\n            filter (dict, optional): The filter to apply to the layer. If None,\n                no filter is applied.\n            paint (dict, optional): The paint properties to apply to the layer.\n                If None, no paint properties are applied.\n            name (str, optional): The name of the layer. If None, a random name\n                is generated.\n            fit_bounds (bool, optional): Whether to adjust the viewport of the\n                map to fit the bounds of the GeoJSON data. Defaults to True.\n            visible (bool, optional): Whether the layer is visible or not.\n                Defaults to True.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            source_args (dict, optional): Additional keyword arguments that are\n                passed to the GeoJSONSource class.\n            **kwargs: Additional keyword arguments that are passed to the Layer class.\n                See https://maplibre.org/maplibre-style-spec/layers/ for more info.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the data is not a URL or a GeoJSON dictionary.\n        \"\"\"\n\n        import os\n\n        bounds = None\n        geom_type = None\n\n        if isinstance(data, str):\n            if os.path.isfile(data) or data.startswith(\"http\"):\n                data = gpd.read_file(data).__geo_interface__\n                bounds = get_bounds(data)\n                source = GeoJSONSource(data=data, **source_args)\n            else:\n                raise ValueError(\"The data must be a URL or a GeoJSON dictionary.\")\n        elif isinstance(data, dict):\n            source = GeoJSONSource(data=data, **source_args)\n\n            bounds = get_bounds(data)\n        else:\n            raise ValueError(\"The data must be a URL or a GeoJSON dictionary.\")\n\n        if name is None:\n            name = \"geojson_\" + random_string()\n\n        if filter is not None:\n            kwargs[\"filter\"] = filter\n        if paint is None:\n            if \"features\" in data:\n                geom_type = data[\"features\"][0][\"geometry\"][\"type\"]\n            elif \"geometry\" in data:\n                geom_type = data[\"geometry\"][\"type\"]\n            if geom_type in [\"Point\", \"MultiPoint\"]:\n                if layer_type is None:\n                    layer_type = \"circle\"\n                paint = {\n                    \"circle-radius\": 5,\n                    \"circle-color\": \"#3388ff\",\n                    \"circle-stroke-color\": \"#ffffff\",\n                    \"circle-stroke-width\": 1,\n                }\n            elif geom_type in [\"LineString\", \"MultiLineString\"]:\n                if layer_type is None:\n                    layer_type = \"line\"\n                paint = {\"line-color\": \"#3388ff\", \"line-width\": 2}\n            elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n                if layer_type is None:\n                    layer_type = \"fill\"\n                paint = {\n                    \"fill-color\": \"#3388ff\",\n                    \"fill-opacity\": 0.8,\n                    \"fill-outline-color\": \"#ffffff\",\n                }\n\n        if paint is not None:\n            kwargs[\"paint\"] = paint\n\n        layer = Layer(\n            id=name,\n            type=layer_type,\n            source=source,\n            **kwargs,\n        )\n        self.add_layer(layer, before_id=before_id, name=name)\n        self.add_popup(name)\n        if fit_bounds and bounds is not None:\n            self.fit_bounds(bounds)\n        self.set_visibility(name, visible)\n\n        if isinstance(paint, dict) and f\"{layer_type}-opacity\" in paint:\n            self.set_opacity(name, paint[f\"{layer_type}-opacity\"])\n        else:\n            self.set_opacity(name, 1.0)\n\n    def add_vector(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        filter: Optional[Dict] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        visible: bool = True,\n        before_id: Optional[str] = None,\n        source_args: Dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a vector layer to the map.\n\n        This method adds a vector layer to the map. The vector data can be a\n        URL or local file path to a vector file. If a name is provided, it\n        is used as the key to store the layer in the layer dictionary. Otherwise,\n        a random name is generated.\n\n        Args:\n            data (str | dict): The vector data. This can be a URL or local file\n                path to a vector file.\n            layer_type (str, optional): The type of the layer. If None, the type\n                is inferred from the GeoJSON data.\n            filter (dict, optional): The filter to apply to the layer. If None,\n                no filter is applied.\n            paint (dict, optional): The paint properties to apply to the layer.\n                If None, no paint properties are applied.\n            name (str, optional): The name of the layer. If None, a random name\n                is generated.\n            fit_bounds (bool, optional): Whether to adjust the viewport of the\n                map to fit the bounds of the GeoJSON data. Defaults to True.\n            visible (bool, optional): Whether the layer is visible or not.\n                Defaults to True.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            source_args (dict, optional): Additional keyword arguments that are\n                passed to the GeoJSONSource class.\n            **kwargs: Additional keyword arguments that are passed to the Layer class.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the data is not a URL or a GeoJSON dictionary.\n        \"\"\"\n\n        if not isinstance(data, gpd.GeoDataFrame):\n            data = gpd.read_file(data).__geo_interface__\n        else:\n            data = data.__geo_interface__\n\n        self.add_geojson(\n            data,\n            layer_type=layer_type,\n            filter=filter,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            visible=visible,\n            before_id=before_id,\n            source_args=source_args,\n            **kwargs,\n        )\n\n    def add_gdf(\n        self,\n        gdf: gpd.GeoDataFrame,\n        layer_type: Optional[str] = None,\n        filter: Optional[Dict] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        visible: bool = True,\n        before_id: Optional[str] = None,\n        source_args: Dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a vector layer to the map.\n\n        This method adds a GeoDataFrame to the map as a vector layer.\n\n        Args:\n            gdf (gpd.GeoDataFrame): The GeoDataFrame to add to the map.\n            layer_type (str, optional): The type of the layer. If None, the type\n                is inferred from the GeoJSON data.\n            filter (dict, optional): The filter to apply to the layer. If None,\n                no filter is applied.\n            paint (dict, optional): The paint properties to apply to the layer.\n                If None, no paint properties are applied.\n            name (str, optional): The name of the layer. If None, a random name\n                is generated.\n            fit_bounds (bool, optional): Whether to adjust the viewport of the\n                map to fit the bounds of the GeoJSON data. Defaults to True.\n            visible (bool, optional): Whether the layer is visible or not.\n                Defaults to True.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            source_args (dict, optional): Additional keyword arguments that are\n                passed to the GeoJSONSource class.\n            **kwargs: Additional keyword arguments that are passed to the Layer class.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the data is not a URL or a GeoJSON dictionary.\n        \"\"\"\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise ValueError(\"The data must be a GeoDataFrame.\")\n        geojson = gdf.__geo_interface__\n        self.add_geojson(\n            geojson,\n            layer_type=layer_type,\n            filter=filter,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            visible=visible,\n            before_id=before_id,\n            source_args=source_args,\n            **kwargs,\n        )\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: str = \"Tile Layer\",\n        attribution: str = \"\",\n        opacity: float = 1.0,\n        visible: bool = True,\n        tile_size: int = 256,\n        before_id: Optional[str] = None,\n        source_args: Dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a TileLayer to the map.\n\n        This method adds a TileLayer to the map. The TileLayer is created from\n            the specified URL, and it is added to the map with the specified\n            name, attribution, visibility, and tile size.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str, optional): The name to use for the layer. Defaults to '\n                Tile Layer'.\n            attribution (str, optional): The attribution to use for the layer.\n                Defaults to ''.\n            visible (bool, optional): Whether the layer should be visible by\n                default. Defaults to True.\n            tile_size (int, optional): The size of the tiles in the layer.\n                Defaults to 256.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            source_args (dict, optional): Additional keyword arguments that are\n                passed to the RasterTileSource class.\n            **kwargs: Additional keyword arguments that are passed to the Layer class.\n                See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.\n\n        Returns:\n            None\n        \"\"\"\n\n        raster_source = RasterTileSource(\n            tiles=[url.strip()],\n            attribution=attribution,\n            tile_size=tile_size,\n            **source_args,\n        )\n        layer = Layer(id=name, source=raster_source, type=LayerType.RASTER, **kwargs)\n        self.add_layer(layer, before_id=before_id, name=name)\n        self.set_visibility(name, visible)\n        self.set_opacity(name, opacity)\n\n    def add_wms_layer(\n        self,\n        url: str,\n        name: str = \"WMS Layer\",\n        attribution: str = \"\",\n        opacity: float = 1.0,\n        visible: bool = True,\n        tile_size: int = 256,\n        before_id: Optional[str] = None,\n        source_args: Dict = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a WMS layer to the map.\n\n        This method adds a WMS layer to the map. The WMS  is created from\n            the specified URL, and it is added to the map with the specified\n            name, attribution, visibility, and tile size.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str, optional): The name to use for the layer. Defaults to\n                'WMS Layer'.\n            attribution (str, optional): The attribution to use for the layer.\n                Defaults to ''.\n            visible (bool, optional): Whether the layer should be visible by\n                default. Defaults to True.\n            tile_size (int, optional): The size of the tiles in the layer.\n                Defaults to 256.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            source_args (dict, optional): Additional keyword arguments that are\n                passed to the RasterTileSource class.\n            **kwargs: Additional keyword arguments that are passed to the Layer class.\n                See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.\n\n        Returns:\n            None\n        \"\"\"\n        self.add_tile_layer(\n            url,\n            name=name,\n            attribution=attribution,\n            opacity=opacity,\n            visible=visible,\n            tile_size=tile_size,\n            before_id=before_id,\n            source_args=source_args,\n            **kwargs,\n        )\n\n    def add_ee_layer(\n        self,\n        asset_id: str,\n        name: str = None,\n        opacity: float = 1.0,\n        attribution: str = \"Google Earth Engine\",\n        visible: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n            https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n        Args:\n            asset_id (str): The ID of the Earth Engine asset.\n            name (str, optional): The name of the tile layer. If not provided,\n                the asset ID will be used. Default is None.\n            opacity (float, optional): The opacity of the tile layer (0 to 1).\n                Default is 1.\n            attribution (str, optional): The attribution text to be displayed.\n                Default is \"Google Earth Engine\".\n            visible (bool, optional): Whether the tile layer should be shown on\n                the map. Default is True.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            **kwargs: Additional keyword arguments to be passed to the underlying\n                `add_tile_layer` method.\n\n        Returns:\n            None\n        \"\"\"\n        import pandas as pd\n\n        df = pd.read_csv(\n            \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n            sep=\"\\t\",\n        )\n\n        asset_id = asset_id.strip()\n        if name is None:\n            name = asset_id\n\n        if asset_id in df[\"id\"].values:\n            url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n            self.add_tile_layer(\n                url,\n                name,\n                attribution=attribution,\n                opacity=opacity,\n                visible=visible,\n                before_id=before_id,\n                **kwargs,\n            )\n        else:\n            print(f\"The provided EE tile layer {asset_id} does not exist.\")\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        opacity: float = 1.0,\n        visible: bool = True,\n        bands: Optional[List[int]] = None,\n        titiler_endpoint: str = \"https://titiler.xyz\",\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a Cloud Optimized Geotiff (COG) TileLayer to the map.\n\n        This method adds a COG TileLayer to the map. The COG TileLayer is created\n        from the specified URL, and it is added to the map with the specified name,\n        attribution, opacity, visibility, and bands.\n\n        Args:\n            url (str): The URL of the COG tile layer.\n            name (str, optional): The name to use for the layer. If None, a\n                random name is generated. Defaults to None.\n            attribution (str, optional): The attribution to use for the layer.\n                Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            visible (bool, optional): Whether the layer should be visible by default.\n                Defaults to True.\n            bands (list, optional): A list of bands to use for the layer.\n                Defaults to None.\n            titiler_endpoint (str, optional): The endpoint of the titiler service.\n                Defaults to \"https://titiler.xyz\".\n            fit_bounds (bool, optional): Whether to adjust the viewport of\n                the map to fit the bounds of the layer. Defaults to True.\n            **kwargs: Arbitrary keyword arguments, including bidx, expression,\n                nodata, unscale, resampling, rescale, color_formula, colormap,\n                    colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/.\n                    To select a certain bands, use bidx=[1, 2, 3]. apply a\n                        rescaling to multiple bands, use something like\n                        `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n        Returns:\n            None\n        \"\"\"\n\n        if name is None:\n            name = \"COG_\" + random_string()\n\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        bounds = cog_bounds(url, titiler_endpoint)\n        self.add_tile_layer(\n            tile_url, name, attribution, opacity, visible, before_id=before_id\n        )\n        if fit_bounds:\n            self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n\n    def add_stac_layer(\n        self,\n        url: Optional[str] = None,\n        collection: Optional[str] = None,\n        item: Optional[str] = None,\n        assets: Optional[Union[str, List[str]]] = None,\n        bands: Optional[List[str]] = None,\n        titiler_endpoint: Optional[str] = None,\n        name: str = \"STAC Layer\",\n        attribution: str = \"\",\n        opacity: float = 1.0,\n        visible: bool = True,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a STAC TileLayer to the map.\n\n        This method adds a STAC TileLayer to the map. The STAC TileLayer is\n        created from the specified URL, collection, item, assets, and bands, and\n        it is added to the map with the specified name, attribution, opacity,\n        visibility, and fit bounds.\n\n        Args:\n            url (str, optional): HTTP URL to a STAC item, e.g., https://bit.ly/3VlttGm.\n                Defaults to None.\n            collection (str, optional): The Microsoft Planetary Computer STAC\n                collection ID, e.g., landsat-8-c2-l2. Defaults to None.\n            item (str, optional): The Microsoft Planetary Computer STAC item ID, e.g.,\n                LC08_L2SP_047027_20201204_02_T1. Defaults to None.\n            assets (str | list, optional): The Microsoft Planetary Computer STAC asset ID,\n                e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.\n            bands (list, optional): A list of band names, e.g.,\n                [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\",\n                \"https://planetarycomputer.microsoft.com/api/data/v1\",\n                \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            visible (bool, optional): A flag indicating whether the layer should\n                be on by default. Defaults to True.\n            fit_bounds (bool, optional): A flag indicating whether the map should\n                be zoomed to the layer extent. Defaults to True.\n            before_id (str, optional): The ID of an existing layer before which\n                the new layer should be inserted.\n            **kwargs: Arbitrary keyword arguments, including bidx, expression,\n                nodata, unscale, resampling, rescale, color_formula, colormap,\n                colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/. To select\n                a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple\n                bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n\n        Returns:\n            None\n        \"\"\"\n        if \"colormap_name\" in kwargs and kwargs[\"colormap_name\"] is None:\n            kwargs.pop(\"colormap_name\")\n\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        bounds = stac_bounds(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(\n            tile_url, name, attribution, opacity, visible, before_id=before_id\n        )\n        if fit_bounds:\n            self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n\n    def add_raster(\n        self,\n        source,\n        indexes=None,\n        colormap=None,\n        vmin=None,\n        vmax=None,\n        nodata=None,\n        attribution=\"Localtileserver\",\n        name=\"Raster\",\n        before_id=None,\n        fit_bounds=True,\n        visible=True,\n        opacity=1.0,\n        array_args={},\n        client_args={\"cors_all\": True},\n        **kwargs,\n    ):\n        \"\"\"Add a local raster dataset to the map.\n            If you are using this function in JupyterHub on a remote server\n            (e.g., Binder, Microsoft Planetary Computer) and if the raster\n            does not render properly, try installing jupyter-server-proxy using\n            `pip install jupyter-server-proxy`, then running the following code\n            before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n            import os\n            os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n        Args:\n            source (str): The path to the GeoTIFF file or the URL of the Cloud\n                Optimized GeoTIFF.\n            indexes (int, optional): The band(s) to use. Band indexing starts\n                at 1. Defaults to None.\n            colormap (str, optional): The name of the colormap from `matplotlib`\n                to use when plotting a single band.\n                See https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n                Default is greyscale.\n            vmin (float, optional): The minimum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            vmax (float, optional): The maximum value to use when colormapping\n                the palette when plotting a single band. Defaults to None.\n            nodata (float, optional): The value from the band to use to interpret\n                as not valid data. Defaults to None.\n            attribution (str, optional): Attribution for the source raster. This\n                defaults to a message about it being a local file.. Defaults to None.\n            layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n            layer_index (int, optional): The index of the layer. Defaults to None.\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n                layer. Defaults to True.\n            visible (bool, optional): Whether the layer is visible. Defaults to True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            array_args (dict, optional): Additional arguments to pass to\n                `array_to_memory_file` when reading the raster. Defaults to {}.\n            client_args (dict, optional): Additional arguments to pass to\n                localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n        \"\"\"\n        import numpy as np\n        import xarray as xr\n\n        if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n            source = array_to_image(source, **array_args)\n\n        tile_layer, tile_client = get_local_tile_layer(\n            source,\n            indexes=indexes,\n            colormap=colormap,\n            vmin=vmin,\n            vmax=vmax,\n            nodata=nodata,\n            opacity=opacity,\n            attribution=attribution,\n            layer_name=name,\n            client_args=client_args,\n            return_client=True,\n            **kwargs,\n        )\n\n        self.add_tile_layer(\n            tile_layer.url,\n            name=name,\n            opacity=opacity,\n            visible=visible,\n            attribution=attribution,\n            before_id=before_id,\n        )\n\n        bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n        bounds = [[bounds[2], bounds[0]], [bounds[3], bounds[1]]]\n        # [minx, miny, maxx, maxy]\n        if fit_bounds:\n            self.fit_bounds(bounds)\n\n    def to_html(\n        self,\n        title: str = \"Map\",\n        width: str = \"100%\",\n        height: str = \"880px\",\n        output: str = None,\n        **kwargs,\n    ):\n        \"\"\"Render the map to an HTML page.\n\n        Args:\n            title (str, optional): The title of the HTML page. Defaults to 'Map'.\n            width (str, optional): The width of the map. Defaults to '100%'.\n            height (str, optional): The height of the map. Defaults to '880px'.\n            **kwargs: Additional keyword arguments that are passed to the\n                `maplibre.ipywidget.MapWidget.to_html()` method.\n\n        Returns:\n            str: The HTML content of the map.\n        \"\"\"\n\n        if \"style\" not in kwargs:\n            kwargs[\"style\"] = f\"width: {width}; height: {height};\"\n        else:\n            kwargs[\"style\"] += f\"width: {width}; height: {height};\"\n        html = super().to_html(title=title, **kwargs)\n        if output:\n            with open(output, \"w\") as f:\n                f.write(html)\n        else:\n            return html\n\n    def set_paint_property(self, name: str, prop: str, value: Any) -&gt; None:\n        \"\"\"\n        Set the opacity of a layer.\n\n        This method sets the opacity of the specified layer to the specified value.\n\n        Args:\n            name (str): The name of the layer.\n            opacity (float): The opacity value to set.\n\n        Returns:\n            None\n        \"\"\"\n        super().set_paint_property(name, prop, value)\n\n        if \"opacity\" in prop and name in self.layer_dict:\n            self.layer_dict[name][\"opacity\"] = value\n        elif name in self.style_dict:\n            layer = self.style_dict[name]\n            if \"paint\" in layer:\n                layer[\"paint\"][prop] = value\n\n    def set_layout_property(self, name: str, prop: str, value: Any) -&gt; None:\n        \"\"\"\n        Set the layout property of a layer.\n\n        This method sets the layout property of the specified layer to the specified value.\n\n        Args:\n            name (str): The name of the layer.\n            prop (str): The layout property to set.\n            value (Any): The value to set.\n\n        Returns:\n            None\n        \"\"\"\n        super().set_layout_property(name, prop, value)\n\n        if name in self.style_dict:\n            layer = self.style_dict[name]\n            if \"layout\" in layer:\n                layer[\"layout\"][prop] = value\n\n    def set_color(self, name: str, color: str) -&gt; None:\n        \"\"\"\n        Set the color of a layer.\n\n        This method sets the color of the specified layer to the specified value.\n\n        Args:\n            name (str): The name of the layer.\n            color (str): The color value to set.\n\n        Returns:\n            None\n        \"\"\"\n        color = check_color(color)\n        super().set_paint_property(\n            name, f\"{self.layer_dict[name]['layer'].type}-color\", color\n        )\n        self.layer_dict[name][\"color\"] = color\n\n    def set_opacity(self, name: str, opacity: float) -&gt; None:\n        \"\"\"\n        Set the opacity of a layer.\n\n        This method sets the opacity of the specified layer to the specified value.\n\n        Args:\n            name (str): The name of the layer.\n            opacity (float): The opacity value to set.\n\n        Returns:\n            None\n        \"\"\"\n\n        if name in self.layer_dict:\n            layer_type = self.layer_dict[name][\"layer\"].to_dict()[\"type\"]\n            prop_name = f\"{layer_type}-opacity\"\n            self.layer_dict[name][\"opacity\"] = opacity\n        elif name in self.style_dict:\n            layer = self.style_dict[name]\n            layer_type = layer.get(\"type\")\n            prop_name = f\"{layer_type}-opacity\"\n            if \"paint\" in layer:\n                layer[\"paint\"][prop_name] = opacity\n        super().set_paint_property(name, prop_name, opacity)\n\n    def set_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"\n        Set the visibility of a layer.\n\n        This method sets the visibility of the specified layer to the specified value.\n\n        Args:\n            name (str): The name of the layer.\n            visible (bool): The visibility value to set.\n\n        Returns:\n            None\n        \"\"\"\n        super().set_visibility(name, visible)\n        self.layer_dict[name][\"visible\"] = visible\n\n    def layer_interact(self, name=None):\n        \"\"\"Create a layer widget for changing the visibility and opacity of a layer.\n\n        Args:\n            name (str): The name of the layer.\n\n        Returns:\n            ipywidgets.Widget: The layer widget.\n        \"\"\"\n\n        import ipywidgets as widgets\n\n        layer_names = list(self.layer_dict.keys())\n        if name is None:\n            name = layer_names[-1]\n        elif name not in layer_names:\n            raise ValueError(f\"Layer {name} not found.\")\n\n        style = {\"description_width\": \"initial\"}\n        dropdown = widgets.Dropdown(\n            options=layer_names,\n            value=name,\n            description=\"Layer\",\n            style=style,\n        )\n        checkbox = widgets.Checkbox(\n            description=\"Visible\",\n            value=self.layer_dict[name][\"visible\"],\n            style=style,\n            layout=widgets.Layout(width=\"120px\"),\n        )\n        opacity_slider = widgets.FloatSlider(\n            description=\"Opacity\",\n            min=0,\n            max=1,\n            step=0.01,\n            value=self.layer_dict[name][\"opacity\"],\n            style=style,\n        )\n\n        color_picker = widgets.ColorPicker(\n            concise=True,\n            value=\"white\",\n            style=style,\n        )\n\n        if self.layer_dict[name][\"color\"] is not None:\n            color_picker.value = self.layer_dict[name][\"color\"]\n            color_picker.disabled = False\n        else:\n            color_picker.value = \"white\"\n            color_picker.disabled = True\n\n        def color_picker_event(change):\n            if self.layer_dict[dropdown.value][\"color\"] is not None:\n                self.set_color(dropdown.value, change.new)\n\n        color_picker.observe(color_picker_event, \"value\")\n\n        hbox = widgets.HBox(\n            [dropdown, checkbox, opacity_slider, color_picker],\n            layout=widgets.Layout(width=\"750px\"),\n        )\n\n        def dropdown_event(change):\n            name = change.new\n            checkbox.value = self.layer_dict[dropdown.value][\"visible\"]\n            opacity_slider.value = self.layer_dict[dropdown.value][\"opacity\"]\n            if self.layer_dict[dropdown.value][\"color\"] is not None:\n                color_picker.value = self.layer_dict[dropdown.value][\"color\"]\n                color_picker.disabled = False\n            else:\n                color_picker.value = \"white\"\n                color_picker.disabled = True\n\n        dropdown.observe(dropdown_event, \"value\")\n\n        def update_layer(change):\n            self.set_visibility(dropdown.value, checkbox.value)\n            self.set_opacity(dropdown.value, opacity_slider.value)\n\n        checkbox.observe(update_layer, \"value\")\n        opacity_slider.observe(update_layer, \"value\")\n\n        return hbox\n\n    def style_layer_interact(self, id=None):\n        \"\"\"Create a layer widget for changing the visibility and opacity of a style layer.\n\n        Args:\n            id (str): The is of the layer.\n\n        Returns:\n            ipywidgets.Widget: The layer widget.\n        \"\"\"\n\n        import ipywidgets as widgets\n\n        layer_ids = list(self.style_dict.keys())\n        layer_ids.sort()\n        if id is None:\n            id = layer_ids[0]\n        elif id not in layer_ids:\n            raise ValueError(f\"Layer {id} not found.\")\n\n        layer = self.style_dict[id]\n        layer_type = layer.get(\"type\")\n        style = {\"description_width\": \"initial\"}\n        dropdown = widgets.Dropdown(\n            options=layer_ids,\n            value=id,\n            description=\"Layer\",\n            style=style,\n        )\n\n        visibility = layer.get(\"layout\", {}).get(\"visibility\", \"visible\")\n        if visibility == \"visible\":\n            visibility = True\n        else:\n            visibility = False\n\n        checkbox = widgets.Checkbox(\n            description=\"Visible\",\n            value=visibility,\n            style=style,\n            layout=widgets.Layout(width=\"120px\"),\n        )\n\n        opacity = layer.get(\"paint\", {}).get(f\"{layer_type}-opacity\", 1.0)\n        opacity_slider = widgets.FloatSlider(\n            description=\"Opacity\",\n            min=0,\n            max=1,\n            step=0.01,\n            value=opacity,\n            style=style,\n        )\n\n        def extract_rgb(rgba_string):\n            import re\n\n            # Extracting the RGB values using regex\n            rgb_tuple = tuple(map(int, re.findall(r\"\\d+\", rgba_string)[:3]))\n            return rgb_tuple\n\n        color = layer.get(\"paint\", {}).get(f\"{layer_type}-color\", \"white\")\n        if color.startswith(\"rgba\"):\n            color = extract_rgb(color)\n        color = check_color(color)\n        color_picker = widgets.ColorPicker(\n            concise=True,\n            value=color,\n            style=style,\n        )\n\n        def color_picker_event(change):\n            self.set_paint_property(dropdown.value, f\"{layer_type}-color\", change.new)\n\n        color_picker.observe(color_picker_event, \"value\")\n\n        hbox = widgets.HBox(\n            [dropdown, checkbox, opacity_slider, color_picker],\n            layout=widgets.Layout(width=\"750px\"),\n        )\n\n        def dropdown_event(change):\n            name = change.new\n            layer = self.style_dict[name]\n            layer_type = layer.get(\"type\")\n\n            visibility = layer.get(\"layout\", {}).get(\"visibility\", \"visible\")\n            if visibility == \"visible\":\n                visibility = True\n            else:\n                visibility = False\n\n            checkbox.value = visibility\n            opacity = layer.get(\"paint\", {}).get(f\"{layer_type}-opacity\", 1.0)\n            opacity_slider.value = opacity\n\n            color = layer.get(\"paint\", {}).get(f\"{layer_type}-color\", \"white\")\n            if color.startswith(\"rgba\"):\n                color = extract_rgb(color)\n            color = check_color(color)\n\n            if color:\n                color_picker.value = color\n                color_picker.disabled = False\n            else:\n                color_picker.value = \"white\"\n                color_picker.disabled = True\n\n        dropdown.observe(dropdown_event, \"value\")\n\n        def update_layer(change):\n            self.set_layout_property(\n                dropdown.value, \"visibility\", \"visible\" if checkbox.value else \"none\"\n            )\n            self.set_paint_property(\n                dropdown.value, f\"{layer_type}-opacity\", opacity_slider.value\n            )\n\n        checkbox.observe(update_layer, \"value\")\n        opacity_slider.observe(update_layer, \"value\")\n\n        return hbox\n\n    def _basemap_widget(self, name=None):\n        \"\"\"Create a layer widget for changing the visibility and opacity of a layer.\n\n        Args:\n            name (str): The name of the layer.\n\n        Returns:\n            ipywidgets.Widget: The layer widget.\n        \"\"\"\n\n        import ipywidgets as widgets\n\n        layer_names = [\n            basemaps[basemap][\"name\"]\n            for basemap in basemaps.keys()\n            if \"layers\" not in basemaps[basemap]\n        ][1:]\n        if name is None:\n            name = layer_names[0]\n        elif name not in layer_names:\n            raise ValueError(f\"Layer {name} not found.\")\n\n        tile = basemaps[name]\n        raster_source = RasterTileSource(\n            tiles=[tile[\"url\"]],\n            attribution=tile[\"attribution\"],\n            tile_size=256,\n        )\n        layer = Layer(id=name, source=raster_source, type=LayerType.RASTER)\n        self.add_layer(layer)\n        self.set_opacity(name, 1.0)\n        self.set_visibility(name, True)\n\n        style = {\"description_width\": \"initial\"}\n        dropdown = widgets.Dropdown(\n            options=layer_names,\n            value=name,\n            description=\"Basemap\",\n            style=style,\n        )\n        checkbox = widgets.Checkbox(\n            description=\"Visible\",\n            value=self.layer_dict[name][\"visible\"],\n            style=style,\n            layout=widgets.Layout(width=\"120px\"),\n        )\n        opacity_slider = widgets.FloatSlider(\n            description=\"Opacity\",\n            min=0,\n            max=1,\n            step=0.01,\n            value=self.layer_dict[name][\"opacity\"],\n            style=style,\n        )\n        hbox = widgets.HBox(\n            [dropdown, checkbox, opacity_slider], layout=widgets.Layout(width=\"600px\")\n        )\n\n        def dropdown_event(change):\n            old = change[\"old\"]\n            name = change.new\n            self.remove_layer(old)\n\n            tile = basemaps[name]\n            raster_source = RasterTileSource(\n                tiles=[tile[\"url\"]],\n                attribution=tile[\"attribution\"],\n                tile_size=256,\n            )\n            layer = Layer(id=name, source=raster_source, type=LayerType.RASTER)\n            self.add_layer(layer)\n            self.set_opacity(name, 1.0)\n            self.set_visibility(name, True)\n\n            checkbox.value = self.layer_dict[dropdown.value][\"visible\"]\n            opacity_slider.value = self.layer_dict[dropdown.value][\"opacity\"]\n\n        dropdown.observe(dropdown_event, \"value\")\n\n        def update_layer(change):\n            self.set_visibility(dropdown.value, checkbox.value)\n            self.set_opacity(dropdown.value, opacity_slider.value)\n\n        checkbox.observe(update_layer, \"value\")\n        opacity_slider.observe(update_layer, \"value\")\n\n        return hbox\n\n    def add_pmtiles(\n        self,\n        url: str,\n        style: Optional[Dict] = None,\n        visible: bool = True,\n        opacity: float = 1.0,\n        exclude_mask: bool = False,\n        tooltip: bool = True,\n        properties: Optional[Dict] = None,\n        template: Optional[str] = None,\n        attribution: str = \"PMTiles\",\n        fit_bounds: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Adds a PMTiles layer to the map.\n\n        Args:\n            url (str): The URL of the PMTiles file.\n            style (dict, optional): The CSS style to apply to the layer. Defaults to None.\n                See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n            visible (bool, optional): Whether the layer should be shown initially. Defaults to True.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n            exclude_mask (bool, optional): Whether to exclude the mask layer. Defaults to False.\n            tooltip (bool, optional): Whether to show tooltips on the layer. Defaults to True.\n            properties (dict, optional): The properties to use for the tooltips. Defaults to None.\n            template (str, optional): The template to use for the tooltips. Defaults to None.\n            attribution (str, optional): The attribution to use for the layer. Defaults to 'PMTiles'.\n            fit_bounds (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n        Returns:\n            None\n        \"\"\"\n\n        try:\n\n            if \"sources\" in kwargs:\n                del kwargs[\"sources\"]\n\n            if \"version\" in kwargs:\n                del kwargs[\"version\"]\n\n            pmtiles_source = {\n                \"type\": \"vector\",\n                \"url\": f\"pmtiles://{url}\",\n                \"attribution\": attribution,\n            }\n\n            if style is None:\n                style = pmtiles_style(url)\n\n            if \"sources\" in style:\n                source_name = list(style[\"sources\"].keys())[0]\n            elif \"layers\" in style:\n                source_name = style[\"layers\"][0][\"source\"]\n            else:\n                source_name = \"source\"\n\n            self.add_source(source_name, pmtiles_source)\n\n            style = replace_hyphens_in_keys(style)\n\n            for params in style[\"layers\"]:\n\n                if exclude_mask and params.get(\"source_layer\") == \"mask\":\n                    continue\n\n                layer = Layer(**params)\n                self.add_layer(layer)\n                self.set_visibility(params[\"id\"], visible)\n                self.set_opacity(params[\"id\"], opacity)\n\n                if tooltip:\n                    self.add_tooltip(params[\"id\"], properties, template)\n\n            if fit_bounds:\n                metadata = pmtiles_metadata(url)\n                bounds = metadata[\"bounds\"]  # [minx, miny, maxx, maxy]\n                self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n\n        except Exception as e:\n            print(e)\n\n    def add_marker(\n        self,\n        marker: Marker = None,\n        lng_lat: List[Union[float, float]] = [],\n        popup: Optional[Dict] = {},\n        options: Optional[Dict] = {},\n    ) -&gt; None:\n        \"\"\"\n        Adds a marker to the map.\n\n        Args:\n            marker (Marker, optional): A Marker object. Defaults to None.\n            lng_lat (List[Union[float, float]]): A list of two floats\n                representing the longitude and latitude of the marker.\n            popup (Optional[str], optional): The text to display in a popup when\n                the marker is clicked. Defaults to None.\n            options (Optional[Dict], optional): A dictionary of options to\n                customize the marker. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n\n        if marker is None:\n            marker = Marker(lng_lat=lng_lat, popup=popup, options=options)\n        super().add_marker(marker)\n\n    def fly_to(\n        self,\n        lon: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        speed: Optional[float] = None,\n        essential: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Makes the map fly to a specified location.\n\n        Args:\n            lon (float): The longitude of the location to fly to.\n            lat (float): The latitude of the location to fly to.\n            zoom (Optional[float], optional): The zoom level to use when flying\n                to the location. Defaults to None.\n            speed (Optional[float], optional): The speed of the fly animation.\n                Defaults to None.\n            essential (bool, optional): Whether the flyTo animation is considered\n                essential and not affected by prefers-reduced-motion. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the flyTo function.\n\n        Returns:\n            None\n        \"\"\"\n\n        center = [lon, lat]\n        kwargs[\"center\"] = center\n        if zoom is not None:\n            kwargs[\"zoom\"] = zoom\n        if speed is not None:\n            kwargs[\"speed\"] = speed\n        if essential:\n            kwargs[\"essential\"] = essential\n\n        super().add_call(\"flyTo\", kwargs)\n\n    def _read_image(self, image: str) -&gt; Dict[str, Union[int, List[int]]]:\n        \"\"\"\n        Reads an image from a URL or a local file path and returns a dictionary\n            with the image data.\n\n        Args:\n            image (str): The URL or local file path to the image.\n\n        Returns:\n            Dict[str, Union[int, List[int]]]: A dictionary with the image width,\n                height, and flattened data.\n\n        Raises:\n            ValueError: If the image argument is not a string representing a URL\n                or a local file path.\n        \"\"\"\n\n        import os\n        from PIL import Image\n        import numpy as np\n\n        if isinstance(image, str):\n            try:\n                if image.startswith(\"http\"):\n                    image = download_file(\n                        image, temp_file_path(image.split(\".\")[-1]), quiet=True\n                    )\n                if os.path.exists(image):\n                    img = Image.open(image)\n                else:\n                    raise ValueError(\"The image file does not exist.\")\n\n                width, height = img.size\n                # Convert image to numpy array and then flatten it\n                img_data = np.array(img, dtype=\"uint8\")\n                if len(img_data.shape) == 3 and img_data.shape[2] == 2:\n                    # Split the grayscale and alpha channels\n                    gray_channel = img_data[:, :, 0]\n                    alpha_channel = img_data[:, :, 1]\n\n                    # Create the R, G, and B channels by duplicating the grayscale channel\n                    R_channel = gray_channel\n                    G_channel = gray_channel\n                    B_channel = gray_channel\n\n                    # Combine the channels into an RGBA image\n                    RGBA_image_data = np.stack(\n                        (R_channel, G_channel, B_channel, alpha_channel), axis=-1\n                    )\n\n                    # Update img_data to the new RGBA image data\n                    img_data = RGBA_image_data\n\n                flat_img_data = img_data.flatten()\n\n                # Create the image dictionary with the flattened data\n                image_dict = {\n                    \"width\": width,\n                    \"height\": height,\n                    \"data\": flat_img_data.tolist(),  # Convert to list if necessary\n                }\n\n                return image_dict\n            except Exception as e:\n                print(e)\n                return None\n        else:\n            raise ValueError(\"The image must be a URL or a local file path.\")\n\n    def add_image(\n        self,\n        id: str,\n        image: Union[str, Dict],\n        width: int = None,\n        height: int = None,\n        coordinates: List[float] = None,\n        icon_size: float = 1.0,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Add an image to the map.\n\n        Args:\n            id (str): The layer ID of the image.\n            image (Union[str, Dict, np.ndarray]): The URL or local file path to\n                the image, or a dictionary containing image data, or a numpy\n                array representing the image.\n            width (int, optional): The width of the image. Defaults to None.\n            height (int, optional): The height of the image. Defaults to None.\n            coordinates (List[float], optional): The longitude and latitude\n                coordinates to place the image.\n            icon_size (float, optional): The size of the icon. Defaults to 1.0.\n\n        Returns:\n            None\n        \"\"\"\n        import numpy as np\n\n        if isinstance(image, str):\n            image_dict = self._read_image(image)\n        elif isinstance(image, dict):\n            image_dict = image\n        elif isinstance(image, np.ndarray):\n            image_dict = {\n                \"width\": width,\n                \"height\": height,\n                \"data\": image.flatten().tolist(),\n            }\n        else:\n            raise ValueError(\n                \"The image must be a URL, a local file path, or a numpy array.\"\n            )\n        super().add_call(\"addImage\", id, image_dict)\n\n        if coordinates is not None:\n\n            source = {\n                \"type\": \"geojson\",\n                \"data\": {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": [\n                        {\n                            \"type\": \"Feature\",\n                            \"geometry\": {\"type\": \"Point\", \"coordinates\": coordinates},\n                        }\n                    ],\n                },\n            }\n\n            self.add_source(\"image_point\", source)\n\n            kwargs[\"id\"] = \"image_points\"\n            kwargs[\"type\"] = \"symbol\"\n            kwargs[\"source\"] = \"image_point\"\n            if \"layout\" not in kwargs:\n                kwargs[\"layout\"] = {}\n            kwargs[\"layout\"][\"icon-image\"] = id\n            kwargs[\"layout\"][\"icon-size\"] = icon_size\n            self.add_layer(kwargs)\n\n    def to_streamlit(\n        self,\n        width: Optional[int] = None,\n        height: Optional[int] = 600,\n        scrolling: Optional[bool] = False,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Convert the map to a Streamlit component.\n\n        This function converts the map to a Streamlit component by encoding the\n        HTML representation of the map as base64 and embedding it in an iframe.\n        The width, height, and scrolling parameters control the appearance of\n        the iframe.\n\n        Args:\n            width (Optional[int]): The width of the iframe. If None, the width\n                will be determined by Streamlit.\n            height (Optional[int]): The height of the iframe. Default is 600.\n            scrolling (Optional[bool]): Whether the iframe should be scrollable.\n                Default is False.\n            **kwargs (Any): Additional arguments to pass to the Streamlit iframe\n                function.\n\n        Returns:\n            Any: The Streamlit component.\n\n        Raises:\n            Exception: If there is an error in creating the Streamlit component.\n        \"\"\"\n\n        try:\n            import streamlit.components.v1 as components\n            import base64\n\n            raw_html = self.to_html().encode(\"utf-8\")\n            raw_html = base64.b64encode(raw_html).decode()\n            return components.iframe(\n                f\"data:text/html;base64,{raw_html}\",\n                width=width,\n                height=height,\n                scrolling=scrolling,\n                **kwargs,\n            )\n\n        except Exception as e:\n            raise Exception(e)\n\n    def rotate_to(\n        self, bearing: float, options: Dict[str, Any] = {}, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Rotate the map to a specified bearing.\n\n        This function rotates the map to a specified bearing. The bearing is specified in degrees\n        counter-clockwise from true north. If the bearing is not specified, the map will rotate to\n        true north. Additional options and keyword arguments can be provided to control the rotation.\n        For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#rotateto\n\n        Args:\n            bearing (float): The bearing to rotate to, in degrees counter-clockwise from true north.\n            options (Dict[str, Any], optional): Additional options to control the rotation. Defaults to {}.\n            **kwargs (Any): Additional keyword arguments to control the rotation.\n\n        Returns:\n            None\n        \"\"\"\n        super().add_call(\"rotateTo\", bearing, options, **kwargs)\n\n    def open_geojson(self, **kwargs: Any) -&gt; \"widgets.FileUpload\":\n        \"\"\"\n        Creates a file uploader widget to upload a GeoJSON file. When a file is\n        uploaded, it is written to a temporary file and added to the map.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the add_geojson method.\n\n        Returns:\n            widgets.FileUpload: The file uploader widget.\n        \"\"\"\n\n        import ipywidgets as widgets\n\n        uploader = widgets.FileUpload(\n            accept=\".geojson\",  # Accept GeoJSON files\n            multiple=False,  # Only single file upload\n            description=\"Open GeoJSON\",\n        )\n\n        def on_upload(change):\n            content = uploader.value[0][\"content\"]\n            temp_file = temp_file_path(extension=\".geojson\")\n            with open(temp_file, \"wb\") as f:\n                f.write(content)\n            self.add_geojson(temp_file, **kwargs)\n\n        uploader.observe(on_upload, names=\"value\")\n\n        return uploader\n\n    def pan_to(\n        self,\n        lnglat: List[float],\n        options: Dict[str, Any] = {},\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Pans the map to a specified location.\n\n        This function pans the map to the specified longitude and latitude coordinates.\n        Additional options and keyword arguments can be provided to control the panning.\n        For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#panto\n\n        Args:\n            lnglat (List[float, float]): The longitude and latitude coordinates to pan to.\n            options (Dict[str, Any], optional): Additional options to control the panning. Defaults to {}.\n            **kwargs (Any): Additional keyword arguments to control the panning.\n\n        Returns:\n            None\n        \"\"\"\n        super().add_call(\"panTo\", lnglat, options, **kwargs)\n\n    def set_pitch(self, pitch: float, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Sets the pitch of the map.\n\n        This function sets the pitch of the map to the specified value. The pitch is the\n        angle of the camera measured in degrees where 0 is looking straight down, and 60 is\n        looking towards the horizon. Additional keyword arguments can be provided to control\n        the pitch. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#setpitch\n\n        Args:\n            pitch (float): The pitch value to set.\n            **kwargs (Any): Additional keyword arguments to control the pitch.\n\n        Returns:\n            None\n        \"\"\"\n        super().add_call(\"setPitch\", pitch, **kwargs)\n\n    def jump_to(self, options: Dict[str, Any] = {}, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Jumps the map to a specified location.\n\n        This function jumps the map to the specified location with the specified options.\n        Additional keyword arguments can be provided to control the jump. For more information,\n        see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#jumpto\n\n        Args:\n            options (Dict[str, Any], optional): Additional options to control the jump. Defaults to {}.\n            **kwargs (Any): Additional keyword arguments to control the jump.\n\n        Returns:\n            None\n        \"\"\"\n        super().add_call(\"jumpTo\", options, **kwargs)\n\n    def _get_3d_terrain_style(\n        self,\n        exaggeration: float = 1,\n        token: str = \"MAPTILER_KEY\",\n        api_key: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the 3D terrain style for the map.\n\n        This function generates a style dictionary for the map that includes 3D terrain features.\n        The terrain exaggeration and API key can be specified. If the API key is not provided,\n        it will be retrieved using the specified token.\n\n        Args:\n            exaggeration (float, optional): The terrain exaggeration. Defaults to 1.\n            token (str, optional): The token to use to retrieve the API key. Defaults to \"MAPTILER_KEY\".\n            api_key (Optional[str], optional): The API key. If not provided, it will be retrieved using the token.\n\n        Returns:\n            Dict[str, Any]: The style dictionary for the map.\n\n        Raises:\n            ValueError: If the API key is not provided and cannot be retrieved using the token.\n        \"\"\"\n\n        if api_key is None:\n            api_key = get_api_key(token)\n\n        if api_key is None:\n            print(\"An API key is required to use the 3D terrain feature.\")\n            return \"dark-matter\"\n\n        style = {\n            \"version\": 8,\n            \"sources\": {\n                \"satellite\": {\n                    \"type\": \"raster\",\n                    \"tiles\": [\n                        \"https://api.maptiler.com/tiles/satellite-v2/{z}/{x}/{y}.jpg?key=\"\n                        + api_key\n                    ],\n                    \"tileSize\": 256,\n                    \"attribution\": \"&amp;copy; MapTiler\",\n                    \"maxzoom\": 19,\n                },\n                \"terrainSource\": {\n                    \"type\": \"raster-dem\",\n                    \"url\": f\"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key={api_key}\",\n                    \"tileSize\": 256,\n                },\n                \"hillshadeSource\": {\n                    \"type\": \"raster-dem\",\n                    \"url\": f\"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key={api_key}\",\n                    \"tileSize\": 256,\n                },\n            },\n            \"layers\": [\n                {\"id\": \"satellite\", \"type\": \"raster\", \"source\": \"satellite\"},\n                {\n                    \"id\": \"hills\",\n                    \"type\": \"hillshade\",\n                    \"source\": \"hillshadeSource\",\n                    \"layout\": {\"visibility\": \"visible\"},\n                    \"paint\": {\"hillshade-shadow-color\": \"#473B24\"},\n                },\n            ],\n            \"terrain\": {\"source\": \"terrainSource\", \"exaggeration\": exaggeration},\n        }\n\n        return style\n\n    def get_style(self):\n        \"\"\"\n        Get the style of the map.\n\n        Returns:\n            Dict: The style of the map.\n        \"\"\"\n        if self._style is not None:\n            if isinstance(self._style, str):\n                response = requests.get(self._style)\n                style = response.json()\n            elif isinstance(self._style, dict):\n                style = self._style\n            return style\n        else:\n            return {}\n\n    def get_style_layers(self, return_ids=False, sorted=True) -&gt; List[str]:\n        \"\"\"\n        Get the names of the basemap layers.\n\n        Returns:\n            List[str]: The names of the basemap layers.\n        \"\"\"\n        style = self.get_style()\n        if \"layers\" in style:\n            layers = style[\"layers\"]\n            if return_ids:\n                ids = [layer[\"id\"] for layer in layers]\n                if sorted:\n                    ids.sort()\n\n                return ids\n            else:\n                return layers\n        else:\n            return []\n\n    def find_style_layer(self, id: str) -&gt; Optional[Dict]:\n        \"\"\"\n        Searches for a style layer in the map's current style by its ID and returns it if found.\n\n        Args:\n            id (str): The ID of the style layer to find.\n\n        Returns:\n            Optional[Dict]: The style layer as a dictionary if found, otherwise None.\n        \"\"\"\n        layers = self.get_style_layers()\n        for layer in layers:\n            if layer[\"id\"] == id:\n                return layer\n        return None\n\n    def zoom_to(self, zoom: float, options: Dict[str, Any] = {}, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Zooms the map to a specified zoom level.\n\n        This function zooms the map to the specified zoom level. Additional options and keyword\n        arguments can be provided to control the zoom. For more information, see\n        https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#zoomto\n\n        Args:\n            zoom (float): The zoom level to zoom to.\n            options (Dict[str, Any], optional): Additional options to control the zoom. Defaults to {}.\n            **kwargs (Any): Additional keyword arguments to control the zoom.\n\n        Returns:\n            None\n        \"\"\"\n        super().add_call(\"zoomTo\", zoom, options, **kwargs)\n\n    def find_first_symbol_layer(self) -&gt; Optional[Dict]:\n        \"\"\"\n        Find the first symbol layer in the map's current style.\n\n        Returns:\n            Optional[Dict]: The first symbol layer as a dictionary if found, otherwise None.\n        \"\"\"\n        layers = self.get_style_layers()\n        for layer in layers:\n            if layer[\"type\"] == \"symbol\":\n                return layer\n        return None\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.__init__","title":"<code>__init__(self, center=(0, 20), zoom=1, pitch=0, bearing=0, style='dark-matter', height='600px', controls={'navigation': 'top-right', 'fullscreen': 'top-right', 'scale': 'bottom-left'}, **kwargs)</code>  <code>special</code>","text":"<p>Create a Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The center of the map (lon, lat). Defaults to (0, 20).</p> <code>(0, 20)</code> <code>zoom</code> <code>float</code> <p>The zoom level of the map. Defaults to 1.</p> <code>1</code> <code>pitch</code> <code>float</code> <p>The pitch of the map. Measured in degrees away from the plane of the screen (0-85) Defaults to 0.</p> <code>0</code> <code>bearing</code> <code>float</code> <p>The bearing of the map. Measured in degrees counter-clockwise from north. Defaults to 0.</p> <code>0</code> <code>style</code> <code>str</code> <p>The style of the map. It can be a string or a URL. If it is a string, it must be one of the following: \"dark-matter\", \"positron\", \"voyager\", \"positron-nolabels\", \"dark-matter-nolabels\", \"voyager-nolabels\", or \"demotiles\". If it is a URL, it must point to a MapLibre style JSON. Defaults to \"dark-matter\".</p> <code>'dark-matter'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to \"600px\".</p> <code>'600px'</code> <code>controls</code> <code>dict</code> <p>The controls and their positions on the map. Defaults to {\"fullscreen\": \"top-right\", \"scale\": \"bottom-left\"}.</p> <code>{'navigation': 'top-right', 'fullscreen': 'top-right', 'scale': 'bottom-left'}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the MapOptions class. See https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/MapOptions/ for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0, 20),\n    zoom: float = 1,\n    pitch: float = 0,\n    bearing: float = 0,\n    style: str = \"dark-matter\",\n    height: str = \"600px\",\n    controls: Dict[str, str] = {\n        \"navigation\": \"top-right\",\n        \"fullscreen\": \"top-right\",\n        \"scale\": \"bottom-left\",\n    },\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Create a Map object.\n\n    Args:\n        center (tuple, optional): The center of the map (lon, lat). Defaults\n            to (0, 20).\n        zoom (float, optional): The zoom level of the map. Defaults to 1.\n        pitch (float, optional): The pitch of the map. Measured in degrees\n            away from the plane of the screen (0-85) Defaults to 0.\n        bearing (float, optional): The bearing of the map. Measured in degrees\n            counter-clockwise from north. Defaults to 0.\n        style (str, optional): The style of the map. It can be a string or a URL.\n            If it is a string, it must be one of the following: \"dark-matter\",\n            \"positron\", \"voyager\", \"positron-nolabels\", \"dark-matter-nolabels\",\n            \"voyager-nolabels\", or \"demotiles\". If it is a URL, it must point to\n            a MapLibre style JSON. Defaults to \"dark-matter\".\n        height (str, optional): The height of the map. Defaults to \"600px\".\n        controls (dict, optional): The controls and their positions on the\n            map. Defaults to {\"fullscreen\": \"top-right\", \"scale\": \"bottom-left\"}.\n        **kwargs: Additional keyword arguments that are passed to the MapOptions class.\n            See https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/MapOptions/\n            for more information.\n\n    Returns:\n        None\n    \"\"\"\n    carto_basemaps = [\n        \"dark-matter\",\n        \"positron\",\n        \"voyager\",\n        \"positron-nolabels\",\n        \"dark-matter-nolabels\",\n        \"voyager-nolabels\",\n    ]\n    if isinstance(style, str):\n\n        if style.startswith(\"https\"):\n            response = requests.get(style)\n            if response.status_code != 200:\n                style = \"dark-matter\"\n\n        if style == \"3d-terrain\":\n            style = self._get_3d_terrain_style()\n\n        if isinstance(style, str) and (style.lower() in carto_basemaps):\n            style = construct_carto_basemap_url(style.lower())\n        elif style == \"demotiles\":\n            style = \"https://demotiles.maplibre.org/style.json\"\n        elif \"background-\" in style:\n            color = style.split(\"-\")[1]\n            style = background(color)\n\n    if style is not None:\n        kwargs[\"style\"] = style\n\n    if len(controls) == 0:\n        kwargs[\"attribution_control\"] = False\n\n    map_options = MapOptions(\n        center=center, zoom=zoom, pitch=pitch, bearing=bearing, **kwargs\n    )\n\n    super().__init__(map_options, height=height)\n    super().use_message_queue()\n\n    for control, position in controls.items():\n        self.add_control(control, position)\n\n    self.layer_dict = {}\n    self.layer_dict[\"background\"] = {\n        \"layer\": Layer(id=\"background\", type=LayerType.BACKGROUND),\n        \"opacity\": 1.0,\n        \"visible\": True,\n        \"type\": \"background\",\n        \"color\": None,\n    }\n    self._style = style\n    self.style_dict = {}\n    for layer in self.get_style_layers():\n        self.style_dict[layer[\"id\"]] = layer\n    self.source_dict = {}\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_basemap","title":"<code>add_basemap(self, basemap=None, opacity=1.0, visible=True, attribution=None, **kwargs)</code>","text":"<p>Adds a basemap to the map.</p> <p>This method adds a basemap to the map. The basemap can be a string from predefined basemaps, an instance of xyzservices.TileProvider, or a key from the basemaps dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str or TileProvider</code> <p>The basemap to add. Can be one of the predefined strings, an instance of xyzservices.TileProvider, or a key from the basemaps dictionary. Defaults to None, which adds the basemap widget.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the basemap. Defaults to 1.0.</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether the basemap is visible or not. Defaults to True.</p> <code>True</code> <code>attribution</code> <code>str</code> <p>The attribution text to display for the basemap. If None, the attribution text is taken from the basemap or the TileProvider. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the RasterTileSource class. See https://bit.ly/4erD2MQ for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the basemap is not one of the predefined strings, not an instance of TileProvider, and not a key from the basemaps dictionary.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: Union[str, xyzservices.TileProvider] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    attribution: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a basemap to the map.\n\n    This method adds a basemap to the map. The basemap can be a string from\n    predefined basemaps, an instance of xyzservices.TileProvider, or a key\n    from the basemaps dictionary.\n\n    Args:\n        basemap (str or TileProvider, optional): The basemap to add. Can be\n            one of the predefined strings, an instance of xyzservices.TileProvider,\n            or a key from the basemaps dictionary. Defaults to None, which adds\n            the basemap widget.\n        opacity (float, optional): The opacity of the basemap. Defaults to 1.0.\n        visible (bool, optional): Whether the basemap is visible or not.\n            Defaults to True.\n        attribution (str, optional): The attribution text to display for the\n            basemap. If None, the attribution text is taken from the basemap\n            or the TileProvider. Defaults to None.\n        **kwargs: Additional keyword arguments that are passed to the\n            RasterTileSource class. See https://bit.ly/4erD2MQ for more information.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the basemap is not one of the predefined strings,\n            not an instance of TileProvider, and not a key from the basemaps dictionary.\n    \"\"\"\n\n    if basemap is None:\n        return self._basemap_widget()\n\n    map_dict = {\n        \"ROADMAP\": \"Google Maps\",\n        \"SATELLITE\": \"Google Satellite\",\n        \"TERRAIN\": \"Google Terrain\",\n        \"HYBRID\": \"Google Hybrid\",\n    }\n\n    name = basemap\n    url = None\n    max_zoom = 30\n    min_zoom = 0\n\n    if isinstance(basemap, str) and basemap.upper() in map_dict:\n        layer = get_google_map(basemap.upper(), **kwargs)\n        url = layer.url\n        name = layer.name\n        attribution = layer.attribution\n\n    elif isinstance(basemap, xyzservices.TileProvider):\n        name = basemap.name\n        url = basemap.build_url()\n        if attribution is None:\n            attribution = basemap.attribution\n        if \"max_zoom\" in basemap.keys():\n            max_zoom = basemap[\"max_zoom\"]\n        if \"min_zoom\" in basemap.keys():\n            min_zoom = basemap[\"min_zoom\"]\n\n    elif basemap in basemaps:\n        url = basemaps[basemap][\"url\"]\n        if attribution is None:\n            attribution = basemaps[basemap][\"attribution\"]\n        if \"max_zoom\" in basemaps[basemap]:\n            max_zoom = basemaps[basemap][\"max_zoom\"]\n        if \"min_zoom\" in basemaps[basemap]:\n            min_zoom = basemaps[basemap][\"min_zoom\"]\n    else:\n        print(\n            \"Basemap can only be one of the following:\\n  {}\".format(\n                \"\\n  \".join(basemaps.keys())\n            )\n        )\n        return\n\n    raster_source = RasterTileSource(\n        tiles=[url],\n        attribution=attribution,\n        max_zoom=max_zoom,\n        min_zoom=min_zoom,\n        tile_size=256,\n        **kwargs,\n    )\n    layer = Layer(id=name, source=raster_source, type=LayerType.RASTER)\n    self.add_layer(layer)\n    self.set_opacity(name, opacity)\n    self.set_visibility(name, visible)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, attribution='', opacity=1.0, visible=True, bands=None, titiler_endpoint='https://titiler.xyz', fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Adds a Cloud Optimized Geotiff (COG) TileLayer to the map.</p> <p>This method adds a COG TileLayer to the map. The COG TileLayer is created from the specified URL, and it is added to the map with the specified name, attribution, opacity, visibility, and bands.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer.</p> required <code>name</code> <code>str</code> <p>The name to use for the layer. If None, a random name is generated. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use for the layer. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be visible by default. Defaults to True.</p> <code>True</code> <code>bands</code> <code>list</code> <p>A list of bands to use for the layer. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>The endpoint of the titiler service. Defaults to \"https://titiler.xyz\".</p> <code>'https://titiler.xyz'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to adjust the viewport of the map to fit the bounds of the layer. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap,     colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/.     To select a certain bands, use bidx=[1, 2, 3]. apply a         rescaling to multiple bands, use something like         <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    opacity: float = 1.0,\n    visible: bool = True,\n    bands: Optional[List[int]] = None,\n    titiler_endpoint: str = \"https://titiler.xyz\",\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a Cloud Optimized Geotiff (COG) TileLayer to the map.\n\n    This method adds a COG TileLayer to the map. The COG TileLayer is created\n    from the specified URL, and it is added to the map with the specified name,\n    attribution, opacity, visibility, and bands.\n\n    Args:\n        url (str): The URL of the COG tile layer.\n        name (str, optional): The name to use for the layer. If None, a\n            random name is generated. Defaults to None.\n        attribution (str, optional): The attribution to use for the layer.\n            Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        visible (bool, optional): Whether the layer should be visible by default.\n            Defaults to True.\n        bands (list, optional): A list of bands to use for the layer.\n            Defaults to None.\n        titiler_endpoint (str, optional): The endpoint of the titiler service.\n            Defaults to \"https://titiler.xyz\".\n        fit_bounds (bool, optional): Whether to adjust the viewport of\n            the map to fit the bounds of the layer. Defaults to True.\n        **kwargs: Arbitrary keyword arguments, including bidx, expression,\n            nodata, unscale, resampling, rescale, color_formula, colormap,\n                colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/.\n                To select a certain bands, use bidx=[1, 2, 3]. apply a\n                    rescaling to multiple bands, use something like\n                    `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n    Returns:\n        None\n    \"\"\"\n\n    if name is None:\n        name = \"COG_\" + random_string()\n\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    bounds = cog_bounds(url, titiler_endpoint)\n    self.add_tile_layer(\n        tile_url, name, attribution, opacity, visible, before_id=before_id\n    )\n    if fit_bounds:\n        self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_control","title":"<code>add_control(self, control, position='top-right', **kwargs)</code>","text":"<p>Adds a control to the map.</p> <p>This method adds a control to the map. The control can be one of the     following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\". If the     control is a string, it is converted to the corresponding control object.     If the control is not a string, it is assumed to be a control object.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>str or object</code> <p>The control to add to the map. Can be one of the following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\".</p> required <code>position</code> <code>str</code> <p>The position of the control. Defaults to \"top-right\".</p> <code>'top-right'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the control object.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the control is a string and is not one of the following: 'scale', 'fullscreen', 'geolocate', 'navigation', \"attribution\".</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_control(\n    self, control: Union[str, Any], position: str = \"top-right\", **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Adds a control to the map.\n\n    This method adds a control to the map. The control can be one of the\n        following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\". If the\n        control is a string, it is converted to the corresponding control object.\n        If the control is not a string, it is assumed to be a control object.\n\n    Args:\n        control (str or object): The control to add to the map. Can be one\n            of the following: 'scale', 'fullscreen', 'geolocate', 'navigation', and \"attribution\".\n        position (str, optional): The position of the control. Defaults to \"top-right\".\n        **kwargs: Additional keyword arguments that are passed to the control object.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the control is a string and is not one of the\n            following: 'scale', 'fullscreen', 'geolocate', 'navigation', \"attribution\".\n    \"\"\"\n\n    if isinstance(control, str):\n        control = control.lower()\n        if control == \"scale\":\n            control = ScaleControl(**kwargs)\n        elif control == \"fullscreen\":\n            control = FullscreenControl(**kwargs)\n        elif control == \"geolocate\":\n            control = GeolocateControl(**kwargs)\n        elif control == \"navigation\":\n            control = NavigationControl(**kwargs)\n        elif control == \"attribution\":\n            control = AttributionControl(**kwargs)\n        else:\n            print(\n                \"Control can only be one of the following: 'scale', 'fullscreen', 'geolocate', 'navigation'\"\n            )\n            return\n\n    super().add_control(control, position)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_ee_layer","title":"<code>add_ee_layer(self, asset_id, name=None, opacity=1.0, attribution='Google Earth Engine', visible=True, before_id=None, **kwargs)</code>","text":"<p>Adds a Google Earth Engine tile layer to the map based on the tile layer URL from     https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The ID of the Earth Engine asset.</p> required <code>name</code> <code>str</code> <p>The name of the tile layer. If not provided, the asset ID will be used. Default is None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the tile layer (0 to 1). Default is 1.</p> <code>1.0</code> <code>attribution</code> <code>str</code> <p>The attribution text to be displayed. Default is \"Google Earth Engine\".</p> <code>'Google Earth Engine'</code> <code>visible</code> <code>bool</code> <p>Whether the tile layer should be shown on the map. Default is True.</p> <code>True</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying <code>add_tile_layer</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_ee_layer(\n    self,\n    asset_id: str,\n    name: str = None,\n    opacity: float = 1.0,\n    attribution: str = \"Google Earth Engine\",\n    visible: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Adds a Google Earth Engine tile layer to the map based on the tile layer URL from\n        https://github.com/opengeos/ee-tile-layers/blob/main/datasets.tsv.\n\n    Args:\n        asset_id (str): The ID of the Earth Engine asset.\n        name (str, optional): The name of the tile layer. If not provided,\n            the asset ID will be used. Default is None.\n        opacity (float, optional): The opacity of the tile layer (0 to 1).\n            Default is 1.\n        attribution (str, optional): The attribution text to be displayed.\n            Default is \"Google Earth Engine\".\n        visible (bool, optional): Whether the tile layer should be shown on\n            the map. Default is True.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        **kwargs: Additional keyword arguments to be passed to the underlying\n            `add_tile_layer` method.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n\n    df = pd.read_csv(\n        \"https://raw.githubusercontent.com/opengeos/ee-tile-layers/main/datasets.tsv\",\n        sep=\"\\t\",\n    )\n\n    asset_id = asset_id.strip()\n    if name is None:\n        name = asset_id\n\n    if asset_id in df[\"id\"].values:\n        url = df.loc[df[\"id\"] == asset_id, \"url\"].values[0]\n        self.add_tile_layer(\n            url,\n            name,\n            attribution=attribution,\n            opacity=opacity,\n            visible=visible,\n            before_id=before_id,\n            **kwargs,\n        )\n    else:\n        print(f\"The provided EE tile layer {asset_id} does not exist.\")\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_gdf","title":"<code>add_gdf(self, gdf, layer_type=None, filter=None, paint=None, name=None, fit_bounds=True, visible=True, before_id=None, source_args={}, **kwargs)</code>","text":"<p>Adds a vector layer to the map.</p> <p>This method adds a GeoDataFrame to the map as a vector layer.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>The GeoDataFrame to add to the map.</p> required <code>layer_type</code> <code>str</code> <p>The type of the layer. If None, the type is inferred from the GeoJSON data.</p> <code>None</code> <code>filter</code> <code>dict</code> <p>The filter to apply to the layer. If None, no filter is applied.</p> <code>None</code> <code>paint</code> <code>dict</code> <p>The paint properties to apply to the layer. If None, no paint properties are applied.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. If None, a random name is generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to adjust the viewport of the map to fit the bounds of the GeoJSON data. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible or not. Defaults to True.</p> <code>True</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>source_args</code> <code>dict</code> <p>Additional keyword arguments that are passed to the GeoJSONSource class.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the Layer class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data is not a URL or a GeoJSON dictionary.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_gdf(\n    self,\n    gdf: gpd.GeoDataFrame,\n    layer_type: Optional[str] = None,\n    filter: Optional[Dict] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    visible: bool = True,\n    before_id: Optional[str] = None,\n    source_args: Dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a vector layer to the map.\n\n    This method adds a GeoDataFrame to the map as a vector layer.\n\n    Args:\n        gdf (gpd.GeoDataFrame): The GeoDataFrame to add to the map.\n        layer_type (str, optional): The type of the layer. If None, the type\n            is inferred from the GeoJSON data.\n        filter (dict, optional): The filter to apply to the layer. If None,\n            no filter is applied.\n        paint (dict, optional): The paint properties to apply to the layer.\n            If None, no paint properties are applied.\n        name (str, optional): The name of the layer. If None, a random name\n            is generated.\n        fit_bounds (bool, optional): Whether to adjust the viewport of the\n            map to fit the bounds of the GeoJSON data. Defaults to True.\n        visible (bool, optional): Whether the layer is visible or not.\n            Defaults to True.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        source_args (dict, optional): Additional keyword arguments that are\n            passed to the GeoJSONSource class.\n        **kwargs: Additional keyword arguments that are passed to the Layer class.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the data is not a URL or a GeoJSON dictionary.\n    \"\"\"\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise ValueError(\"The data must be a GeoDataFrame.\")\n    geojson = gdf.__geo_interface__\n    self.add_geojson(\n        geojson,\n        layer_type=layer_type,\n        filter=filter,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        visible=visible,\n        before_id=before_id,\n        source_args=source_args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, filter=None, paint=None, name=None, fit_bounds=True, visible=True, before_id=None, source_args={}, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>This method adds a GeoJSON layer to the map. The GeoJSON data can be a URL to a GeoJSON file or a GeoJSON dictionary. If a name is provided, it is used as the key to store the layer in the layer dictionary. Otherwise, a random name is generated.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | dict</code> <p>The GeoJSON data. This can be a URL to a GeoJSON file or a GeoJSON dictionary.</p> required <code>layer_type</code> <code>str</code> <p>The type of the layer. It can be one of the following: 'circle', 'fill', 'fill-extrusion', 'line', 'symbol', 'raster', 'background', 'heatmap', 'hillshade'. If None, the type is inferred from the GeoJSON data.</p> <code>None</code> <code>filter</code> <code>dict</code> <p>The filter to apply to the layer. If None, no filter is applied.</p> <code>None</code> <code>paint</code> <code>dict</code> <p>The paint properties to apply to the layer. If None, no paint properties are applied.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. If None, a random name is generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to adjust the viewport of the map to fit the bounds of the GeoJSON data. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible or not. Defaults to True.</p> <code>True</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>source_args</code> <code>dict</code> <p>Additional keyword arguments that are passed to the GeoJSONSource class.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the Layer class. See https://maplibre.org/maplibre-style-spec/layers/ for more info.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data is not a URL or a GeoJSON dictionary.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    filter: Optional[Dict] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    visible: bool = True,\n    before_id: Optional[str] = None,\n    source_args: Dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a GeoJSON layer to the map.\n\n    This method adds a GeoJSON layer to the map. The GeoJSON data can be a\n    URL to a GeoJSON file or a GeoJSON dictionary. If a name is provided, it\n    is used as the key to store the layer in the layer dictionary. Otherwise,\n    a random name is generated.\n\n    Args:\n        data (str | dict): The GeoJSON data. This can be a URL to a GeoJSON\n            file or a GeoJSON dictionary.\n        layer_type (str, optional): The type of the layer. It can be one of\n            the following: 'circle', 'fill', 'fill-extrusion', 'line', 'symbol',\n            'raster', 'background', 'heatmap', 'hillshade'. If None, the type\n            is inferred from the GeoJSON data.\n        filter (dict, optional): The filter to apply to the layer. If None,\n            no filter is applied.\n        paint (dict, optional): The paint properties to apply to the layer.\n            If None, no paint properties are applied.\n        name (str, optional): The name of the layer. If None, a random name\n            is generated.\n        fit_bounds (bool, optional): Whether to adjust the viewport of the\n            map to fit the bounds of the GeoJSON data. Defaults to True.\n        visible (bool, optional): Whether the layer is visible or not.\n            Defaults to True.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        source_args (dict, optional): Additional keyword arguments that are\n            passed to the GeoJSONSource class.\n        **kwargs: Additional keyword arguments that are passed to the Layer class.\n            See https://maplibre.org/maplibre-style-spec/layers/ for more info.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the data is not a URL or a GeoJSON dictionary.\n    \"\"\"\n\n    import os\n\n    bounds = None\n    geom_type = None\n\n    if isinstance(data, str):\n        if os.path.isfile(data) or data.startswith(\"http\"):\n            data = gpd.read_file(data).__geo_interface__\n            bounds = get_bounds(data)\n            source = GeoJSONSource(data=data, **source_args)\n        else:\n            raise ValueError(\"The data must be a URL or a GeoJSON dictionary.\")\n    elif isinstance(data, dict):\n        source = GeoJSONSource(data=data, **source_args)\n\n        bounds = get_bounds(data)\n    else:\n        raise ValueError(\"The data must be a URL or a GeoJSON dictionary.\")\n\n    if name is None:\n        name = \"geojson_\" + random_string()\n\n    if filter is not None:\n        kwargs[\"filter\"] = filter\n    if paint is None:\n        if \"features\" in data:\n            geom_type = data[\"features\"][0][\"geometry\"][\"type\"]\n        elif \"geometry\" in data:\n            geom_type = data[\"geometry\"][\"type\"]\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            if layer_type is None:\n                layer_type = \"circle\"\n            paint = {\n                \"circle-radius\": 5,\n                \"circle-color\": \"#3388ff\",\n                \"circle-stroke-color\": \"#ffffff\",\n                \"circle-stroke-width\": 1,\n            }\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            if layer_type is None:\n                layer_type = \"line\"\n            paint = {\"line-color\": \"#3388ff\", \"line-width\": 2}\n        elif geom_type in [\"Polygon\", \"MultiPolygon\"]:\n            if layer_type is None:\n                layer_type = \"fill\"\n            paint = {\n                \"fill-color\": \"#3388ff\",\n                \"fill-opacity\": 0.8,\n                \"fill-outline-color\": \"#ffffff\",\n            }\n\n    if paint is not None:\n        kwargs[\"paint\"] = paint\n\n    layer = Layer(\n        id=name,\n        type=layer_type,\n        source=source,\n        **kwargs,\n    )\n    self.add_layer(layer, before_id=before_id, name=name)\n    self.add_popup(name)\n    if fit_bounds and bounds is not None:\n        self.fit_bounds(bounds)\n    self.set_visibility(name, visible)\n\n    if isinstance(paint, dict) and f\"{layer_type}-opacity\" in paint:\n        self.set_opacity(name, paint[f\"{layer_type}-opacity\"])\n    else:\n        self.set_opacity(name, 1.0)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_image","title":"<code>add_image(self, id, image, width=None, height=None, coordinates=None, icon_size=1.0, **kwargs)</code>","text":"<p>Add an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The layer ID of the image.</p> required <code>image</code> <code>Union[str, Dict, np.ndarray]</code> <p>The URL or local file path to the image, or a dictionary containing image data, or a numpy array representing the image.</p> required <code>width</code> <code>int</code> <p>The width of the image. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the image. Defaults to None.</p> <code>None</code> <code>coordinates</code> <code>List[float]</code> <p>The longitude and latitude coordinates to place the image.</p> <code>None</code> <code>icon_size</code> <code>float</code> <p>The size of the icon. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_image(\n    self,\n    id: str,\n    image: Union[str, Dict],\n    width: int = None,\n    height: int = None,\n    coordinates: List[float] = None,\n    icon_size: float = 1.0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Add an image to the map.\n\n    Args:\n        id (str): The layer ID of the image.\n        image (Union[str, Dict, np.ndarray]): The URL or local file path to\n            the image, or a dictionary containing image data, or a numpy\n            array representing the image.\n        width (int, optional): The width of the image. Defaults to None.\n        height (int, optional): The height of the image. Defaults to None.\n        coordinates (List[float], optional): The longitude and latitude\n            coordinates to place the image.\n        icon_size (float, optional): The size of the icon. Defaults to 1.0.\n\n    Returns:\n        None\n    \"\"\"\n    import numpy as np\n\n    if isinstance(image, str):\n        image_dict = self._read_image(image)\n    elif isinstance(image, dict):\n        image_dict = image\n    elif isinstance(image, np.ndarray):\n        image_dict = {\n            \"width\": width,\n            \"height\": height,\n            \"data\": image.flatten().tolist(),\n        }\n    else:\n        raise ValueError(\n            \"The image must be a URL, a local file path, or a numpy array.\"\n        )\n    super().add_call(\"addImage\", id, image_dict)\n\n    if coordinates is not None:\n\n        source = {\n            \"type\": \"geojson\",\n            \"data\": {\n                \"type\": \"FeatureCollection\",\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"geometry\": {\"type\": \"Point\", \"coordinates\": coordinates},\n                    }\n                ],\n            },\n        }\n\n        self.add_source(\"image_point\", source)\n\n        kwargs[\"id\"] = \"image_points\"\n        kwargs[\"type\"] = \"symbol\"\n        kwargs[\"source\"] = \"image_point\"\n        if \"layout\" not in kwargs:\n            kwargs[\"layout\"] = {}\n        kwargs[\"layout\"][\"icon-image\"] = id\n        kwargs[\"layout\"][\"icon-size\"] = icon_size\n        self.add_layer(kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_layer","title":"<code>add_layer(self, layer, before_id=None, name=None)</code>","text":"<p>Adds a layer to the map.</p> <p>This method adds a layer to the map. If a name is provided, it is used     as the key to store the layer in the layer dictionary. Otherwise,     the layer's ID is used as the key. If a before_id is provided, the     layer is inserted before the layer with that ID.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer object to add to the map.</p> required <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name to use as the key to store the layer in the layer dictionary. If None, the layer's ID is used as the key.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_layer(\n    self,\n    layer: \"Layer\",\n    before_id: Optional[str] = None,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Adds a layer to the map.\n\n    This method adds a layer to the map. If a name is provided, it is used\n        as the key to store the layer in the layer dictionary. Otherwise,\n        the layer's ID is used as the key. If a before_id is provided, the\n        layer is inserted before the layer with that ID.\n\n    Args:\n        layer (Layer): The layer object to add to the map.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        name (str, optional): The name to use as the key to store the layer\n            in the layer dictionary. If None, the layer's ID is used as the key.\n\n    Returns:\n        None\n    \"\"\"\n    if isinstance(layer, dict):\n        if \"minzoom\" in layer:\n            layer[\"min-zoom\"] = layer.pop(\"minzoom\")\n        if \"maxzoom\" in layer:\n            layer[\"max-zoom\"] = layer.pop(\"maxzoom\")\n        layer = replace_top_level_hyphens(layer)\n        layer = Layer(**layer)\n\n    if name is None:\n        name = layer.id\n\n    if (\n        \"paint\" in layer.to_dict()\n        and f\"{layer.type}-color\" in layer.paint\n        and isinstance(layer.paint[f\"{layer.type}-color\"], str)\n    ):\n        color = check_color(layer.paint[f\"{layer.type}-color\"])\n    else:\n        color = None\n\n    self.layer_dict[name] = {\n        \"layer\": layer,\n        \"opacity\": 1.0,\n        \"visible\": True,\n        \"type\": layer.type,\n        \"color\": color,\n    }\n    super().add_layer(layer, before_id=before_id)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_marker","title":"<code>add_marker(self, marker=None, lng_lat=[], popup={}, options={})</code>","text":"<p>Adds a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>Marker</code> <p>A Marker object. Defaults to None.</p> <code>None</code> <code>lng_lat</code> <code>List[Union[float, float]]</code> <p>A list of two floats representing the longitude and latitude of the marker.</p> <code>[]</code> <code>popup</code> <code>Optional[str]</code> <p>The text to display in a popup when the marker is clicked. Defaults to None.</p> <code>{}</code> <code>options</code> <code>Optional[Dict]</code> <p>A dictionary of options to customize the marker. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_marker(\n    self,\n    marker: Marker = None,\n    lng_lat: List[Union[float, float]] = [],\n    popup: Optional[Dict] = {},\n    options: Optional[Dict] = {},\n) -&gt; None:\n    \"\"\"\n    Adds a marker to the map.\n\n    Args:\n        marker (Marker, optional): A Marker object. Defaults to None.\n        lng_lat (List[Union[float, float]]): A list of two floats\n            representing the longitude and latitude of the marker.\n        popup (Optional[str], optional): The text to display in a popup when\n            the marker is clicked. Defaults to None.\n        options (Optional[Dict], optional): A dictionary of options to\n            customize the marker. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n\n    if marker is None:\n        marker = Marker(lng_lat=lng_lat, popup=popup, options=options)\n    super().add_marker(marker)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_pmtiles","title":"<code>add_pmtiles(self, url, style=None, visible=True, opacity=1.0, exclude_mask=False, tooltip=True, properties=None, template=None, attribution='PMTiles', fit_bounds=True, **kwargs)</code>","text":"<p>Adds a PMTiles layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>style</code> <code>dict</code> <p>The CSS style to apply to the layer. Defaults to None. See https://docs.mapbox.com/style-spec/reference/layers/ for more info.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be shown initially. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>exclude_mask</code> <code>bool</code> <p>Whether to exclude the mask layer. Defaults to False.</p> <code>False</code> <code>tooltip</code> <code>bool</code> <p>Whether to show tooltips on the layer. Defaults to True.</p> <code>True</code> <code>properties</code> <code>dict</code> <p>The properties to use for the tooltips. Defaults to None.</p> <code>None</code> <code>template</code> <code>str</code> <p>The template to use for the tooltips. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use for the layer. Defaults to 'PMTiles'.</p> <code>'PMTiles'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to zoom to the layer extent. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the PMTilesLayer constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_pmtiles(\n    self,\n    url: str,\n    style: Optional[Dict] = None,\n    visible: bool = True,\n    opacity: float = 1.0,\n    exclude_mask: bool = False,\n    tooltip: bool = True,\n    properties: Optional[Dict] = None,\n    template: Optional[str] = None,\n    attribution: str = \"PMTiles\",\n    fit_bounds: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a PMTiles layer to the map.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        style (dict, optional): The CSS style to apply to the layer. Defaults to None.\n            See https://docs.mapbox.com/style-spec/reference/layers/ for more info.\n        visible (bool, optional): Whether the layer should be shown initially. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        exclude_mask (bool, optional): Whether to exclude the mask layer. Defaults to False.\n        tooltip (bool, optional): Whether to show tooltips on the layer. Defaults to True.\n        properties (dict, optional): The properties to use for the tooltips. Defaults to None.\n        template (str, optional): The template to use for the tooltips. Defaults to None.\n        attribution (str, optional): The attribution to use for the layer. Defaults to 'PMTiles'.\n        fit_bounds (bool, optional): Whether to zoom to the layer extent. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the PMTilesLayer constructor.\n\n    Returns:\n        None\n    \"\"\"\n\n    try:\n\n        if \"sources\" in kwargs:\n            del kwargs[\"sources\"]\n\n        if \"version\" in kwargs:\n            del kwargs[\"version\"]\n\n        pmtiles_source = {\n            \"type\": \"vector\",\n            \"url\": f\"pmtiles://{url}\",\n            \"attribution\": attribution,\n        }\n\n        if style is None:\n            style = pmtiles_style(url)\n\n        if \"sources\" in style:\n            source_name = list(style[\"sources\"].keys())[0]\n        elif \"layers\" in style:\n            source_name = style[\"layers\"][0][\"source\"]\n        else:\n            source_name = \"source\"\n\n        self.add_source(source_name, pmtiles_source)\n\n        style = replace_hyphens_in_keys(style)\n\n        for params in style[\"layers\"]:\n\n            if exclude_mask and params.get(\"source_layer\") == \"mask\":\n                continue\n\n            layer = Layer(**params)\n            self.add_layer(layer)\n            self.set_visibility(params[\"id\"], visible)\n            self.set_opacity(params[\"id\"], opacity)\n\n            if tooltip:\n                self.add_tooltip(params[\"id\"], properties, template)\n\n        if fit_bounds:\n            metadata = pmtiles_metadata(url)\n            bounds = metadata[\"bounds\"]  # [minx, miny, maxx, maxy]\n            self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_raster","title":"<code>add_raster(self, source, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution='Localtileserver', name='Raster', before_id=None, fit_bounds=True, visible=True, opacity=1.0, array_args={}, client_args={'cors_all': True}, **kwargs)</code>","text":"<p>Add a local raster dataset to the map.     If you are using this function in JupyterHub on a remote server     (e.g., Binder, Microsoft Planetary Computer) and if the raster     does not render properly, try installing jupyter-server-proxy using     <code>pip install jupyter-server-proxy</code>, then running the following code     before calling this function. For more info, see https://bit.ly/3JbmF93.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the palette when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>'Localtileserver'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to 'Raster'.</p> required <code>layer_index</code> <code>int</code> <p>The index of the layer. Defaults to None.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to True.</p> required <code>visible</code> <code>bool</code> <p>Whether the layer is visible. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> <code>array_args</code> <code>dict</code> <p>Additional arguments to pass to <code>array_to_memory_file</code> when reading the raster. Defaults to {}.</p> <code>{}</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to localtileserver.TileClient. Defaults to { \"cors_all\": False }.</p> <code>{'cors_all': True}</code> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_raster(\n    self,\n    source,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=\"Localtileserver\",\n    name=\"Raster\",\n    before_id=None,\n    fit_bounds=True,\n    visible=True,\n    opacity=1.0,\n    array_args={},\n    client_args={\"cors_all\": True},\n    **kwargs,\n):\n    \"\"\"Add a local raster dataset to the map.\n        If you are using this function in JupyterHub on a remote server\n        (e.g., Binder, Microsoft Planetary Computer) and if the raster\n        does not render properly, try installing jupyter-server-proxy using\n        `pip install jupyter-server-proxy`, then running the following code\n        before calling this function. For more info, see https://bit.ly/3JbmF93.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud\n            Optimized GeoTIFF.\n        indexes (int, optional): The band(s) to use. Band indexing starts\n            at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib`\n            to use when plotting a single band.\n            See https://matplotlib.org/stable/gallery/color/colormap_reference.html.\n            Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping\n            the palette when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret\n            as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This\n            defaults to a message about it being a local file.. Defaults to None.\n        layer_name (str, optional): The layer name to use. Defaults to 'Raster'.\n        layer_index (int, optional): The index of the layer. Defaults to None.\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the\n            layer. Defaults to True.\n        visible (bool, optional): Whether the layer is visible. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n        array_args (dict, optional): Additional arguments to pass to\n            `array_to_memory_file` when reading the raster. Defaults to {}.\n        client_args (dict, optional): Additional arguments to pass to\n            localtileserver.TileClient. Defaults to { \"cors_all\": False }.\n    \"\"\"\n    import numpy as np\n    import xarray as xr\n\n    if isinstance(source, np.ndarray) or isinstance(source, xr.DataArray):\n        source = array_to_image(source, **array_args)\n\n    tile_layer, tile_client = get_local_tile_layer(\n        source,\n        indexes=indexes,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        opacity=opacity,\n        attribution=attribution,\n        layer_name=name,\n        client_args=client_args,\n        return_client=True,\n        **kwargs,\n    )\n\n    self.add_tile_layer(\n        tile_layer.url,\n        name=name,\n        opacity=opacity,\n        visible=visible,\n        attribution=attribution,\n        before_id=before_id,\n    )\n\n    bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    bounds = [[bounds[2], bounds[0]], [bounds[3], bounds[1]]]\n    # [minx, miny, maxx, maxy]\n    if fit_bounds:\n        self.fit_bounds(bounds)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_source","title":"<code>add_source(self, id, source)</code>","text":"<p>Adds a source to the map.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the source.</p> required <code>source</code> <code>str or dict</code> <p>The source data. .</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_source(self, id: str, source: Union[str, Dict]) -&gt; None:\n    \"\"\"\n    Adds a source to the map.\n\n    Args:\n        id (str): The ID of the source.\n        source (str or dict): The source data. .\n\n    Returns:\n        None\n    \"\"\"\n    super().add_source(id, source)\n    self.source_dict[id] = source\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='', opacity=1.0, visible=True, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>This method adds a STAC TileLayer to the map. The STAC TileLayer is created from the specified URL, collection, item, assets, and bands, and it is added to the map with the specified name, attribution, opacity, visibility, and fit bounds.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://bit.ly/3VlttGm. Defaults to None.</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2. Defaults to None.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1. Defaults to None.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>A flag indicating whether the layer should be on by default. Defaults to True.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>A flag indicating whether the map should be zoomed to the layer extent. Defaults to True.</p> <code>True</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: Optional[str] = None,\n    collection: Optional[str] = None,\n    item: Optional[str] = None,\n    assets: Optional[Union[str, List[str]]] = None,\n    bands: Optional[List[str]] = None,\n    titiler_endpoint: Optional[str] = None,\n    name: str = \"STAC Layer\",\n    attribution: str = \"\",\n    opacity: float = 1.0,\n    visible: bool = True,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a STAC TileLayer to the map.\n\n    This method adds a STAC TileLayer to the map. The STAC TileLayer is\n    created from the specified URL, collection, item, assets, and bands, and\n    it is added to the map with the specified name, attribution, opacity,\n    visibility, and fit bounds.\n\n    Args:\n        url (str, optional): HTTP URL to a STAC item, e.g., https://bit.ly/3VlttGm.\n            Defaults to None.\n        collection (str, optional): The Microsoft Planetary Computer STAC\n            collection ID, e.g., landsat-8-c2-l2. Defaults to None.\n        item (str, optional): The Microsoft Planetary Computer STAC item ID, e.g.,\n            LC08_L2SP_047027_20201204_02_T1. Defaults to None.\n        assets (str | list, optional): The Microsoft Planetary Computer STAC asset ID,\n            e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.\n        bands (list, optional): A list of band names, e.g.,\n            [\"SR_B7\", \"SR_B5\", \"SR_B4\"]. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\",\n            \"https://planetarycomputer.microsoft.com/api/data/v1\",\n            \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        visible (bool, optional): A flag indicating whether the layer should\n            be on by default. Defaults to True.\n        fit_bounds (bool, optional): A flag indicating whether the map should\n            be zoomed to the layer extent. Defaults to True.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        **kwargs: Arbitrary keyword arguments, including bidx, expression,\n            nodata, unscale, resampling, rescale, color_formula, colormap,\n            colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/. To select\n            a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple\n            bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n\n    Returns:\n        None\n    \"\"\"\n    if \"colormap_name\" in kwargs and kwargs[\"colormap_name\"] is None:\n        kwargs.pop(\"colormap_name\")\n\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    bounds = stac_bounds(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(\n        tile_url, name, attribution, opacity, visible, before_id=before_id\n    )\n    if fit_bounds:\n        self.fit_bounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]])\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_tile_layer","title":"<code>add_tile_layer(self, url, name='Tile Layer', attribution='', opacity=1.0, visible=True, tile_size=256, before_id=None, source_args={}, **kwargs)</code>","text":"<p>Adds a TileLayer to the map.</p> <p>This method adds a TileLayer to the map. The TileLayer is created from     the specified URL, and it is added to the map with the specified     name, attribution, visibility, and tile size.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>The name to use for the layer. Defaults to ' Tile Layer'.</p> <code>'Tile Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use for the layer. Defaults to ''.</p> <code>''</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be visible by default. Defaults to True.</p> <code>True</code> <code>tile_size</code> <code>int</code> <p>The size of the tiles in the layer. Defaults to 256.</p> <code>256</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>source_args</code> <code>dict</code> <p>Additional keyword arguments that are passed to the RasterTileSource class.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the Layer class. See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: str = \"Tile Layer\",\n    attribution: str = \"\",\n    opacity: float = 1.0,\n    visible: bool = True,\n    tile_size: int = 256,\n    before_id: Optional[str] = None,\n    source_args: Dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a TileLayer to the map.\n\n    This method adds a TileLayer to the map. The TileLayer is created from\n        the specified URL, and it is added to the map with the specified\n        name, attribution, visibility, and tile size.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str, optional): The name to use for the layer. Defaults to '\n            Tile Layer'.\n        attribution (str, optional): The attribution to use for the layer.\n            Defaults to ''.\n        visible (bool, optional): Whether the layer should be visible by\n            default. Defaults to True.\n        tile_size (int, optional): The size of the tiles in the layer.\n            Defaults to 256.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        source_args (dict, optional): Additional keyword arguments that are\n            passed to the RasterTileSource class.\n        **kwargs: Additional keyword arguments that are passed to the Layer class.\n            See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.\n\n    Returns:\n        None\n    \"\"\"\n\n    raster_source = RasterTileSource(\n        tiles=[url.strip()],\n        attribution=attribution,\n        tile_size=tile_size,\n        **source_args,\n    )\n    layer = Layer(id=name, source=raster_source, type=LayerType.RASTER, **kwargs)\n    self.add_layer(layer, before_id=before_id, name=name)\n    self.set_visibility(name, visible)\n    self.set_opacity(name, opacity)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_vector","title":"<code>add_vector(self, data, layer_type=None, filter=None, paint=None, name=None, fit_bounds=True, visible=True, before_id=None, source_args={}, **kwargs)</code>","text":"<p>Adds a vector layer to the map.</p> <p>This method adds a vector layer to the map. The vector data can be a URL or local file path to a vector file. If a name is provided, it is used as the key to store the layer in the layer dictionary. Otherwise, a random name is generated.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | dict</code> <p>The vector data. This can be a URL or local file path to a vector file.</p> required <code>layer_type</code> <code>str</code> <p>The type of the layer. If None, the type is inferred from the GeoJSON data.</p> <code>None</code> <code>filter</code> <code>dict</code> <p>The filter to apply to the layer. If None, no filter is applied.</p> <code>None</code> <code>paint</code> <code>dict</code> <p>The paint properties to apply to the layer. If None, no paint properties are applied.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer. If None, a random name is generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to adjust the viewport of the map to fit the bounds of the GeoJSON data. Defaults to True.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether the layer is visible or not. Defaults to True.</p> <code>True</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>source_args</code> <code>dict</code> <p>Additional keyword arguments that are passed to the GeoJSONSource class.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the Layer class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data is not a URL or a GeoJSON dictionary.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_vector(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    filter: Optional[Dict] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    visible: bool = True,\n    before_id: Optional[str] = None,\n    source_args: Dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a vector layer to the map.\n\n    This method adds a vector layer to the map. The vector data can be a\n    URL or local file path to a vector file. If a name is provided, it\n    is used as the key to store the layer in the layer dictionary. Otherwise,\n    a random name is generated.\n\n    Args:\n        data (str | dict): The vector data. This can be a URL or local file\n            path to a vector file.\n        layer_type (str, optional): The type of the layer. If None, the type\n            is inferred from the GeoJSON data.\n        filter (dict, optional): The filter to apply to the layer. If None,\n            no filter is applied.\n        paint (dict, optional): The paint properties to apply to the layer.\n            If None, no paint properties are applied.\n        name (str, optional): The name of the layer. If None, a random name\n            is generated.\n        fit_bounds (bool, optional): Whether to adjust the viewport of the\n            map to fit the bounds of the GeoJSON data. Defaults to True.\n        visible (bool, optional): Whether the layer is visible or not.\n            Defaults to True.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        source_args (dict, optional): Additional keyword arguments that are\n            passed to the GeoJSONSource class.\n        **kwargs: Additional keyword arguments that are passed to the Layer class.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the data is not a URL or a GeoJSON dictionary.\n    \"\"\"\n\n    if not isinstance(data, gpd.GeoDataFrame):\n        data = gpd.read_file(data).__geo_interface__\n    else:\n        data = data.__geo_interface__\n\n    self.add_geojson(\n        data,\n        layer_type=layer_type,\n        filter=filter,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        visible=visible,\n        before_id=before_id,\n        source_args=source_args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, name='WMS Layer', attribution='', opacity=1.0, visible=True, tile_size=256, before_id=None, source_args={}, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>This method adds a WMS layer to the map. The WMS  is created from     the specified URL, and it is added to the map with the specified     name, attribution, visibility, and tile size.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>The name to use for the layer. Defaults to 'WMS Layer'.</p> <code>'WMS Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use for the layer. Defaults to ''.</p> <code>''</code> <code>visible</code> <code>bool</code> <p>Whether the layer should be visible by default. Defaults to True.</p> <code>True</code> <code>tile_size</code> <code>int</code> <p>The size of the tiles in the layer. Defaults to 256.</p> <code>256</code> <code>before_id</code> <code>str</code> <p>The ID of an existing layer before which the new layer should be inserted.</p> <code>None</code> <code>source_args</code> <code>dict</code> <p>Additional keyword arguments that are passed to the RasterTileSource class.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that are passed to the Layer class. See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    name: str = \"WMS Layer\",\n    attribution: str = \"\",\n    opacity: float = 1.0,\n    visible: bool = True,\n    tile_size: int = 256,\n    before_id: Optional[str] = None,\n    source_args: Dict = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Adds a WMS layer to the map.\n\n    This method adds a WMS layer to the map. The WMS  is created from\n        the specified URL, and it is added to the map with the specified\n        name, attribution, visibility, and tile size.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str, optional): The name to use for the layer. Defaults to\n            'WMS Layer'.\n        attribution (str, optional): The attribution to use for the layer.\n            Defaults to ''.\n        visible (bool, optional): Whether the layer should be visible by\n            default. Defaults to True.\n        tile_size (int, optional): The size of the tiles in the layer.\n            Defaults to 256.\n        before_id (str, optional): The ID of an existing layer before which\n            the new layer should be inserted.\n        source_args (dict, optional): Additional keyword arguments that are\n            passed to the RasterTileSource class.\n        **kwargs: Additional keyword arguments that are passed to the Layer class.\n            See https://eodagmbh.github.io/py-maplibregl/api/layer/ for more information.\n\n    Returns:\n        None\n    \"\"\"\n    self.add_tile_layer(\n        url,\n        name=name,\n        attribution=attribution,\n        opacity=opacity,\n        visible=visible,\n        tile_size=tile_size,\n        before_id=before_id,\n        source_args=source_args,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.find_first_symbol_layer","title":"<code>find_first_symbol_layer(self)</code>","text":"<p>Find the first symbol layer in the map's current style.</p> <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>The first symbol layer as a dictionary if found, otherwise None.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def find_first_symbol_layer(self) -&gt; Optional[Dict]:\n    \"\"\"\n    Find the first symbol layer in the map's current style.\n\n    Returns:\n        Optional[Dict]: The first symbol layer as a dictionary if found, otherwise None.\n    \"\"\"\n    layers = self.get_style_layers()\n    for layer in layers:\n        if layer[\"type\"] == \"symbol\":\n            return layer\n    return None\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.find_style_layer","title":"<code>find_style_layer(self, id)</code>","text":"<p>Searches for a style layer in the map's current style by its ID and returns it if found.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the style layer to find.</p> required <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>The style layer as a dictionary if found, otherwise None.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def find_style_layer(self, id: str) -&gt; Optional[Dict]:\n    \"\"\"\n    Searches for a style layer in the map's current style by its ID and returns it if found.\n\n    Args:\n        id (str): The ID of the style layer to find.\n\n    Returns:\n        Optional[Dict]: The style layer as a dictionary if found, otherwise None.\n    \"\"\"\n    layers = self.get_style_layers()\n    for layer in layers:\n        if layer[\"id\"] == id:\n            return layer\n    return None\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.fit_bounds","title":"<code>fit_bounds(self, bounds)</code>","text":"<p>Adjusts the viewport of the map to fit the specified geographical bounds     in the format of [[lon_min, lat_min], [lon_max, lat_max]] or     [lon_min, lat_min, lon_max, lat_max].</p> <p>This method adjusts the viewport of the map so that the specified geographical bounds are visible in the viewport. The bounds are specified as a list of two points, where each point is a list of two numbers representing the longitude and latitude.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of two points representing the geographical bounds that         should be visible in the viewport. Each point is a list of two         numbers representing the longitude and latitude. For example,         [[32.958984, -5.353521],[43.50585, 5.615985]]</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def fit_bounds(self, bounds: List[Tuple[float, float]]) -&gt; None:\n    \"\"\"\n    Adjusts the viewport of the map to fit the specified geographical bounds\n        in the format of [[lon_min, lat_min], [lon_max, lat_max]] or\n        [lon_min, lat_min, lon_max, lat_max].\n\n    This method adjusts the viewport of the map so that the specified geographical bounds\n    are visible in the viewport. The bounds are specified as a list of two points,\n    where each point is a list of two numbers representing the longitude and latitude.\n\n    Args:\n        bounds (list): A list of two points representing the geographical bounds that\n                    should be visible in the viewport. Each point is a list of two\n                    numbers representing the longitude and latitude. For example,\n                    [[32.958984, -5.353521],[43.50585, 5.615985]]\n\n    Returns:\n        None\n    \"\"\"\n\n    if isinstance(bounds, list):\n        if len(bounds) == 4 and all(isinstance(i, (int, float)) for i in bounds):\n            bounds = [[bounds[0], bounds[1]], [bounds[2], bounds[3]]]\n\n    self.add_call(\"fitBounds\", bounds)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.fly_to","title":"<code>fly_to(self, lon, lat, zoom=None, speed=None, essential=True, **kwargs)</code>","text":"<p>Makes the map fly to a specified location.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the location to fly to.</p> required <code>lat</code> <code>float</code> <p>The latitude of the location to fly to.</p> required <code>zoom</code> <code>Optional[float]</code> <p>The zoom level to use when flying to the location. Defaults to None.</p> <code>None</code> <code>speed</code> <code>Optional[float]</code> <p>The speed of the fly animation. Defaults to None.</p> <code>None</code> <code>essential</code> <code>bool</code> <p>Whether the flyTo animation is considered essential and not affected by prefers-reduced-motion. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the flyTo function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def fly_to(\n    self,\n    lon: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    speed: Optional[float] = None,\n    essential: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Makes the map fly to a specified location.\n\n    Args:\n        lon (float): The longitude of the location to fly to.\n        lat (float): The latitude of the location to fly to.\n        zoom (Optional[float], optional): The zoom level to use when flying\n            to the location. Defaults to None.\n        speed (Optional[float], optional): The speed of the fly animation.\n            Defaults to None.\n        essential (bool, optional): Whether the flyTo animation is considered\n            essential and not affected by prefers-reduced-motion. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the flyTo function.\n\n    Returns:\n        None\n    \"\"\"\n\n    center = [lon, lat]\n    kwargs[\"center\"] = center\n    if zoom is not None:\n        kwargs[\"zoom\"] = zoom\n    if speed is not None:\n        kwargs[\"speed\"] = speed\n    if essential:\n        kwargs[\"essential\"] = essential\n\n    super().add_call(\"flyTo\", kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.get_style","title":"<code>get_style(self)</code>","text":"<p>Get the style of the map.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>The style of the map.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def get_style(self):\n    \"\"\"\n    Get the style of the map.\n\n    Returns:\n        Dict: The style of the map.\n    \"\"\"\n    if self._style is not None:\n        if isinstance(self._style, str):\n            response = requests.get(self._style)\n            style = response.json()\n        elif isinstance(self._style, dict):\n            style = self._style\n        return style\n    else:\n        return {}\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.get_style_layers","title":"<code>get_style_layers(self, return_ids=False, sorted=True)</code>","text":"<p>Get the names of the basemap layers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The names of the basemap layers.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def get_style_layers(self, return_ids=False, sorted=True) -&gt; List[str]:\n    \"\"\"\n    Get the names of the basemap layers.\n\n    Returns:\n        List[str]: The names of the basemap layers.\n    \"\"\"\n    style = self.get_style()\n    if \"layers\" in style:\n        layers = style[\"layers\"]\n        if return_ids:\n            ids = [layer[\"id\"] for layer in layers]\n            if sorted:\n                ids.sort()\n\n            return ids\n        else:\n            return layers\n    else:\n        return []\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.jump_to","title":"<code>jump_to(self, options={}, **kwargs)</code>","text":"<p>Jumps the map to a specified location.</p> <p>This function jumps the map to the specified location with the specified options. Additional keyword arguments can be provided to control the jump. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#jumpto</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Dict[str, Any]</code> <p>Additional options to control the jump. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to control the jump.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def jump_to(self, options: Dict[str, Any] = {}, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Jumps the map to a specified location.\n\n    This function jumps the map to the specified location with the specified options.\n    Additional keyword arguments can be provided to control the jump. For more information,\n    see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#jumpto\n\n    Args:\n        options (Dict[str, Any], optional): Additional options to control the jump. Defaults to {}.\n        **kwargs (Any): Additional keyword arguments to control the jump.\n\n    Returns:\n        None\n    \"\"\"\n    super().add_call(\"jumpTo\", options, **kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.layer_interact","title":"<code>layer_interact(self, name=None)</code>","text":"<p>Create a layer widget for changing the visibility and opacity of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets.Widget</code> <p>The layer widget.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def layer_interact(self, name=None):\n    \"\"\"Create a layer widget for changing the visibility and opacity of a layer.\n\n    Args:\n        name (str): The name of the layer.\n\n    Returns:\n        ipywidgets.Widget: The layer widget.\n    \"\"\"\n\n    import ipywidgets as widgets\n\n    layer_names = list(self.layer_dict.keys())\n    if name is None:\n        name = layer_names[-1]\n    elif name not in layer_names:\n        raise ValueError(f\"Layer {name} not found.\")\n\n    style = {\"description_width\": \"initial\"}\n    dropdown = widgets.Dropdown(\n        options=layer_names,\n        value=name,\n        description=\"Layer\",\n        style=style,\n    )\n    checkbox = widgets.Checkbox(\n        description=\"Visible\",\n        value=self.layer_dict[name][\"visible\"],\n        style=style,\n        layout=widgets.Layout(width=\"120px\"),\n    )\n    opacity_slider = widgets.FloatSlider(\n        description=\"Opacity\",\n        min=0,\n        max=1,\n        step=0.01,\n        value=self.layer_dict[name][\"opacity\"],\n        style=style,\n    )\n\n    color_picker = widgets.ColorPicker(\n        concise=True,\n        value=\"white\",\n        style=style,\n    )\n\n    if self.layer_dict[name][\"color\"] is not None:\n        color_picker.value = self.layer_dict[name][\"color\"]\n        color_picker.disabled = False\n    else:\n        color_picker.value = \"white\"\n        color_picker.disabled = True\n\n    def color_picker_event(change):\n        if self.layer_dict[dropdown.value][\"color\"] is not None:\n            self.set_color(dropdown.value, change.new)\n\n    color_picker.observe(color_picker_event, \"value\")\n\n    hbox = widgets.HBox(\n        [dropdown, checkbox, opacity_slider, color_picker],\n        layout=widgets.Layout(width=\"750px\"),\n    )\n\n    def dropdown_event(change):\n        name = change.new\n        checkbox.value = self.layer_dict[dropdown.value][\"visible\"]\n        opacity_slider.value = self.layer_dict[dropdown.value][\"opacity\"]\n        if self.layer_dict[dropdown.value][\"color\"] is not None:\n            color_picker.value = self.layer_dict[dropdown.value][\"color\"]\n            color_picker.disabled = False\n        else:\n            color_picker.value = \"white\"\n            color_picker.disabled = True\n\n    dropdown.observe(dropdown_event, \"value\")\n\n    def update_layer(change):\n        self.set_visibility(dropdown.value, checkbox.value)\n        self.set_opacity(dropdown.value, opacity_slider.value)\n\n    checkbox.observe(update_layer, \"value\")\n    opacity_slider.observe(update_layer, \"value\")\n\n    return hbox\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.open_geojson","title":"<code>open_geojson(self, **kwargs)</code>","text":"<p>Creates a file uploader widget to upload a GeoJSON file. When a file is uploaded, it is written to a temporary file and added to the map.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the add_geojson method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>widgets.FileUpload</code> <p>The file uploader widget.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def open_geojson(self, **kwargs: Any) -&gt; \"widgets.FileUpload\":\n    \"\"\"\n    Creates a file uploader widget to upload a GeoJSON file. When a file is\n    uploaded, it is written to a temporary file and added to the map.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the add_geojson method.\n\n    Returns:\n        widgets.FileUpload: The file uploader widget.\n    \"\"\"\n\n    import ipywidgets as widgets\n\n    uploader = widgets.FileUpload(\n        accept=\".geojson\",  # Accept GeoJSON files\n        multiple=False,  # Only single file upload\n        description=\"Open GeoJSON\",\n    )\n\n    def on_upload(change):\n        content = uploader.value[0][\"content\"]\n        temp_file = temp_file_path(extension=\".geojson\")\n        with open(temp_file, \"wb\") as f:\n            f.write(content)\n        self.add_geojson(temp_file, **kwargs)\n\n    uploader.observe(on_upload, names=\"value\")\n\n    return uploader\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.pan_to","title":"<code>pan_to(self, lnglat, options={}, **kwargs)</code>","text":"<p>Pans the map to a specified location.</p> <p>This function pans the map to the specified longitude and latitude coordinates. Additional options and keyword arguments can be provided to control the panning. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#panto</p> <p>Parameters:</p> Name Type Description Default <code>lnglat</code> <code>List[float, float]</code> <p>The longitude and latitude coordinates to pan to.</p> required <code>options</code> <code>Dict[str, Any]</code> <p>Additional options to control the panning. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to control the panning.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def pan_to(\n    self,\n    lnglat: List[float],\n    options: Dict[str, Any] = {},\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Pans the map to a specified location.\n\n    This function pans the map to the specified longitude and latitude coordinates.\n    Additional options and keyword arguments can be provided to control the panning.\n    For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#panto\n\n    Args:\n        lnglat (List[float, float]): The longitude and latitude coordinates to pan to.\n        options (Dict[str, Any], optional): Additional options to control the panning. Defaults to {}.\n        **kwargs (Any): Additional keyword arguments to control the panning.\n\n    Returns:\n        None\n    \"\"\"\n    super().add_call(\"panTo\", lnglat, options, **kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.remove_layer","title":"<code>remove_layer(self, name)</code>","text":"<p>Removes a layer from the map.</p> <p>This method removes a layer from the map using the layer's name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer to remove.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def remove_layer(self, name: str) -&gt; None:\n    \"\"\"\n    Removes a layer from the map.\n\n    This method removes a layer from the map using the layer's name.\n\n    Args:\n        name (str): The name of the layer to remove.\n\n    Returns:\n        None\n    \"\"\"\n\n    super().add_call(\"removeLayer\", name)\n    if name in self.layer_dict:\n        self.layer_dict.pop(name)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.rotate_to","title":"<code>rotate_to(self, bearing, options={}, **kwargs)</code>","text":"<p>Rotate the map to a specified bearing.</p> <p>This function rotates the map to a specified bearing. The bearing is specified in degrees counter-clockwise from true north. If the bearing is not specified, the map will rotate to true north. Additional options and keyword arguments can be provided to control the rotation. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#rotateto</p> <p>Parameters:</p> Name Type Description Default <code>bearing</code> <code>float</code> <p>The bearing to rotate to, in degrees counter-clockwise from true north.</p> required <code>options</code> <code>Dict[str, Any]</code> <p>Additional options to control the rotation. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to control the rotation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def rotate_to(\n    self, bearing: float, options: Dict[str, Any] = {}, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Rotate the map to a specified bearing.\n\n    This function rotates the map to a specified bearing. The bearing is specified in degrees\n    counter-clockwise from true north. If the bearing is not specified, the map will rotate to\n    true north. Additional options and keyword arguments can be provided to control the rotation.\n    For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#rotateto\n\n    Args:\n        bearing (float): The bearing to rotate to, in degrees counter-clockwise from true north.\n        options (Dict[str, Any], optional): Additional options to control the rotation. Defaults to {}.\n        **kwargs (Any): Additional keyword arguments to control the rotation.\n\n    Returns:\n        None\n    \"\"\"\n    super().add_call(\"rotateTo\", bearing, options, **kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_center","title":"<code>set_center(self, lon, lat, zoom=None)</code>","text":"<p>Sets the center of the map.</p> <p>This method sets the center of the map to the specified longitude and latitude. If a zoom level is provided, it also sets the zoom level of the map.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>The longitude of the center of the map.</p> required <code>lat</code> <code>float</code> <p>The latitude of the center of the map.</p> required <code>zoom</code> <code>int</code> <p>The zoom level of the map. If None, the zoom level is not changed.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_center(self, lon: float, lat: float, zoom: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Sets the center of the map.\n\n    This method sets the center of the map to the specified longitude and latitude.\n    If a zoom level is provided, it also sets the zoom level of the map.\n\n    Args:\n        lon (float): The longitude of the center of the map.\n        lat (float): The latitude of the center of the map.\n        zoom (int, optional): The zoom level of the map. If None, the zoom\n            level is not changed.\n\n    Returns:\n        None\n    \"\"\"\n    center = [lon, lat]\n    self.add_call(\"setCenter\", center)\n\n    if zoom is not None:\n        self.add_call(\"setZoom\", zoom)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_color","title":"<code>set_color(self, name, color)</code>","text":"<p>Set the color of a layer.</p> <p>This method sets the color of the specified layer to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>color</code> <code>str</code> <p>The color value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_color(self, name: str, color: str) -&gt; None:\n    \"\"\"\n    Set the color of a layer.\n\n    This method sets the color of the specified layer to the specified value.\n\n    Args:\n        name (str): The name of the layer.\n        color (str): The color value to set.\n\n    Returns:\n        None\n    \"\"\"\n    color = check_color(color)\n    super().set_paint_property(\n        name, f\"{self.layer_dict[name]['layer'].type}-color\", color\n    )\n    self.layer_dict[name][\"color\"] = color\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_layout_property","title":"<code>set_layout_property(self, name, prop, value)</code>","text":"<p>Set the layout property of a layer.</p> <p>This method sets the layout property of the specified layer to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>prop</code> <code>str</code> <p>The layout property to set.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_layout_property(self, name: str, prop: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the layout property of a layer.\n\n    This method sets the layout property of the specified layer to the specified value.\n\n    Args:\n        name (str): The name of the layer.\n        prop (str): The layout property to set.\n        value (Any): The value to set.\n\n    Returns:\n        None\n    \"\"\"\n    super().set_layout_property(name, prop, value)\n\n    if name in self.style_dict:\n        layer = self.style_dict[name]\n        if \"layout\" in layer:\n            layer[\"layout\"][prop] = value\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_opacity","title":"<code>set_opacity(self, name, opacity)</code>","text":"<p>Set the opacity of a layer.</p> <p>This method sets the opacity of the specified layer to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>opacity</code> <code>float</code> <p>The opacity value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_opacity(self, name: str, opacity: float) -&gt; None:\n    \"\"\"\n    Set the opacity of a layer.\n\n    This method sets the opacity of the specified layer to the specified value.\n\n    Args:\n        name (str): The name of the layer.\n        opacity (float): The opacity value to set.\n\n    Returns:\n        None\n    \"\"\"\n\n    if name in self.layer_dict:\n        layer_type = self.layer_dict[name][\"layer\"].to_dict()[\"type\"]\n        prop_name = f\"{layer_type}-opacity\"\n        self.layer_dict[name][\"opacity\"] = opacity\n    elif name in self.style_dict:\n        layer = self.style_dict[name]\n        layer_type = layer.get(\"type\")\n        prop_name = f\"{layer_type}-opacity\"\n        if \"paint\" in layer:\n            layer[\"paint\"][prop_name] = opacity\n    super().set_paint_property(name, prop_name, opacity)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_paint_property","title":"<code>set_paint_property(self, name, prop, value)</code>","text":"<p>Set the opacity of a layer.</p> <p>This method sets the opacity of the specified layer to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>opacity</code> <code>float</code> <p>The opacity value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_paint_property(self, name: str, prop: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the opacity of a layer.\n\n    This method sets the opacity of the specified layer to the specified value.\n\n    Args:\n        name (str): The name of the layer.\n        opacity (float): The opacity value to set.\n\n    Returns:\n        None\n    \"\"\"\n    super().set_paint_property(name, prop, value)\n\n    if \"opacity\" in prop and name in self.layer_dict:\n        self.layer_dict[name][\"opacity\"] = value\n    elif name in self.style_dict:\n        layer = self.style_dict[name]\n        if \"paint\" in layer:\n            layer[\"paint\"][prop] = value\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_pitch","title":"<code>set_pitch(self, pitch, **kwargs)</code>","text":"<p>Sets the pitch of the map.</p> <p>This function sets the pitch of the map to the specified value. The pitch is the angle of the camera measured in degrees where 0 is looking straight down, and 60 is looking towards the horizon. Additional keyword arguments can be provided to control the pitch. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#setpitch</p> <p>Parameters:</p> Name Type Description Default <code>pitch</code> <code>float</code> <p>The pitch value to set.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to control the pitch.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_pitch(self, pitch: float, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Sets the pitch of the map.\n\n    This function sets the pitch of the map to the specified value. The pitch is the\n    angle of the camera measured in degrees where 0 is looking straight down, and 60 is\n    looking towards the horizon. Additional keyword arguments can be provided to control\n    the pitch. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#setpitch\n\n    Args:\n        pitch (float): The pitch value to set.\n        **kwargs (Any): Additional keyword arguments to control the pitch.\n\n    Returns:\n        None\n    \"\"\"\n    super().add_call(\"setPitch\", pitch, **kwargs)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_visibility","title":"<code>set_visibility(self, name, visible)</code>","text":"<p>Set the visibility of a layer.</p> <p>This method sets the visibility of the specified layer to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>visible</code> <code>bool</code> <p>The visibility value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"\n    Set the visibility of a layer.\n\n    This method sets the visibility of the specified layer to the specified value.\n\n    Args:\n        name (str): The name of the layer.\n        visible (bool): The visibility value to set.\n\n    Returns:\n        None\n    \"\"\"\n    super().set_visibility(name, visible)\n    self.layer_dict[name][\"visible\"] = visible\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.set_zoom","title":"<code>set_zoom(self, zoom=None)</code>","text":"<p>Sets the zoom level of the map.</p> <p>This method sets the zoom level of the map to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The zoom level of the map.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def set_zoom(self, zoom: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Sets the zoom level of the map.\n\n    This method sets the zoom level of the map to the specified value.\n\n    Args:\n        zoom (int): The zoom level of the map.\n\n    Returns:\n        None\n    \"\"\"\n    self.add_call(\"setZoom\", zoom)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.style_layer_interact","title":"<code>style_layer_interact(self, id=None)</code>","text":"<p>Create a layer widget for changing the visibility and opacity of a style layer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The is of the layer.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets.Widget</code> <p>The layer widget.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def style_layer_interact(self, id=None):\n    \"\"\"Create a layer widget for changing the visibility and opacity of a style layer.\n\n    Args:\n        id (str): The is of the layer.\n\n    Returns:\n        ipywidgets.Widget: The layer widget.\n    \"\"\"\n\n    import ipywidgets as widgets\n\n    layer_ids = list(self.style_dict.keys())\n    layer_ids.sort()\n    if id is None:\n        id = layer_ids[0]\n    elif id not in layer_ids:\n        raise ValueError(f\"Layer {id} not found.\")\n\n    layer = self.style_dict[id]\n    layer_type = layer.get(\"type\")\n    style = {\"description_width\": \"initial\"}\n    dropdown = widgets.Dropdown(\n        options=layer_ids,\n        value=id,\n        description=\"Layer\",\n        style=style,\n    )\n\n    visibility = layer.get(\"layout\", {}).get(\"visibility\", \"visible\")\n    if visibility == \"visible\":\n        visibility = True\n    else:\n        visibility = False\n\n    checkbox = widgets.Checkbox(\n        description=\"Visible\",\n        value=visibility,\n        style=style,\n        layout=widgets.Layout(width=\"120px\"),\n    )\n\n    opacity = layer.get(\"paint\", {}).get(f\"{layer_type}-opacity\", 1.0)\n    opacity_slider = widgets.FloatSlider(\n        description=\"Opacity\",\n        min=0,\n        max=1,\n        step=0.01,\n        value=opacity,\n        style=style,\n    )\n\n    def extract_rgb(rgba_string):\n        import re\n\n        # Extracting the RGB values using regex\n        rgb_tuple = tuple(map(int, re.findall(r\"\\d+\", rgba_string)[:3]))\n        return rgb_tuple\n\n    color = layer.get(\"paint\", {}).get(f\"{layer_type}-color\", \"white\")\n    if color.startswith(\"rgba\"):\n        color = extract_rgb(color)\n    color = check_color(color)\n    color_picker = widgets.ColorPicker(\n        concise=True,\n        value=color,\n        style=style,\n    )\n\n    def color_picker_event(change):\n        self.set_paint_property(dropdown.value, f\"{layer_type}-color\", change.new)\n\n    color_picker.observe(color_picker_event, \"value\")\n\n    hbox = widgets.HBox(\n        [dropdown, checkbox, opacity_slider, color_picker],\n        layout=widgets.Layout(width=\"750px\"),\n    )\n\n    def dropdown_event(change):\n        name = change.new\n        layer = self.style_dict[name]\n        layer_type = layer.get(\"type\")\n\n        visibility = layer.get(\"layout\", {}).get(\"visibility\", \"visible\")\n        if visibility == \"visible\":\n            visibility = True\n        else:\n            visibility = False\n\n        checkbox.value = visibility\n        opacity = layer.get(\"paint\", {}).get(f\"{layer_type}-opacity\", 1.0)\n        opacity_slider.value = opacity\n\n        color = layer.get(\"paint\", {}).get(f\"{layer_type}-color\", \"white\")\n        if color.startswith(\"rgba\"):\n            color = extract_rgb(color)\n        color = check_color(color)\n\n        if color:\n            color_picker.value = color\n            color_picker.disabled = False\n        else:\n            color_picker.value = \"white\"\n            color_picker.disabled = True\n\n    dropdown.observe(dropdown_event, \"value\")\n\n    def update_layer(change):\n        self.set_layout_property(\n            dropdown.value, \"visibility\", \"visible\" if checkbox.value else \"none\"\n        )\n        self.set_paint_property(\n            dropdown.value, f\"{layer_type}-opacity\", opacity_slider.value\n        )\n\n    checkbox.observe(update_layer, \"value\")\n    opacity_slider.observe(update_layer, \"value\")\n\n    return hbox\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.to_html","title":"<code>to_html(self, title='Map', width='100%', height='880px', output=None, **kwargs)</code>","text":"<p>Render the map to an HTML page.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the HTML page. Defaults to 'Map'.</p> <code>'Map'</code> <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '880px'.</p> <code>'880px'</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the <code>maplibre.ipywidget.MapWidget.to_html()</code> method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML content of the map.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def to_html(\n    self,\n    title: str = \"Map\",\n    width: str = \"100%\",\n    height: str = \"880px\",\n    output: str = None,\n    **kwargs,\n):\n    \"\"\"Render the map to an HTML page.\n\n    Args:\n        title (str, optional): The title of the HTML page. Defaults to 'Map'.\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '880px'.\n        **kwargs: Additional keyword arguments that are passed to the\n            `maplibre.ipywidget.MapWidget.to_html()` method.\n\n    Returns:\n        str: The HTML content of the map.\n    \"\"\"\n\n    if \"style\" not in kwargs:\n        kwargs[\"style\"] = f\"width: {width}; height: {height};\"\n    else:\n        kwargs[\"style\"] += f\"width: {width}; height: {height};\"\n    html = super().to_html(title=title, **kwargs)\n    if output:\n        with open(output, \"w\") as f:\n            f.write(html)\n    else:\n        return html\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.to_streamlit","title":"<code>to_streamlit(self, width=None, height=600, scrolling=False, **kwargs)</code>","text":"<p>Convert the map to a Streamlit component.</p> <p>This function converts the map to a Streamlit component by encoding the HTML representation of the map as base64 and embedding it in an iframe. The width, height, and scrolling parameters control the appearance of the iframe.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>Optional[int]</code> <p>The width of the iframe. If None, the width will be determined by Streamlit.</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the iframe. Default is 600.</p> <code>600</code> <code>scrolling</code> <code>Optional[bool]</code> <p>Whether the iframe should be scrollable. Default is False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the Streamlit iframe function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The Streamlit component.</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If there is an error in creating the Streamlit component.</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def to_streamlit(\n    self,\n    width: Optional[int] = None,\n    height: Optional[int] = 600,\n    scrolling: Optional[bool] = False,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Convert the map to a Streamlit component.\n\n    This function converts the map to a Streamlit component by encoding the\n    HTML representation of the map as base64 and embedding it in an iframe.\n    The width, height, and scrolling parameters control the appearance of\n    the iframe.\n\n    Args:\n        width (Optional[int]): The width of the iframe. If None, the width\n            will be determined by Streamlit.\n        height (Optional[int]): The height of the iframe. Default is 600.\n        scrolling (Optional[bool]): Whether the iframe should be scrollable.\n            Default is False.\n        **kwargs (Any): Additional arguments to pass to the Streamlit iframe\n            function.\n\n    Returns:\n        Any: The Streamlit component.\n\n    Raises:\n        Exception: If there is an error in creating the Streamlit component.\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n        import base64\n\n        raw_html = self.to_html().encode(\"utf-8\")\n        raw_html = base64.b64encode(raw_html).decode()\n        return components.iframe(\n            f\"data:text/html;base64,{raw_html}\",\n            width=width,\n            height=height,\n            scrolling=scrolling,\n            **kwargs,\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"maplibregl/#leafmap.maplibregl.Map.zoom_to","title":"<code>zoom_to(self, zoom, options={}, **kwargs)</code>","text":"<p>Zooms the map to a specified zoom level.</p> <p>This function zooms the map to the specified zoom level. Additional options and keyword arguments can be provided to control the zoom. For more information, see https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#zoomto</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>The zoom level to zoom to.</p> required <code>options</code> <code>Dict[str, Any]</code> <p>Additional options to control the zoom. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to control the zoom.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>leafmap/maplibregl.py</code> <pre><code>def zoom_to(self, zoom: float, options: Dict[str, Any] = {}, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Zooms the map to a specified zoom level.\n\n    This function zooms the map to the specified zoom level. Additional options and keyword\n    arguments can be provided to control the zoom. For more information, see\n    https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#zoomto\n\n    Args:\n        zoom (float): The zoom level to zoom to.\n        options (Dict[str, Any], optional): Additional options to control the zoom. Defaults to {}.\n        **kwargs (Any): Additional keyword arguments to control the zoom.\n\n    Returns:\n        None\n    \"\"\"\n    super().add_call(\"zoomTo\", zoom, options, **kwargs)\n</code></pre>"},{"location":"maps/","title":"Interactive maps","text":"<p>This page demonstrates some interactive maps created using the kepler.gl plotting backend.</p>"},{"location":"maps/#create-an-interactive-map","title":"Create an interactive map","text":"<p>You can specify various parameters to initialize the map, such as <code>center</code>, <code>zoom</code>, <code>height</code>, and <code>widescreen</code>.</p> <pre><code>import leafmap.kepler as leafmap\nm = leafmap.Map(center=[40, -100], zoom=2, height=600, widescreen=False)\nm\n</code></pre>"},{"location":"maps/#add-a-csv","title":"Add a CSV","text":"<pre><code>m = leafmap.Map(center=[37.7621, -122.4143], zoom=12)\nin_csv = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_data.csv'\nconfig = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_config.json'\nm.add_csv(in_csv, layer_name=\"hex_data\", config=config)\nm\n</code></pre>"},{"location":"maps/#add-a-geojson","title":"Add a GeoJSON","text":"<pre><code>m = leafmap.Map(center=[20, 0], zoom=1)\nlines = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson'\nm.add_geojson(lines, layer_name=\"Cable lines\")\nm\n</code></pre> <p>Add a GeoJSON with US state boundaries to the map.</p> <pre><code>m = leafmap.Map(center=[50, -110], zoom=2)\npolygons = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json'\nm.add_geojson(polygons, layer_name=\"Countries\")\nm\n</code></pre>"},{"location":"maps/#add-a-shapefile","title":"Add a shapefile","text":"<pre><code>m = leafmap.Map(center=[20, 0], zoom=1)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, \"Countries\")\nm\n</code></pre>"},{"location":"maps/#add-a-geodataframe","title":"Add a GeoDataFrame","text":"<pre><code>import geopandas as gpd\ngdf = gpd.read_file(\"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.geojson\")\nm = leafmap.Map(center=[20, 0], zoom=1)\nm.add_gdf(gdf, \"World cities\")\nm\n</code></pre>"},{"location":"osm/","title":"osm module","text":"<p>The module contains functions for downloading OpenStreetMap data. It wraps the geometries module of the osmnx package (see https://osmnx.readthedocs.io/en/stable/osmnx.html#module-osmnx.geometries). Credits to Geoff Boeing, the developer of the osmnx package. Most functions for downloading OpenStreetMap data require tags of map features. The list of commonly used tags can be found at https://wiki.openstreetmap.org/wiki/Map_features</p>"},{"location":"osm/#leafmap.osm.osm_gdf_from_address","title":"<code>osm_gdf_from_address(address, tags, dist=1000)</code>","text":"<p>Create GeoDataFrame of OSM entities within some distance N, S, E, W of address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_address(address: str, tags: Dict, dist: Optional[int] = 1000):\n    \"\"\"Create GeoDataFrame of OSM entities within some distance N, S, E, W of address.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_address(address, tags, dist)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_bbox","title":"<code>osm_gdf_from_bbox(north, south, east, west, tags)</code>","text":"<p>Create a GeoDataFrame of OSM entities within a N, S, E, W bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_bbox(north: float, south: float, east: float, west: float, tags: Dict):\n    \"\"\"Create a GeoDataFrame of OSM entities within a N, S, E, W bounding box.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_bbox(north, south, east, west, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_geocode","title":"<code>osm_gdf_from_geocode(query, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>which_result</code> <code>INT</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_geocode(\n    query: Union[str, Dict, List],\n    which_result: Optional[int] = None,\n    by_osmid: Optional[bool] = False,\n    buffer_dist: Optional[float] = None,\n):\n    \"\"\"Retrieves place(s) by name or ID from the Nominatim API as a GeoDataFrame.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        which_result (INT, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame.\n    \"\"\"\n\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/\")\n\n    import osmnx as ox\n\n    gdf = ox.geocode_to_gdf(query, which_result, by_osmid, buffer_dist)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_place","title":"<code>osm_gdf_from_place(query, tags, which_result=None, buffer_dist=None)</code>","text":"<p>Create GeoDataFrame of OSM entities within boundaries of geocodable place(s).</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_place(\n    query: Union[str, Dict, List],\n    tags: Dict,\n    which_result: Optional[int] = None,\n    buffer_dist: Optional[float] = None,\n):\n    \"\"\"Create GeoDataFrame of OSM entities within boundaries of geocodable place(s).\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    ox.config(use_cache=True, log_console=False)\n\n    gdf = ox.geometries_from_place(query, tags, which_result, buffer_dist)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_point","title":"<code>osm_gdf_from_point(center_point, tags, dist=1000)</code>","text":"<p>Create GeoDataFrame of OSM entities within some distance N, S, E, W of a point.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_point(\n    center_point: Tuple[float, float], tags: Dict, dist: Optional[int] = 1000\n):\n    \"\"\"Create GeoDataFrame of OSM entities within some distance N, S, E, W of a point.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_point(center_point, tags, dist)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_polygon","title":"<code>osm_gdf_from_polygon(polygon, tags)</code>","text":"<p>Create GeoDataFrame of OSM entities within boundaries of a (multi)polygon.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_polygon(polygon, tags: Dict):\n    \"\"\"Create GeoDataFrame of OSM entities within boundaries of a (multi)polygon.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_polygon(polygon, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_gdf_from_xml","title":"<code>osm_gdf_from_xml(filepath, polygon=None, tags=None)</code>","text":"<p>Create a GeoDataFrame of OSM entities in an OSM-formatted XML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>File path to file containing OSM XML data</p> required <code>polygon</code> <code>shapely.geometry.Polygon</code> <p>Optional geographic boundary to filter objects. Defaults to None.</p> <code>None</code> <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_gdf_from_xml(filepath: str, polygon=None, tags: Dict = None):\n    \"\"\"Create a GeoDataFrame of OSM entities in an OSM-formatted XML file.\n\n    Args:\n        filepath (str): File path to file containing OSM XML data\n        polygon (shapely.geometry.Polygon, optional): Optional geographic boundary to filter objects. Defaults to None.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame of OSM entities.\n    \"\"\"\n    check_package(\"osmnx\", \"https://osmnx.readthedocs.io/en/stable/#installation\")\n    import osmnx as ox\n\n    gdf = ox.geometries_from_xml(filepath, polygon, tags)\n    return gdf\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_address","title":"<code>osm_geojson_from_address(address, tags, filepath=None, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of address as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_address(\n    address: str, tags: Dict, filepath: str = None, dist: Optional[int] = 1000\n) -&gt; Dict:\n    \"\"\"Download OSM entities within some distance N, S, E, W of address as a GeoJSON.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON. Defaults to None.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_bbox","title":"<code>osm_geojson_from_bbox(north, south, east, west, tags, filepath=None)</code>","text":"<p>Download OSM entities within a N, S, E, W bounding box as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_bbox(\n    north: float,\n    south: float,\n    east: float,\n    west: float,\n    tags: Dict,\n    filepath: Optional[str] = None,\n):\n    \"\"\"Download OSM entities within a N, S, E, W bounding box as a GeoJSON.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_geocode","title":"<code>osm_geojson_from_geocode(query, filepath, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Download place(s) by name or ID from the Nominatim API as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_geocode(\n    query: Union[str, Dict, List],\n    filepath: str,\n    which_result: Optional[int] = None,\n    by_osmid: Optional[bool] = False,\n    buffer_dist: Optional[float] = None,\n):\n    \"\"\"Download place(s) by name or ID from the Nominatim API as a GeoJSON.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        filepath (str): File path to the output GeoJSON.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_geocode(query, which_result, by_osmid, buffer_dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_place","title":"<code>osm_geojson_from_place(query, tags, filepath, which_result=None, buffer_dist=None)</code>","text":"<p>Download OSM entities within boundaries of geocodable place(s) as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_place(\n    query: Union[str, Dict, List],\n    tags: Dict,\n    filepath: str,\n    which_result: Optional[int] = None,\n    buffer_dist: Optional[float] = None,\n) -&gt; Dict:\n    \"\"\"Download OSM entities within boundaries of geocodable place(s) as a GeoJSON.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_point","title":"<code>osm_geojson_from_point(center_point, tags, filepath, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of point as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_point(\n    center_point: Tuple[float, float],\n    tags: Dict,\n    filepath: str,\n    dist: Optional[int] = 1000,\n) -&gt; Dict:\n    \"\"\"Download OSM entities within some distance N, S, E, W of point as a GeoJSON.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_geojson_from_polygon","title":"<code>osm_geojson_from_polygon(polygon, tags, filepath=None)</code>","text":"<p>Download OSM entities within boundaries of a (multi)polygon as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output GeoJSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A GeoJSON dictionary of OSM entities.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_geojson_from_polygon(\n    polygon, tags: Dict, filepath: Optional[str] = None\n) -&gt; Dict:\n    \"\"\"Download OSM entities within boundaries of a (multi)polygon as a GeoJSON.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str, optional): File path to the output GeoJSON.\n\n    Returns:\n        dict: A GeoJSON dictionary of OSM entities.\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    if filepath is not None:\n        gdf.to_file(filepath, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_address","title":"<code>osm_shp_from_address(address, tags, filepath, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of address as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode and use as the central point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_address(\n    address: str, tags: Dict, filepath: str, dist: Optional[int] = 1000\n):\n    \"\"\"Download OSM entities within some distance N, S, E, W of address as a shapefile.\n\n    Args:\n        address (str): The address to geocode and use as the central point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n\n    \"\"\"\n    gdf = osm_gdf_from_address(address, tags, dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_bbox","title":"<code>osm_shp_from_bbox(north, south, east, west, tags, filepath)</code>","text":"<p>Download OSM entities within a N, S, E, W bounding box as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>Northern latitude of bounding box.</p> required <code>south</code> <code>float</code> <p>Southern latitude of bounding box.</p> required <code>east</code> <code>float</code> <p>Eastern longitude of bounding box.</p> required <code>west</code> <code>float</code> <p>Western longitude of bounding box.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_bbox(\n    north: float, south: float, east: float, west: float, tags: Dict, filepath: str\n):\n    \"\"\"Download OSM entities within a N, S, E, W bounding box as a shapefile.\n\n    Args:\n        north (float): Northern latitude of bounding box.\n        south (float): Southern latitude of bounding box.\n        east (float): Eastern longitude of bounding box.\n        west (float): Western longitude of bounding box.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n    \"\"\"\n    gdf = osm_gdf_from_bbox(north, south, east, west, tags)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_geocode","title":"<code>osm_shp_from_geocode(query, filepath, which_result=None, by_osmid=False, buffer_dist=None)</code>","text":"<p>Download place(s) by name or ID from the Nominatim API as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>by_osmid</code> <code>bool</code> <p>If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.</p> <code>False</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_geocode(\n    query: Union[str, Dict, List],\n    filepath: str,\n    which_result: Optional[int] = None,\n    by_osmid: Optional[bool] = False,\n    buffer_dist: Optional[float] = None,\n):\n    \"\"\"Download place(s) by name or ID from the Nominatim API as a shapefile.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        by_osmid (bool, optional): If True, handle query as an OSM ID for lookup rather than text search. Defaults to False.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n    \"\"\"\n    gdf = osm_gdf_from_geocode(query, which_result, by_osmid, buffer_dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_place","title":"<code>osm_shp_from_place(query, tags, filepath, which_result=None, buffer_dist=None)</code>","text":"<p>Download OSM entities within boundaries of geocodable place(s) as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | dict | list</code> <p>Query string(s) or structured dict(s) to geocode.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>which_result</code> <code>int</code> <p>Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.</p> <code>None</code> <code>buffer_dist</code> <code>float</code> <p>Distance to buffer around the place geometry, in meters. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_place(\n    query: Union[str, Dict, List],\n    tags: Dict,\n    filepath: str,\n    which_result: Optional[int] = None,\n    buffer_dist: Optional[float] = None,\n):\n    \"\"\"Download OSM entities within boundaries of geocodable place(s) as a shapefile.\n\n    Args:\n        query (str | dict | list): Query string(s) or structured dict(s) to geocode.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        which_result (int, optional): Which geocoding result to use. if None, auto-select the first (Multi)Polygon or raise an error if OSM doesn't return one. to get the top match regardless of geometry type, set which_result=1. Defaults to None.\n        buffer_dist (float, optional): Distance to buffer around the place geometry, in meters. Defaults to None.\n    \"\"\"\n    gdf = osm_gdf_from_place(query, tags, which_result, buffer_dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_point","title":"<code>osm_shp_from_point(center_point, tags, filepath, dist=1000)</code>","text":"<p>Download OSM entities within some distance N, S, E, W of point as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>center_point</code> <code>tuple</code> <p>The (lat, lng) center point around which to get the geometries.</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>dist</code> <code>int</code> <p>Distance in meters. Defaults to 1000.</p> <code>1000</code> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_point(\n    center_point: Tuple[float, float],\n    tags: Dict,\n    filepath: str,\n    dist: Optional[int] = 1000,\n):\n    \"\"\"Download OSM entities within some distance N, S, E, W of point as a shapefile.\n\n    Args:\n        center_point (tuple): The (lat, lng) center point around which to get the geometries.\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n        dist (int, optional): Distance in meters. Defaults to 1000.\n    \"\"\"\n    gdf = osm_gdf_from_point(center_point, tags, dist)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_shp_from_polygon","title":"<code>osm_shp_from_polygon(polygon, tags, filepath)</code>","text":"<p>Download OSM entities within boundaries of a (multi)polygon as a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>shapely.geometry.Polygon | shapely.geometry.MultiPolygon</code> <p>Geographic boundaries to fetch geometries within</p> required <code>tags</code> <code>dict</code> <p>Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.</p> required <code>filepath</code> <code>str</code> <p>File path to the output shapefile.</p> required Source code in <code>leafmap/osm.py</code> <pre><code>def osm_shp_from_polygon(polygon, tags: Dict, filepath: str):\n    \"\"\"Download OSM entities within boundaries of a (multi)polygon as a shapefile.\n\n    Args:\n        polygon (shapely.geometry.Polygon | shapely.geometry.MultiPolygon): Geographic boundaries to fetch geometries within\n        tags (dict): Dict of tags used for finding objects in the selected area. Results returned are the union, not intersection of each individual tag. Each result matches at least one given tag. The dict keys should be OSM tags, (e.g., building, landuse, highway, etc) and the dict values should be either True to retrieve all items with the given tag, or a string to get a single tag-value combination, or a list of strings to get multiple values for the given tag. For example, tags = {\u2018building\u2019: True} would return all building footprints in the area. tags = {\u2018amenity\u2019:True, \u2018landuse\u2019:[\u2018retail\u2019,\u2019commercial\u2019], \u2018highway\u2019:\u2019bus_stop\u2019} would return all amenities, landuse=retail, landuse=commercial, and highway=bus_stop.\n        filepath (str): File path to the output shapefile.\n    \"\"\"\n    gdf = osm_gdf_from_polygon(polygon, tags)\n    gdf.to_file(filepath)\n</code></pre>"},{"location":"osm/#leafmap.osm.osm_tags_list","title":"<code>osm_tags_list()</code>","text":"<p>Open a browser to see all tags of OSM features.</p> Source code in <code>leafmap/osm.py</code> <pre><code>def osm_tags_list():\n    \"\"\"Open a browser to see all tags of OSM features.\"\"\"\n    import webbrowser\n\n    webbrowser.open_new_tab(\"https://wiki.openstreetmap.org/wiki/Map_features\")\n</code></pre>"},{"location":"pc/","title":"pc module","text":"<p>A module for Microsoft Planetary Computer (PC).</p>"},{"location":"pc/#leafmap.pc.get_bands","title":"<code>get_bands(collection, item=None)</code>","text":"<p>Get the bands of an item.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection the item is in.</p> required <code>item</code> <code>str</code> <p>The item to get the bands of.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of bands.</p> Source code in <code>leafmap/pc.py</code> <pre><code>def get_bands(collection, item=None):\n    \"\"\"Get the bands of an item.\n\n    Args:\n        collection (str): The collection the item is in.\n        item (str): The item to get the bands of.\n\n    Returns:\n        list: A list of bands.\n    \"\"\"\n    if item is None:\n        item = get_first_item(collection, return_id=True)\n    return stac_bands(collection=collection, items=item)\n</code></pre>"},{"location":"pc/#leafmap.pc.get_first_item","title":"<code>get_first_item(collection, return_id=False)</code>","text":"<p>Get the first item in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection to get the first item from.</p> required <code>return_id</code> <code>bool</code> <p>If True, return the item's ID instead of the item itself.</p> <code>False</code> <p>Returns:</p> Type Description <code>pystac.Item</code> <p>The first item in the collection.</p> Source code in <code>leafmap/pc.py</code> <pre><code>def get_first_item(collection: str, return_id: Optional[bool] = False):\n    \"\"\"Get the first item in a collection.\n\n    Args:\n        collection (str): The collection to get the first item from.\n        return_id (bool, optional): If True, return the item's ID instead of the item itself.\n\n    Returns:\n        pystac.Item: The first item in the collection.\n    \"\"\"\n    catalog = Client.open(PC_ENDPOINT)\n    col = catalog.get_child(collection)\n    item = next(col.get_items())\n    if return_id:\n        return item.id\n    else:\n        return item\n</code></pre>"},{"location":"pc/#leafmap.pc.get_pc_collection_list","title":"<code>get_pc_collection_list()</code>","text":"<p>Get a list of collections in the Microsoft Planetary Computer catalog.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of collections.</p> Source code in <code>leafmap/pc.py</code> <pre><code>def get_pc_collection_list() -&gt; List:\n    \"\"\"Get a list of collections in the Microsoft Planetary Computer catalog.\n\n    Returns:\n        list: A list of collections.\n    \"\"\"\n    inventory = get_pc_inventory()\n\n    names = []\n\n    for key in inventory:\n        names.append(f\"{key} - {inventory[key]['title']}\")\n    names.sort()\n\n    return names\n</code></pre>"},{"location":"pc/#leafmap.pc.get_pc_collections","title":"<code>get_pc_collections(verbose=False)</code>","text":"<p>Get a list of all collections in the Microsoft Planetary Computer catalog.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print the collections to the console.</p> <code>False</code> Source code in <code>leafmap/pc.py</code> <pre><code>def get_pc_collections(verbose: Optional[bool] = False):\n    \"\"\"Get a list of all collections in the Microsoft Planetary Computer catalog.\n\n    Args:\n        verbose (bool, optional): If True, print the collections to the console.\n    \"\"\"\n    catalog = Client.open(PC_ENDPOINT)\n    collections = catalog.get_children()\n    result = {}\n    for collection in collections:\n        result[collection.id] = collection.title\n        if verbose:\n            print(f\"{collection.id} - {collection.title}\")\n\n    return result\n</code></pre>"},{"location":"pc/#leafmap.pc.get_pc_inventory","title":"<code>get_pc_inventory(refresh=False, verbose=False)</code>","text":"<p>Get the inventory of the Microsoft Planetary Computer catalog.</p> <p>Parameters:</p> Name Type Description Default <code>refresh</code> <code>bool</code> <p>If True, refresh the inventory.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print the collections to the console.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of collections and their bands.</p> Source code in <code>leafmap/pc.py</code> <pre><code>def get_pc_inventory(refresh: Optional[bool] = False, verbose: Optional[bool] = False):\n    \"\"\"Get the inventory of the Microsoft Planetary Computer catalog.\n\n    Args:\n        refresh (bool, optional): If True, refresh the inventory.\n        verbose (bool, optional): If True, print the collections to the console.\n\n    Returns:\n        dict: A dictionary of collections and their bands.\n    \"\"\"\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    filepath = os.path.join(pkg_dir, \"data/pc_inventory.json\")\n\n    if refresh:\n        catalog = Client.open(PC_ENDPOINT)\n        collections = catalog.get_children()\n        data = {}\n        for collection in collections:\n            try:\n                if verbose:\n                    print(f\"{collection.id} - {collection.title}\")\n                first_item = get_first_item(collection.id, return_id=True)\n                bands = stac_assets(collection=collection.id, item=first_item)\n                if isinstance(bands, list):\n                    data[collection.id] = {}\n                    data[collection.id][\"title\"] = collection.title\n                    data[collection.id][\"first_item\"] = first_item\n                    data[collection.id][\"bands\"] = bands\n            except Exception as e:\n                if verbose:\n                    print(f\"{collection.id} has no bands.\")\n\n        with open(filepath, \"w\") as f:\n            json.dump(data, f, indent=4)\n\n    else:\n        with open(filepath, \"r\") as f:\n            data = json.load(f)\n\n    return data\n</code></pre>"},{"location":"plot/","title":"plot module","text":"<p>Module for plotting data using plotly.express.</p>"},{"location":"plot/#leafmap.plot.bar_chart","title":"<code>bar_chart(data=None, x=None, y=None, color=None, descending=True, sort_column=None, max_rows=None, x_label=None, y_label=None, title=None, legend_title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a bar chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to True.</p> <code>True</code> <code>sort_column</code> <code>str</code> <p>The column to sort the data. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>legend_title</code> <code>str</code> <p>Title for the legend. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>leafmap/plot.py</code> <pre><code>def bar_chart(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=True,\n    sort_column=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    legend_title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n    \"\"\"Create a bar chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to True.\n        sort_column (str, optional): The column to sort the data. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        legend_title (str, optional): Title for the legend. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        if sort_column is None:\n            if isinstance(y, str):\n                sort_column = y\n            elif isinstance(y, list):\n                sort_column = y[0]\n        data.sort_values([sort_column, x], ascending=not (descending), inplace=True)\n        if \"barmode\" not in kwargs:\n            kwargs[\"barmode\"] = \"group\"\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        if isinstance(y, str):\n            labels[y] = y_label\n        elif isinstance(y, list):\n            labels[y[0]] = y_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.bar(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#leafmap.plot.histogram","title":"<code>histogram(data=None, x=None, y=None, color=None, descending=None, max_rows=None, x_label=None, y_label=None, title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a line chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>leafmap/plot.py</code> <pre><code>def histogram(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n    \"\"\"Create a line chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        data.sort_values([y, x], ascending=not (descending), inplace=True)\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        labels[y] = y_label\n\n    try:\n        fig = px.histogram(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#leafmap.plot.line_chart","title":"<code>line_chart(data=None, x=None, y=None, color=None, descending=None, max_rows=None, x_label=None, y_label=None, title=None, legend_title=None, width=None, height=500, layout_args={}, **kwargs)</code>","text":"<p>Create a line chart with plotly.express,</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame | array-like | dict | str (local file path or HTTP URL) This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> <code>None</code> <code>x</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the x axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>y</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to position marks along the y axis in cartesian coordinates. Either <code>x</code> or <code>y</code> can optionally be a list of column references or array_likes,  in which case the data will be treated as if it were 'wide' rather than 'long'.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to None.</p> <code>None</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>x_label</code> <code>str</code> <p>Label for the x axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>str</code> <p>Label for the y axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>legend_title</code> <code>str</code> <p>Title for the legend. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the plot in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the plot in pixels. Defaults to 500.</p> <code>500</code> <code>layout_args</code> <code>dict</code> <p>Layout arguments for the plot to be passed to fig.update_layout(), such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.</p> <code>{}</code> <code>**kwargs</code> <p>Any additional arguments to pass to plotly.express.bar(), such as:</p> <p>pattern_shape: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign pattern shapes to marks. facet_row: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the vertical direction. facet_col: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to facetted subplots in the horizontal direction. facet_col_wrap: int     Maximum number of facet columns. Wraps the column variable at this     width, so that the column facets span multiple rows. Ignored if 0, and     forced to 0 if <code>facet_row</code> or a <code>marginal</code> is set. facet_row_spacing: float between 0 and 1     Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7     when facet_col_wrap is used. facet_col_spacing: float between 0 and 1     Spacing between facet columns, in paper units Default is 0.02. hover_name: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in bold     in the hover tooltip. hover_data: list of str or int, or Series or array-like, or dict     Either a list of names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects or a dict with column names as keys, with values     True (for default formatting) False (in order to remove this column     from hover information), or a formatting string, for example ':.3f' or     '|%a' or list-like data to appear in the hover tooltip or tuples with a     bool or formatting string as first element, and list-like data to     appear in hover as second element Values from these columns appear as     extra data in the hover tooltip. custom_data: list of str or int, or Series or array-like     Either names of columns in <code>data_frame</code>, or pandas Series, or     array_like objects Values from these columns are extra data, to be used     in widgets or Dash callbacks for example. This data is not user-visible     but is included in events emitted by the figure (lasso selection etc.) text: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like appear in the     figure as text labels. base: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     position the base of the bar. error_x: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars. If <code>error_x_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_x</code> is used for the positive direction     only. error_x_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size x-axis error bars in the negative direction. Ignored if <code>error_x</code>     is <code>None</code>. error_y: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars. If <code>error_y_minus</code> is <code>None</code>, error bars will     be symmetrical, otherwise <code>error_y</code> is used for the positive direction     only. error_y_minus: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     size y-axis error bars in the negative direction. Ignored if <code>error_y</code>     is <code>None</code>. animation_frame: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     assign marks to animation frames. animation_group: str or int or Series or array-like     Either a name of a column in <code>data_frame</code>, or a pandas Series or     array_like object. Values from this column or array_like are used to     provide object-constancy across animation frames: rows with matching     <code>animation_group</code>s will be treated as if they describe the same object     in each frame. category_orders: dict with str keys and list of str values (default <code>{}</code>)     By default, in Python 3.6+, the order of categorical values in axes,     legends and facets depends on the order in which these values are first     encountered in <code>data_frame</code> (and no order is guaranteed by default in     Python below 3.6). This parameter is used to force a specific ordering     of values per column. The keys of this dict should correspond to column     names, and the values should be lists of strings corresponding to the     specific display order desired. labels: dict with str keys and str values (default <code>{}</code>)     By default, column names are used in the figure for axis titles, legend     entries and hovers. This parameter allows this to be overridden. The     keys of this dict should correspond to column names, and the values     should correspond to the desired label to be displayed. color_discrete_sequence: list of str     Strings should define valid CSS-colors. When <code>color</code> is set and the     values in the corresponding column are not numeric, values in that     column are assigned colors by cycling through <code>color_discrete_sequence</code>     in the order described in <code>category_orders</code>, unless the value of     <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color     sequences are available in the <code>plotly.express.colors</code> submodules,     specifically <code>plotly.express.colors.qualitative</code>. color_discrete_map: dict with str keys and str values (default <code>{}</code>)     String values should define valid CSS-colors Used to override     <code>color_discrete_sequence</code> to assign a specific colors to marks     corresponding with specific values. Keys in <code>color_discrete_map</code> should     be values in the column denoted by <code>color</code>. Alternatively, if the     values of <code>color</code> are valid colors, the string <code>'identity'</code> may be     passed to cause them to be used directly. color_continuous_scale: list of str     Strings should define valid CSS-colors This list is used to build a     continuous color scale when the column denoted by <code>color</code> contains     numeric data. Various useful color scales are available in the     <code>plotly.express.colors</code> submodules, specifically     <code>plotly.express.colors.sequential</code>, <code>plotly.express.colors.diverging</code>     and <code>plotly.express.colors.cyclical</code>. pattern_shape_sequence: list of str     Strings should define valid plotly.js patterns-shapes. When     <code>pattern_shape</code> is set, values in that column are assigned patterns-     shapes by cycling through <code>pattern_shape_sequence</code> in the order     described in <code>category_orders</code>, unless the value of <code>pattern_shape</code> is     a key in <code>pattern_shape_map</code>. pattern_shape_map: dict with str keys and str values (default <code>{}</code>)     Strings values define plotly.js patterns-shapes. Used to override     <code>pattern_shape_sequences</code> to assign a specific patterns-shapes to lines     corresponding with specific values. Keys in <code>pattern_shape_map</code> should     be values in the column denoted by <code>pattern_shape</code>. Alternatively, if     the values of <code>pattern_shape</code> are valid patterns-shapes names, the     string <code>'identity'</code> may be passed to cause them to be used directly. range_color: list of two numbers     If provided, overrides auto-scaling on the continuous color scale. color_continuous_midpoint: number (default <code>None</code>)     If set, computes the bounds of the continuous color scale to have the     desired midpoint. Setting this value is recommended when using     <code>plotly.express.colors.diverging</code> color scales as the inputs to     <code>color_continuous_scale</code>. opacity: float     Value between 0 and 1. Sets the opacity for markers. orientation: str, one of <code>'h'</code> for horizontal or <code>'v'</code> for vertical.     (default <code>'v'</code> if <code>x</code> and <code>y</code> are provided and both continuous or both     categorical,  otherwise <code>'v'</code>(<code>'h'</code>) if <code>x</code>(<code>y</code>) is categorical and     <code>y</code>(<code>x</code>) is continuous,  otherwise <code>'v'</code>(<code>'h'</code>) if only <code>x</code>(<code>y</code>) is     provided) barmode: str (default <code>'relative'</code>)     One of <code>'group'</code>, <code>'overlay'</code> or <code>'relative'</code> In <code>'relative'</code> mode,     bars are stacked above zero for positive values and below zero for     negative values. In <code>'overlay'</code> mode, bars are drawn on top of one     another. In <code>'group'</code> mode, bars are placed beside each other. log_x: boolean (default <code>False</code>)     If <code>True</code>, the x-axis is log-scaled in cartesian coordinates. log_y: boolean (default <code>False</code>)     If <code>True</code>, the y-axis is log-scaled in cartesian coordinates. range_x: list of two numbers     If provided, overrides auto-scaling on the x-axis in cartesian     coordinates. range_y: list of two numbers     If provided, overrides auto-scaling on the y-axis in cartesian     coordinates. text_auto: bool or string (default <code>False</code>)     If <code>True</code> or a string, the x or y or z values will be displayed as     text, depending on the orientation A string like <code>'.2f'</code> will be     interpreted as a <code>texttemplate</code> numeric formatting directive. template: str or dict or plotly.graph_objects.layout.Template instance     The figure template name (must be a key in plotly.io.templates) or     definition.</p> <code>{}</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>leafmap/plot.py</code> <pre><code>def line_chart(\n    data=None,\n    x=None,\n    y=None,\n    color=None,\n    descending=None,\n    max_rows=None,\n    x_label=None,\n    y_label=None,\n    title=None,\n    legend_title=None,\n    width=None,\n    height=500,\n    layout_args={},\n    **kwargs,\n):\n    \"\"\"Create a line chart with plotly.express,\n\n    Args:\n        data: DataFrame | array-like | dict | str (local file path or HTTP URL)\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        x: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the x axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        y: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            position marks along the y axis in cartesian coordinates. Either `x` or\n            `y` can optionally be a list of column references or array_likes,  in\n            which case the data will be treated as if it were 'wide' rather than\n            'long'.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to None.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        x_label (str, optional): Label for the x axis. Defaults to None.\n        y_label (str, optional): Label for the y axis. Defaults to None.\n        title (str, optional): Title for the plot. Defaults to None.\n        legend_title (str, optional): Title for the legend. Defaults to None.\n        width (int, optional): Width of the plot in pixels. Defaults to None.\n        height (int, optional): Height of the plot in pixels. Defaults to 500.\n        layout_args (dict, optional): Layout arguments for the plot to be passed to fig.update_layout(),\n            such as {'title':'Plot Title', 'title_x':0.5}. Defaults to None.\n        **kwargs: Any additional arguments to pass to plotly.express.bar(), such as:\n\n            pattern_shape: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign pattern shapes to marks.\n            facet_row: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the vertical direction.\n            facet_col: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to facetted subplots in the horizontal direction.\n            facet_col_wrap: int\n                Maximum number of facet columns. Wraps the column variable at this\n                width, so that the column facets span multiple rows. Ignored if 0, and\n                forced to 0 if `facet_row` or a `marginal` is set.\n            facet_row_spacing: float between 0 and 1\n                Spacing between facet rows, in paper units. Default is 0.03 or 0.0.7\n                when facet_col_wrap is used.\n            facet_col_spacing: float between 0 and 1\n                Spacing between facet columns, in paper units Default is 0.02.\n            hover_name: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in bold\n                in the hover tooltip.\n            hover_data: list of str or int, or Series or array-like, or dict\n                Either a list of names of columns in `data_frame`, or pandas Series, or\n                array_like objects or a dict with column names as keys, with values\n                True (for default formatting) False (in order to remove this column\n                from hover information), or a formatting string, for example ':.3f' or\n                '|%a' or list-like data to appear in the hover tooltip or tuples with a\n                bool or formatting string as first element, and list-like data to\n                appear in hover as second element Values from these columns appear as\n                extra data in the hover tooltip.\n            custom_data: list of str or int, or Series or array-like\n                Either names of columns in `data_frame`, or pandas Series, or\n                array_like objects Values from these columns are extra data, to be used\n                in widgets or Dash callbacks for example. This data is not user-visible\n                but is included in events emitted by the figure (lasso selection etc.)\n            text: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like appear in the\n                figure as text labels.\n            base: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                position the base of the bar.\n            error_x: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars. If `error_x_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_x` is used for the positive direction\n                only.\n            error_x_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size x-axis error bars in the negative direction. Ignored if `error_x`\n                is `None`.\n            error_y: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars. If `error_y_minus` is `None`, error bars will\n                be symmetrical, otherwise `error_y` is used for the positive direction\n                only.\n            error_y_minus: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                size y-axis error bars in the negative direction. Ignored if `error_y`\n                is `None`.\n            animation_frame: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                assign marks to animation frames.\n            animation_group: str or int or Series or array-like\n                Either a name of a column in `data_frame`, or a pandas Series or\n                array_like object. Values from this column or array_like are used to\n                provide object-constancy across animation frames: rows with matching\n                `animation_group`s will be treated as if they describe the same object\n                in each frame.\n            category_orders: dict with str keys and list of str values (default `{}`)\n                By default, in Python 3.6+, the order of categorical values in axes,\n                legends and facets depends on the order in which these values are first\n                encountered in `data_frame` (and no order is guaranteed by default in\n                Python below 3.6). This parameter is used to force a specific ordering\n                of values per column. The keys of this dict should correspond to column\n                names, and the values should be lists of strings corresponding to the\n                specific display order desired.\n            labels: dict with str keys and str values (default `{}`)\n                By default, column names are used in the figure for axis titles, legend\n                entries and hovers. This parameter allows this to be overridden. The\n                keys of this dict should correspond to column names, and the values\n                should correspond to the desired label to be displayed.\n            color_discrete_sequence: list of str\n                Strings should define valid CSS-colors. When `color` is set and the\n                values in the corresponding column are not numeric, values in that\n                column are assigned colors by cycling through `color_discrete_sequence`\n                in the order described in `category_orders`, unless the value of\n                `color` is a key in `color_discrete_map`. Various useful color\n                sequences are available in the `plotly.express.colors` submodules,\n                specifically `plotly.express.colors.qualitative`.\n            color_discrete_map: dict with str keys and str values (default `{}`)\n                String values should define valid CSS-colors Used to override\n                `color_discrete_sequence` to assign a specific colors to marks\n                corresponding with specific values. Keys in `color_discrete_map` should\n                be values in the column denoted by `color`. Alternatively, if the\n                values of `color` are valid colors, the string `'identity'` may be\n                passed to cause them to be used directly.\n            color_continuous_scale: list of str\n                Strings should define valid CSS-colors This list is used to build a\n                continuous color scale when the column denoted by `color` contains\n                numeric data. Various useful color scales are available in the\n                `plotly.express.colors` submodules, specifically\n                `plotly.express.colors.sequential`, `plotly.express.colors.diverging`\n                and `plotly.express.colors.cyclical`.\n            pattern_shape_sequence: list of str\n                Strings should define valid plotly.js patterns-shapes. When\n                `pattern_shape` is set, values in that column are assigned patterns-\n                shapes by cycling through `pattern_shape_sequence` in the order\n                described in `category_orders`, unless the value of `pattern_shape` is\n                a key in `pattern_shape_map`.\n            pattern_shape_map: dict with str keys and str values (default `{}`)\n                Strings values define plotly.js patterns-shapes. Used to override\n                `pattern_shape_sequences` to assign a specific patterns-shapes to lines\n                corresponding with specific values. Keys in `pattern_shape_map` should\n                be values in the column denoted by `pattern_shape`. Alternatively, if\n                the values of `pattern_shape` are valid patterns-shapes names, the\n                string `'identity'` may be passed to cause them to be used directly.\n            range_color: list of two numbers\n                If provided, overrides auto-scaling on the continuous color scale.\n            color_continuous_midpoint: number (default `None`)\n                If set, computes the bounds of the continuous color scale to have the\n                desired midpoint. Setting this value is recommended when using\n                `plotly.express.colors.diverging` color scales as the inputs to\n                `color_continuous_scale`.\n            opacity: float\n                Value between 0 and 1. Sets the opacity for markers.\n            orientation: str, one of `'h'` for horizontal or `'v'` for vertical.\n                (default `'v'` if `x` and `y` are provided and both continuous or both\n                categorical,  otherwise `'v'`(`'h'`) if `x`(`y`) is categorical and\n                `y`(`x`) is continuous,  otherwise `'v'`(`'h'`) if only `x`(`y`) is\n                provided)\n            barmode: str (default `'relative'`)\n                One of `'group'`, `'overlay'` or `'relative'` In `'relative'` mode,\n                bars are stacked above zero for positive values and below zero for\n                negative values. In `'overlay'` mode, bars are drawn on top of one\n                another. In `'group'` mode, bars are placed beside each other.\n            log_x: boolean (default `False`)\n                If `True`, the x-axis is log-scaled in cartesian coordinates.\n            log_y: boolean (default `False`)\n                If `True`, the y-axis is log-scaled in cartesian coordinates.\n            range_x: list of two numbers\n                If provided, overrides auto-scaling on the x-axis in cartesian\n                coordinates.\n            range_y: list of two numbers\n                If provided, overrides auto-scaling on the y-axis in cartesian\n                coordinates.\n            text_auto: bool or string (default `False`)\n                If `True` or a string, the x or y or z values will be displayed as\n                text, depending on the orientation A string like `'.2f'` will be\n                interpreted as a `texttemplate` numeric formatting directive.\n            template: str or dict or plotly.graph_objects.layout.Template instance\n                The figure template name (must be a key in plotly.io.templates) or\n                definition.\n\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None:\n        data.sort_values([y, x], ascending=not (descending), inplace=True)\n\n    if isinstance(max_rows, int):\n        data = data.head(max_rows)\n\n    if \"labels\" in kwargs:\n        labels = kwargs[\"labels\"]\n        kwargs.pop(\"labels\")\n    else:\n        labels = {}\n\n    if x_label is not None:\n        labels[x] = x_label\n    if y_label is not None:\n        labels[y] = y_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.line(\n            data,\n            x=x,\n            y=y,\n            color=color,\n            labels=labels,\n            title=title,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise ValueError(f\"Could not create bar plot. {e}\")\n</code></pre>"},{"location":"plot/#leafmap.plot.pie_chart","title":"<code>pie_chart(data, names=None, values=None, descending=True, max_rows=None, other_label=None, color=None, color_discrete_sequence=None, color_discrete_map=None, hover_name=None, hover_data=None, custom_data=None, labels=None, title=None, legend_title=None, template=None, width=None, height=None, opacity=None, hole=None, layout_args={}, **kwargs)</code>","text":"<p>Create a plotly pie chart.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>DataFrame or array-like or dict This argument needs to be passed for column names (and not keyword names) to be used. Array-like and dict are transformed internally to a pandas DataFrame. Optional: if missing, a DataFrame gets constructed under the hood using the other arguments.</p> required <code>names</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used as labels for sectors.</p> <code>None</code> <code>values</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to set values associated to sectors.</p> <code>None</code> <code>descending</code> <code>bool</code> <p>Whether to sort the data in descending order. Defaults to True.</p> <code>True</code> <code>max_rows</code> <code>int</code> <p>Maximum number of rows to display. Defaults to None.</p> <code>None</code> <code>other_label</code> <code>str</code> <p>Label for the \"other\" category. Defaults to None.</p> <code>None</code> <code>color</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like are used to assign color to marks.</p> <code>None</code> <code>color_discrete_sequence</code> <p>list of str Strings should define valid CSS-colors. When <code>color</code> is set and the values in the corresponding column are not numeric, values in that column are assigned colors by cycling through <code>color_discrete_sequence</code> in the order described in <code>category_orders</code>, unless the value of <code>color</code> is a key in <code>color_discrete_map</code>. Various useful color sequences are available in the <code>plotly.express.colors</code> submodules, specifically <code>plotly.express.colors.qualitative</code>.</p> <code>None</code> <code>color_discrete_map</code> <p>dict with str keys and str values (default <code>{}</code>) String values should define valid CSS-colors Used to override <code>color_discrete_sequence</code> to assign a specific colors to marks corresponding with specific values. Keys in <code>color_discrete_map</code> should be values in the column denoted by <code>color</code>. Alternatively, if the values of <code>color</code> are valid colors, the string <code>'identity'</code> may be passed to cause them to be used directly.</p> <code>None</code> <code>hover_name</code> <p>str or int or Series or array-like Either a name of a column in <code>data_frame</code>, or a pandas Series or array_like object. Values from this column or array_like appear in bold in the hover tooltip.</p> <code>None</code> <code>hover_data</code> <p>list of str or int, or Series or array-like, or dict Either a list of names of columns in <code>data_frame</code>, or pandas Series, or array_like objects or a dict with column names as keys, with values True (for default formatting) False (in order to remove this column from hover information), or a formatting string, for example ':.3f' or '|%a' or list-like data to appear in the hover tooltip or tuples with a bool or formatting string as first element, and list-like data to appear in hover as second element Values from these columns appear as extra data in the hover tooltip.</p> <code>None</code> <code>custom_data</code> <p>list of str or int, or Series or array-like Either names of columns in <code>data_frame</code>, or pandas Series, or array_like objects Values from these columns are extra data, to be used in widgets or Dash callbacks for example. This data is not user-visible but is included in events emitted by the figure (lasso selection etc.)</p> <code>None</code> <code>labels</code> <p>dict with str keys and str values (default <code>{}</code>) By default, column names are used in the figure for axis titles, legend entries and hovers. This parameter allows this to be overridden. The keys of this dict should correspond to column names, and the values should correspond to the desired label to be displayed.</p> <code>None</code> <code>title</code> <p>str The figure title.</p> <code>None</code> <code>template</code> <p>str or dict or plotly.graph_objects.layout.Template instance The figure template name (must be a key in plotly.io.templates) or definition.</p> <code>None</code> <code>width</code> <p>int (default <code>None</code>) The figure width in pixels.</p> <code>None</code> <code>height</code> <p>int (default <code>None</code>) The figure height in pixels.</p> <code>None</code> <code>opacity</code> <p>float Value between 0 and 1. Sets the opacity for markers.</p> <code>None</code> <code>hole</code> <p>float Sets the fraction of the radius to cut out of the pie.Use this to make a donut chart.</p> <code>None</code> <p>Returns:</p> Type Description <code>plotly.graph_objs._figure.Figure</code> <p>A plotly figure object.</p> Source code in <code>leafmap/plot.py</code> <pre><code>def pie_chart(\n    data,\n    names=None,\n    values=None,\n    descending=True,\n    max_rows=None,\n    other_label=None,\n    color=None,\n    color_discrete_sequence=None,\n    color_discrete_map=None,\n    hover_name=None,\n    hover_data=None,\n    custom_data=None,\n    labels=None,\n    title=None,\n    legend_title=None,\n    template=None,\n    width=None,\n    height=None,\n    opacity=None,\n    hole=None,\n    layout_args={},\n    **kwargs,\n):\n    \"\"\"Create a plotly pie chart.\n\n    Args:\n        data: DataFrame or array-like or dict\n            This argument needs to be passed for column names (and not keyword\n            names) to be used. Array-like and dict are transformed internally to a\n            pandas DataFrame. Optional: if missing, a DataFrame gets constructed\n            under the hood using the other arguments.\n        names: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used as\n            labels for sectors.\n        values: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            set values associated to sectors.\n        descending (bool, optional): Whether to sort the data in descending order. Defaults to True.\n        max_rows (int, optional): Maximum number of rows to display. Defaults to None.\n        other_label (str, optional): Label for the \"other\" category. Defaults to None.\n        color: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like are used to\n            assign color to marks.\n        color_discrete_sequence: list of str\n            Strings should define valid CSS-colors. When `color` is set and the\n            values in the corresponding column are not numeric, values in that\n            column are assigned colors by cycling through `color_discrete_sequence`\n            in the order described in `category_orders`, unless the value of\n            `color` is a key in `color_discrete_map`. Various useful color\n            sequences are available in the `plotly.express.colors` submodules,\n            specifically `plotly.express.colors.qualitative`.\n        color_discrete_map: dict with str keys and str values (default `{}`)\n            String values should define valid CSS-colors Used to override\n            `color_discrete_sequence` to assign a specific colors to marks\n            corresponding with specific values. Keys in `color_discrete_map` should\n            be values in the column denoted by `color`. Alternatively, if the\n            values of `color` are valid colors, the string `'identity'` may be\n            passed to cause them to be used directly.\n        hover_name: str or int or Series or array-like\n            Either a name of a column in `data_frame`, or a pandas Series or\n            array_like object. Values from this column or array_like appear in bold\n            in the hover tooltip.\n        hover_data: list of str or int, or Series or array-like, or dict\n            Either a list of names of columns in `data_frame`, or pandas Series, or\n            array_like objects or a dict with column names as keys, with values\n            True (for default formatting) False (in order to remove this column\n            from hover information), or a formatting string, for example ':.3f' or\n            '|%a' or list-like data to appear in the hover tooltip or tuples with a\n            bool or formatting string as first element, and list-like data to\n            appear in hover as second element Values from these columns appear as\n            extra data in the hover tooltip.\n        custom_data: list of str or int, or Series or array-like\n            Either names of columns in `data_frame`, or pandas Series, or\n            array_like objects Values from these columns are extra data, to be used\n            in widgets or Dash callbacks for example. This data is not user-visible\n            but is included in events emitted by the figure (lasso selection etc.)\n        labels: dict with str keys and str values (default `{}`)\n            By default, column names are used in the figure for axis titles, legend\n            entries and hovers. This parameter allows this to be overridden. The\n            keys of this dict should correspond to column names, and the values\n            should correspond to the desired label to be displayed.\n        title: str\n            The figure title.\n        template: str or dict or plotly.graph_objects.layout.Template instance\n            The figure template name (must be a key in plotly.io.templates) or\n            definition.\n        width: int (default `None`)\n            The figure width in pixels.\n        height: int (default `None`)\n            The figure height in pixels.\n        opacity: float\n            Value between 0 and 1. Sets the opacity for markers.\n        hole: float\n            Sets the fraction of the radius to cut out of the pie.Use this to make\n            a donut chart.\n\n    Returns:\n        plotly.graph_objs._figure.Figure: A plotly figure object.\n    \"\"\"\n    if isinstance(data, str):\n        if data.startswith(\"http\"):\n            data = github_raw_url(data)\n            data = get_direct_url(data)\n\n        try:\n            data = pd.read_csv(data)\n        except Exception as e:\n            raise ValueError(f\"Could not read data from {data}. {e}\")\n\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\n            \"data must be a pandas DataFrame, a string or an ee.FeatureCollection.\"\n        )\n\n    if descending is not None and isinstance(values, str):\n        data.sort_values([values], ascending=not (descending), inplace=True)\n\n    if other_label is None:\n        other_label = \"Other\"\n\n    if max_rows is not None and isinstance(names, str) and isinstance(values, str):\n        max_rows = min(len(data), max_rows) - 2\n        value = data.iloc[max_rows][values]\n        data.loc[data[values] &lt; value, names] = other_label\n\n    if isinstance(legend_title, str):\n        if \"legend\" not in layout_args:\n            layout_args[\"legend\"] = {}\n        layout_args[\"legend\"][\"title\"] = legend_title\n\n    try:\n        fig = px.pie(\n            data_frame=data,\n            names=names,\n            values=values,\n            color=color,\n            color_discrete_sequence=color_discrete_sequence,\n            color_discrete_map=color_discrete_map,\n            hover_name=hover_name,\n            hover_data=hover_data,\n            custom_data=custom_data,\n            labels=labels,\n            title=title,\n            template=template,\n            width=width,\n            height=height,\n            opacity=opacity,\n            hole=hole,\n            **kwargs,\n        )\n\n        if isinstance(layout_args, dict):\n            fig.update_layout(**layout_args)\n\n        return fig\n    except Exception as e:\n        raise Exception(f\"Could not create pie chart. {e}\")\n</code></pre>"},{"location":"plotlymap/","title":"plotlymap module","text":""},{"location":"plotlymap/#leafmap.plotlymap.Canvas","title":"<code> Canvas        </code>","text":"<p>The widgets.HBox containing the map and a toolbar.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>class Canvas:\n    \"\"\"The widgets.HBox containing the map and a toolbar.\"\"\"\n\n    def __init__(\n        self,\n        map,\n        map_min_width: Optional[str] = \"90%\",\n        map_max_width: Optional[str] = \"98%\",\n        map_refresh: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize the Canvas.\n\n        Args:\n            map (go.FigureWidget): The map to display.\n            map_min_width (str, optional): The minimum width of the map. Defaults to '90%'.\n            map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n            map_refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n        \"\"\"\n        from .toolbar import plotly_toolbar\n\n        map_widget = widgets.Output(layout=widgets.Layout(width=map_max_width))\n        with map_widget:\n            display(map)\n\n        self.map = map\n        self.map_min_width = map_min_width\n        self.map_max_width = map_max_width\n        self.map_refresh = map_refresh\n        self.map_widget = map_widget\n\n        container_widget = widgets.VBox()\n        self.container_widget = container_widget\n\n        toolbar_widget = plotly_toolbar(self)\n        sidebar_widget = widgets.VBox([toolbar_widget, container_widget])\n        canvas = widgets.HBox([map_widget, sidebar_widget])\n\n        self.canvas = canvas\n        self.toolbar_widget = toolbar_widget\n\n    def toolbar_reset(self):\n        \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n        if hasattr(self, \"toolbar\"):\n            toolbar_grid = self.toolbar\n            for tool in toolbar_grid.children:\n                tool.value = False\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Canvas.__init__","title":"<code>__init__(self, map, map_min_width='90%', map_max_width='98%', map_refresh=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the Canvas.</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>go.FigureWidget</code> <p>The map to display.</p> required <code>map_min_width</code> <code>str</code> <p>The minimum width of the map. Defaults to '90%'.</p> <code>'90%'</code> <code>map_max_width</code> <code>str</code> <p>The maximum width of the map. Defaults to '98%'.</p> <code>'98%'</code> <code>map_refresh</code> <code>bool</code> <p>Whether to refresh the map when the map is resized. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def __init__(\n    self,\n    map,\n    map_min_width: Optional[str] = \"90%\",\n    map_max_width: Optional[str] = \"98%\",\n    map_refresh: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Initialize the Canvas.\n\n    Args:\n        map (go.FigureWidget): The map to display.\n        map_min_width (str, optional): The minimum width of the map. Defaults to '90%'.\n        map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n        map_refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n    \"\"\"\n    from .toolbar import plotly_toolbar\n\n    map_widget = widgets.Output(layout=widgets.Layout(width=map_max_width))\n    with map_widget:\n        display(map)\n\n    self.map = map\n    self.map_min_width = map_min_width\n    self.map_max_width = map_max_width\n    self.map_refresh = map_refresh\n    self.map_widget = map_widget\n\n    container_widget = widgets.VBox()\n    self.container_widget = container_widget\n\n    toolbar_widget = plotly_toolbar(self)\n    sidebar_widget = widgets.VBox([toolbar_widget, container_widget])\n    canvas = widgets.HBox([map_widget, sidebar_widget])\n\n    self.canvas = canvas\n    self.toolbar_widget = toolbar_widget\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Canvas.toolbar_reset","title":"<code>toolbar_reset(self)</code>","text":"<p>Reset the toolbar so that no tool is selected.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def toolbar_reset(self):\n    \"\"\"Reset the toolbar so that no tool is selected.\"\"\"\n    if hasattr(self, \"toolbar\"):\n        toolbar_grid = self.toolbar\n        for tool in toolbar_grid.children:\n            tool.value = False\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map","title":"<code> Map            (FigureWidget)         </code>","text":"<p>The Map class inherits the Plotly FigureWidget class. More info at https://plotly.com/python/figurewidget.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>class Map(go.FigureWidget):\n    \"\"\"The Map class inherits the Plotly FigureWidget class. More info at https://plotly.com/python/figurewidget.\"\"\"\n\n    def __init__(\n        self,\n        center: Optional[Tuple[float, float]] = (20, 0),\n        zoom: Optional[float] = 1,\n        basemap: Optional[str] = \"open-street-map\",\n        height: Optional[int] = 600,\n        **kwargs,\n    ):\n        \"\"\"Initializes a map. More info at https://plotly.com/python/mapbox-layers/\n\n        Args:\n            center (tuple, optional): Center of the map. Defaults to (20, 0).\n            zoom (float, optional): Zoom level of the map. Defaults to 1.\n            basemap (str, optional): Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.\n            height (int, optional): Height of the map. Defaults to 600.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.add_scattermapbox()\n        self.update_layout(\n            {\n                \"mapbox\": {\n                    \"style\": basemap,\n                    \"center\": {\"lat\": center[0], \"lon\": center[1]},\n                    \"zoom\": zoom,\n                },\n                \"margin\": {\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n                \"height\": height,\n            }\n        )\n\n    def show(\n        self,\n        toolbar: Optional[bool] = True,\n        map_min_width: Optional[str] = \"91%\",\n        map_max_width: Optional[str] = \"98%\",\n        refresh: Optional[bool] = False,\n        **kwargs,\n    ):\n        \"\"\"Shows the map.\n\n        Args:\n            toolbar (bool, optional): Whether to show the toolbar. Defaults to True.\n            map_min_width (str, optional): The minimum width of the map. Defaults to '91%'.\n            map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n            refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n\n        Returns:\n            Canvas: Map canvas.\n        \"\"\"\n        if not toolbar:\n            super().show(**kwargs)\n        else:\n            canvas = Canvas(\n                self,\n                map_min_width=map_min_width,\n                map_max_width=map_max_width,\n                map_refresh=refresh,\n            )\n            return canvas.canvas\n\n    def clear_controls(self):\n        \"\"\"Removes all controls from the map.\"\"\"\n        config = {\n            \"scrollZoom\": True,\n            \"displayModeBar\": False,\n            \"editable\": True,\n            \"showLink\": False,\n            \"displaylogo\": False,\n        }\n        self.show(toolbar=False, config=config)\n\n    def add_controls(self, controls: List):\n        \"\"\"Adds controls to the map.\n\n        Args:\n            controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n            )\n\n        self.update_layout(modebar_add=controls)\n\n    def remove_controls(self, controls: List):\n        \"\"\"Removes controls to the map.\n\n        Args:\n            controls (list): List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/3Jk7wkb\"\n            )\n\n        self.update_layout(modebar_remove=controls)\n\n    def set_center(self, lat: float, lon: float, zoom: Optional[float] = None):\n        \"\"\"Sets the center of the map.\n\n        Args:\n            lat (float): Latitude.\n            lon (float): Longitude.\n            zoom (int, optional): Zoom level of the map. Defaults to None.\n        \"\"\"\n        self.update_layout(\n            mapbox=dict(\n                center=dict(lat=lat, lon=lon),\n                zoom=zoom if zoom is not None else self.layout.mapbox.zoom,\n            )\n        )\n\n    def add_basemap(self, basemap: Optional[str] = \"ROADMAP\"):\n        \"\"\"Adds a basemap to the map.\n\n        Args:\n            basemap (str, optional): Can be one of string from basemaps. Defaults to 'ROADMAP'.\n        \"\"\"\n        if basemap not in basemaps:\n            raise ValueError(\n                f\"Basemap {basemap} not found. Choose from {','.join(basemaps.keys())}\"\n            )\n\n        if basemap in self.get_tile_layers():\n            self.remove_basemap(basemap)\n        layers = list(self.layout.mapbox.layers) + [basemaps[basemap]]\n        self.update_layout(mapbox_layers=layers)\n\n    def remove_basemap(self, name: str):\n        \"\"\"Removes a basemap from the map.\n\n        Args:\n            name (str): Name of the basemap to remove.\n        \"\"\"\n        layers = list(self.layout.mapbox.layers)\n        layers = [layer for layer in layers if layer[\"name\"] != name]\n        self.layout.mapbox.layers = layers\n\n    def add_mapbox_layer(self, style: Union[str, Dict], access_token=None):\n        \"\"\"Adds a mapbox layer to the map.\n\n        Args:\n            layer (str | dict): Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/\n            access_token (str, optional): The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.\n        \"\"\"\n\n        if access_token is None:\n            access_token = os.environ.get(\"MAPBOX_TOKEN\")\n\n        self.update_layout(\n            mapbox_style=style, mapbox_layers=[], mapbox_accesstoken=access_token\n        )\n\n    def add_layer(self, layer, name: Optional[str] = None, **kwargs):\n        \"\"\"Adds a layer to the map.\n\n        Args:\n            layer (plotly.graph_objects): Layer to add.\n            name (str, optional): Name of the layer. Defaults to None.\n        \"\"\"\n        if isinstance(name, str):\n            layer.name = name\n        self.add_trace(layer, **kwargs)\n\n    def remove_layer(self, name: str):\n        \"\"\"Removes a layer from the map.\n\n        Args:\n            name (str): Name of the layer to remove.\n        \"\"\"\n        if name in self.get_data_layers():\n            self.data = [layer for layer in self.data if layer.name != name]\n        elif name in self.get_tile_layers():\n            self.layout.mapbox.layers = [\n                layer for layer in self.layout.mapbox.layers if layer[\"name\"] != name\n            ]\n\n    def clear_layers(self, clear_basemap: Optional[bool] = False):\n        \"\"\"Clears all layers from the map.\n\n        Args:\n            clear_basemap (bool, optional): If True, clears the basemap. Defaults to False.\n        \"\"\"\n        if clear_basemap:\n            self.data = []\n        else:\n            if len(self.data) &gt; 1:\n                self.data = self.data[:1]\n\n    def get_layers(self) -&gt; Dict:\n        \"\"\"Returns a dictionary of all layers in the map.\n        Returns:\n            dict: A dictionary of all layers in the map.\n        \"\"\"\n        layers = {}\n\n        for layer in self.layout.mapbox.layers:\n            if layer[\"name\"] is not None:\n                layers[layer[\"name\"]] = layer\n\n        for layer in self.data:\n            if layer.name is not None and layer.name != \"trace 0\":\n                layers[layer.name] = layer\n\n        return layers\n\n    def get_tile_layers(self) -&gt; Dict:\n        \"\"\"Returns a dictionary of tile layers in the map.\n\n        Returns:\n            dict: A dictionary of tile layers in the map.\n        \"\"\"\n\n        layers = {}\n\n        for layer in self.layout.mapbox.layers:\n            if layer[\"name\"] is not None:\n                layers[layer[\"name\"]] = layer\n\n        return layers\n\n    def get_data_layers(self) -&gt; Dict:\n        \"\"\"Returns a dictionary of data layers in the map.\n\n        Returns:\n            dict: A dictionary of data layers in the map.\n        \"\"\"\n\n        layers = {}\n\n        for layer in self.data:\n            if layer.name is not None and layer.name != \"trace 0\":\n                layers[layer.name] = layer\n\n        return layers\n\n    def find_layer_index(self, name: str) -&gt; int:\n        \"\"\"Finds the index of a layer.\n\n        Args:\n            name (str): Name of the layer to find.\n\n        Returns:\n            int: Index of the layer.\n        \"\"\"\n        for i, layer in enumerate(self.data):\n            if layer.name == name:\n                return i\n\n        for i, layer in enumerate(self.layout.mapbox.layers):\n            if layer[\"name\"] == name:\n                return i\n\n        return None\n\n    def set_layer_visibility(self, name: str, show: Optional[bool] = True):\n        \"\"\"Sets the visibility of a layer.\n\n        Args:\n            name (str): Name of the layer to set.\n            show (bool, optional): If True, shows the layer. Defaults to True.\n        \"\"\"\n\n        if name in self.get_tile_layers():\n            index = self.find_layer_index(name)\n            self.layout.mapbox.layers[index].visible = show\n        elif name in self.get_data_layers():\n            index = self.find_layer_index(name)\n            self.data[index].visible = show\n        else:\n            print(f\"Layer {name} not found.\")\n\n    def set_layer_opacity(self, name: str, opacity: Optional[float] = 1):\n        \"\"\"Sets the visibility of a layer.\n\n        Args:\n            name (str): Name of the layer to set.\n            opacity (float, optional): Opacity of the layer. Defaults to 1.\n        \"\"\"\n\n        if name in self.get_tile_layers():\n            index = self.find_layer_index(name)\n            self.layout.mapbox.layers[index].opacity = opacity\n        elif name in self.get_data_layers():\n            index = self.find_layer_index(name)\n            layer = self.data[index]\n            if hasattr(layer, \"opacity\"):\n                layer.opacity = opacity\n            elif hasattr(layer, \"marker\"):\n                layer.marker.opacity = opacity\n        else:\n            print(f\"Layer {name} not found.\")\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = \"TileLayer\",\n        attribution: Optional[str] = \"\",\n        opacity: Optional[float] = 1.0,\n        **kwargs,\n    ):\n        \"\"\"Adds a TileLayer to the map.\n\n        Args:\n            url (str): The URL of the tile layer.\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n\n        layer = {\n            \"below\": \"traces\",\n            \"sourcetype\": \"raster\",\n            \"sourceattribution\": attribution,\n            \"source\": [url],\n            \"opacity\": opacity,\n            \"name\": name,\n        }\n        layers = list(self.layout.mapbox.layers) + [layer]\n        self.update_layout(mapbox_layers=layers)\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = \"Untitled\",\n        attribution: Optional[str] = \"\",\n        opacity: Optional[float] = 1.0,\n        bands: Optional[List] = None,\n        titiler_endpoint: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Adds a COG TileLayer to the map.\n\n        Args:\n            url (str): The URL of the COG tile layer, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n            name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n            bands (list, optional): The bands to use. Defaults to None.\n            titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n            **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n                color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n                and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n                apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n        \"\"\"\n        tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n        center = cog_center(url, titiler_endpoint)  # (lon, lat)\n        self.add_tile_layer(tile_url, name, attribution, opacity)\n        self.set_center(lon=center[0], lat=center[1], zoom=10)\n\n    def add_stac_layer(\n        self,\n        url: str = None,\n        collection: str = None,\n        items: str = None,\n        assets: str = None,\n        bands: List = None,\n        titiler_endpoint: Optional[str] = None,\n        name: Optional[str] = \"STAC Layer\",\n        attribution: Optional[str] = \"\",\n        opacity: Optional[float] = 1.0,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n            collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n            items (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n            assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n            bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        tile_url = stac_tile(\n            url, collection, item, assets, bands, titiler_endpoint, **kwargs\n        )\n        center = stac_center(url, collection, item, titiler_endpoint)\n        self.add_tile_layer(tile_url, name, attribution, opacity)\n        self.set_center(lon=center[0], lat=center[1], zoom=10)\n\n    def add_mosaic_layer(\n        self,\n        url: str,\n        titiler_endpoint: Optional[str] = None,\n        name: Optional[str] = \"Mosaic Layer\",\n        attribution: Optional[str] = \"\",\n        opacity: Optional[float] = 1.0,\n        **kwargs,\n    ):\n        \"\"\"Adds a STAC TileLayer to the map.\n\n        Args:\n            url (str): HTTP URL to a MosaicJSON.\n            titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n            name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n            attribution (str, optional): The attribution to use. Defaults to ''.\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n        center = mosaic_info(url, titiler_endpoint)[\"center\"]\n        self.add_tile_layer(tile_url, name, attribution, opacity)\n        self.set_center(lon=center[0], lat=center[1], zoom=10)\n\n    def add_planet_by_month(\n        self,\n        year: Optional[int] = 2016,\n        month: Optional[int] = 1,\n        api_key: Optional[str] = None,\n        token_name: Optional[str] = \"PLANET_API_KEY\",\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        opacity: Optional[float] = 1.0,\n    ):\n        \"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        if name is None:\n            name = str(year) + \"-\" + str(month).zfill(2)\n        tile_url = planet_by_month(year, month, api_key, token_name)\n        self.add_tile_layer(\n            tile_url, name=name, attribution=attribution, opacity=opacity\n        )\n\n    def add_planet_by_quarter(\n        self,\n        year: Optional[int] = 2016,\n        quarter: Optional[int] = 1,\n        api_key: Optional[str] = None,\n        token_name: Optional[str] = \"PLANET_API_KEY\",\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        opacity: Optional[float] = 1.0,\n    ):\n        \"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n        Args:\n            year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n            quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n            api_key (str, optional): The Planet API key. Defaults to None.\n            token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n            name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n            attribution (str): The attribution to use. Defaults to \"\".\n            opacity (float, optional): The opacity of the layer. Defaults to 1.\n        \"\"\"\n        if name is None:\n            name = str(year) + \"-\" + \"q\" + str(quarter)\n        tile_url = planet_by_quarter(year, quarter, api_key, token_name)\n        self.add_tile_layer(\n            tile_url, name=name, attribution=attribution, opacity=opacity\n        )\n\n    def save(\n        self,\n        file: str,\n        format: Optional[str] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        scale: Optional[int] = None,\n        **kwargs,\n    ):\n        \"\"\"Convert a map to a static image and write it to a file or writeable object\n\n        Args:\n            file (str): A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)\n            format (str, optional): The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.\n            width (int, optional): The width of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.\n            height (int, optional): The height of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.\n            scale (int, optional): The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.\n        \"\"\"\n        self.write_image(\n            file, format=format, width=width, height=height, scale=scale, **kwargs\n        )\n\n    def add_choropleth_map(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        z: Optional[str] = None,\n        colorscale: Optional[str] = \"Viridis\",\n        **kwargs,\n    ):\n        \"\"\"Adds a choropleth map to the map.\n\n        Args:\n            data (str): File path to vector data, e.g., https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\n            name (str, optional): Name of the layer. Defaults to None.\n            z (str, optional): Z value of the data. Defaults to None.\n            colorscale (str, optional): Color scale of the data. Defaults to \"Viridis\".\n        \"\"\"\n        check_package(\"geopandas\")\n        import json\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data).to_crs(epsg=4326)\n        geojson = json.loads(gdf.to_json())\n\n        self.add_choroplethmapbox(\n            geojson=geojson,\n            locations=gdf.index,\n            z=gdf[z],\n            name=name,\n            colorscale=colorscale,\n            **kwargs,\n        )\n\n    def add_scatter_plot_demo(self, **kwargs):\n        \"\"\"Adds a scatter plot to the map.\"\"\"\n        lons = np.random.random(1000) * 360.0\n        lats = np.random.random(1000) * 180.0 - 90.0\n        z = np.random.random(1000) * 50.0\n        self.add_scattermapbox(\n            lon=lons, lat=lats, marker={\"color\": z}, name=\"Random points\", **kwargs\n        )\n\n    def add_heatmap(\n        self,\n        data: Union[str, DataFrame],\n        latitude: Optional[str] = \"latitude\",\n        longitude: Optional[str] = \"longitude\",\n        z: Optional[str] = \"value\",\n        radius: Optional[int] = 10,\n        colorscale: Optional[str] = None,\n        name: Optional[str] = \"Heat map\",\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps\n\n        Args:\n            data (str | pd.DataFrame): File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            z (str, optional): The column name of z values. Defaults to \"value\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n            colorscale (str, optional): Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n\n        \"\"\"\n\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n        elif isinstance(data, pd.DataFrame):\n            df = data\n        else:\n            raise ValueError(\"data must be a DataFrame or a file path.\")\n\n        heatmap = go.Densitymapbox(\n            lat=df[latitude],\n            lon=df[longitude],\n            z=df[z],\n            radius=radius,\n            colorscale=colorscale,\n            name=name,\n            **kwargs,\n        )\n        self.add_trace(heatmap)\n\n    def add_heatmap_demo(self, **kwargs):\n        \"\"\"Adds a heatmap to the map.\"\"\"\n        quakes = pd.read_csv(\n            \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\"\n        )\n        heatmap = go.Densitymapbox(\n            lat=quakes.Latitude,\n            lon=quakes.Longitude,\n            z=quakes.Magnitude,\n            radius=10,\n            name=\"Earthquake\",\n            **kwargs,\n        )\n\n        self.add_basemap(\"Esri.WorldTopoMap\")\n        self.add_trace(heatmap)\n\n    def add_gdf_demo(\n        self,\n        gdf,\n        label_col: Optional[str],\n        color_col: Optional[str],\n        color_continuous_scale: Optional[str] = \"Viridis\",\n        **kwargs,\n    ):\n        check_package(\"geopandas\", \"https://geopandas.org\")\n        import geopandas as gpd\n\n        geojson_url = str(gdf)\n\n        if isinstance(gdf, str):\n            gdf = gpd.read_file(gdf).to_crs(epsg=4326)\n\n        fig = go.Choroplethmapbox(\n            geojson=geojson_url,\n            featureidkey=\"properties.{}\".format(label_col),\n            locations=gdf[label_col],\n            z=gdf[color_col],\n            autocolorscale=False,\n            colorscale=color_continuous_scale,\n            marker_line_color=\"peachpuff\",\n            colorbar=dict(\n                title={\"text\": \"Legend\"},\n                thickness=15,\n                len=0.35,\n                bgcolor=\"rgba(255,255,255,0.6)\",\n                xanchor=\"left\",\n                x=0.02,\n                yanchor=\"bottom\",\n                y=0.05,\n            ),\n        )\n        self.add_trace(fig)\n\n    def add_gdf(\n        self,\n        gdf,\n        label_col: Optional[str] = None,\n        color_col: Optional[str] = None,\n        labels=None,\n        opacity: Optional[float] = 1.0,\n        zoom: Optional[int] = None,\n        color_continuous_scale: Optional[str] = \"Viridis\",\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoDataFrame to the map.\n        Args:\n            gdf (GeoDataFrame): A GeoDataFrame.\n            label_col (str, optional): The column name of locations. Defaults to None.\n            color_col (str, optional): The column name of color. Defaults to None.\n        \"\"\"\n\n        check_package(\"geopandas\", \"https://geopandas.org\")\n        import geopandas as gpd\n\n        if isinstance(gdf, str):\n            gdf = gpd.read_file(gdf)\n\n        if not isinstance(gdf, gpd.GeoDataFrame):\n            raise ValueError(\"gdf must be a GeoDataFrame.\")\n\n        gdf = gdf.to_crs(epsg=4326)\n        # geom_type = gdf_geom_type(gdf)\n        center_lon, center_lat = gdf_centroid(gdf)\n\n        if isinstance(label_col, str):\n            gdf = gdf.set_index(label_col)\n            if label_col == color_col:\n                gdf[label_col] = gdf.index\n            label_col = gdf.index\n        elif label_col is None:\n            label_col = gdf.index\n\n        if isinstance(color_col, str):\n            if color_col not in gdf.columns:\n                raise ValueError(\n                    f\"color must be a column name in the GeoDataFrame. Can be one of {','.join(gdf.columns)} \"\n                )\n        fig = px.choropleth_mapbox(\n            gdf,\n            geojson=gdf.geometry,\n            locations=label_col,\n            color=color_col,\n            color_continuous_scale=color_continuous_scale,\n            opacity=opacity,\n            labels=labels,\n            # mapbox_style=\"carto-positron\",\n            **kwargs,\n        )\n\n        self.add_traces(fig.data)\n        self.set_center(center_lat, center_lon, zoom)\n\n    def add_geojson_layer(\n        self,\n        geojson_in: Union[str, Dict],\n        name: str,\n        color: Optional[str] = \"blue\",\n        opacity: Optional[float] = 1,\n    ):\n        \"\"\"Prepare proper and give style for different type of Geometry\n\n        Args:\n            in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n            name (str): Name for the Layer\n            color (str, optional): Plain name for color (e.g: blue) or color code (e.g: #FF0000)\n            opacity(float, optional): opacity of the layer in Map\n        \"\"\"\n\n        import json\n        import requests\n\n        if isinstance(geojson_in, dict):\n            data = geojson_in\n        elif geojson_in.startswith(\"http\"):\n            data = requests.get(geojson_in).json()\n        elif geojson_in.lower().endswith((\".json\", \".geojson\")):\n            with open(geojson_in) as fp:\n                data = json.load(fp)\n        else:\n            data = geojson_in\n\n        \"\"\" Only Checking Geometry of first feature( todo : handle multiple type of Geometry in same geojson ) \"\"\"\n        first_feature = data[\"features\"][0]\n        geometry_type = first_feature[\"geometry\"][\"type\"]\n\n        if geometry_type.lower() in [\"polygon\", \"multipolygon\"]:\n            type = \"fill\"\n        elif geometry_type.lower() in [\"linstring\", \"multilinestring\"]:\n            type = \"line\"\n        elif geometry_type.lower() in [\"point\", \"multipoint\"]:\n            type = \"circle\"\n        else:\n            type = \"fill\"\n\n        self.add_geojson(data, name, type, color, opacity)\n\n    def add_geojson(\n        self,\n        data: Dict,\n        name: str,\n        type: Optional[str],\n        color: Optional[str],\n        opacity: Optional[float],\n    ):\n        \"\"\"Add layers to the Map\n\n        Args:\n            data (dict): Geojson in Dict form\n            name (str): Name for the Layer\n            color (str, optional): Plain name for color (e.g: blue) or color code (e.g: #FF0000)\n            opacity(float, optional): opacity of the layer in Map\n        \"\"\"\n\n        new_layer = {\n            \"source\": data,\n            \"name\": name,\n            \"type\": type,\n            \"opacity\": opacity,\n            \"color\": color,\n        }\n        if type == \"circle\":\n            new_layer[\"circle\"] = {\"radius\": 5}\n        existing_layers = list(self.layout.mapbox.layers)\n\n        existing_layers.append(new_layer)\n\n        self.update_layout(mapbox={\"layers\": tuple(existing_layers)})\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.__init__","title":"<code>__init__(self, center=(20, 0), zoom=1, basemap='open-street-map', height=600, **kwargs)</code>  <code>special</code>","text":"<p>Initializes a map. More info at https://plotly.com/python/mapbox-layers/</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Center of the map. Defaults to (20, 0).</p> <code>(20, 0)</code> <code>zoom</code> <code>float</code> <p>Zoom level of the map. Defaults to 1.</p> <code>1</code> <code>basemap</code> <code>str</code> <p>Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.</p> <code>'open-street-map'</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def __init__(\n    self,\n    center: Optional[Tuple[float, float]] = (20, 0),\n    zoom: Optional[float] = 1,\n    basemap: Optional[str] = \"open-street-map\",\n    height: Optional[int] = 600,\n    **kwargs,\n):\n    \"\"\"Initializes a map. More info at https://plotly.com/python/mapbox-layers/\n\n    Args:\n        center (tuple, optional): Center of the map. Defaults to (20, 0).\n        zoom (float, optional): Zoom level of the map. Defaults to 1.\n        basemap (str, optional): Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" . Defaults to 'open-street-map'.\n        height (int, optional): Height of the map. Defaults to 600.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.add_scattermapbox()\n    self.update_layout(\n        {\n            \"mapbox\": {\n                \"style\": basemap,\n                \"center\": {\"lat\": center[0], \"lon\": center[1]},\n                \"zoom\": zoom,\n            },\n            \"margin\": {\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0},\n            \"height\": height,\n        }\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_basemap","title":"<code>add_basemap(self, basemap='ROADMAP')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Can be one of string from basemaps. Defaults to 'ROADMAP'.</p> <code>'ROADMAP'</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_basemap(self, basemap: Optional[str] = \"ROADMAP\"):\n    \"\"\"Adds a basemap to the map.\n\n    Args:\n        basemap (str, optional): Can be one of string from basemaps. Defaults to 'ROADMAP'.\n    \"\"\"\n    if basemap not in basemaps:\n        raise ValueError(\n            f\"Basemap {basemap} not found. Choose from {','.join(basemaps.keys())}\"\n        )\n\n    if basemap in self.get_tile_layers():\n        self.remove_basemap(basemap)\n    layers = list(self.layout.mapbox.layers) + [basemaps[basemap]]\n    self.update_layout(mapbox_layers=layers)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_choropleth_map","title":"<code>add_choropleth_map(self, data, name=None, z=None, colorscale='Viridis', **kwargs)</code>","text":"<p>Adds a choropleth map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>File path to vector data, e.g., https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>Z value of the data. Defaults to None.</p> <code>None</code> <code>colorscale</code> <code>str</code> <p>Color scale of the data. Defaults to \"Viridis\".</p> <code>'Viridis'</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_choropleth_map(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    z: Optional[str] = None,\n    colorscale: Optional[str] = \"Viridis\",\n    **kwargs,\n):\n    \"\"\"Adds a choropleth map to the map.\n\n    Args:\n        data (str): File path to vector data, e.g., https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\n        name (str, optional): Name of the layer. Defaults to None.\n        z (str, optional): Z value of the data. Defaults to None.\n        colorscale (str, optional): Color scale of the data. Defaults to \"Viridis\".\n    \"\"\"\n    check_package(\"geopandas\")\n    import json\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data).to_crs(epsg=4326)\n    geojson = json.loads(gdf.to_json())\n\n    self.add_choroplethmapbox(\n        geojson=geojson,\n        locations=gdf.index,\n        z=gdf[z],\n        name=name,\n        colorscale=colorscale,\n        **kwargs,\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_cog_layer","title":"<code>add_cog_layer(self, url, name='Untitled', attribution='', opacity=1.0, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Adds a COG TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the COG tile layer, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Untitled'.</p> <code>'Untitled'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> <code>bands</code> <code>list</code> <p>The bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale, color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/ and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3]. apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = \"Untitled\",\n    attribution: Optional[str] = \"\",\n    opacity: Optional[float] = 1.0,\n    bands: Optional[List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Adds a COG TileLayer to the map.\n\n    Args:\n        url (str): The URL of the COG tile layer, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        name (str, optional): The layer name to use for the layer. Defaults to 'Untitled'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n        bands (list, optional): The bands to use. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        **kwargs: Arbitrary keyword arguments, including bidx, expression, nodata, unscale, resampling, rescale,\n            color_formula, colormap, colormap_name, return_mask. See https://developmentseed.org/titiler/endpoints/cog/\n            and https://cogeotiff.github.io/rio-tiler/colormap/. To select a certain bands, use bidx=[1, 2, 3].\n            apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n    \"\"\"\n    tile_url = cog_tile(url, bands, titiler_endpoint, **kwargs)\n    center = cog_center(url, titiler_endpoint)  # (lon, lat)\n    self.add_tile_layer(tile_url, name, attribution, opacity)\n    self.set_center(lon=center[0], lat=center[1], zoom=10)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_controls","title":"<code>add_controls(self, controls)</code>","text":"<p>Adds controls to the map.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>list</code> <p>List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_controls(self, controls: List):\n    \"\"\"Adds controls to the map.\n\n    Args:\n        controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n    \"\"\"\n    if isinstance(controls, str):\n        controls = [controls]\n    elif not isinstance(controls, list):\n        raise ValueError(\n            \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n        )\n\n    self.update_layout(modebar_add=controls)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_gdf","title":"<code>add_gdf(self, gdf, label_col=None, color_col=None, labels=None, opacity=1.0, zoom=None, color_continuous_scale='Viridis', **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>label_col</code> <code>str</code> <p>The column name of locations. Defaults to None.</p> <code>None</code> <code>color_col</code> <code>str</code> <p>The column name of color. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_gdf(\n    self,\n    gdf,\n    label_col: Optional[str] = None,\n    color_col: Optional[str] = None,\n    labels=None,\n    opacity: Optional[float] = 1.0,\n    zoom: Optional[int] = None,\n    color_continuous_scale: Optional[str] = \"Viridis\",\n    **kwargs,\n):\n    \"\"\"Adds a GeoDataFrame to the map.\n    Args:\n        gdf (GeoDataFrame): A GeoDataFrame.\n        label_col (str, optional): The column name of locations. Defaults to None.\n        color_col (str, optional): The column name of color. Defaults to None.\n    \"\"\"\n\n    check_package(\"geopandas\", \"https://geopandas.org\")\n    import geopandas as gpd\n\n    if isinstance(gdf, str):\n        gdf = gpd.read_file(gdf)\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise ValueError(\"gdf must be a GeoDataFrame.\")\n\n    gdf = gdf.to_crs(epsg=4326)\n    # geom_type = gdf_geom_type(gdf)\n    center_lon, center_lat = gdf_centroid(gdf)\n\n    if isinstance(label_col, str):\n        gdf = gdf.set_index(label_col)\n        if label_col == color_col:\n            gdf[label_col] = gdf.index\n        label_col = gdf.index\n    elif label_col is None:\n        label_col = gdf.index\n\n    if isinstance(color_col, str):\n        if color_col not in gdf.columns:\n            raise ValueError(\n                f\"color must be a column name in the GeoDataFrame. Can be one of {','.join(gdf.columns)} \"\n            )\n    fig = px.choropleth_mapbox(\n        gdf,\n        geojson=gdf.geometry,\n        locations=label_col,\n        color=color_col,\n        color_continuous_scale=color_continuous_scale,\n        opacity=opacity,\n        labels=labels,\n        # mapbox_style=\"carto-positron\",\n        **kwargs,\n    )\n\n    self.add_traces(fig.data)\n    self.set_center(center_lat, center_lon, zoom)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_geojson","title":"<code>add_geojson(self, data, name, type, color, opacity)</code>","text":"<p>Add layers to the Map</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Geojson in Dict form</p> required <code>name</code> <code>str</code> <p>Name for the Layer</p> required <code>color</code> <code>str</code> <p>Plain name for color (e.g: blue) or color code (e.g: #FF0000)</p> required <code>opacity(float,</code> <code>optional</code> <p>opacity of the layer in Map</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_geojson(\n    self,\n    data: Dict,\n    name: str,\n    type: Optional[str],\n    color: Optional[str],\n    opacity: Optional[float],\n):\n    \"\"\"Add layers to the Map\n\n    Args:\n        data (dict): Geojson in Dict form\n        name (str): Name for the Layer\n        color (str, optional): Plain name for color (e.g: blue) or color code (e.g: #FF0000)\n        opacity(float, optional): opacity of the layer in Map\n    \"\"\"\n\n    new_layer = {\n        \"source\": data,\n        \"name\": name,\n        \"type\": type,\n        \"opacity\": opacity,\n        \"color\": color,\n    }\n    if type == \"circle\":\n        new_layer[\"circle\"] = {\"radius\": 5}\n    existing_layers = list(self.layout.mapbox.layers)\n\n    existing_layers.append(new_layer)\n\n    self.update_layout(mapbox={\"layers\": tuple(existing_layers)})\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_geojson_layer","title":"<code>add_geojson_layer(self, geojson_in, name, color='blue', opacity=1)</code>","text":"<p>Prepare proper and give style for different type of Geometry</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The file path or http URL to the input GeoJSON or a dictionary containing the geojson.</p> required <code>name</code> <code>str</code> <p>Name for the Layer</p> required <code>color</code> <code>str</code> <p>Plain name for color (e.g: blue) or color code (e.g: #FF0000)</p> <code>'blue'</code> <code>opacity(float,</code> <code>optional</code> <p>opacity of the layer in Map</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_geojson_layer(\n    self,\n    geojson_in: Union[str, Dict],\n    name: str,\n    color: Optional[str] = \"blue\",\n    opacity: Optional[float] = 1,\n):\n    \"\"\"Prepare proper and give style for different type of Geometry\n\n    Args:\n        in_geojson (str | dict): The file path or http URL to the input GeoJSON or a dictionary containing the geojson.\n        name (str): Name for the Layer\n        color (str, optional): Plain name for color (e.g: blue) or color code (e.g: #FF0000)\n        opacity(float, optional): opacity of the layer in Map\n    \"\"\"\n\n    import json\n    import requests\n\n    if isinstance(geojson_in, dict):\n        data = geojson_in\n    elif geojson_in.startswith(\"http\"):\n        data = requests.get(geojson_in).json()\n    elif geojson_in.lower().endswith((\".json\", \".geojson\")):\n        with open(geojson_in) as fp:\n            data = json.load(fp)\n    else:\n        data = geojson_in\n\n    \"\"\" Only Checking Geometry of first feature( todo : handle multiple type of Geometry in same geojson ) \"\"\"\n    first_feature = data[\"features\"][0]\n    geometry_type = first_feature[\"geometry\"][\"type\"]\n\n    if geometry_type.lower() in [\"polygon\", \"multipolygon\"]:\n        type = \"fill\"\n    elif geometry_type.lower() in [\"linstring\", \"multilinestring\"]:\n        type = \"line\"\n    elif geometry_type.lower() in [\"point\", \"multipoint\"]:\n        type = \"circle\"\n    else:\n        type = \"fill\"\n\n    self.add_geojson(data, name, type, color, opacity)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', z='value', radius=10, colorscale=None, name='Heat map', **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>z</code> <code>str</code> <p>The column name of z values. Defaults to \"value\".</p> <code>'value'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>10</code> <code>colorscale</code> <code>str</code> <p>Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Union[str, DataFrame],\n    latitude: Optional[str] = \"latitude\",\n    longitude: Optional[str] = \"longitude\",\n    z: Optional[str] = \"value\",\n    radius: Optional[int] = 10,\n    colorscale: Optional[str] = None,\n    name: Optional[str] = \"Heat map\",\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://plotly.com/python/mapbox-density-heatmaps\n\n    Args:\n        data (str | pd.DataFrame): File path or HTTP URL to the input file or a . For example, https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        z (str, optional): The column name of z values. Defaults to \"value\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n        colorscale (str, optional): Color scale of the data, e.g., Viridis. See https://plotly.com/python/builtin-colorscales. Defaults to None.\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n\n    \"\"\"\n\n    if isinstance(data, str):\n        df = pd.read_csv(data)\n    elif isinstance(data, pd.DataFrame):\n        df = data\n    else:\n        raise ValueError(\"data must be a DataFrame or a file path.\")\n\n    heatmap = go.Densitymapbox(\n        lat=df[latitude],\n        lon=df[longitude],\n        z=df[z],\n        radius=radius,\n        colorscale=colorscale,\n        name=name,\n        **kwargs,\n    )\n    self.add_trace(heatmap)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_heatmap_demo","title":"<code>add_heatmap_demo(self, **kwargs)</code>","text":"<p>Adds a heatmap to the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_heatmap_demo(self, **kwargs):\n    \"\"\"Adds a heatmap to the map.\"\"\"\n    quakes = pd.read_csv(\n        \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\"\n    )\n    heatmap = go.Densitymapbox(\n        lat=quakes.Latitude,\n        lon=quakes.Longitude,\n        z=quakes.Magnitude,\n        radius=10,\n        name=\"Earthquake\",\n        **kwargs,\n    )\n\n    self.add_basemap(\"Esri.WorldTopoMap\")\n    self.add_trace(heatmap)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_layer","title":"<code>add_layer(self, layer, name=None, **kwargs)</code>","text":"<p>Adds a layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>plotly.graph_objects</code> <p>Layer to add.</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_layer(self, layer, name: Optional[str] = None, **kwargs):\n    \"\"\"Adds a layer to the map.\n\n    Args:\n        layer (plotly.graph_objects): Layer to add.\n        name (str, optional): Name of the layer. Defaults to None.\n    \"\"\"\n    if isinstance(name, str):\n        layer.name = name\n    self.add_trace(layer, **kwargs)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_mapbox_layer","title":"<code>add_mapbox_layer(self, style, access_token=None)</code>","text":"<p>Adds a mapbox layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str | dict</code> <p>Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/</p> required <code>access_token</code> <code>str</code> <p>The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.</p> <code>None</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_mapbox_layer(self, style: Union[str, Dict], access_token=None):\n    \"\"\"Adds a mapbox layer to the map.\n\n    Args:\n        layer (str | dict): Layer to add. Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\". See https://plotly.com/python/mapbox-layers/ and https://docs.mapbox.com/mapbox-gl-js/style-spec/\n        access_token (str, optional): The Mapbox Access token. It can be set as an environment variable \"MAPBOX_TOKEN\". Defaults to None.\n    \"\"\"\n\n    if access_token is None:\n        access_token = os.environ.get(\"MAPBOX_TOKEN\")\n\n    self.update_layout(\n        mapbox_style=style, mapbox_layers=[], mapbox_accesstoken=access_token\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_mosaic_layer","title":"<code>add_mosaic_layer(self, url, titiler_endpoint=None, name='Mosaic Layer', attribution='', opacity=1.0, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'Mosaic Layer'.</p> <code>'Mosaic Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_mosaic_layer(\n    self,\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n    name: Optional[str] = \"Mosaic Layer\",\n    attribution: Optional[str] = \"\",\n    opacity: Optional[float] = 1.0,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'Mosaic Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    tile_url = mosaic_tile(url, titiler_endpoint, **kwargs)\n    center = mosaic_info(url, titiler_endpoint)[\"center\"]\n    self.add_tile_layer(tile_url, name, attribution, opacity)\n    self.set_center(lon=center[0], lat=center[1], zoom=10)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_planet_by_month","title":"<code>add_planet_by_month(self, year=2016, month=1, api_key=None, token_name='PLANET_API_KEY', name=None, attribution='', opacity=1.0)</code>","text":"<p>Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_planet_by_month(\n    self,\n    year: Optional[int] = 2016,\n    month: Optional[int] = 1,\n    api_key: Optional[str] = None,\n    token_name: Optional[str] = \"PLANET_API_KEY\",\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    opacity: Optional[float] = 1.0,\n):\n    \"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    if name is None:\n        name = str(year) + \"-\" + str(month).zfill(2)\n    tile_url = planet_by_month(year, month, api_key, token_name)\n    self.add_tile_layer(\n        tile_url, name=name, attribution=attribution, opacity=opacity\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_planet_by_quarter","title":"<code>add_planet_by_quarter(self, year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY', name=None, attribution='', opacity=1.0)</code>","text":"<p>Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_planet_by_quarter(\n    self,\n    year: Optional[int] = 2016,\n    quarter: Optional[int] = 1,\n    api_key: Optional[str] = None,\n    token_name: Optional[str] = \"PLANET_API_KEY\",\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    opacity: Optional[float] = 1.0,\n):\n    \"\"\"Adds Planet global mosaic by month to the map. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    if name is None:\n        name = str(year) + \"-\" + \"q\" + str(quarter)\n    tile_url = planet_by_quarter(year, quarter, api_key, token_name)\n    self.add_tile_layer(\n        tile_url, name=name, attribution=attribution, opacity=opacity\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_scatter_plot_demo","title":"<code>add_scatter_plot_demo(self, **kwargs)</code>","text":"<p>Adds a scatter plot to the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_scatter_plot_demo(self, **kwargs):\n    \"\"\"Adds a scatter plot to the map.\"\"\"\n    lons = np.random.random(1000) * 360.0\n    lats = np.random.random(1000) * 180.0 - 90.0\n    z = np.random.random(1000) * 50.0\n    self.add_scattermapbox(\n        lon=lons, lat=lats, marker={\"color\": z}, name=\"Random points\", **kwargs\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_stac_layer","title":"<code>add_stac_layer(self, url=None, collection=None, items=None, assets=None, bands=None, titiler_endpoint=None, name='STAC Layer', attribution='', opacity=1.0, **kwargs)</code>","text":"<p>Adds a STAC TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>items</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>The layer name to use for the layer. Defaults to 'STAC Layer'.</p> <code>'STAC Layer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to ''.</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: str = None,\n    collection: str = None,\n    items: str = None,\n    assets: str = None,\n    bands: List = None,\n    titiler_endpoint: Optional[str] = None,\n    name: Optional[str] = \"STAC Layer\",\n    attribution: Optional[str] = \"\",\n    opacity: Optional[float] = 1.0,\n    **kwargs,\n):\n    \"\"\"Adds a STAC TileLayer to the map.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        items (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        name (str, optional): The layer name to use for the layer. Defaults to 'STAC Layer'.\n        attribution (str, optional): The attribution to use. Defaults to ''.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n    tile_url = stac_tile(\n        url, collection, item, assets, bands, titiler_endpoint, **kwargs\n    )\n    center = stac_center(url, collection, item, titiler_endpoint)\n    self.add_tile_layer(tile_url, name, attribution, opacity)\n    self.set_center(lon=center[0], lat=center[1], zoom=10)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.add_tile_layer","title":"<code>add_tile_layer(self, url, name='TileLayer', attribution='', opacity=1.0, **kwargs)</code>","text":"<p>Adds a TileLayer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer.</p> required <code>name</code> <code>str</code> <p>Name of the layer. Defaults to 'TileLayer'.</p> <code>'TileLayer'</code> <code>attribution</code> <code>str</code> <p>The attribution to use. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.</p> <code>1.0</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = \"TileLayer\",\n    attribution: Optional[str] = \"\",\n    opacity: Optional[float] = 1.0,\n    **kwargs,\n):\n    \"\"\"Adds a TileLayer to the map.\n\n    Args:\n        url (str): The URL of the tile layer.\n        name (str, optional): Name of the layer. Defaults to 'TileLayer'.\n        attribution (str): The attribution to use. Defaults to \"\".\n        opacity (float, optional): The opacity of the layer. Defaults to 1.\n    \"\"\"\n\n    layer = {\n        \"below\": \"traces\",\n        \"sourcetype\": \"raster\",\n        \"sourceattribution\": attribution,\n        \"source\": [url],\n        \"opacity\": opacity,\n        \"name\": name,\n    }\n    layers = list(self.layout.mapbox.layers) + [layer]\n    self.update_layout(mapbox_layers=layers)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.clear_controls","title":"<code>clear_controls(self)</code>","text":"<p>Removes all controls from the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def clear_controls(self):\n    \"\"\"Removes all controls from the map.\"\"\"\n    config = {\n        \"scrollZoom\": True,\n        \"displayModeBar\": False,\n        \"editable\": True,\n        \"showLink\": False,\n        \"displaylogo\": False,\n    }\n    self.show(toolbar=False, config=config)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.clear_layers","title":"<code>clear_layers(self, clear_basemap=False)</code>","text":"<p>Clears all layers from the map.</p> <p>Parameters:</p> Name Type Description Default <code>clear_basemap</code> <code>bool</code> <p>If True, clears the basemap. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def clear_layers(self, clear_basemap: Optional[bool] = False):\n    \"\"\"Clears all layers from the map.\n\n    Args:\n        clear_basemap (bool, optional): If True, clears the basemap. Defaults to False.\n    \"\"\"\n    if clear_basemap:\n        self.data = []\n    else:\n        if len(self.data) &gt; 1:\n            self.data = self.data[:1]\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.find_layer_index","title":"<code>find_layer_index(self, name)</code>","text":"<p>Finds the index of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to find.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the layer.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def find_layer_index(self, name: str) -&gt; int:\n    \"\"\"Finds the index of a layer.\n\n    Args:\n        name (str): Name of the layer to find.\n\n    Returns:\n        int: Index of the layer.\n    \"\"\"\n    for i, layer in enumerate(self.data):\n        if layer.name == name:\n            return i\n\n    for i, layer in enumerate(self.layout.mapbox.layers):\n        if layer[\"name\"] == name:\n            return i\n\n    return None\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.get_data_layers","title":"<code>get_data_layers(self)</code>","text":"<p>Returns a dictionary of data layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of data layers in the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def get_data_layers(self) -&gt; Dict:\n    \"\"\"Returns a dictionary of data layers in the map.\n\n    Returns:\n        dict: A dictionary of data layers in the map.\n    \"\"\"\n\n    layers = {}\n\n    for layer in self.data:\n        if layer.name is not None and layer.name != \"trace 0\":\n            layers[layer.name] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.get_layers","title":"<code>get_layers(self)</code>","text":"<p>Returns a dictionary of all layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of all layers in the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def get_layers(self) -&gt; Dict:\n    \"\"\"Returns a dictionary of all layers in the map.\n    Returns:\n        dict: A dictionary of all layers in the map.\n    \"\"\"\n    layers = {}\n\n    for layer in self.layout.mapbox.layers:\n        if layer[\"name\"] is not None:\n            layers[layer[\"name\"]] = layer\n\n    for layer in self.data:\n        if layer.name is not None and layer.name != \"trace 0\":\n            layers[layer.name] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.get_tile_layers","title":"<code>get_tile_layers(self)</code>","text":"<p>Returns a dictionary of tile layers in the map.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of tile layers in the map.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def get_tile_layers(self) -&gt; Dict:\n    \"\"\"Returns a dictionary of tile layers in the map.\n\n    Returns:\n        dict: A dictionary of tile layers in the map.\n    \"\"\"\n\n    layers = {}\n\n    for layer in self.layout.mapbox.layers:\n        if layer[\"name\"] is not None:\n            layers[layer[\"name\"]] = layer\n\n    return layers\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.remove_basemap","title":"<code>remove_basemap(self, name)</code>","text":"<p>Removes a basemap from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the basemap to remove.</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def remove_basemap(self, name: str):\n    \"\"\"Removes a basemap from the map.\n\n    Args:\n        name (str): Name of the basemap to remove.\n    \"\"\"\n    layers = list(self.layout.mapbox.layers)\n    layers = [layer for layer in layers if layer[\"name\"] != name]\n    self.layout.mapbox.layers = layers\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.remove_controls","title":"<code>remove_controls(self, controls)</code>","text":"<p>Removes controls to the map.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>list</code> <p>List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def remove_controls(self, controls: List):\n    \"\"\"Removes controls to the map.\n\n    Args:\n        controls (list): List of controls to remove, e.g., [\"zoomin\", \"zoomout\", \"toimage\", \"pan\", \"resetview\"]. See https://bit.ly/3Jk7wkb\n    \"\"\"\n    if isinstance(controls, str):\n        controls = [controls]\n    elif not isinstance(controls, list):\n        raise ValueError(\n            \"Controls must be a string or a list of strings. See https://bit.ly/3Jk7wkb\"\n        )\n\n    self.update_layout(modebar_remove=controls)\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.remove_layer","title":"<code>remove_layer(self, name)</code>","text":"<p>Removes a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required Source code in <code>leafmap/plotlymap.py</code> <pre><code>def remove_layer(self, name: str):\n    \"\"\"Removes a layer from the map.\n\n    Args:\n        name (str): Name of the layer to remove.\n    \"\"\"\n    if name in self.get_data_layers():\n        self.data = [layer for layer in self.data if layer.name != name]\n    elif name in self.get_tile_layers():\n        self.layout.mapbox.layers = [\n            layer for layer in self.layout.mapbox.layers if layer[\"name\"] != name\n        ]\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.save","title":"<code>save(self, file, format=None, width=None, height=None, scale=None, **kwargs)</code>","text":"<p>Convert a map to a static image and write it to a file or writeable object</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)</p> required <code>format</code> <code>str</code> <p>The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the exported image in layout pixels. If the <code>scale</code> property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the exported image in layout pixels. If the <code>scale</code> property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.</p> <code>None</code> <code>scale</code> <code>int</code> <p>The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def save(\n    self,\n    file: str,\n    format: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    scale: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"Convert a map to a static image and write it to a file or writeable object\n\n    Args:\n        file (str): A string representing a local file path or a writeable object (e.g. a pathlib.Path object or an open file descriptor)\n        format (str, optional): The desired image format. One of png, jpg, jpeg, webp, svg, pdf, eps. Defaults to None.\n        width (int, optional): The width of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the width of the exported image in physical pixels.. Defaults to None.\n        height (int, optional): The height of the exported image in layout pixels. If the `scale` property is 1.0, this will also be the height of the exported image in physical pixels.. Defaults to None.\n        scale (int, optional): The scale factor to use when exporting the figure. A scale factor larger than 1.0 will increase the image resolution with respect to the figure's layout pixel dimensions. Whereas as scale factor of less than 1.0 will decrease the image resolution.. Defaults to None.\n    \"\"\"\n    self.write_image(\n        file, format=format, width=width, height=height, scale=scale, **kwargs\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.set_center","title":"<code>set_center(self, lat, lon, zoom=None)</code>","text":"<p>Sets the center of the map.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>lon</code> <code>float</code> <p>Longitude.</p> required <code>zoom</code> <code>int</code> <p>Zoom level of the map. Defaults to None.</p> <code>None</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def set_center(self, lat: float, lon: float, zoom: Optional[float] = None):\n    \"\"\"Sets the center of the map.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        zoom (int, optional): Zoom level of the map. Defaults to None.\n    \"\"\"\n    self.update_layout(\n        mapbox=dict(\n            center=dict(lat=lat, lon=lon),\n            zoom=zoom if zoom is not None else self.layout.mapbox.zoom,\n        )\n    )\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.set_layer_opacity","title":"<code>set_layer_opacity(self, name, opacity=1)</code>","text":"<p>Sets the visibility of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to set.</p> required <code>opacity</code> <code>float</code> <p>Opacity of the layer. Defaults to 1.</p> <code>1</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def set_layer_opacity(self, name: str, opacity: Optional[float] = 1):\n    \"\"\"Sets the visibility of a layer.\n\n    Args:\n        name (str): Name of the layer to set.\n        opacity (float, optional): Opacity of the layer. Defaults to 1.\n    \"\"\"\n\n    if name in self.get_tile_layers():\n        index = self.find_layer_index(name)\n        self.layout.mapbox.layers[index].opacity = opacity\n    elif name in self.get_data_layers():\n        index = self.find_layer_index(name)\n        layer = self.data[index]\n        if hasattr(layer, \"opacity\"):\n            layer.opacity = opacity\n        elif hasattr(layer, \"marker\"):\n            layer.marker.opacity = opacity\n    else:\n        print(f\"Layer {name} not found.\")\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.set_layer_visibility","title":"<code>set_layer_visibility(self, name, show=True)</code>","text":"<p>Sets the visibility of a layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to set.</p> required <code>show</code> <code>bool</code> <p>If True, shows the layer. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def set_layer_visibility(self, name: str, show: Optional[bool] = True):\n    \"\"\"Sets the visibility of a layer.\n\n    Args:\n        name (str): Name of the layer to set.\n        show (bool, optional): If True, shows the layer. Defaults to True.\n    \"\"\"\n\n    if name in self.get_tile_layers():\n        index = self.find_layer_index(name)\n        self.layout.mapbox.layers[index].visible = show\n    elif name in self.get_data_layers():\n        index = self.find_layer_index(name)\n        self.data[index].visible = show\n    else:\n        print(f\"Layer {name} not found.\")\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.Map.show","title":"<code>show(self, toolbar=True, map_min_width='91%', map_max_width='98%', refresh=False, **kwargs)</code>","text":"<p>Shows the map.</p> <p>Parameters:</p> Name Type Description Default <code>toolbar</code> <code>bool</code> <p>Whether to show the toolbar. Defaults to True.</p> <code>True</code> <code>map_min_width</code> <code>str</code> <p>The minimum width of the map. Defaults to '91%'.</p> <code>'91%'</code> <code>map_max_width</code> <code>str</code> <p>The maximum width of the map. Defaults to '98%'.</p> <code>'98%'</code> <code>refresh</code> <code>bool</code> <p>Whether to refresh the map when the map is resized. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Canvas</code> <p>Map canvas.</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def show(\n    self,\n    toolbar: Optional[bool] = True,\n    map_min_width: Optional[str] = \"91%\",\n    map_max_width: Optional[str] = \"98%\",\n    refresh: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Shows the map.\n\n    Args:\n        toolbar (bool, optional): Whether to show the toolbar. Defaults to True.\n        map_min_width (str, optional): The minimum width of the map. Defaults to '91%'.\n        map_max_width (str, optional): The maximum width of the map. Defaults to '98%'.\n        refresh (bool, optional): Whether to refresh the map when the map is resized. Defaults to False.\n\n    Returns:\n        Canvas: Map canvas.\n    \"\"\"\n    if not toolbar:\n        super().show(**kwargs)\n    else:\n        canvas = Canvas(\n            self,\n            map_min_width=map_min_width,\n            map_max_width=map_max_width,\n            map_refresh=refresh,\n        )\n        return canvas.canvas\n</code></pre>"},{"location":"plotlymap/#leafmap.plotlymap.fix_widget_error","title":"<code>fix_widget_error()</code>","text":"<p>Fix FigureWidget - 'mapbox._derived' Value Error. Adopted from: https://github.com/plotly/plotly.py/issues/2570#issuecomment-738735816</p> Source code in <code>leafmap/plotlymap.py</code> <pre><code>def fix_widget_error():\n    \"\"\"\n    Fix FigureWidget - 'mapbox._derived' Value Error.\n    Adopted from: https://github.com/plotly/plotly.py/issues/2570#issuecomment-738735816\n    \"\"\"\n    import shutil\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"plotly\", \"plotly.py\"))\n\n    basedatatypesPath = os.path.join(pkg_dir, \"basedatatypes.py\")\n\n    backup_file = basedatatypesPath.replace(\".py\", \"_bk.py\")\n    shutil.copyfile(basedatatypesPath, backup_file)\n\n    # read basedatatypes.py\n    with open(basedatatypesPath, \"r\") as f:\n        lines = f.read()\n\n    find = \"if not BaseFigure._is_key_path_compatible(key_path_str, self.layout):\"\n\n    replace = \"\"\"if not BaseFigure._is_key_path_compatible(key_path_str, self.layout):\n                if key_path_str == \"mapbox._derived\":\n                    return\"\"\"\n\n    # add new text\n    lines = lines.replace(find, replace)\n\n    # overwrite old 'basedatatypes.py'\n    with open(basedatatypesPath, \"w\") as f:\n        f.write(lines)\n</code></pre>"},{"location":"search_bk/","title":"Search bk","text":"Search"},{"location":"stac/","title":"stac module","text":""},{"location":"stac/#leafmap.stac.PlanetaryComputerEndpoint","title":"<code> PlanetaryComputerEndpoint            (TitilerEndpoint)         </code>","text":"<p>This class contains the methods for the Microsoft Planetary Computer endpoint.</p> Source code in <code>leafmap/stac.py</code> <pre><code>class PlanetaryComputerEndpoint(TitilerEndpoint):\n    \"\"\"This class contains the methods for the Microsoft Planetary Computer endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint: Optional[str] = \"https://planetarycomputer.microsoft.com/api/data/v1\",\n        name: Optional[str] = \"item\",\n        TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n    ):\n        \"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n            name (str, optional): The name to be used in the file path. Defaults to \"item\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        super().__init__(endpoint, name, TileMatrixSetId)\n\n    def url_for_stac_collection(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_collection_assets(self):\n        return f\"{self.endpoint}/collection/assets\"\n\n    def url_for_collection_bounds(self):\n        return f\"{self.endpoint}/collection/bounds\"\n\n    def url_for_collection_info(self):\n        return f\"{self.endpoint}/collection/info\"\n\n    def url_for_collection_info_geojson(self):\n        return f\"{self.endpoint}/collection/info.geojson\"\n\n    def url_for_collection_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/collection/point/{lon},{lat}\"\n\n    def url_for_collection_wmts(self):\n        return f\"{self.endpoint}/collection/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n\n    def url_for_collection_lat_lon_assets(self, lng, lat):\n        return f\"{self.endpoint}/collection/{lng},{lat}/assets\"\n\n    def url_for_collection_bbox_assets(self, minx, miny, maxx, maxy):\n        return f\"{self.endpoint}/collection/{minx},{miny},{maxx},{maxy}/assets\"\n\n    def url_for_stac_mosaic(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_mosaic_info(self, searchid):\n        return f\"{self.endpoint}/mosaic/{searchid}/info\"\n\n    def url_for_mosaic_lat_lon_assets(self, searchid, lon, lat):\n        return f\"{self.endpoint}/mosaic/{searchid}/{lon},{lat}/assets\"\n</code></pre>"},{"location":"stac/#leafmap.stac.PlanetaryComputerEndpoint.__init__","title":"<code>__init__(self, endpoint='https://planetarycomputer.microsoft.com/api/data/v1', name='item', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the PlanetaryComputerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".</p> <code>'https://planetarycomputer.microsoft.com/api/data/v1'</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"item\".</p> <code>'item'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>leafmap/stac.py</code> <pre><code>def __init__(\n    self,\n    endpoint: Optional[str] = \"https://planetarycomputer.microsoft.com/api/data/v1\",\n    name: Optional[str] = \"item\",\n    TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n):\n    \"\"\"Initialize the PlanetaryComputerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://planetarycomputer.microsoft.com/api/data/v1\".\n        name (str, optional): The name to be used in the file path. Defaults to \"item\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    super().__init__(endpoint, name, TileMatrixSetId)\n</code></pre>"},{"location":"stac/#leafmap.stac.TitilerEndpoint","title":"<code> TitilerEndpoint        </code>","text":"<p>This class contains the methods for the titiler endpoint.</p> Source code in <code>leafmap/stac.py</code> <pre><code>class TitilerEndpoint:\n    \"\"\"This class contains the methods for the titiler endpoint.\"\"\"\n\n    def __init__(\n        self,\n        endpoint: Optional[str] = None,\n        name: Optional[str] = \"stac\",\n        TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n    ):\n        \"\"\"Initialize the TitilerEndpoint object.\n\n        Args:\n            endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n            name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n            TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n        \"\"\"\n        self.endpoint = endpoint\n        self.name = name\n        self.TileMatrixSetId = TileMatrixSetId\n\n    def url_for_stac_item(self):\n        return f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/tilejson.json\"\n\n    def url_for_stac_assets(self):\n        return f\"{self.endpoint}/{self.name}/assets\"\n\n    def url_for_stac_bounds(self):\n        return f\"{self.endpoint}/{self.name}/bounds\"\n\n    def url_for_stac_info(self):\n        return f\"{self.endpoint}/{self.name}/info\"\n\n    def url_for_stac_info_geojson(self):\n        return f\"{self.endpoint}/{self.name}/info.geojson\"\n\n    def url_for_stac_statistics(self):\n        return f\"{self.endpoint}/{self.name}/statistics\"\n\n    def url_for_stac_pixel_value(self, lon, lat):\n        return f\"{self.endpoint}/{self.name}/point/{lon},{lat}\"\n\n    def url_for_stac_wmts(self):\n        return (\n            f\"{self.endpoint}/{self.name}/{self.TileMatrixSetId}/WMTSCapabilities.xml\"\n        )\n</code></pre>"},{"location":"stac/#leafmap.stac.TitilerEndpoint.__init__","title":"<code>__init__(self, endpoint=None, name='stac', TileMatrixSetId='WebMercatorQuad')</code>  <code>special</code>","text":"<p>Initialize the TitilerEndpoint object.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>name</code> <code>str</code> <p>The name to be used in the file path. Defaults to \"stac\".</p> <code>'stac'</code> <code>TileMatrixSetId</code> <code>str</code> <p>The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".</p> <code>'WebMercatorQuad'</code> Source code in <code>leafmap/stac.py</code> <pre><code>def __init__(\n    self,\n    endpoint: Optional[str] = None,\n    name: Optional[str] = \"stac\",\n    TileMatrixSetId: Optional[str] = \"WebMercatorQuad\",\n):\n    \"\"\"Initialize the TitilerEndpoint object.\n\n    Args:\n        endpoint (str, optional): The endpoint of the titiler server. Defaults to \"https://titiler.xyz\".\n        name (str, optional): The name to be used in the file path. Defaults to \"stac\".\n        TileMatrixSetId (str, optional): The TileMatrixSetId to be used in the file path. Defaults to \"WebMercatorQuad\".\n    \"\"\"\n    self.endpoint = endpoint\n    self.name = name\n    self.TileMatrixSetId = TileMatrixSetId\n</code></pre>"},{"location":"stac/#leafmap.stac.check_titiler_endpoint","title":"<code>check_titiler_endpoint(titiler_endpoint=None)</code>","text":"<p>Returns the default titiler endpoint.</p> <p>Returns:</p> Type Description <code>object</code> <p>A titiler endpoint.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def check_titiler_endpoint(titiler_endpoint: Optional[str] = None):\n    \"\"\"Returns the default titiler endpoint.\n\n    Returns:\n        object: A titiler endpoint.\n    \"\"\"\n    if titiler_endpoint is None:\n        if os.environ.get(\"TITILER_ENDPOINT\") is not None:\n            titiler_endpoint = os.environ.get(\"TITILER_ENDPOINT\")\n\n            if titiler_endpoint == \"planetary-computer\":\n                titiler_endpoint = PlanetaryComputerEndpoint()\n        else:\n            titiler_endpoint = \"https://titiler.xyz\"\n    elif titiler_endpoint in [\"planetary-computer\", \"pc\"]:\n        titiler_endpoint = PlanetaryComputerEndpoint()\n\n    return titiler_endpoint\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_bands","title":"<code>cog_bands(url, titiler_endpoint=None)</code>","text":"<p>Get band names of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_bands(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get band names of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/info\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    bands = [b[0] for b in r[\"band_descriptions\"]]\n    return bands\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_bounds","title":"<code>cog_bounds(url, titiler_endpoint=None)</code>","text":"<p>Get the bounding box of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_bounds(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get the bounding box of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(f\"{titiler_endpoint}/cog/bounds\", params={\"url\": url}).json()\n\n    if \"bounds\" in r.keys():\n        bounds = r[\"bounds\"]\n    else:\n        bounds = None\n    return bounds\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_center","title":"<code>cog_center(url, titiler_endpoint=None)</code>","text":"<p>Get the centroid of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_center(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; Tuple:\n    \"\"\"Get the centroid of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    bounds = cog_bounds(url, titiler_endpoint)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_info","title":"<code>cog_info(url, titiler_endpoint=None, return_geojson=False)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_info(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n    return_geojson: Optional[bool] = False,\n) -&gt; List:\n    \"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    info = \"info\"\n    if return_geojson:\n        info = \"info.geojson\"\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{info}\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_mosaic","title":"<code>cog_mosaic(links, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, **kwargs)</code>","text":"<p>Creates a COG mosaic from a list of COG URLs.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list</code> <p>A list containing COG HTTP URLs.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>Exception</code> <p>If the COG mosaic fails to create.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_mosaic(\n    links: List,\n    titiler_endpoint: Optional[str] = None,\n    username: Optional[str] = \"anonymous\",\n    layername=None,\n    overwrite: Optional[bool] = False,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Creates a COG mosaic from a list of COG URLs.\n\n    Args:\n        links (list): A list containing COG HTTP URLs.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n\n    Raises:\n        Exception: If the COG mosaic fails to create.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if layername is None:\n        layername = \"layer_X\"\n\n    try:\n        if verbose:\n            print(\"Creating COG masaic ...\")\n\n        # Create token\n        r = requests.post(\n            f\"{titiler_endpoint}/tokens/create\",\n            json={\"username\": username, \"scope\": [\"mosaic:read\", \"mosaic:create\"]},\n        ).json()\n        token = r[\"token\"]\n\n        # Create mosaic\n        requests.post(\n            f\"{titiler_endpoint}/mosaicjson/create\",\n            json={\n                \"username\": username,\n                \"layername\": layername,\n                \"files\": links,\n                # \"overwrite\": overwrite\n            },\n            params={\n                \"access_token\": token,\n            },\n        ).json()\n\n        r2 = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/{username}.{layername}/tilejson.json\",\n        ).json()\n\n        return r2[\"tiles\"][0]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_mosaic_from_file","title":"<code>cog_mosaic_from_file(filepath, skip_rows=0, titiler_endpoint=None, username='anonymous', layername=None, overwrite=False, verbose=True, **kwargs)</code>","text":"<p>Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Local path or HTTP URL to the csv/txt file containing COG URLs.</p> required <code>skip_rows</code> <code>int</code> <p>The number of rows to skip in the file. Defaults to 0.</p> <code>0</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>username</code> <code>str</code> <p>User name for the titiler endpoint. Defaults to \"anonymous\".</p> <code>'anonymous'</code> <code>layername</code> <code>[type]</code> <p>Layer name to use. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the layer name if existing. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL for the COG mosaic.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_mosaic_from_file(\n    filepath: str,\n    skip_rows: Optional[int] = 0,\n    titiler_endpoint: Optional[str] = None,\n    username: Optional[str] = \"anonymous\",\n    layername=None,\n    overwrite: Optional[bool] = False,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Creates a COG mosaic from a csv/txt file stored locally for through HTTP URL.\n\n    Args:\n        filepath (str): Local path or HTTP URL to the csv/txt file containing COG URLs.\n        skip_rows (int, optional): The number of rows to skip in the file. Defaults to 0.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        username (str, optional): User name for the titiler endpoint. Defaults to \"anonymous\".\n        layername ([type], optional): Layer name to use. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite the layer name if existing. Defaults to False.\n        verbose (bool, optional): Whether to print out descriptive information. Defaults to True.\n\n    Returns:\n        str: The tile URL for the COG mosaic.\n    \"\"\"\n    import urllib\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    links = []\n    if filepath.startswith(\"http\"):\n        data = urllib.request.urlopen(filepath)\n        for line in data:\n            links.append(line.decode(\"utf-8\").strip())\n\n    else:\n        with open(filepath) as f:\n            links = [line.strip() for line in f.readlines()]\n\n    links = links[skip_rows:]\n    # print(links)\n    mosaic = cog_mosaic(\n        links, titiler_endpoint, username, layername, overwrite, verbose, **kwargs\n    )\n    return mosaic\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_pixel_value","title":"<code>cog_pixel_value(lon, lat, url, bidx, titiler_endpoint=None, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_pixel_value(\n    lon: float,\n    lat: float,\n    url: str,\n    bidx: Optional[str],\n    titiler_endpoint: Optional[str] = None,\n    verbose: Optional[bool] = True,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    kwargs[\"url\"] = url\n    if bidx is not None:\n        kwargs[\"bidx\"] = bidx\n\n    r = requests.get(f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs).json()\n    bands = cog_bands(url, titiler_endpoint)\n    # if isinstance(titiler_endpoint, str):\n    #     r = requests.get(f\"{titiler_endpoint}/cog/point/{lon},{lat}\", params=kwargs).json()\n    # else:\n    #     r = requests.get(\n    #         titiler_endpoint.url_for_stac_pixel_value(lon, lat), params=kwargs\n    #     ).json()\n\n    if \"detail\" in r:\n        if verbose:\n            print(r[\"detail\"])\n        return None\n    else:\n        values = r[\"values\"]\n        result = dict(zip(bands, values))\n        return result\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_stats","title":"<code>cog_stats(url, titiler_endpoint=None)</code>","text":"<p>Get band statistics of a Cloud Optimized GeoTIFF (COG).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_stats(\n    url: str,\n    titiler_endpoint: Optional[str] = None,\n) -&gt; List:\n    \"\"\"Get band statistics of a Cloud Optimized GeoTIFF (COG).\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/statistics\",\n        params={\n            \"url\": url,\n        },\n    ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_tile","title":"<code>cog_tile(url, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get a tile layer from a Cloud Optimized GeoTIFF (COG).     Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>bands</code> <code>list</code> <p>List of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the titiler endpoint. For more information about the available arguments, see https://developmentseed.org/titiler/endpoints/cog/#tiles. For example, to apply a rescaling to multiple bands, use something like <code>rescale=[\"164,223\",\"130,211\",\"99,212\"]</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the COG Tile layer URL and bounds.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_tile(\n    url,\n    bands: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Get a tile layer from a Cloud Optimized GeoTIFF (COG).\n        Source code adapted from https://developmentseed.org/titiler/examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        bands (list, optional): List of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): TiTiler endpoint. Defaults to \"https://titiler.xyz\".\n        **kwargs: Additional arguments to pass to the titiler endpoint. For more information about the available arguments, see https://developmentseed.org/titiler/endpoints/cog/#tiles.\n            For example, to apply a rescaling to multiple bands, use something like `rescale=[\"164,223\",\"130,211\",\"99,212\"]`.\n\n    Returns:\n        tuple: Returns the COG Tile layer URL and bounds.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    kwargs[\"url\"] = url\n\n    band_names = cog_bands(url, titiler_endpoint)\n\n    if isinstance(bands, str):\n        bands = [bands]\n\n    if bands is None and \"bidx\" not in kwargs:\n        if len(band_names) &gt;= 3:\n            kwargs[\"bidx\"] = [1, 2, 3]\n    elif isinstance(bands, list) and \"bidx\" not in kwargs:\n        if all(isinstance(x, int) for x in bands):\n            if len(set(bands)) == 1:\n                bands = bands[0]\n            kwargs[\"bidx\"] = bands\n        elif all(isinstance(x, str) for x in bands):\n            if len(set(bands)) == 1:\n                bands = bands[0]\n            kwargs[\"bidx\"] = [band_names.index(x) + 1 for x in bands]\n        else:\n            raise ValueError(\"Bands must be a list of integers or strings.\")\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"].lower()\n        del kwargs[\"palette\"]\n\n    if \"bidx\" not in kwargs:\n        kwargs[\"bidx\"] = [1]\n    elif isinstance(kwargs[\"bidx\"], int):\n        kwargs[\"bidx\"] = [kwargs[\"bidx\"]]\n\n    if \"rescale\" not in kwargs:\n        stats = cog_stats(url, titiler_endpoint)\n\n        if \"message\" not in stats:\n            try:\n                rescale = []\n                for i in band_names:\n                    rescale.append(\n                        \"{},{}\".format(\n                            stats[i][\"percentile_2\"],\n                            stats[i][\"percentile_98\"],\n                        )\n                    )\n                kwargs[\"rescale\"] = rescale\n            except Exception as e:\n                print(e)\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    if \"default_vis\" in kwargs.keys() and kwargs[\"default_vis\"]:\n        kwargs = {\"url\": url}\n\n    r = requests.get(\n        f\"{titiler_endpoint}/cog/{TileMatrixSetId}/tilejson.json\", params=kwargs\n    ).json()\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"stac/#leafmap.stac.cog_tile_vmin_vmax","title":"<code>cog_tile_vmin_vmax(url, bands=None, titiler_endpoint=None, percentile=True, **kwargs)</code>","text":"<p>Get a tile layer from a Cloud Optimized GeoTIFF (COG) and return the minimum and maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif</p> required <code>bands</code> <code>list</code> <p>List of bands to use. Defaults to None.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint. Defaults to \"https://titiler.xyz\".</p> <code>None</code> <code>percentile</code> <code>bool</code> <p>Whether to use percentiles or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Returns the minimum and maximum values.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def cog_tile_vmin_vmax(\n    url: str,\n    bands: Optional[List] = None,\n    titiler_endpoint: Optional[str] = None,\n    percentile: Optional[bool] = True,\n    **kwargs,\n) -&gt; Tuple:\n    \"\"\"Get a tile layer from a Cloud Optimized GeoTIFF (COG) and return the minimum and maximum values.\n\n    Args:\n        url (str): HTTP URL to a COG, e.g., https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\n        bands (list, optional): List of bands to use. Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint. Defaults to \"https://titiler.xyz\".\n        percentile (bool, optional): Whether to use percentiles or not. Defaults to True.\n    Returns:\n        tuple: Returns the minimum and maximum values.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    stats = cog_stats(url, titiler_endpoint)\n\n    if isinstance(bands, str):\n        bands = [bands]\n\n    if bands is not None:\n        stats = {s: stats[s] for s in stats if s in bands}\n\n    if percentile:\n        vmin = min([stats[s][\"percentile_2\"] for s in stats])\n        vmax = max([stats[s][\"percentile_98\"] for s in stats])\n    else:\n        vmin = min([stats[s][\"min\"] for s in stats])\n        vmax = max([stats[s][\"max\"] for s in stats])\n\n    return vmin, vmax\n</code></pre>"},{"location":"stac/#leafmap.stac.create_mosaicjson","title":"<code>create_mosaicjson(images, output)</code>","text":"<p>Create a mosaicJSON file from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>A list of image URLs or a URL to a text file containing a list of image URLs.</p> required <code>output</code> <code>str</code> <p>The output mosaicJSON file path.</p> required Source code in <code>leafmap/stac.py</code> <pre><code>def create_mosaicjson(images, output):\n    \"\"\"Create a mosaicJSON file from a list of images.\n\n    Args:\n        images (str | list): A list of image URLs or a URL to a text file containing a list of image URLs.\n        output (str): The output mosaicJSON file path.\n\n    \"\"\"\n    try:\n        from cogeo_mosaic.mosaic import MosaicJSON\n        from cogeo_mosaic.backends import MosaicBackend\n    except ImportError:\n        raise ImportError(\n            \"cogeo-mosaic is required to use this function. \"\n            \"Install with `pip install cogeo-mosaic`.\"\n        )\n\n    if isinstance(images, str):\n        if images.startswith(\"http\"):\n            import urllib.request\n\n            with urllib.request.urlopen(images) as f:\n                file_contents = f.read().decode(\"utf-8\")\n                images = file_contents.strip().split(\"\\n\")\n        elif not os.path.exists(images):\n            raise FileNotFoundError(f\"{images} does not exist.\")\n\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a URL.\")\n\n    mosaic = MosaicJSON.from_urls(images)\n    with MosaicBackend(output, mosaic_def=mosaic) as f:\n        f.write(overwrite=True)\n</code></pre>"},{"location":"stac/#leafmap.stac.download_data_catalogs","title":"<code>download_data_catalogs(out_dir=None, quiet=True, overwrite=False)</code>","text":"<p>Download geospatial data catalogs from https://github.com/giswqs/geospatial-data-catalogs.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress the download progress bar. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing data catalog. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the downloaded data catalog.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def download_data_catalogs(\n    out_dir: Optional[str] = None,\n    quiet: Optional[bool] = True,\n    overwrite: Optional[bool] = False,\n) -&gt; str:\n    \"\"\"Download geospatial data catalogs from https://github.com/giswqs/geospatial-data-catalogs.\n\n    Args:\n        out_dir (str, optional): The output directory. Defaults to None.\n        quiet (bool, optional): Whether to suppress the download progress bar. Defaults to True.\n        overwrite (bool, optional): Whether to overwrite the existing data catalog. Defaults to False.\n\n    Returns:\n        str: The path to the downloaded data catalog.\n    \"\"\"\n    import tempfile\n    import gdown\n    import zipfile\n\n    if out_dir is None:\n        out_dir = tempfile.gettempdir()\n    elif not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    url = \"https://github.com/giswqs/geospatial-data-catalogs/archive/refs/heads/master.zip\"\n\n    out_file = os.path.join(out_dir, \"geospatial-data-catalogs.zip\")\n    work_dir = os.path.join(out_dir, \"geospatial-data-catalogs-master\")\n\n    if os.path.exists(work_dir) and not overwrite:\n        return work_dir\n    else:\n        gdown.download(url, out_file, quiet=quiet)\n        with zipfile.ZipFile(out_file, \"r\") as zip_ref:\n            zip_ref.extractall(out_dir)\n        return work_dir\n</code></pre>"},{"location":"stac/#leafmap.stac.flatten_dict","title":"<code>flatten_dict(my_dict, parent_key=False, sep='.')</code>","text":"<p>Flattens a nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>my_dict</code> <code>dict</code> <p>The dictionary to flatten.</p> required <code>parent_key</code> <code>bool</code> <p>Whether to include the parent key. Defaults to False.</p> <code>False</code> <code>sep</code> <code>str</code> <p>The separator to use. Defaults to '.'.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The flattened dictionary.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def flatten_dict(my_dict, parent_key=False, sep=\".\"):\n    \"\"\"Flattens a nested dictionary.\n\n    Args:\n        my_dict (dict): The dictionary to flatten.\n        parent_key (bool, optional): Whether to include the parent key. Defaults to False.\n        sep (str, optional): The separator to use. Defaults to '.'.\n\n    Returns:\n        dict: The flattened dictionary.\n    \"\"\"\n\n    flat_dict = {}\n    for key, value in my_dict.items():\n        if not isinstance(value, dict):\n            flat_dict[key] = value\n        else:\n            sub_dict = flatten_dict(value)\n            for sub_key, sub_value in sub_dict.items():\n                if parent_key:\n                    flat_dict[parent_key + sep + sub_key] = sub_value\n                else:\n                    flat_dict[sub_key] = sub_value\n\n    return flat_dict\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_all_items","title":"<code>maxar_all_items(collection_id, return_gdf=True, assets=['visual'], verbose=True, **kwargs)</code>","text":"<p>Retrieve STAC items from Maxar's public STAC API.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame. Defaults to True.</p> <code>True</code> <code>assets</code> <code>list</code> <p>A list of asset names to include in the GeoDataFrame. It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].</p> <code>['visual']</code> <code>verbose</code> <code>bool</code> <p>If True, print progress. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | pystac.ItemCollection</code> <p>If return_gdf is True, return a GeoDataFrame.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_all_items(\n    collection_id: str,\n    return_gdf: Optional[bool] = True,\n    assets: Optional[List] = [\"visual\"],\n    verbose: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Retrieve STAC items from Maxar's public STAC API.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        return_gdf (bool, optional): If True, return a GeoDataFrame. Defaults to True.\n        assets (list, optional): A list of asset names to include in the GeoDataFrame.\n            It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].\n        verbose (bool, optional): If True, print progress. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        GeoDataFrame | pystac.ItemCollection: If return_gdf is True, return a GeoDataFrame.\n    \"\"\"\n\n    child_ids = maxar_child_collections(collection_id, **kwargs)\n    for index, child_id in enumerate(child_ids):\n        if verbose:\n            print(\n                f\"Processing ({str(index+1).zfill(len(str(len(child_ids))))} out of {len(child_ids)}): {child_id} ...\"\n            )\n        items = maxar_items(collection_id, child_id, return_gdf, assets, **kwargs)\n        if return_gdf:\n            if child_id == child_ids[0]:\n                gdf = items\n            else:\n                gdf = gdf.append(items)\n        else:\n            if child_id == child_ids[0]:\n                items_all = items\n            else:\n                items_all.extend(items)\n\n    if return_gdf:\n        return gdf\n    else:\n        return items_all\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_child_collections","title":"<code>maxar_child_collections(collection_id, return_ids=True, **kwargs)</code>","text":"<p>Get a list of Maxar child collections.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>return_ids</code> <code>bool</code> <p>Whether to return the collection ids. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of Maxar child collections.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_child_collections(\n    collection_id: str, return_ids: Optional[bool] = True, **kwargs\n) -&gt; List:\n    \"\"\"Get a list of Maxar child collections.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        return_ids (bool, optional): Whether to return the collection ids. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        list: A list of Maxar child collections.\n    \"\"\"\n\n    import tempfile\n    from pystac import Catalog\n\n    file_path = os.path.join(tempfile.gettempdir(), f\"maxar-{collection_id}.txt\")\n    if return_ids:\n        if os.path.exists(file_path):\n            with open(file_path, \"r\") as f:\n                return [line.strip() for line in f.readlines()]\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collections = root_catalog.get_child(collection_id).get_collections()\n\n    if return_ids:\n        collection_ids = [collection.id for collection in collections]\n        with open(file_path, \"w\") as f:\n            f.write(\"\\n\".join(collection_ids))\n        return collection_ids\n\n    else:\n        return collections\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_collection_url","title":"<code>maxar_collection_url(collection, dtype='geojson', raw=True)</code>","text":"<p>Retrieve the URL to a Maxar Open Data collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>dtype</code> <code>str</code> <p>The data type. It can be 'geojson' or 'tsv'. Defaults to 'geojson'.</p> <code>'geojson'</code> <code>raw</code> <code>bool</code> <p>If True, return the raw URL. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL to the collection.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_collection_url(collection, dtype=\"geojson\", raw=True):\n    \"\"\"Retrieve the URL to a Maxar Open Data collection.\n\n    Args:\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        dtype (str, optional): The data type. It can be 'geojson' or 'tsv'. Defaults to 'geojson'.\n        raw (bool, optional): If True, return the raw URL. Defaults to True.\n\n    Returns:\n        str: The URL to the collection.\n    \"\"\"\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    if dtype not in [\"geojson\", \"tsv\"]:\n        raise ValueError(f\"Invalid dtype. It can be 'geojson' or 'tsv'.\")\n\n    if raw:\n        url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}.{dtype}\"\n    else:\n        url = f\"https://github.com/giswqs/maxar-open-data/blob/master/datasets/{collection}.{dtype}\"\n    return url\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_collections","title":"<code>maxar_collections(return_ids=True, **kwargs)</code>","text":"<p>Get a list of Maxar collections.</p> <p>Parameters:</p> Name Type Description Default <code>return_ids</code> <code>bool</code> <p>Whether to return the collection ids. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list </code> <p>A list of Maxar collections.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_collections(return_ids: Optional[bool] = True, **kwargs) -&gt; List:\n    \"\"\"Get a list of Maxar collections.\n\n    Args:\n        return_ids (bool, optional): Whether to return the collection ids. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        list : A list of Maxar collections.\n    \"\"\"\n\n    import tempfile\n    from pystac import Catalog\n    import pandas as pd\n\n    if return_ids:\n        url = \"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets.csv\"\n        df = pd.read_csv(url)\n        return df[\"dataset\"].tolist()\n\n    file_path = os.path.join(tempfile.gettempdir(), \"maxar-collections.txt\")\n    if return_ids:\n        if os.path.exists(file_path):\n            with open(file_path, \"r\") as f:\n                return [line.strip() for line in f.readlines()]\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collections = root_catalog.get_collections()\n\n    # if return_ids:\n    #     collection_ids = [collection.id for collection in collections]\n    #     with open(file_path, \"w\") as f:\n    #         f.write(\"\\n\".join(collection_ids))\n\n    #     return collection_ids\n    # else:\n    return collections\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_download","title":"<code>maxar_download(images, out_dir=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, overwrite=False)</code>","text":"<p>Download Mxar Open Data images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | images</code> <p>The list of image links or a file path to a geojson or tsv containing the Maxar download links.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_download(\n    images,\n    out_dir=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    overwrite=False,\n):\n    \"\"\"Download Mxar Open Data images.\n\n    Args:\n        images (str | images): The list of image links or a file path to a geojson or tsv containing the Maxar download links.\n        out_dir (str, optional): The output directory. Defaults to None.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n\n    \"\"\"\n    import gdown\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if isinstance(images, str):\n        if images.endswith(\".geojson\"):\n            import geopandas as gpd\n\n            data = gpd.read_file(images)\n            images = data[\"visual\"].tolist()\n        elif images.endswith(\".tsv\"):\n            import pandas as pd\n\n            data = pd.read_csv(images, sep=\"\\t\")\n            images = data[\"visual\"].tolist()\n        else:\n            raise ValueError(f\"Invalid file type. It can be 'geojson' or 'tsv'.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    for index, image in enumerate(images):\n        items = image.split(\"/\")\n        file_name = items[7] + \".tif\"\n        dir_name = items[-1].split(\"-\")[0]\n        if not os.path.exists(os.path.join(out_dir, dir_name)):\n            os.makedirs(os.path.join(out_dir, dir_name))\n        out_file = os.path.join(out_dir, dir_name, file_name)\n        if os.path.exists(out_file) and (not overwrite):\n            print(f\"{out_file} already exists. Skipping...\")\n            continue\n        if not quiet:\n            print(\n                f\"Downloading {str(index+1).zfill(len(str(len(images))))} out of {len(images)}: {dir_name}/{file_name}\"\n            )\n\n        gdown.download(\n            image, out_file, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n        )\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_items","title":"<code>maxar_items(collection_id, child_id, return_gdf=True, assets=['visual'], **kwargs)</code>","text":"<p>Retrieve STAC items from Maxar's public STAC API.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23 Use maxar_collections() to retrieve all available collection IDs.</p> required <code>child_id</code> <code>str</code> <p>The child collection ID, e.g., 1050050044DE7E00 Use maxar_child_collections() to retrieve all available child collection IDs.</p> required <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame. Defaults to True.</p> <code>True</code> <code>assets</code> <code>list</code> <p>A list of asset names to include in the GeoDataFrame. It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].</p> <code>['visual']</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Catalog.from_file() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | pystac.ItemCollection</code> <p>If return_gdf is True, return a GeoDataFrame.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_items(\n    collection_id: str,\n    child_id: str,\n    return_gdf: Optional[bool] = True,\n    assets: Optional[List] = [\"visual\"],\n    **kwargs,\n):\n    \"\"\"Retrieve STAC items from Maxar's public STAC API.\n\n    Args:\n        collection_id (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23\n            Use maxar_collections() to retrieve all available collection IDs.\n        child_id (str): The child collection ID, e.g., 1050050044DE7E00\n            Use maxar_child_collections() to retrieve all available child collection IDs.\n        return_gdf (bool, optional): If True, return a GeoDataFrame. Defaults to True.\n        assets (list, optional): A list of asset names to include in the GeoDataFrame.\n            It can be \"visual\", \"ms_analytic\", \"pan_analytic\", \"data-mask\". Defaults to ['visual'].\n        **kwargs: Additional keyword arguments to pass to the pystac Catalog.from_file() method.\n\n    Returns:\n        GeoDataFrame | pystac.ItemCollection: If return_gdf is True, return a GeoDataFrame.\n    \"\"\"\n\n    import pickle\n    import tempfile\n    from pystac import Catalog, ItemCollection\n\n    file_path = os.path.join(\n        tempfile.gettempdir(), f\"maxar-{collection_id}-{child_id}.pkl\"\n    )\n\n    if os.path.exists(file_path):\n        with open(file_path, \"rb\") as f:\n            items = pickle.load(f)\n        if return_gdf:\n            import geopandas as gpd\n\n            gdf = gpd.GeoDataFrame.from_features(\n                pystac.ItemCollection(items).to_dict(), crs=\"EPSG:4326\"\n            )\n            # convert bbox column type from list to string\n            gdf[\"proj:bbox\"] = [\",\".join(map(str, l)) for l in gdf[\"proj:bbox\"]]\n            if assets is not None:\n                if isinstance(assets, str):\n                    assets = [assets]\n                elif not isinstance(assets, list):\n                    raise ValueError(\"assets must be a list or a string.\")\n\n                for asset in assets:\n                    links = []\n                    for item in items:\n                        if asset in item.get_assets():\n                            link = item.get_assets()[asset].get_absolute_href()\n                            links.append(link)\n                        else:\n                            links.append(\"\")\n\n                    gdf[asset] = links\n\n            return gdf\n        else:\n            return items\n\n    if \"MAXAR_STAC_API\" in os.environ:\n        url = os.environ[\"MAXAR_STAC_API\"]\n    else:\n        url = \"https://maxar-opendata.s3.amazonaws.com/events/catalog.json\"\n\n    root_catalog = Catalog.from_file(url, **kwargs)\n\n    collection = root_catalog.get_child(collection_id)\n    child = collection.get_child(child_id)\n\n    items = ItemCollection(child.get_all_items())\n\n    with open(file_path, \"wb\") as f:\n        pickle.dump(items, f)\n\n    if return_gdf:\n        import geopandas as gpd\n\n        gdf = gpd.GeoDataFrame.from_features(\n            pystac.ItemCollection(items).to_dict(), crs=\"EPSG:4326\"\n        )\n        # convert bbox column type from list to string\n        gdf[\"proj:bbox\"] = [\",\".join(map(str, l)) for l in gdf[\"proj:bbox\"]]\n        if assets is not None:\n            if isinstance(assets, str):\n                assets = [assets]\n            elif not isinstance(assets, list):\n                raise ValueError(\"assets must be a list or a string.\")\n\n            for asset in assets:\n                links = []\n                for item in items:\n                    if asset in item.get_assets():\n                        link = item.get_assets()[asset].get_absolute_href()\n                        links.append(link)\n                    else:\n                        links.append(\"\")\n\n                gdf[asset] = links\n\n        return gdf\n    else:\n        return items\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_refresh","title":"<code>maxar_refresh()</code>","text":"<p>Refresh the cached Maxar STAC items.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_refresh():\n    \"\"\"Refresh the cached Maxar STAC items.\"\"\"\n    import tempfile\n\n    temp_dir = tempfile.gettempdir()\n    for f in os.listdir(temp_dir):\n        if f.startswith(\"maxar-\"):\n            os.remove(os.path.join(temp_dir, f))\n\n    print(\"Maxar STAC items cache has been refreshed.\")\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_search","title":"<code>maxar_search(collection, start_date=None, end_date=None, bbox=None, within=False, align=True)</code>","text":"<p>Search Maxar Open Data by collection ID, date range, and/or bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>start_date</code> <code>str</code> <p>The start date, e.g., 2023-01-01. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date, e.g., 2023-12-31. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>list | GeoDataFrame</code> <p>The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.</p> <code>None</code> <code>within</code> <code>bool</code> <p>Whether to filter by the bounding box or the bounding box's interior. Defaults to False.</p> <code>False</code> <code>align</code> <code>bool</code> <p>If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing the search results.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_search(\n    collection, start_date=None, end_date=None, bbox=None, within=False, align=True\n):\n    \"\"\"Search Maxar Open Data by collection ID, date range, and/or bounding box.\n\n    Args:\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        start_date (str, optional): The start date, e.g., 2023-01-01. Defaults to None.\n        end_date (str, optional): The end date, e.g., 2023-12-31. Defaults to None.\n        bbox (list | GeoDataFrame): The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.\n        within (bool, optional): Whether to filter by the bounding box or the bounding box's interior. Defaults to False.\n        align (bool, optional): If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame containing the search results.\n    \"\"\"\n    import datetime\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}.geojson\"\n    data = gpd.read_file(url)\n\n    if bbox is not None:\n        bbox = gpd.GeoDataFrame(\n            geometry=[Polygon.from_bounds(*bbox)],\n            crs=\"epsg:4326\",\n        )\n        if within:\n            data = data[data.within(bbox.unary_union, align=align)]\n        else:\n            data = data[data.intersects(bbox.unary_union, align=align)]\n\n    date_field = \"datetime\"\n    new_field = f\"{date_field}_temp\"\n    data[new_field] = pd.to_datetime(data[date_field])\n\n    if end_date is None:\n        end_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    if start_date is None:\n        start_date = data[new_field].min()\n\n    mask = (data[new_field] &gt;= start_date) &amp; (data[new_field] &lt;= end_date)\n    result = data.loc[mask]\n    return result.drop(columns=[new_field], axis=1)\n</code></pre>"},{"location":"stac/#leafmap.stac.maxar_tile_url","title":"<code>maxar_tile_url(collection, tile, dtype='geojson', raw=True)</code>","text":"<p>Retrieve the URL to a Maxar Open Data tile.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The collection ID, e.g., Kahramanmaras-turkey-earthquake-23. Use maxar_collections() to retrieve all available collection IDs.</p> required <code>tile</code> <code>str</code> <p>The tile ID, e.g., 10300500D9F8E600.</p> required <code>dtype</code> <code>str</code> <p>The data type. It can be 'geojson', 'json' or 'tsv'. Defaults to 'geojson'.</p> <code>'geojson'</code> <code>raw</code> <code>bool</code> <p>If True, return the raw URL. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL to the tile.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def maxar_tile_url(collection, tile, dtype=\"geojson\", raw=True):\n    \"\"\"Retrieve the URL to a Maxar Open Data tile.\n\n    Args:\n\n        collection (str): The collection ID, e.g., Kahramanmaras-turkey-earthquake-23.\n            Use maxar_collections() to retrieve all available collection IDs.\n        tile (str): The tile ID, e.g., 10300500D9F8E600.\n        dtype (str, optional): The data type. It can be 'geojson', 'json' or 'tsv'. Defaults to 'geojson'.\n        raw (bool, optional): If True, return the raw URL. Defaults to True.\n\n    Returns:\n        str: The URL to the tile.\n    \"\"\"\n\n    collections = maxar_collections()\n    if collection not in collections:\n        raise ValueError(\n            f\"Invalid collection name. Use maxar_collections() to retrieve all available collection IDs.\"\n        )\n\n    if dtype not in [\"geojson\", \"json\", \"tsv\"]:\n        raise ValueError(f\"Invalid dtype. It can be 'geojson', 'json' or 'tsv'.\")\n\n    if raw:\n        url = f\"https://raw.githubusercontent.com/giswqs/maxar-open-data/master/datasets/{collection}/{tile}.{dtype}\"\n    else:\n        url = f\"https://github.com/giswqs/maxar-open-data/blob/master/datasets/{collection}/{tile}.{dtype}\"\n\n    return url\n</code></pre>"},{"location":"stac/#leafmap.stac.oam_search","title":"<code>oam_search(bbox=None, start_date=None, end_date=None, limit=100, return_gdf=True, **kwargs)</code>","text":"<p>Search OpenAerialMap (https://openaerialmap.org) and return a GeoDataFrame or list of image metadata.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | str</code> <p>The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 100.</p> <code>100</code> <code>return_gdf</code> <code>bool</code> <p>If True, return a GeoDataFrame, otherwise return a list. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame | list</code> <p>If return_gdf is True, return a GeoDataFrame. Otherwise, return a list.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def oam_search(\n    bbox=None, start_date=None, end_date=None, limit=100, return_gdf=True, **kwargs\n):\n    \"\"\"Search OpenAerialMap (https://openaerialmap.org) and return a GeoDataFrame or list of image metadata.\n\n    Args:\n        bbox (list | str, optional): The bounding box [xmin, ymin, xmax, ymax] to search within. Defaults to None.\n        start_date (str, optional): The start date to search within, such as \"2015-04-20T00:00:00.000Z\". Defaults to None.\n        end_date (str, optional): The end date to search within, such as \"2015-04-21T00:00:00.000Z\". Defaults to None.\n        limit (int, optional): The maximum number of results to return. Defaults to 100.\n        return_gdf (bool, optional): If True, return a GeoDataFrame, otherwise return a list. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the API. See https://hotosm.github.io/oam-api/\n\n    Returns:\n        GeoDataFrame | list: If return_gdf is True, return a GeoDataFrame. Otherwise, return a list.\n    \"\"\"\n\n    if return_gdf:\n        import pandas as pd\n        from shapely.geometry import Polygon\n        import geopandas as gpd\n\n    url = \"https://api.openaerialmap.org/meta\"\n    if bbox is not None:\n        if isinstance(bbox, str):\n            bbox = [float(x) for x in bbox.split(\",\")]\n        if not isinstance(bbox, list):\n            raise ValueError(\"bbox must be a list.\")\n        if len(bbox) != 4:\n            raise ValueError(\"bbox must be a list of 4 numbers.\")\n        bbox = \",\".join(map(str, bbox))\n        kwargs[\"bbox\"] = bbox\n\n    if start_date is not None:\n        kwargs[\"acquisition_from\"] = start_date\n\n    if end_date is not None:\n        kwargs[\"acquisition_to\"] = end_date\n\n    if limit is not None:\n        kwargs[\"limit\"] = limit\n\n    try:\n        r = requests.get(url, params=kwargs).json()\n        if \"results\" in r:\n            results = []\n            for result in r[\"results\"]:\n                if \"geojson\" in result:\n                    del result[\"geojson\"]\n                if \"projection\" in result:\n                    del result[\"projection\"]\n                if \"footprint\" in result:\n                    del result[\"footprint\"]\n                result = flatten_dict(result)\n                results.append(result)\n\n            if not return_gdf:\n                return results\n            else:\n                df = pd.DataFrame(results)\n\n                polygons = [Polygon.from_bounds(*bbox) for bbox in df[\"bbox\"]]\n                gdf = gpd.GeoDataFrame(geometry=polygons, crs=\"epsg:4326\")\n\n                return pd.concat([gdf, df], axis=1)\n\n        else:\n            print(\"No results found.\")\n            return None\n\n    except Exception as e:\n        return None\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_assets","title":"<code>stac_assets(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get all assets of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of assets.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_assets(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get all assets of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of assets.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/assets\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_assets(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_bands","title":"<code>stac_bands(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band names of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of band names</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_bands(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band names of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of band names\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/assets\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_assets(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_bounds","title":"<code>stac_bounds(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_bounds(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get the bounding box of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n        response = requests.get(url)\n        r = response.json()\n        if \"mosaicjson\" in r:\n            if \"bounds\" in r:\n                return r[\"bounds\"]\n\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/bounds\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_bounds(), params=kwargs).json()\n\n    bounds = r[\"bounds\"]\n    return bounds\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_center","title":"<code>stac_center(url=None, collection=None, item=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing (longitude, latitude)</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_center(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; Tuple[float, float]:\n    \"\"\"Get the centroid of a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        tuple: A tuple representing (longitude, latitude)\n    \"\"\"\n    bounds = stac_bounds(url, collection, item, titiler_endpoint, **kwargs)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lon, lat)\n    return center\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_client","title":"<code>stac_client(url, headers=None, parameters=None, ignore_conformance=False, modifier=None, request_modifier=None, stac_io=None, return_col_id=False, get_root=True, **kwargs)</code>","text":"<p>Get the STAC client. It wraps the pystac.Client.open() method. See     https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of a STAC Catalog.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of additional headers to use in all requests made to any part of this Catalog/API. Defaults to None.</p> <code>None</code> <code>parameters</code> <code>dict</code> <p>Optional dictionary of query string parameters to include in all requests. Defaults to None.</p> <code>None</code> <code>ignore_conformance</code> <code>bool</code> <p>Ignore any advertised Conformance Classes in this Catalog/API. This means that functions will skip checking conformance, and may throw an unknown error if that feature is not supported, rather than a NotImplementedError. Defaults to False.</p> <code>False</code> <code>modifier</code> <code>function</code> <p>A callable that modifies the children collection and items returned by this Client. This can be useful for injecting authentication parameters into child assets to access data from non-public sources. Defaults to None.</p> <code>None</code> <code>request_modifier</code> <code>function</code> <p>A callable that either modifies a Request instance or returns a new one. This can be useful for injecting Authentication headers and/or signing fully-formed requests (e.g. signing requests using AWS SigV4). The callable should expect a single argument, which will be an instance of requests.Request. If the callable returns a requests.Request, that will be used. Alternately, the callable may simply modify the provided request object and return None.</p> <code>None</code> <code>stac_io</code> <code>pystac.stac_io</code> <p>A StacApiIO object to use for I/O requests. Generally, leave this to the default. However in cases where customized I/O processing is required, a custom instance can be provided here.</p> <code>None</code> <code>return_col_id</code> <code>bool</code> <p>Return the collection ID. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac.Client.open() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>pystac.Client</code> <p>The STAC client.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_client(\n    url: str,\n    headers: Optional[Dict] = None,\n    parameters: Optional[Dict] = None,\n    ignore_conformance: Optional[bool] = False,\n    modifier: Optional[Callable] = None,\n    request_modifier: Optional[Callable] = None,\n    stac_io=None,\n    return_col_id: Optional[bool] = False,\n    get_root: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Get the STAC client. It wraps the pystac.Client.open() method. See\n        https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open\n\n    Args:\n        url (str): The URL of a STAC Catalog.\n        headers (dict, optional):  A dictionary of additional headers to use in all requests\n            made to any part of this Catalog/API. Defaults to None.\n        parameters (dict, optional): Optional dictionary of query string parameters to include in all requests.\n            Defaults to None.\n        ignore_conformance (bool, optional): Ignore any advertised Conformance Classes in this Catalog/API.\n            This means that functions will skip checking conformance, and may throw an unknown error\n            if that feature is not supported, rather than a NotImplementedError. Defaults to False.\n        modifier (function, optional): A callable that modifies the children collection and items\n            returned by this Client. This can be useful for injecting authentication parameters\n            into child assets to access data from non-public sources. Defaults to None.\n        request_modifier (function, optional): A callable that either modifies a Request instance or returns\n            a new one. This can be useful for injecting Authentication headers and/or signing fully-formed\n            requests (e.g. signing requests using AWS SigV4). The callable should expect a single argument,\n            which will be an instance of requests.Request. If the callable returns a requests.Request, that\n            will be used. Alternately, the callable may simply modify the provided request object and\n            return None.\n        stac_io (pystac.stac_io, optional): A StacApiIO object to use for I/O requests. Generally, leave\n            this to the default. However in cases where customized I/O processing is required, a custom\n            instance can be provided here.\n        return_col_id (bool, optional): Return the collection ID. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pystac.Client.open() method.\n\n    Returns:\n        pystac.Client: The STAC client.\n    \"\"\"\n    from pystac_client import Client\n\n    collection_id = None\n\n    if not get_root:\n        return_col_id = False\n\n    try:\n        if get_root:\n            root = stac_root_link(url, return_col_id=return_col_id)\n        else:\n            root = url\n\n        if return_col_id:\n            client = Client.open(\n                root[0],\n                headers,\n                parameters,\n                ignore_conformance,\n                modifier,\n                request_modifier,\n                stac_io,\n                **kwargs,\n            )\n            collection_id = root[1]\n            return client, collection_id\n        else:\n            client = Client.open(\n                root,\n                headers,\n                parameters,\n                ignore_conformance,\n                modifier,\n                request_modifier,\n                stac_io,\n                **kwargs,\n            )\n            return client, client.id\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_collections","title":"<code>stac_collections(url, return_ids=False, get_root=True, **kwargs)</code>","text":"<p>Get the collection IDs of a STAC catalog.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC catalog URL.</p> required <code>return_ids</code> <code>bool</code> <p>Return collection IDs. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the stac_client() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of collection IDs.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_collections(\n    url: str, return_ids: Optional[bool] = False, get_root=True, **kwargs\n) -&gt; List:\n    \"\"\"Get the collection IDs of a STAC catalog.\n\n    Args:\n        url (str): The STAC catalog URL.\n        return_ids (bool, optional): Return collection IDs. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the stac_client() method.\n\n    Returns:\n        list: A list of collection IDs.\n    \"\"\"\n    try:\n        client, _ = stac_client(url, get_root=get_root, **kwargs)\n        collections = client.get_all_collections()\n\n        if return_ids:\n            return [c.id for c in collections]\n        else:\n            return collections\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_info","title":"<code>stac_info(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_info(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/info\", params=kwargs).json()\n    else:\n        r = requests.get(titiler_endpoint.url_for_stac_info(), params=kwargs).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_info_geojson","title":"<code>stac_info_geojson(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band info of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band info.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_info_geojson(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band info of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band info.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/info.geojson\", params=kwargs).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_info_geojson(), params=kwargs\n        ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_min_max","title":"<code>stac_min_max(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the min and max values of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_min_max(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get the min and max values of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    stats = stac_stats(url, collection, item, assets, titiler_endpoint, **kwargs)\n\n    values = stats.values()\n\n    min_values = [v[\"min\"] for v in values]\n    max_values = [v[\"max\"] for v in values]\n\n    return min(min_values), max(max_values)\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_object_type","title":"<code>stac_object_type(url, **kwargs)</code>","text":"<p>Get the STAC object type.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC object URL.</p> required <code>**kwargs</code> <p>Keyword arguments for pystac.STACObject.from_file(). Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The STAC object type, can be catalog, collection, or item.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_object_type(url: str, **kwargs) -&gt; str:\n    \"\"\"Get the STAC object type.\n\n    Args:\n        url (str): The STAC object URL.\n        **kwargs: Keyword arguments for pystac.STACObject.from_file(). Defaults to None.\n\n    Returns:\n        str: The STAC object type, can be catalog, collection, or item.\n    \"\"\"\n    try:\n        obj = pystac.STACObject.from_file(url, **kwargs)\n\n        if isinstance(obj, pystac.Collection):\n            return \"collection\"\n        elif isinstance(obj, pystac.Item):\n            return \"item\"\n        elif isinstance(obj, pystac.Catalog):\n            return \"catalog\"\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_pixel_value","title":"<code>stac_pixel_value(lon, lat, url=None, collection=None, item=None, assets=None, titiler_endpoint=None, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from STAC assets.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print out the error message. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of pixel values for each asset.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_pixel_value(\n    lon: float,\n    lat: float,\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    verbose: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Get pixel value from STAC assets.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print out the error message. Defaults to True.\n\n    Returns:\n        list: A dictionary of pixel values for each asset.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if assets is None:\n        assets = stac_assets(\n            url=url,\n            collection=collection,\n            item=item,\n            titiler_endpoint=titiler_endpoint,\n        )\n    kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n\n        r = requests.get(\n            f\"{titiler_endpoint}/stac/point/{lon},{lat}\", params=kwargs\n        ).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_pixel_value(lon, lat), params=kwargs\n        ).json()\n\n    if \"detail\" in r:\n        if verbose:\n            print(r[\"detail\"])\n        return None\n    else:\n        values = r[\"values\"]\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n        result = dict(zip(assets, values))\n        return result\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_root_link","title":"<code>stac_root_link(url, return_col_id=False, **kwargs)</code>","text":"<p>Get the root link of a STAC object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC object URL.</p> required <code>return_col_id</code> <code>bool</code> <p>Return the collection ID if the STAC object is a collection. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Keyword arguments for pystac.STACObject.from_file(). Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The root link of the STAC object.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_root_link(url: str, return_col_id: Optional[bool] = False, **kwargs) -&gt; str:\n    \"\"\"Get the root link of a STAC object.\n\n    Args:\n        url (str): The STAC object URL.\n        return_col_id (bool, optional): Return the collection ID if the STAC object is a collection. Defaults to False.\n        **kwargs: Keyword arguments for pystac.STACObject.from_file(). Defaults to None.\n\n    Returns:\n        str: The root link of the STAC object.\n    \"\"\"\n    collection_id = None\n    try:\n        obj = pystac.STACObject.from_file(url, **kwargs)\n        if isinstance(obj, pystac.Collection):\n            collection_id = obj.id\n        href = obj.get_root_link().get_href()\n\n        if not url.startswith(href):\n            href = obj.get_self_href()\n\n        if return_col_id:\n            return href, collection_id\n        else:\n            return href\n\n    except Exception as e:\n        print(e)\n        if return_col_id:\n            return None, None\n        else:\n            return None\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_search","title":"<code>stac_search(url, method='POST', max_items=None, limit=100, ids=None, collections=None, bbox=None, intersects=None, datetime=None, query=None, filter=None, filter_lang=None, sortby=None, fields=None, get_collection=False, get_items=False, get_assets=False, get_links=False, get_gdf=False, get_info=False, get_root=True, **kwargs)</code>","text":"<p>Search a STAC API. The function wraps the pysatc_client.Client.search() method. See     https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The STAC API URL.</p> required <code>method</code> <code>str</code> <p>The HTTP method to use when making a request to the service. This must be either \"GET\", \"POST\", or None. If None, this will default to \"POST\". If a \"POST\" request receives a 405 status for the response, it will automatically retry with \"GET\" for all subsequent requests. Defaults to \"POST\".</p> <code>'POST'</code> <code>max_items</code> <code>init</code> <p>The maximum number of items to return from the search, even if there are more matching results. This client to limit the total number of Items returned from the items(), item_collections(), and items_as_dicts methods(). The client will continue to request pages of items until the number of max items is reached. This parameter defaults to 100. Setting this to None will allow iteration over a possibly very large number of results.. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>A recommendation to the service as to the number of items to return per page of results. Defaults to 100.</p> <code>100</code> <code>ids</code> <code>list</code> <p>List of one or more Item ids to filter on. Defaults to None.</p> <code>None</code> <code>collections</code> <code>list</code> <p>List of one or more Collection IDs or pystac.Collection instances. Only Items in one of the provided Collections will be searched. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>list | tuple</code> <p>A list, tuple, or iterator representing a bounding box of 2D or 3D coordinates. Results will be filtered to only those intersecting the bounding box. Defaults to None.</p> <code>None</code> <code>intersects</code> <code>str | dict</code> <p>A string or dictionary representing a GeoJSON geometry, or an object that implements a geo_interface property, as supported by several libraries including Shapely, ArcPy, PySAL, and geojson. Results filtered to only those intersecting the geometry. Defaults to None.</p> <code>None</code> <code>datetime</code> <code>str</code> <p>Either a single datetime or datetime range used to filter results. You may express a single datetime using a datetime.datetime instance, a RFC 3339-compliant timestamp, or a simple date string (see below). Instances of datetime.datetime may be either timezone aware or unaware. Timezone aware instances will be converted to a UTC timestamp before being passed to the endpoint. Timezone unaware instances are assumed to represent UTC timestamps. You may represent a datetime range using a \"/\" separated string as described in the spec, or a list, tuple, or iterator of 2 timestamps or datetime instances. For open-ended ranges, use either \"..\" ('2020-01-01:00:00:00Z/..', ['2020-01-01:00:00:00Z', '..']) or a value of None (['2020-01-01:00:00:00Z', None]). If using a simple date string, the datetime can be specified in YYYY-mm-dd format, optionally truncating to YYYY-mm or just YYYY. Simple date strings will be expanded to include the entire time period. Defaults to None.</p> <code>None</code> <code>query</code> <code>list</code> <p>List or JSON of query parameters as per the STAC API query extension. such as {\"eo:cloud_cover\":{\"lt\":10}}. Defaults to None.</p> <code>None</code> <code>filter</code> <code>dict</code> <p>JSON of query parameters as per the STAC API filter extension. Defaults to None.</p> <code>None</code> <code>filter_lang</code> <code>str</code> <p>Language variant used in the filter body. If filter is a dictionary or not provided, defaults to \u2018cql2-json\u2019. If filter is a string, defaults to cql2-text. Defaults to None.</p> <code>None</code> <code>sortby</code> <code>str | list</code> <p>A single field or list of fields to sort the response by. such as [{ 'field': 'properties.eo:cloud_cover', 'direction': 'asc' }]. Defaults to None.</p> <code>None</code> <code>fields</code> <code>list</code> <p>A list of fields to include in the response. Note this may result in invalid STAC objects, as they may not have required fields. Use items_as_dicts to avoid object unmarshalling errors. Defaults to None.</p> <code>None</code> <code>get_collection</code> <code>bool</code> <p>True to return a pystac.ItemCollection. Defaults to False.</p> <code>False</code> <code>get_items</code> <code>bool</code> <p>True to return a list of pystac.Item. Defaults to False.</p> <code>False</code> <code>get_assets</code> <code>bool</code> <p>True to return a list of pystac.Asset. Defaults to False.</p> <code>False</code> <code>get_links</code> <code>bool</code> <p>True to return a list of links. Defaults to False.</p> <code>False</code> <code>get_gdf</code> <code>bool</code> <p>True to return a GeoDataFrame. Defaults to False.</p> <code>False</code> <code>get_info</code> <code>bool</code> <p>True to return a dictionary of STAC items. Defaults to False.</p> <code>False</code> <code>get_root</code> <code>bool</code> <p>Get the root link of the STAC object. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the stac_client() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list | pystac.ItemCollection </code> <p>The search results as a list of links or a pystac.ItemCollection.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_search(\n    url: str,\n    method: Optional[str] = \"POST\",\n    max_items: Optional[int] = None,\n    limit: Optional[int] = 100,\n    ids: Optional[List] = None,\n    collections: Optional[List] = None,\n    bbox: Optional[Union[List, Tuple]] = None,\n    intersects: Optional[Union[str, Dict]] = None,\n    datetime: Optional[str] = None,\n    query: Optional[List] = None,\n    filter: Optional[Dict] = None,\n    filter_lang: Optional[str] = None,\n    sortby: Optional[Union[List, str]] = None,\n    fields: Optional[List] = None,\n    get_collection: Optional[bool] = False,\n    get_items: Optional[bool] = False,\n    get_assets: Optional[bool] = False,\n    get_links: Optional[bool] = False,\n    get_gdf: Optional[bool] = False,\n    get_info: Optional[bool] = False,\n    get_root: Optional[bool] = True,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Search a STAC API. The function wraps the pysatc_client.Client.search() method. See\n        https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search\n\n    Args:\n        url (str): The STAC API URL.\n        method (str, optional): The HTTP method to use when making a request to the service.\n            This must be either \"GET\", \"POST\", or None. If None, this will default to \"POST\".\n            If a \"POST\" request receives a 405 status for the response, it will automatically\n            retry with \"GET\" for all subsequent requests. Defaults to \"POST\".\n        max_items (init, optional): The maximum number of items to return from the search,\n            even if there are more matching results. This client to limit the total number of\n            Items returned from the items(), item_collections(), and items_as_dicts methods().\n            The client will continue to request pages of items until the number of max items\n            is reached. This parameter defaults to 100. Setting this to None will allow iteration\n            over a possibly very large number of results.. Defaults to None.\n        limit (int, optional): A recommendation to the service as to the number of items to\n            return per page of results. Defaults to 100.\n        ids (list, optional): List of one or more Item ids to filter on. Defaults to None.\n        collections (list, optional): List of one or more Collection IDs or pystac.Collection instances.\n            Only Items in one of the provided Collections will be searched. Defaults to None.\n        bbox (list | tuple, optional): A list, tuple, or iterator representing a bounding box of 2D\n            or 3D coordinates. Results will be filtered to only those intersecting the bounding box.\n            Defaults to None.\n        intersects (str | dict, optional):  A string or dictionary representing a GeoJSON geometry, or\n            an object that implements a __geo_interface__ property, as supported by several\n            libraries including Shapely, ArcPy, PySAL, and geojson. Results filtered to only\n            those intersecting the geometry. Defaults to None.\n        datetime (str, optional): Either a single datetime or datetime range used to filter results.\n            You may express a single datetime using a datetime.datetime instance, a RFC 3339-compliant\n            timestamp, or a simple date string (see below). Instances of datetime.datetime may be either\n            timezone aware or unaware. Timezone aware instances will be converted to a UTC timestamp\n            before being passed to the endpoint. Timezone unaware instances are assumed to represent\n            UTC timestamps. You may represent a datetime range using a \"/\" separated string as described\n            in the spec, or a list, tuple, or iterator of 2 timestamps or datetime instances.\n            For open-ended ranges, use either \"..\" ('2020-01-01:00:00:00Z/..', ['2020-01-01:00:00:00Z', '..'])\n            or a value of None (['2020-01-01:00:00:00Z', None]). If using a simple date string,\n            the datetime can be specified in YYYY-mm-dd format, optionally truncating to\n            YYYY-mm or just YYYY. Simple date strings will be expanded to include the entire\n            time period. Defaults to None.\n        query (list, optional): List or JSON of query parameters as per the STAC API query extension.\n            such as {\"eo:cloud_cover\":{\"lt\":10}}. Defaults to None.\n        filter (dict, optional): JSON of query parameters as per the STAC API filter extension. Defaults to None.\n        filter_lang (str, optional): Language variant used in the filter body. If filter is a dictionary\n            or not provided, defaults to \u2018cql2-json\u2019. If filter is a string, defaults to cql2-text. Defaults to None.\n        sortby (str | list, optional): A single field or list of fields to sort the response by.\n            such as [{ 'field': 'properties.eo:cloud_cover', 'direction': 'asc' }]. Defaults to None.\n        fields (list, optional): A list of fields to include in the response. Note this may result in\n            invalid STAC objects, as they may not have required fields. Use items_as_dicts to avoid object\n            unmarshalling errors. Defaults to None.\n        get_collection (bool, optional): True to return a pystac.ItemCollection. Defaults to False.\n        get_items (bool, optional): True to return a list of pystac.Item. Defaults to False.\n        get_assets (bool, optional): True to return a list of pystac.Asset. Defaults to False.\n        get_links (bool, optional): True to return a list of links. Defaults to False.\n        get_gdf (bool, optional): True to return a GeoDataFrame. Defaults to False.\n        get_info (bool, optional): True to return a dictionary of STAC items. Defaults to False.\n        get_root (bool, optional): Get the root link of the STAC object. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the stac_client() function.\n\n    Returns:\n        list | pystac.ItemCollection : The search results as a list of links or a pystac.ItemCollection.\n    \"\"\"\n\n    client, collection_id = stac_client(\n        url, return_col_id=True, get_root=get_root, **kwargs\n    )\n\n    if client is None:\n        return None\n    else:\n        if isinstance(intersects, dict) and \"geometry\" in intersects:\n            intersects = intersects[\"geometry\"]\n\n        if collection_id is not None and collections is None:\n            collections = [collection_id]\n\n        search = client.search(\n            method=method,\n            max_items=max_items,\n            limit=limit,\n            ids=ids,\n            collections=collections,\n            bbox=bbox,\n            intersects=intersects,\n            datetime=datetime,\n            query=query,\n            filter=filter,\n            filter_lang=filter_lang,\n            sortby=sortby,\n            fields=fields,\n        )\n\n        if get_collection:\n            return search.item_collection()\n        elif get_items:\n            return list(search.items())\n        elif get_assets:\n            assets = {}\n            for item in search.items():\n                assets[item.id] = {}\n                for key, value in item.get_assets().items():\n                    assets[item.id][key] = value.href\n            return assets\n        elif get_links:\n            return [item.get_self_href() for item in search.items()]\n        elif get_gdf:\n            import geopandas as gpd\n\n            gdf = gpd.GeoDataFrame.from_features(\n                search.item_collection().to_dict(), crs=\"EPSG:4326\"\n            )\n            return gdf\n        elif get_info:\n            items = search.items()\n            info = {}\n            for item in items:\n                info[item.id] = {\n                    \"id\": item.id,\n                    \"href\": item.get_self_href(),\n                    \"bands\": list(item.get_assets().keys()),\n                    \"assets\": item.get_assets(),\n                }\n            return info\n        else:\n            return search\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_search_to_df","title":"<code>stac_search_to_df(search, **kwargs)</code>","text":"<p>Convert STAC search result to a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the DataFrame.drop() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Pandas DataFrame object.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_search_to_df(search, **kwargs) -&gt; DataFrame:\n    \"\"\"Convert STAC search result to a DataFrame.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n        **kwargs: Additional keyword arguments to pass to the DataFrame.drop() function.\n\n    Returns:\n        DataFrame: A Pandas DataFrame object.\n    \"\"\"\n    gdf = stac_search_to_gdf(search)\n    return gdf.drop(columns=[\"geometry\"], **kwargs)\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_search_to_dict","title":"<code>stac_search_to_dict(search, **kwargs)</code>","text":"<p>Convert STAC search result to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of STAC items, with the stac item id as the key, and the stac item as the value.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_search_to_dict(search, **kwargs) -&gt; Dict:\n    \"\"\"Convert STAC search result to a dictionary.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n\n    Returns:\n        dict: A dictionary of STAC items, with the stac item id as the key, and the stac item as the value.\n    \"\"\"\n\n    items = list(search.item_collection())\n    info = {}\n    for item in items:\n        info[item.id] = {\n            \"id\": item.id,\n            \"href\": item.get_self_href(),\n            \"bands\": list(item.get_assets().keys()),\n            \"assets\": item.get_assets(),\n        }\n        links = {}\n        assets = item.get_assets()\n        for key, value in assets.items():\n            links[key] = value.href\n        info[item.id][\"links\"] = links\n    return info\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_search_to_gdf","title":"<code>stac_search_to_gdf(search, **kwargs)</code>","text":"<p>Convert STAC search result to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the GeoDataFrame.from_features() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame object.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_search_to_gdf(search, **kwargs):\n    \"\"\"Convert STAC search result to a GeoDataFrame.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n        **kwargs: Additional keyword arguments to pass to the GeoDataFrame.from_features() function.\n\n    Returns:\n        GeoDataFrame: A GeoPandas GeoDataFrame object.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.GeoDataFrame.from_features(\n        search.item_collection().to_dict(), crs=\"EPSG:4326\", **kwargs\n    )\n    return gdf\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_search_to_list","title":"<code>stac_search_to_list(search, **kwargs)</code>","text":"<p>Convert STAC search result to a list.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>pystac_client.item_search</code> <p>The search result returned by leafmap.stac_search().</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of STAC items.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_search_to_list(search, **kwargs) -&gt; List:\n    \"\"\"Convert STAC search result to a list.\n\n    Args:\n        search (pystac_client.item_search): The search result returned by leafmap.stac_search().\n\n    Returns:\n        list: A list of STAC items.\n    \"\"\"\n\n    return search.item_collections()\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_stats","title":"<code>stac_stats(url=None, collection=None, item=None, assets=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get band statistics of a STAC item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A dictionary of band statistics.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_stats(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; List:\n    \"\"\"Get band statistics of a STAC item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        list: A dictionary of band statistics.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n    if assets is not None:\n        kwargs[\"assets\"] = assets\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(f\"{titiler_endpoint}/stac/statistics\", params=kwargs).json()\n    else:\n        r = requests.get(\n            titiler_endpoint.url_for_stac_statistics(), params=kwargs\n        ).json()\n\n    return r\n</code></pre>"},{"location":"stac/#leafmap.stac.stac_tile","title":"<code>stac_tile(url=None, collection=None, item=None, assets=None, bands=None, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json</p> <code>None</code> <code>collection</code> <code>str</code> <p>The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.</p> <code>None</code> <code>item</code> <code>str</code> <p>The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.</p> <code>None</code> <code>assets</code> <code>str | list</code> <p>The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].</p> <code>None</code> <code>bands</code> <code>list</code> <p>A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Returns the STAC Tile layer URL.</p> Source code in <code>leafmap/stac.py</code> <pre><code>def stac_tile(\n    url: str = None,\n    collection: str = None,\n    item: str = None,\n    assets: Union[str, List] = None,\n    bands: list = None,\n    titiler_endpoint: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Get a tile layer from a single SpatialTemporal Asset Catalog (STAC) item.\n\n    Args:\n        url (str): HTTP URL to a STAC item, e.g., https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\n        collection (str): The Microsoft Planetary Computer STAC collection ID, e.g., landsat-8-c2-l2.\n        item (str): The Microsoft Planetary Computer STAC item ID, e.g., LC08_L2SP_047027_20201204_02_T1.\n        assets (str | list): The Microsoft Planetary Computer STAC asset ID, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"].\n        bands (list): A list of band names, e.g., [\"SR_B7\", \"SR_B5\", \"SR_B4\"]\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"https://planetarycomputer.microsoft.com/api/data/v1\", \"planetary-computer\", \"pc\". Defaults to None.\n\n    Returns:\n        str: Returns the STAC Tile layer URL.\n    \"\"\"\n\n    if url is None and collection is None:\n        raise ValueError(\"Either url or collection must be specified.\")\n\n    if collection is not None and titiler_endpoint is None:\n        titiler_endpoint = \"planetary-computer\"\n\n    if url is not None:\n        kwargs[\"url\"] = url\n    if collection is not None:\n        kwargs[\"collection\"] = collection\n    if item is not None:\n        kwargs[\"item\"] = item\n\n    if \"palette\" in kwargs:\n        kwargs[\"colormap_name\"] = kwargs[\"palette\"].lower()\n        del kwargs[\"palette\"]\n\n    if isinstance(bands, list) and len(set(bands)) == 1:\n        bands = bands[0]\n\n    if isinstance(assets, list) and len(set(assets)) == 1:\n        assets = assets[0]\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if \"expression\" in kwargs and (\"asset_as_band\" not in kwargs):\n        kwargs[\"asset_as_band\"] = True\n\n    mosaic_json = False\n\n    if isinstance(titiler_endpoint, PlanetaryComputerEndpoint):\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n        if assets is None and (bands is not None):\n            assets = bands\n        else:\n            kwargs[\"bidx\"] = bands\n\n        kwargs[\"assets\"] = assets\n\n        if (\n            (assets is not None)\n            and (\"asset_expression\" not in kwargs)\n            and (\"expression\" not in kwargs)\n            and (\"rescale\" not in kwargs)\n        ):\n            stats = stac_stats(\n                collection=collection,\n                item=item,\n                assets=assets,\n                titiler_endpoint=titiler_endpoint,\n            )\n            if \"detail\" not in stats:\n                try:\n                    percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n                    percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n                except:\n                    percentile_2 = min(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_2\"]\n                            for s in stats\n                        ]\n                    )\n                    percentile_98 = max(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_98\"]\n                            for s in stats\n                        ]\n                    )\n                kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n            else:\n                print(stats[\"detail\"])  # When operation times out.\n\n    else:\n        data = requests.get(url).json()\n        if \"mosaicjson\" in data:\n            mosaic_json = True\n\n        if isinstance(bands, str):\n            bands = bands.split(\",\")\n        if isinstance(assets, str):\n            assets = assets.split(\",\")\n\n        if assets is None:\n            if bands is not None:\n                assets = bands\n            else:\n                bnames = stac_bands(url)\n                if isinstance(bnames, list):\n                    if len(bnames) &gt;= 3:\n                        assets = bnames[0:3]\n                    else:\n                        assets = bnames[0]\n                else:\n                    assets = None\n\n        else:\n            kwargs[\"asset_bidx\"] = bands\n        if assets is not None:\n            kwargs[\"assets\"] = assets\n\n        if (\n            (assets is not None)\n            and (\"asset_expression\" not in kwargs)\n            and (\"expression\" not in kwargs)\n            and (\"rescale\" not in kwargs)\n        ):\n            stats = stac_stats(\n                url=url,\n                assets=assets,\n                titiler_endpoint=titiler_endpoint,\n            )\n            if \"detail\" not in stats:\n                try:\n                    percentile_2 = min([stats[s][\"percentile_2\"] for s in stats])\n                    percentile_98 = max([stats[s][\"percentile_98\"] for s in stats])\n                except:\n                    percentile_2 = min(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_2\"]\n                            for s in stats\n                        ]\n                    )\n                    percentile_98 = max(\n                        [\n                            stats[s][list(stats[s].keys())[0]][\"percentile_98\"]\n                            for s in stats\n                        ]\n                    )\n                kwargs[\"rescale\"] = f\"{percentile_2},{percentile_98}\"\n            else:\n                print(stats[\"detail\"])  # When operation times out.\n\n    TileMatrixSetId = \"WebMercatorQuad\"\n    if \"TileMatrixSetId\" in kwargs.keys():\n        TileMatrixSetId = kwargs[\"TileMatrixSetId\"]\n        kwargs.pop(\"TileMatrixSetId\")\n\n    if mosaic_json:\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/tilejson.json\", params=kwargs\n        ).json()\n    else:\n        if isinstance(titiler_endpoint, str):\n            r = requests.get(\n                f\"{titiler_endpoint}/stac/{TileMatrixSetId}/tilejson.json\",\n                params=kwargs,\n            ).json()\n        else:\n            r = requests.get(titiler_endpoint.url_for_stac_item(), params=kwargs).json()\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"toolbar/","title":"toolbar module","text":"<p>Module for dealing with the toolbar.</p>"},{"location":"toolbar/#leafmap.toolbar.census_widget","title":"<code>census_widget(m)</code>","text":"<p>Widget for adding US Census data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def census_widget(m):\n    \"\"\"Widget for adding US Census data.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    # from owslib.wms import WebMapService\n\n    census_dict = get_census_dict()\n    m.add_census_data(\"Census 2020\", \"States\")\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"filter\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    wms = widgets.Dropdown(\n        options=census_dict.keys(),\n        value=\"Census 2020\",\n        description=\"WMS:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    layer = widgets.Dropdown(\n        options=census_dict[\"Census 2020\"][\"layers\"],\n        value=\"States\",\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Replace existing census data layer\",\n        value=True,\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    # output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        wms,\n        layer,\n        checkbox,\n        # output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def wms_change(change):\n        layer.options = census_dict[change[\"new\"]][\"layers\"]\n        layer.value = layer.options[0]\n\n    wms.observe(wms_change, \"value\")\n\n    def layer_change(change):\n        if change[\"new\"] != \"\":\n            if checkbox.value:\n                m.layers = m.layers[:-1]\n            m.add_census_data(wms.value, layer.value)\n\n            # with output:\n            #     w = WebMapService(census_dict[wms.value][\"url\"])\n            #     output.outputs = ()\n            #     print(w[layer.value].abstract)\n\n    layer.observe(layer_change, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.change_basemap","title":"<code>change_basemap(m, position='topright')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def change_basemap(m, position: Optional[str] = \"topright\"):\n    \"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): leafmap.Map.\n    \"\"\"\n    from .basemaps import get_xyz_dict\n    from .leafmap import basemaps, get_basemap\n\n    xyz_dict = get_xyz_dict()\n\n    value = \"OpenStreetMap\"\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n\n    def on_click(change):\n        if change[\"new\"]:\n            basemap_name = dropdown.value\n            if basemap_name not in m.get_layer_names():\n                m.add_basemap(basemap_name)\n                if basemap_name in xyz_dict:\n                    if \"bounds\" in xyz_dict[basemap_name]:\n                        bounds = xyz_dict[basemap_name][\"bounds\"]\n                        bounds = [\n                            bounds[0][1],\n                            bounds[0][0],\n                            bounds[1][1],\n                            bounds[1][0],\n                        ]\n                        m.zoom_to_bounds(bounds)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        m.toolbar_reset()\n        if m.basemap_ctrl is not None and m.basemap_ctrl in m.controls:\n            m.remove_control(m.basemap_ctrl)\n        basemap_widget.close()\n\n    close_btn.on_click(close_click)\n\n    basemap_control = ipyleaflet.WidgetControl(widget=basemap_widget, position=position)\n    m.add(basemap_control)\n    m.basemap_ctrl = basemap_control\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.download_osm","title":"<code>download_osm(m)</code>","text":"<p>Widget for downloading OSM data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def download_osm(m):\n    \"\"\"Widget for downloading OSM data.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Checkbox\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Option 1\", \"Option 2\", \"Option 3\"],\n        value=None,\n        description=\"Dropdown:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    int_slider = widgets.IntSlider(\n        min=1,\n        max=100,\n        description=\"Int Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label()\n\n    # widgets.jslink((int_slider, \"value\"), (int_slider_label, \"value\"))\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n\n    int_slider.observe(int_slider_changed, \"value\")\n\n    float_slider = widgets.FloatSlider(\n        min=1,\n        max=100,\n        description=\"Float Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    float_slider_label = widgets.Label()\n\n    # widgets.jslink((float_slider, \"value\"), (float_slider_label, \"value\"))\n    def float_slider_changed(change):\n        if change[\"new\"]:\n            float_slider_label.value = str(float_slider.value)\n\n    float_slider.observe(float_slider_changed, \"value\")\n\n    color = widgets.ColorPicker(\n        concise=False,\n        description=\"Color:\",\n        value=\"white\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    text = widgets.Text(\n        value=\"\",\n        description=\"Textbox:\",\n        placeholder=\"Placeholder\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Placeholder\",\n        layout=widgets.Layout(width=widget_width),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n    buttons.style.button_padding = \"0px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        widgets.HBox([int_slider, int_slider_label]),\n        widgets.HBox([float_slider, float_slider_label]),\n        dropdown,\n        text,\n        color,\n        textarea,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.edit_draw_gui","title":"<code>edit_draw_gui(m)</code>","text":"<p>Generates a tool GUI for editing vector data attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def edit_draw_gui(m):\n    \"\"\"Generates a tool GUI for editing vector data attribute table.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n    import pandas as pd\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    m.edit_mode = True\n\n    n_props = len(m.get_draw_props())\n    if n_props == 0:\n        n_props = 1\n\n    if \"MAX_PROPS\" in os.environ:\n        max_props = int(os.environ[\"MAX_PROPS\"])\n    else:\n        max_props = n_props + 10\n\n    sheet = ipysheet.from_dataframe(m.get_draw_props(n_props, return_df=True))\n    m.edit_sheet = sheet\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n    m.edit_output = output\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Edit attribute table\",\n        icon=\"pencil-square-o\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    open_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Open vector data\",\n        icon=\"folder-open\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    save_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Save to file\",\n        icon=\"floppy-o\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    refresh_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Get attribute\",\n        icon=\"refresh\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    m.edit_refresh = refresh_button\n\n    int_slider = widgets.IntSlider(\n        min=n_props,\n        max=max_props,\n        description=\"Rows:\",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"85px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label()\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"64px\"\n\n    with output:\n        output.outputs = ()\n        display(m.edit_sheet)\n\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n            m.edit_sheet.rows = int_slider.value\n            m.num_attributes = int_slider.value\n            with output:\n                output.outputs = ()\n                m.edit_sheet = ipysheet.from_dataframe(\n                    m.get_draw_props(n=int_slider.value, return_df=True)\n                )\n                display(m.edit_sheet)\n\n    int_slider.observe(int_slider_changed, \"value\")\n    m.num_attributes = int_slider.value\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [\n        close_button,\n        toolbar_button,\n        open_button,\n        save_button,\n        refresh_button,\n        int_slider,\n        int_slider_label,\n    ]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        output,\n        buttons,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.edit_mode = False\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def open_chooser_callback(chooser):\n        with output:\n            import geopandas as gpd\n\n            gdf = gpd.read_file(chooser.selected)\n            geojson = gdf_to_geojson(gdf, epsg=4326, tuple_to_list=True)\n            m.draw_control.data = m.draw_control.data + (geojson[\"features\"])\n            m.draw_features = m.draw_features + (geojson[\"features\"])\n            open_button.value = False\n\n            m.edit_props = gdf.drop([\"geometry\"], axis=1).columns.tolist()\n            int_slider.value = len(m.edit_props)\n\n        if m.open_control in m.controls:\n            m.remove_control(m.open_control)\n            delattr(m, \"open_control\")\n\n    def open_btn_click(change):\n        if change[\"new\"]:\n            save_button.value = False\n\n            open_chooser = FileChooser(\n                os.getcwd(),\n                sandbox_path=m.sandbox_path,\n                layout=widgets.Layout(width=\"454px\"),\n            )\n            open_chooser.filter_pattern = [\"*.shp\", \"*.geojson\", \"*.gpkg\"]\n            open_chooser.use_dir_icons = True\n            open_chooser.register_callback(open_chooser_callback)\n\n            open_control = ipyleaflet.WidgetControl(\n                widget=open_chooser, position=\"topright\"\n            )\n            m.add(open_control)\n            m.open_control = open_control\n\n    open_button.observe(open_btn_click, \"value\")\n\n    def chooser_callback(chooser):\n        m.save_draw_features(chooser.selected, indent=None)\n        if m.file_control in m.controls:\n            m.remove_control(m.file_control)\n            delattr(m, \"file_control\")\n        with output:\n            print(f\"Saved to {chooser.selected}\")\n\n    def save_btn_click(change):\n        if change[\"new\"]:\n            save_button.value = False\n\n            file_chooser = FileChooser(\n                os.getcwd(),\n                sandbox_path=m.sandbox_path,\n                layout=widgets.Layout(width=\"454px\"),\n            )\n            file_chooser.filter_pattern = [\"*.shp\", \"*.geojson\", \"*.gpkg\"]\n            file_chooser.default_filename = \"data.geojson\"\n            file_chooser.use_dir_icons = True\n            file_chooser.register_callback(chooser_callback)\n\n            file_control = ipyleaflet.WidgetControl(\n                widget=file_chooser, position=\"topright\"\n            )\n            m.add(file_control)\n            m.file_control = file_control\n\n    save_button.observe(save_btn_click, \"value\")\n\n    def refresh_btn_click(change):\n        if change[\"new\"]:\n            refresh_button.value = False\n            if m.draw_control.last_action == \"edited\":\n                with output:\n                    geometries = [\n                        feature[\"geometry\"] for feature in m.draw_control.data\n                    ]\n                    if len(m.draw_features) &gt; 0:\n                        if (\n                            m.draw_features[-1][\"geometry\"]\n                            == m.draw_control.last_draw[\"geometry\"]\n                        ):\n                            m.draw_features.pop()\n                    for feature in m.draw_features:\n                        if feature[\"geometry\"] not in geometries:\n                            feature[\"geometry\"] = m.draw_control.last_draw[\"geometry\"]\n                            values = []\n                            props = ipysheet.to_dataframe(m.edit_sheet)[\"Key\"].tolist()\n                            for prop in props:\n                                if prop in feature[\"properties\"]:\n                                    values.append(feature[\"properties\"][prop])\n                                else:\n                                    values.append(\"\")\n                            df = pd.DataFrame({\"Key\": props, \"Value\": values})\n                            df.index += 1\n                            m.edit_sheet = ipysheet.from_dataframe(df)\n                            output.outputs = ()\n                            display(m.edit_sheet)\n\n    refresh_button.observe(refresh_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                display(m.edit_sheet)\n                if len(m.draw_control.data) == 0:\n                    print(\"Please draw a feature first.\")\n                else:\n                    if m.draw_control.last_action == \"edited\":\n                        m.update_draw_features()\n                    m.update_draw_props(ipysheet.to_dataframe(m.edit_sheet))\n        elif change[\"new\"] == \"Reset\":\n            m.edit_sheet = ipysheet.from_dataframe(\n                m.get_draw_props(int_slider.value, return_df=True)\n            )\n            with output:\n                output.outputs = ()\n                display(m.edit_sheet)\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.edit_mode = False\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.inspector_gui","title":"<code>inspector_gui(m, position='topright', opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def inspector_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n\n    widget_width = \"250px\"\n    padding = \"0px 5px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if m is not None:\n        marker_cluster = ipyleaflet.MarkerCluster(name=\"Inspector Markers\")\n        setattr(m, \"pixel_values\", [])\n        setattr(m, \"marker_cluster\", marker_cluster)\n\n        if not hasattr(m, \"interact_mode\"):\n            setattr(m, \"interact_mode\", False)\n\n        if not hasattr(m, \"inspector_output\"):\n            inspector_output = widgets.Output(\n                layout=widgets.Layout(width=widget_width, padding=\"0px 5px 5px 5px\")\n            )\n            setattr(m, \"inspector_output\", inspector_output)\n\n        output = m.inspector_output\n        output.outputs = ()\n\n        if not hasattr(m, \"inspector_add_marker\"):\n            inspector_add_marker = widgets.Checkbox(\n                description=\"Add Marker at clicked location\",\n                value=True,\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_add_marker\", inspector_add_marker)\n        add_marker = m.inspector_add_marker\n\n        if not hasattr(m, \"inspector_bands_chk\"):\n            inspector_bands_chk = widgets.Checkbox(\n                description=\"Get pixel value for visible bands only\",\n                indent=False,\n                layout=widgets.Layout(padding=padding, width=widget_width),\n            )\n            setattr(m, \"inspector_bands_chk\", inspector_bands_chk)\n        bands_chk = m.inspector_bands_chk\n\n        if not hasattr(m, \"inspector_class_label\"):\n            inspector_label = widgets.Text(\n                value=\"\",\n                description=\"Class label:\",\n                placeholder=\"Add a label to the marker\",\n                style=style,\n                layout=widgets.Layout(width=widget_width, padding=padding),\n            )\n            setattr(m, \"inspector_class_label\", inspector_label)\n        label = m.inspector_class_label\n\n        options = []\n        if hasattr(m, \"cog_layer_dict\"):\n            options = list(m.cog_layer_dict.keys())\n            options.sort()\n        if len(options) == 0:\n            default_option = None\n        else:\n            default_option = options[0]\n        if not hasattr(m, \"inspector_dropdown\"):\n            inspector_dropdown = widgets.Dropdown(\n                options=options,\n                value=default_option,\n                description=\"Select a layer:\",\n                layout=widgets.Layout(width=widget_width, padding=padding),\n                style=style,\n            )\n            setattr(m, \"inspector_dropdown\", inspector_dropdown)\n\n        dropdown = m.inspector_dropdown\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"info\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Download\", \"Reset\", \"Close\"],\n        tooltips=[\"Download\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    if len(options) == 0:\n        with output:\n            print(\"No COG/STAC layers available\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        add_marker,\n        label,\n        dropdown,\n        bands_chk,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def chk_change(change):\n        if hasattr(m, \"pixel_values\"):\n            m.pixel_values = []\n        if hasattr(m, \"marker_cluster\"):\n            m.marker_cluster.markers = []\n        output.outputs = ()\n\n    bands_chk.observe(chk_change, \"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n\n                m.marker_cluster.markers = []\n                m.pixel_values = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Download\":\n            with output:\n                output.outputs = ()\n                if len(m.pixel_values) == 0:\n                    print(\n                        \"No pixel values available. Click on the map to start collection data.\"\n                    )\n                else:\n                    print(\"Downloading pixel values...\")\n                    df = pd.DataFrame(m.pixel_values)\n                    temp_csv = temp_file_path(\"csv\")\n                    df.to_csv(temp_csv, index=False)\n                    link = create_download_link(temp_csv)\n                    with output:\n                        output.outputs = ()\n                        display(link)\n        elif change[\"new\"] == \"Reset\":\n            label.value = \"\"\n            output.outputs = ()\n            if hasattr(m, \"pixel_values\"):\n                m.pixel_values = []\n            if hasattr(m, \"marker_cluster\"):\n                m.marker_cluster.markers = []\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                if hasattr(m, \"inspector_mode\"):\n                    delattr(m, \"inspector_mode\")\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                m.default_style = {\"cursor\": \"default\"}\n                m.marker_cluster.markers = []\n                marker_cluster_layer = m.find_layer(\"Inspector Markers\")\n                if marker_cluster_layer is not None:\n                    m.remove_layer(marker_cluster_layer)\n                m.pixel_values = []\n\n                if hasattr(m, \"pixel_values\"):\n                    delattr(m, \"pixel_values\")\n\n                if hasattr(m, \"marker_cluster\"):\n                    delattr(m, \"marker_cluster\")\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n\n    def handle_interaction(**kwargs):\n        latlon = kwargs.get(\"coordinates\")\n        lat = round(latlon[0], 4)\n        lon = round(latlon[1], 4)\n        if (\n            kwargs.get(\"type\") == \"click\"\n            and hasattr(m, \"inspector_mode\")\n            and m.inspector_mode\n        ):\n            m.default_style = {\"cursor\": \"wait\"}\n\n            with output:\n                output.outputs = ()\n                print(\"Getting pixel value ...\")\n\n                layer_dict = m.cog_layer_dict[dropdown.value]\n\n            if layer_dict[\"type\"] == \"STAC\":\n                if bands_chk.value:\n                    assets = layer_dict[\"assets\"]\n                else:\n                    assets = None\n\n                result = stac_pixel_value(\n                    lon,\n                    lat,\n                    layer_dict[\"url\"],\n                    layer_dict[\"collection\"],\n                    layer_dict[\"item\"],\n                    assets,\n                    layer_dict[\"titiler_endpoint\"],\n                    verbose=False,\n                )\n\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n\n                else:\n                    with output:\n                        output.clear_output()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n            elif layer_dict[\"type\"] == \"COG\":\n\n                if m.inspector_bands_chk.value:\n                    indexes = layer_dict[\"indexes\"]\n                else:\n                    indexes = list(range(1, len(layer_dict[\"band_names\"]) + 1))\n\n                result = cog_pixel_value(\n                    lon, lat, layer_dict[\"url\"], indexes, verbose=False\n                )\n                if result is not None:\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n                else:\n                    with output:\n                        output.outputs = ()\n                        print(\"No pixel value available\")\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n\n            elif layer_dict[\"type\"] == \"LOCAL\":\n                try:\n                    data = local_tile_pixel_value(\n                        lon, lat, layer_dict[\"tile_client\"], verbose=False\n                    )\n\n                    result = {}\n                    band_names = data.band_names\n                    values = data.array.data.tolist()\n                    for i, band in enumerate(band_names):\n                        result[band] = values[i]\n\n                    if m.inspector_bands_chk.value:\n                        vis_bands = m.cog_layer_dict[m.inspector_dropdown.value][\n                            \"vis_bands\"\n                        ]\n                        new_result = {}\n                        for key in result:\n                            if key in vis_bands:\n                                new_result[key] = result[key]\n                        result = new_result\n\n                    with output:\n                        output.clear_output()\n                        print(f\"lat, lon: {lat:.4f}, {lon:.4f}\\n\")\n                        for key in result:\n                            print(f\"{key}: {result[key]}\")\n\n                        result[\"latitude\"] = lat\n                        result[\"longitude\"] = lon\n                        result[\"label\"] = label.value\n                        m.pixel_values.append(result)\n                    if add_marker.value:\n                        markers = list(m.marker_cluster.markers)\n                        markers.append(ipyleaflet.Marker(location=latlon))\n                        m.marker_cluster.markers = markers\n\n                except Exception as e:\n                    with output:\n                        output.clear_output()\n                        print(e)\n                        bounds = m.cog_layer_dict[m.inspector_dropdown.value][\"bounds\"]\n                        m.zoom_to_bounds(bounds)\n\n            m.default_style = {\"cursor\": \"crosshair\"}\n\n    if m is not None:\n        if not hasattr(m, \"marker_cluster\"):\n            setattr(m, \"marker_cluster\", marker_cluster)\n        m.add(marker_cluster)\n\n        if not m.interact_mode:\n            m.on_interaction(handle_interaction)\n            m.interact_mode = True\n\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n\n        if not hasattr(m, \"inspector_mode\"):\n            if hasattr(m, \"cog_layer_dict\"):\n                setattr(m, \"inspector_mode\", True)\n            else:\n                setattr(m, \"inspector_mode\", False)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.layer_manager_gui","title":"<code>layer_manager_gui(m, position='topright', opened=True, return_widget=False)</code>","text":"<p>Creates a layer manager widget.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The geemap.Map object.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>return_widget</code> <code>bool</code> <p>Whether to return the widget. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/toolbar.py</code> <pre><code>def layer_manager_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    return_widget: Optional[bool] = False,\n):\n    \"\"\"Creates a layer manager widget.\n\n    Args:\n        m (geemap.Map): The geemap.Map object.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        return_widget (bool, optional): Whether to return the widget. Defaults to False.\n    \"\"\"\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layer Manager\",\n        icon=\"server\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = []\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_header]\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [layers_button]\n\n    layers_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            m.toolbar_reset()\n            if m.layer_manager is not None and m.layer_manager in m.controls:\n                m.remove_control(m.layer_manager)\n                m.layer_manager = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=False,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = True\n                else:\n                    for layer in m.layers:\n                        if hasattr(layer, \"visible\"):\n                            layer.visible = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            layers = [lyr for lyr in m.layers]\n\n            # if the layers contain unsupported layers (e.g., GeoJSON, GeoData), adds the ipyleaflet built-in LayerControl\n            if len(layers) &lt; (len(m.layers) - 1):\n                if m.layer_control is None:\n                    layer_control = ipyleaflet.LayersControl(position=\"topright\")\n                    m.layer_control = layer_control\n                if m.layer_control not in m.controls:\n                    m.add(m.layer_control)\n\n            # for non-TileLayer, use layer.style={'opacity':0, 'fillOpacity': 0} to turn layer off.\n            for layer in layers:\n                visible = True\n                if hasattr(layer, \"visible\"):\n                    visible = layer.visible\n                layer_chk = widgets.Checkbox(\n                    value=visible,\n                    description=layer.name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n\n                if layer in m.geojson_layers:\n                    try:\n                        opacity = max(\n                            layer.style[\"opacity\"], layer.style[\"fillOpacity\"]\n                        )\n                    except KeyError:\n                        opacity = 1.0\n                elif hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n                layer_settings = widgets.Button(\n                    icon=\"gear\",\n                    tooltip=layer.name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 0px\"\n                    ),\n                )\n\n                def layer_settings_click(b):\n                    if b.tooltip in m.cog_layer_dict:\n                        m._add_layer_editor(\n                            position=\"topright\",\n                            layer_dict=m.cog_layer_dict[b.tooltip],\n                        )\n\n                layer_settings.on_click(layer_settings_click)\n\n                def layer_opacity_changed(change):\n                    if change[\"new\"]:\n                        layer.style = {\n                            \"opacity\": change[\"new\"],\n                            \"fillOpacity\": change[\"new\"],\n                        }\n\n                if hasattr(layer, \"visible\"):\n                    widgets.jslink((layer_chk, \"value\"), (layer, \"visible\"))\n\n                if layer in m.geojson_layers:\n                    layer_opacity.observe(layer_opacity_changed, \"value\")\n                elif hasattr(layer, \"opacity\"):\n                    widgets.jsdlink((layer_opacity, \"value\"), (layer, \"opacity\"))\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n                m.layer_widget = layers_hbox\n\n            toolbar_header.children = [close_button, layers_button]\n            toolbar_footer.children = layers_hbox\n\n        else:\n            toolbar_header.children = [layers_button]\n\n    layers_button.observe(layers_btn_click, \"value\")\n    layers_button.value = opened\n\n    if not hasattr(m, \"layer_manager_widget\"):\n        m.layer_manager_widget = toolbar_footer\n\n    if return_widget:\n        return m.layer_widget\n    else:\n        layer_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if layer_control not in m.controls:\n            m.add_control(layer_control)\n            m.layer_manager = layer_control\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.main_toolbar","title":"<code>main_toolbar(m)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leafmap Map object.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def main_toolbar(m):\n    \"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (leafmap.Map): The leafmap Map object.\n    \"\"\"\n    all_tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n        \"globe\": {\n            \"name\": \"split_map\",\n            \"tooltip\": \"Split-panel map\",\n        },\n        \"adjust\": {\n            \"name\": \"planet\",\n            \"tooltip\": \"Planet imagery\",\n        },\n        \"folder-open\": {\n            \"name\": \"open_data\",\n            \"tooltip\": \"Open local vector/raster data\",\n        },\n        \"gears\": {\n            \"name\": \"whitebox\",\n            \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n        },\n        \"fast-forward\": {\n            \"name\": \"timeslider\",\n            \"tooltip\": \"Activate the time slider\",\n        },\n        \"eraser\": {\n            \"name\": \"eraser\",\n            \"tooltip\": \"Remove all drawn features\",\n        },\n        \"camera\": {\n            \"name\": \"save_map\",\n            \"tooltip\": \"Save map as HTML or image\",\n        },\n        \"filter\": {\n            \"name\": \"census\",\n            \"tooltip\": \"Get US Census data\",\n        },\n        \"info\": {\n            \"name\": \"inspector\",\n            \"tooltip\": \"Get COG/STAC pixel value\",\n        },\n        \"search\": {\n            \"name\": \"search_xyz\",\n            \"tooltip\": \"Search XYZ tile services\",\n        },\n        \"download\": {\n            \"name\": \"download_osm\",\n            \"tooltip\": \"Download OSM data\",\n        },\n        \"picture-o\": {\n            \"name\": \"raster\",\n            \"tooltip\": \"Open COG/STAC dataset\",\n        },\n        \"search-plus\": {\n            \"name\": \"search_geojson\",\n            \"tooltip\": \"Search features in GeoJSON layer\",\n        },\n        \"table\": {\n            \"name\": \"attribute_table\",\n            \"tooltip\": \"Open attribute table\",\n        },\n        \"pencil-square-o\": {\n            \"name\": \"edit_vector\",\n            \"tooltip\": \"Create vector data\",\n        },\n        \"stack-exchange\": {\n            \"name\": \"stac\",\n            \"tooltip\": \"Discover STAC Catalog\",\n        },\n        \"plane\": {\n            \"name\": \"oam\",\n            \"tooltip\": \"Search OpenAerialMap\",\n        },\n        # \"spinner\": {\n        #     \"name\": \"placeholder2\",\n        #     \"tooltip\": \"This is a placeholder\",\n        # },\n        # \"question\": {\n        #     \"name\": \"help\",\n        #     \"tooltip\": \"Get help\",\n        # },\n    }\n\n    # if m.sandbox_path is None and (os.environ.get(\"USE_VOILA\") is not None):\n    #     voila_tools = [\"camera\", \"folder-open\", \"gears\"]\n\n    #     for item in voila_tools:\n    #         if item in tools.keys():\n    #             del tools[item]\n\n    tools = {}\n    for tool in all_tools:\n        if os.environ.get(all_tools[tool][\"name\"].upper(), \"\").upper() != \"FALSE\":\n            tools[tool] = all_tools[tool]\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n    toolnames = [item[\"name\"].upper() for item in list(all_tools.values())]\n    toolnames.sort()\n    setattr(m, \"_ENV_VARS\", toolnames)\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"109px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    m.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n\n            if tool_name == \"basemap\":\n                change_basemap(m)\n            if tool_name == \"split_map\":\n                split_basemaps(m)\n            if tool_name == \"planet\":\n                split_basemaps(m, layers_dict=planet_tiles())\n            elif tool_name == \"open_data\":\n                open_data_widget(m)\n            elif tool_name == \"eraser\":\n                if m.draw_control is not None:\n                    m.draw_control.clear()\n                    m.user_roi = None\n                    m.user_rois = None\n                    m.draw_features = []\n            elif tool_name == \"whitebox\":\n                import whiteboxgui.whiteboxgui as wbt\n\n                tools_dict = wbt.get_wbt_dict()\n                wbt_toolbox = wbt.build_toolbox(\n                    tools_dict,\n                    max_width=\"800px\",\n                    max_height=\"500px\",\n                    sandbox_path=m.sandbox_path,\n                )\n                wbt_control = ipyleaflet.WidgetControl(\n                    widget=wbt_toolbox, position=\"bottomright\"\n                )\n                m.whitebox = wbt_control\n                m.add(wbt_control)\n            elif tool_name == \"timeslider\":\n                m.add_time_slider()\n            elif tool_name == \"save_map\":\n                save_map((m))\n            elif tool_name == \"census\":\n                census_widget(m)\n            elif tool_name == \"inspector\":\n                inspector_gui(m)\n            elif tool_name == \"search_xyz\":\n                search_basemaps(m)\n            elif tool_name == \"download_osm\":\n                download_osm(m)\n            elif tool_name == \"raster\":\n                open_raster_gui(m)\n            elif tool_name == \"search_geojson\":\n                search_geojson_gui(m)\n            elif tool_name == \"attribute_table\":\n                select_table_gui(m)\n            elif tool_name == \"edit_vector\":\n                edit_draw_gui(m)\n            elif tool_name == \"stac\":\n                stac_gui(m)\n            elif tool_name == \"oam\":\n                oam_search_gui(m)\n            elif tool_name == \"help\":\n                import webbrowser\n\n                webbrowser.open_new_tab(\"https://leafmap.org\")\n                current_tool.value = False\n        else:\n            # tool = change[\"owner\"]\n            # tool_name = tools[tool.icon][\"name\"]\n            pass\n\n        m.toolbar_reset()\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    m.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            toolbar_footer.children = layer_manager_gui(m, return_widget=True)\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    toolbar_control = ipyleaflet.WidgetControl(\n        widget=toolbar_widget, position=\"topright\"\n    )\n\n    m.add(toolbar_control)\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.nasa_data_gui","title":"<code>nasa_data_gui(m, position='topright', opened=True, default_dataset='GEDI_L4A_AGB_Density_V2_1_2056', **kwargs)</code>","text":"<p>Search NASA Earth data interactive</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>opened</code> <code>bool</code> <p>Whether to open the widget. Defaults to True.</p> <code>True</code> <code>default_dataset</code> <code>str</code> <p>The default dataset. Defaults to \"GEDI_L4A_AGB_Density_V2_1_2056\".</p> <code>'GEDI_L4A_AGB_Density_V2_1_2056'</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def nasa_data_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    default_dataset: Optional[str] = \"GEDI_L4A_AGB_Density_V2_1_2056\",\n    **kwargs,\n):\n    \"\"\"Search NASA Earth data interactive\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n        opened (bool, optional): Whether to open the widget. Defaults to True.\n        default_dataset (str, optional): The default dataset. Defaults to \"GEDI_L4A_AGB_Density_V2_1_2056\".\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    widget_width = \"400px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if not hasattr(m, \"_NASA_DATA\"):\n        url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\n        df = pd.read_csv(url, sep=\"\\t\")\n        setattr(m, \"_NASA_DATA\", df)\n        names = df[\"ShortName\"].tolist()\n        setattr(m, \"_NASA_DATA_NAMES\", names)\n\n    default_title = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == default_dataset][\n        \"EntryTitle\"\n    ].values[0]\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Search NASA Earth data\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Keyword:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    short_name = widgets.Dropdown(\n        options=m._NASA_DATA_NAMES,\n        value=default_dataset,\n        description=\"Short Name:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    title = widgets.Text(\n        value=default_title,\n        description=\"Title:\",\n        style=style,\n        disabled=True,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    max_items = widgets.IntText(\n        value=50,\n        description=\"Max items:\",\n        style=style,\n        layout=widgets.Layout(width=\"125px\", padding=padding),\n    )\n\n    bbox = widgets.Text(\n        value=\"\",\n        description=\"Bounding box:\",\n        placeholder=\"xmin, ymin, xmax, ymax\",\n        style=style,\n        layout=widgets.Layout(width=\"271px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"198px\", padding=padding),\n    )\n\n    dataset = widgets.Dropdown(\n        value=None,\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"65px\"\n\n    def change_keyword(change):\n        short_name.options = nasa_datasets(\n            keyword.value, df=m._NASA_DATA, return_short_name=True\n        )\n\n    keyword.on_submit(change_keyword)\n\n    def change_dataset(change):\n        title.value = m._NASA_DATA[m._NASA_DATA[\"ShortName\"] == short_name.value][\n            \"EntryTitle\"\n        ].values[0]\n        dataset.value = None\n        dataset.options = []\n\n    short_name.observe(change_dataset, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        keyword,\n        short_name,\n        title,\n        widgets.HBox([max_items, bbox]),\n        widgets.HBox([start_date, end_date]),\n        dataset,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.clear_output()\n                with output:\n                    print(\"Searching...\")\n\n                    if bbox.value.strip() == \"\":\n                        if m.user_roi_bounds() is not None:\n                            bounds = tuple(m.user_roi_bounds())\n                        else:\n                            bounds = (\n                                m.bounds[0][1],\n                                m.bounds[0][0],\n                                m.bounds[1][1],\n                                m.bounds[1][0],\n                            )\n                    else:\n                        bounds = tuple(map(float, bbox.value.split(\",\")))\n                        if len(bounds) != 4:\n                            print(\"Please provide a valid bounding box.\")\n                            bounds = None\n\n                    if start_date.value is not None and end_date.value is not None:\n                        date_range = (str(start_date.value), str(end_date.value))\n                    elif start_date.value is not None:\n                        date_range = (\n                            str(start_date.value),\n                            datetime.today().strftime(\"%Y-%m-%d\"),\n                        )\n                    else:\n                        date_range = None\n\n                    output.clear_output(wait=True)\n                    try:\n                        results, gdf = nasa_data_search(\n                            count=max_items.value,\n                            short_name=short_name.value,\n                            bbox=bounds,\n                            temporal=date_range,\n                            return_gdf=True,\n                        )\n\n                        if len(results) &gt; 0:\n                            if \"Footprints\" in m.get_layer_names():\n                                m.remove(m.find_layer(\"Footprints\"))\n                            if (\n                                hasattr(m, \"_NASA_DATA_CTRL\")\n                                and m._NASA_DATA_CTRL in m.controls\n                            ):\n                                m.remove(m._NASA_DATA_CTRL)\n                            m.add_gdf(\n                                gdf,\n                                layer_name=\"Footprints\",\n                                info_mode=\"on_click\",\n                                zoom_to_layer=False,\n                            )\n                            setattr(m, \"_NASA_DATA_CTRL\", m.controls[-1])\n\n                            dataset.options = gdf[\"native-id\"].values.tolist()\n                            dataset.value = dataset.options[0]\n\n                            setattr(m, \"_NASA_DATA_GDF\", gdf)\n                            setattr(m, \"_NASA_DATA_RESULTS\", results)\n\n                    except Exception as e:\n                        print(e)\n\n        elif change[\"new\"] == \"Display\":\n            output.clear_output()\n            with output:\n                print(\"To be implemented...\")\n\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            short_name.options = m._NASA_DATA_NAMES\n            short_name.value = default_dataset\n            title.value = default_title\n            max_items.value = 50\n            bbox.value = \"Map bounds\"\n            start_date.value = None\n            end_date.value = None\n            dataset.options = []\n            dataset.value = None\n            output.clear_output()\n\n            if \"Footprints\" in m.get_layer_names():\n                m.remove(m.find_layer(\"Footprints\"))\n            if hasattr(m, \"_NASA_DATA_CTRL\") and m._NASA_DATA_CTRL in m.controls:\n                m.remove(m._NASA_DATA_CTRL)\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.oam_search_gui","title":"<code>oam_search_gui(m, position='topright', opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def oam_search_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"plane\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Map bounds\", \"User drawn ROI\", \"Custom bbox\"],\n        value=\"Map bounds\",\n        description=\"bbox:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"end date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Additional parameters\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Addition parameters as a dictionary, e.g., {'platform': 'UAV'}\",\n        layout=widgets.Layout(width=widget_width),\n    )\n\n    params_hbox = widgets.HBox()\n\n    def checkbox_changed(change):\n        if checkbox.value:\n            params_hbox.children = [textarea]\n        else:\n            params_hbox.children = []\n\n    checkbox.observe(checkbox_changed, \"value\")\n\n    int_slider = widgets.IntSlider(\n        value=100,\n        min=1,\n        max=200,\n        description=\"Limit: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label(\"100\")\n\n    def int_slider_changed(change):\n        if change[\"new\"]:\n            int_slider_label.value = str(int_slider.value)\n\n    int_slider.observe(int_slider_changed, \"value\")\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        dropdown,\n        start_date,\n        end_date,\n        widgets.HBox([int_slider, int_slider_label]),\n        checkbox,\n        params_hbox,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.outputs = ()\n                if m is not None:\n                    if dropdown.value == \"Map bounds\":\n                        bbox = m.get_bbox()\n                    elif dropdown.value == \"User drawn ROI\":\n                        bbox = m.user_roi_bounds()\n                    else:\n                        bbox = None\n\n                    if start_date.value is not None:\n                        start = str(start_date.value)\n                    else:\n                        start = None\n                    if end_date.value is not None:\n                        end = str(end_date.value)\n                    else:\n                        end = None\n\n                    if (\n                        checkbox.value\n                        and textarea.value.strip().startswith(\"{\")\n                        and textarea.value.strip().endswith(\"}\")\n                    ):\n                        params = eval(textarea.value)\n                    else:\n                        params = {}\n\n                    limit = int_slider.value\n\n                    m.oam_search(bbox, start, end, limit=limit, **params)\n\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            dropdown.value = \"Map bounds\"\n            start_date.value = None\n            end_date.value = None\n            checkbox.value = False\n            int_slider.value = 100\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.open_data_widget","title":"<code>open_data_widget(m)</code>","text":"<p>A widget for opening local vector/raster data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def open_data_widget(m):\n    \"\"\"A widget for opening local vector/raster data.\n\n    Args:\n        m (object): leafmap.Map\n    \"\"\"\n    import warnings\n    from .colormaps import list_colormaps\n\n    warnings.filterwarnings(\"ignore\")\n\n    padding = \"0px 0px 0px 5px\"\n    style = {\"description_width\": \"initial\"}\n\n    file_type = widgets.ToggleButtons(\n        options=[\"Shapefile\", \"GeoJSON\", \"CSV\", \"Vector\", \"Raster\"],\n        tooltips=[\n            \"Open a shapefile\",\n            \"Open a GeoJSON file\",\n            \"Open a vector dataset\",\n            \"Create points from CSV\",\n            \"Open a vector dataset\",\n            \"Open a raster dataset\",\n        ],\n    )\n    file_type.style.button_width = \"88px\"\n\n    filepath = widgets.Text(\n        value=\"\",\n        description=\"File path or http URL:\",\n        tooltip=\"Enter a file path or http URL to vector data\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n    http_widget = widgets.HBox()\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.filter_pattern = \"*.shp\"\n    file_chooser.use_dir_icons = True\n\n    layer_name = widgets.Text(\n        value=\"Shapefile\",\n        description=\"Enter a layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    longitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Longitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    latitude = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Latitude:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    label = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Label:\",\n        layout=widgets.Layout(width=\"149px\", padding=padding),\n        style=style,\n    )\n\n    point_check = widgets.Checkbox(\n        description=\"Is it a point layer?\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=\"150px\"),\n        style=style,\n    )\n\n    point_popup = widgets.SelectMultiple(\n        options=[\n            \"None\",\n        ],\n        value=[\"None\"],\n        description=\"Popup attributes:\",\n        disabled=False,\n        style=style,\n    )\n\n    csv_widget = widgets.HBox()\n    point_widget = widgets.HBox()\n\n    def point_layer_check(change):\n        if point_check.value:\n            if filepath.value.strip() != \"\":\n                m.default_style = {\"cursor\": \"wait\"}\n                point_popup.options = vector_col_names(filepath.value)\n                point_popup.value = [point_popup.options[0]]\n\n            point_widget.children = [point_check, point_popup]\n        else:\n            point_widget.children = [point_check]\n\n    point_check.observe(point_layer_check)\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    # ok_cancel.style.button_width = \"50px\"\n\n    bands = widgets.Text(\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Enter a list of band indices\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\"),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    palette = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"300px\"),\n        style=style,\n    )\n\n    raster_options = widgets.VBox()\n\n    def filepath_change(change):\n        if file_type.value == \"Raster\":\n            pass\n            # if (\n            #     filepath.value.startswith(\"http\")\n            #     or filepath.value.endswith(\".txt\")\n            #     or filepath.value.endswith(\".csv\")\n            # ):\n            #     bands.disabled = True\n            #     palette.disabled = False\n            #     # x_dim.disabled = True\n            #     # y_dim.disabled = True\n            # else:\n            #     bands.disabled = False\n            #     palette.disabled = False\n            #     # x_dim.disabled = True\n            #     # y_dim.disabled = True\n\n    filepath.observe(filepath_change, \"value\")\n\n    tool_output = widgets.Output(\n        layout=widgets.Layout(max_height=\"150px\", max_width=\"500px\", overflow=\"auto\")\n    )\n\n    main_widget = widgets.VBox(\n        [\n            file_type,\n            file_chooser,\n            http_widget,\n            csv_widget,\n            layer_name,\n            point_widget,\n            raster_options,\n            ok_cancel,\n            tool_output,\n        ]\n    )\n\n    tool_output_ctrl = ipyleaflet.WidgetControl(widget=main_widget, position=\"topright\")\n\n    if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n        m.remove_control(m.tool_output_ctrl)\n\n    def bands_changed(change):\n        if change[\"new\"] and \",\" in change[\"owner\"].value:\n            palette.value = None\n            palette.disabled = True\n        else:\n            palette.disabled = False\n\n    bands.observe(bands_changed, \"value\")\n\n    def chooser_callback(chooser):\n        filepath.value = file_chooser.selected\n\n        if file_type.value == \"CSV\":\n            import pandas as pd\n\n            df = pd.read_csv(filepath.value)\n            col_names = df.columns.values.tolist()\n            longitude.options = col_names\n            latitude.options = col_names\n            label.options = col_names\n\n            if \"longitude\" in col_names:\n                longitude.value = \"longitude\"\n            if \"latitude\" in col_names:\n                latitude.value = \"latitude\"\n            if \"name\" in col_names:\n                label.value = \"name\"\n\n    file_chooser.register_callback(chooser_callback)\n\n    def file_type_changed(change):\n        ok_cancel.value = None\n        file_chooser.default_path = os.getcwd()\n        file_chooser.reset()\n        layer_name.value = file_type.value\n        csv_widget.children = []\n        filepath.value = \"\"\n        tool_output.outputs = ()\n\n        if change[\"new\"] == \"Shapefile\":\n            file_chooser.filter_pattern = \"*.shp\"\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = []\n        elif change[\"new\"] == \"GeoJSON\":\n            file_chooser.filter_pattern = [\"*.geojson\", \"*.json\"]\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Vector\":\n            file_chooser.filter_pattern = \"*.*\"\n            raster_options.children = []\n            point_widget.children = [point_check]\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"CSV\":\n            file_chooser.filter_pattern = [\"*.csv\", \"*.CSV\"]\n            csv_widget.children = [longitude, latitude, label]\n            raster_options.children = []\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n        elif change[\"new\"] == \"Raster\":\n            file_chooser.filter_pattern = [\"*.tif\", \"*.img\"]\n            palette.options = list_colormaps(add_extra=True)\n            palette.value = None\n            raster_options.children = [\n                widgets.HBox([bands, vmin, vmax]),\n                widgets.HBox([nodata, palette]),\n            ]\n            point_widget.children = []\n            point_check.value = False\n            http_widget.children = [filepath]\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            m.default_style = {\"cursor\": \"wait\"}\n            file_path = filepath.value\n\n            with tool_output:\n                tool_output.outputs = ()\n                if file_path.strip() != \"\":\n                    ext = os.path.splitext(file_path)[1]\n                    if point_check.value:\n                        popup = list(point_popup.value)\n                        if len(popup) == 1:\n                            popup = popup[0]\n                        m.add_point_layer(\n                            file_path,\n                            popup=popup,\n                            layer_name=layer_name.value,\n                        )\n                    elif ext.lower() == \".shp\":\n                        m.add_shp(file_path, style={}, layer_name=layer_name.value)\n                    elif ext.lower() == \".geojson\":\n                        m.add_geojson(file_path, style={}, layer_name=layer_name.value)\n\n                    elif ext.lower() == \".csv\" and file_type.value == \"CSV\":\n                        m.add_xy_data(\n                            file_path,\n                            x=longitude.value,\n                            y=latitude.value,\n                            label=label.value,\n                            layer_name=layer_name.value,\n                        )\n\n                    elif (\n                        ext.lower() in [\".tif\", \"img\"]\n                    ) and file_type.value == \"Raster\":\n                        band = None\n                        vis_min = None\n                        vis_max = None\n                        vis_nodata = None\n\n                        try:\n                            if len(bands.value) &gt; 0:\n                                band = int(bands.value)\n                            if len(vmin.value) &gt; 0:\n                                vis_min = float(vmin.value)\n                            if len(vmax.value) &gt; 0:\n                                vis_max = float(vmax.value)\n                            if len(nodata.value) &gt; 0:\n                                vis_nodata = float(nodata.value)\n                        except Exception as _:\n                            pass\n\n                        m.add_raster(\n                            file_path,\n                            layer_name=layer_name.value,\n                            band=band,\n                            palette=palette.value,\n                            vmin=vis_min,\n                            vmax=vis_max,\n                            nodata=vis_nodata,\n                        )\n\n                else:\n                    print(\"Please select a file to open.\")\n\n            m.toolbar_reset()\n            m.default_style = {\"cursor\": \"default\"}\n\n        elif change[\"new\"] == \"Reset\":\n            file_chooser.reset()\n            tool_output.outputs = ()\n            filepath.value = \"\"\n            m.toolbar_reset()\n        elif change[\"new\"] == \"Close\":\n            if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n                m.remove_control(m.tool_output_ctrl)\n                m.tool_output_ctrl = None\n                m.toolbar_reset()\n\n        ok_cancel.value = None\n\n    file_type.observe(file_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n    # file_chooser.register_callback(chooser_callback)\n\n    m.add(tool_output_ctrl)\n    m.tool_output_ctrl = tool_output_ctrl\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.open_raster_gui","title":"<code>open_raster_gui(m)</code>","text":"<p>A widget for opening local/remote COG/STAC data.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def open_raster_gui(m):\n    \"\"\"A widget for opening local/remote COG/STAC data.\n\n    Args:\n        m (object): leafmap.Map\n    \"\"\"\n\n    padding = \"0px 0px 0px 5px\"\n    style = {\"description_width\": \"initial\"}\n\n    tool_output = widgets.Output(\n        layout=widgets.Layout(max_height=\"150px\", max_width=\"500px\", overflow=\"auto\")\n    )\n\n    file_type = widgets.ToggleButtons(\n        options=[\"GeoTIFF\", \"COG\", \"STAC\", \"Microsoft\"],\n        tooltips=[\n            \"Open a local GeoTIFF file\",\n            \"Open a remote COG file\",\n            \"Open a remote STAC item\",\n            \"Create COG from Microsoft Planetary Computer\",\n        ],\n    )\n    file_type.style.button_width = \"110px\"\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.filter_pattern = [\"*.tif\", \"*.tiff\"]\n    file_chooser.use_dir_icons = True\n\n    source_widget = widgets.VBox([file_chooser])\n\n    http_url = widgets.Text(\n        value=\"\",\n        description=\"HTTP URL:\",\n        tooltip=\"Enter an http URL to COG file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[\"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\"],\n        value=\"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\",\n        description=\"PC Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    items = widgets.Text(\n        value=\"LC08_L2SP_047027_20201204_02_T1\",\n        description=\"STAC Items:\",\n        tooltip=\"STAC Item ID\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    assets = widgets.Text(\n        value=\"SR_B7,SR_B5,SR_B4\",\n        description=\"STAC Assets:\",\n        tooltip=\"STAC Asset ID\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"GeoTIFF\",\n        description=\"Enter a layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    # ok_cancel.style.button_width = \"50px\"\n\n    bands = widgets.Text(\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Enter a list of band indices\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        value=None,\n        options=[],\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"150px\", padding=padding),\n    )\n\n    local_tile_palettes = list_palettes(add_extra=True)\n    cog_stac_palettes = list_palettes(lowercase=True)\n    palette_options = local_tile_palettes\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"300px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text1 = \"Additional parameters in the format of a dictionary, for example, \\n {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5']}\"\n    add_params_text2 = \"Additional parameters in the format of a dictionary, for example, \\n {'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text1,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    params_widget = widgets.HBox()\n\n    raster_options = widgets.VBox()\n    raster_options.children = [\n        widgets.HBox([red, green, blue]),\n        widgets.HBox([vmin, vmax, nodata]),\n        widgets.HBox([palette, checkbox]),\n        params_widget,\n    ]\n\n    def collection_changed(change):\n        if change[\"new\"]:\n            if not hasattr(m, \"pc_inventory\"):\n                setattr(m, \"pc_inventory\", get_pc_inventory())\n            col_name = change[\"new\"].split(\" - \")[0]\n            items.value = m.pc_inventory[col_name][\"first_item\"]\n            band_names = m.pc_inventory[col_name][\"bands\"]\n            red.options = band_names\n            green.options = band_names\n            blue.options = band_names\n\n            if change[\"new\"] == \"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\":\n                items.value = \"LC08_L2SP_047027_20201204_02_T1\"\n                assets.value = \"SR_B7,SR_B5,SR_B4\"\n                red.value = \"SR_B7\"\n                green.value = \"SR_B5\"\n                blue.value = \"SR_B4\"\n            elif change[\"new\"] == \"sentinel-2-l2a - Sentinel-2 Level-2A\":\n                items.value = \"S2B_MSIL2A_20190629T212529_R043_T06VVN_20201006T080531\"\n                assets.value = \"B08,B04,B03\"\n                red.value = \"B08\"\n                green.value = \"B04\"\n                blue.value = \"B03\"\n            else:\n                if len(band_names) &gt; 2:\n                    assets.value = \",\".join(band_names[:3])\n                    red.value = band_names[0]\n                    green.value = band_names[1]\n                    blue.value = band_names[2]\n                else:\n                    assets.value = band_names[0]\n                    red.value = band_names[0]\n                    green.value = band_names[0]\n                    blue.value = band_names[0]\n\n    collection.observe(collection_changed, names=\"value\")\n\n    def band_changed(change):\n        if change[\"name\"]:\n            if not checkbox.value:\n                if file_type.value == \"GeoTIFF\":\n                    if hasattr(m, \"tile_client\"):\n                        min_max = local_tile_vmin_vmax(\n                            m.tile_client, bands=[red.value, green.value, blue.value]\n                        )\n                        vmin.value = str(min_max[0])\n                        vmax.value = str(min_max[1])\n                elif file_type.value == \"Microsoft\":\n                    if len(set([red.value, green.value, blue.value])) == 1:\n                        assets.value = f\"{red.value}\"\n                    else:\n                        assets.value = f\"{red.value},{green.value},{blue.value}\"\n\n    red.observe(band_changed, names=\"value\")\n    green.observe(band_changed, names=\"value\")\n    blue.observe(band_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [add_params]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def url_change(change):\n        if change[\"new\"] and change[\"new\"].startswith(\"http\"):\n            with tool_output:\n                try:\n                    print(\"Retrieving band names...\")\n                    if file_type.value == \"COG\":\n                        bandnames = cog_bands(change[\"new\"])\n                    elif file_type.value == \"STAC\":\n                        bandnames = stac_bands(change[\"new\"])\n                    red.options = bandnames\n                    green.options = bandnames\n                    blue.options = bandnames\n                    if len(bandnames) &gt; 2:\n                        red.value = bandnames[0]\n                        green.value = bandnames[1]\n                        blue.value = bandnames[2]\n                    else:\n                        red.value = bandnames[0]\n                        green.value = bandnames[0]\n                        blue.value = bandnames[0]\n                    tool_output.outputs = ()\n\n                except Exception as e:\n                    print(e)\n                    print(\"Error loading URL.\")\n                    return\n        else:\n            red.options = []\n            green.options = []\n            blue.options = []\n            vmin.value = \"\"\n            vmax.value = \"\"\n            nodata.value = \"\"\n            palette.value = None\n\n    http_url.observe(url_change, names=\"value\")\n\n    main_widget = widgets.VBox(\n        [\n            file_type,\n            source_widget,\n            layer_name,\n            raster_options,\n            ok_cancel,\n            tool_output,\n        ]\n    )\n\n    tool_output_ctrl = ipyleaflet.WidgetControl(widget=main_widget, position=\"topright\")\n\n    if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n        m.remove_control(m.tool_output_ctrl)\n\n    def bands_changed(change):\n        if change[\"new\"] and \",\" in change[\"owner\"].value:\n            palette.value = None\n            palette.disabled = True\n        else:\n            palette.disabled = False\n\n    bands.observe(bands_changed, \"value\")\n\n    def chooser_callback(chooser):\n        try:\n            source = file_chooser.selected\n            tile_layer, tile_client = get_local_tile_layer(source, return_client=True)\n            if not hasattr(m, \"tile_client\"):\n                setattr(m, \"tile_client\", tile_client)\n            bandnames = local_tile_bands(tile_client)\n            red.options = bandnames\n            green.options = bandnames\n            blue.options = bandnames\n            if len(bandnames) &gt; 2:\n                red.value = bandnames[0]\n                green.value = bandnames[1]\n                blue.value = bandnames[2]\n                min_max = local_tile_vmin_vmax(\n                    tile_client, bands=[red.value, green.value, blue.value]\n                )\n                vmin.value = str(min_max[0])\n                vmax.value = str(min_max[1])\n            else:\n                red.value = bandnames[0]\n                green.value = bandnames[0]\n                blue.value = bandnames[0]\n                min_max = local_tile_vmin_vmax(tile_client)\n                vmin.value = str(min_max[0])\n                vmax.value = str(min_max[1])\n        except Exception as e:\n            with tool_output:\n                print(e)\n\n    file_chooser.register_callback(chooser_callback)\n\n    def file_type_changed(change):\n        ok_cancel.value = None\n        file_chooser.default_path = os.getcwd()\n        file_chooser.reset()\n        layer_name.value = file_type.value\n        http_url.value = \"\"\n        tool_output.outputs = ()\n        red.value = None\n        green.value = None\n        blue.value = None\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n\n        if change[\"new\"] == \"GeoTIFF\":\n            source_widget.children = [file_chooser]\n            file_chooser.filter_pattern = [\"*.tif\", \"*.tiff\"]\n            palette.options = local_tile_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text1\n            raster_options.children = [\n                widgets.HBox([red, green, blue]),\n                widgets.HBox([vmin, vmax, nodata]),\n                widgets.HBox([palette, checkbox]),\n                params_widget,\n            ]\n        elif change[\"new\"] == \"COG\":\n            http_url.value = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n            source_widget.children = [http_url]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text2\n        elif change[\"new\"] == \"STAC\":\n            http_url.value = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n            source_widget.children = [http_url]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            red.value = \"B3\"\n            green.value = \"B2\"\n            blue.value = \"B1\"\n            add_params.placeholder = add_params_text2\n        elif change[\"new\"] == \"Microsoft\":\n            source_widget.children = [collection, items, assets]\n            palette.options = cog_stac_palettes\n            palette.value = None\n            add_params.placeholder = add_params_text2\n            collection.options = get_pc_collection_list()\n            collection.value = \"landsat-8-c2-l2 - Landsat 8 Collection 2 Level-2\"\n            if not hasattr(m, \"pc_inventory\"):\n                setattr(m, \"pc_inventory\", get_pc_inventory())\n            items.value = \"LC08_L2SP_047027_20201204_02_T1\"\n            assets.value = \"SR_B7,SR_B5,SR_B4\"\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            m.default_style = {\"cursor\": \"wait\"}\n            # file_path = http_url.value\n\n            with tool_output:\n                tool_output.outputs = ()\n                print(\"Loading data...\")\n                if file_type.value == \"GeoTIFF\" and file_chooser.selected:\n                    band = None\n                    vis_min = None\n                    vis_max = None\n                    vis_nodata = None\n                    vis_palette = None\n\n                    try:\n                        if len(red.options) &gt; 2:\n                            band = [red.value, green.value, blue.value]\n                            if len(set(band)) &gt; 1:\n                                palette.value = None\n                            else:\n                                band = [red.value]\n                        else:\n                            band = [red.value]\n                        if len(vmin.value) &gt; 0:\n                            vis_min = float(vmin.value)\n                        if len(vmax.value) &gt; 0:\n                            vis_max = float(vmax.value)\n                        if len(nodata.value) &gt; 0:\n                            vis_nodata = float(nodata.value)\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                            if \"palette\" in vis_params:\n                                vis_palette = vis_params[\"palette\"]\n                            else:\n                                vis_palette = get_palette_colors(\n                                    palette.value, hashtag=True\n                                )\n                        elif palette.value is not None:\n                            vis_palette = get_palette_colors(\n                                palette.value, hashtag=True\n                            )\n                    except Exception as e:\n                        pass\n\n                    m.add_raster(\n                        file_chooser.selected,\n                        layer_name=layer_name.value,\n                        band=band,\n                        palette=vis_palette,\n                        vmin=vis_min,\n                        vmax=vis_max,\n                        nodata=vis_nodata,\n                    )\n                    tool_output.outputs = ()\n                elif file_type.value in [\"COG\", \"STAC\"] and http_url.value:\n                    try:\n                        tool_output.outputs = ()\n                        print(\"Loading data...\")\n\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                        else:\n                            vis_params = {}\n\n                        if (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) == 1\n                        ):\n                            vis_params[\"colormap_name\"] = palette.value\n                        elif (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) &gt; 1\n                        ):\n                            palette.value = None\n                            print(\"Palette can only be set for single band images.\")\n\n                        if vmin.value and vmax.value:\n                            vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                        if nodata.value:\n                            vis_params[\"nodata\"] = nodata.value\n\n                        if file_type.value == \"COG\":\n                            m.add_cog_layer(\n                                http_url.value,\n                                name=layer_name.value,\n                                bands=[red.value, green.value, blue.value],\n                                **vis_params,\n                            )\n                        elif file_type.value == \"STAC\":\n                            m.add_stac_layer(\n                                http_url.value,\n                                bands=[red.value, green.value, blue.value],\n                                name=layer_name.value,\n                                **vis_params,\n                            )\n                        tool_output.outputs = ()\n                    except Exception as e:\n                        print(e)\n                        print(\"Error loading data.\")\n                        return\n\n                elif file_type.value == \"Microsoft\":\n                    try:\n                        tool_output.outputs = ()\n                        print(\"Loading data...\")\n\n                        if (\n                            checkbox.value\n                            and add_params.value.strip().startswith(\"{\")\n                            and add_params.value.strip().endswith(\"}\")\n                        ):\n                            vis_params = eval(add_params.value)\n                        else:\n                            vis_params = {}\n\n                        if (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) == 1\n                        ) or (palette.value and \"expression\" in vis_params):\n                            vis_params[\"colormap_name\"] = palette.value\n                        elif (\n                            palette.value\n                            and len(set([red.value, green.value, blue.value])) &gt; 1\n                            and \"expression\" not in vis_params\n                        ):\n                            palette.value = None\n                            print(\"Palette can only be set for single band images.\")\n\n                        if vmin.value and vmax.value:\n                            vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                        if nodata.value:\n                            vis_params[\"nodata\"] = nodata.value\n\n                        col = collection.value.split(\" - \")[0]\n                        m.add_stac_layer(\n                            collection=col,\n                            item=items.value,\n                            assets=assets.value,\n                            name=layer_name.value,\n                            **vis_params,\n                        )\n                        tool_output.outputs = ()\n                    except Exception as e:\n                        print(e)\n                        print(\"Error loading data.\")\n                        return\n\n                else:\n                    tool_output.outputs = ()\n                    print(\"Please select a file and enter an http URL.\")\n\n            m.toolbar_reset()\n            m.default_style = {\"cursor\": \"default\"}\n\n        elif change[\"new\"] == \"Reset\":\n            file_chooser.reset()\n            tool_output.outputs = ()\n            http_url.value = \"\"\n            add_params.value = \"\"\n            checkbox.value = False\n            palette.value = None\n            red.value = None\n            green.value = None\n            blue.value = None\n            vmin.value = \"\"\n            vmax.value = \"\"\n            nodata.value = \"\"\n            collection.value = None\n            items.value = \"\"\n            assets.value = \"\"\n            m.toolbar_reset()\n        elif change[\"new\"] == \"Close\":\n            if m.tool_output_ctrl is not None and m.tool_output_ctrl in m.controls:\n                m.remove_control(m.tool_output_ctrl)\n                m.tool_output_ctrl = None\n                m.toolbar_reset()\n\n        ok_cancel.value = None\n\n    file_type.observe(file_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n\n    m.add(tool_output_ctrl)\n    m.tool_output_ctrl = tool_output_ctrl\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.plotly_basemap_gui","title":"<code>plotly_basemap_gui(canvas, map_min_width='78%', map_max_width='98%')</code>","text":"<p>Widget for changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>object</code> <p>leafmap.Map.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def plotly_basemap_gui(canvas, map_min_width=\"78%\", map_max_width=\"98%\"):\n    \"\"\"Widget for changing basemaps.\n\n    Args:\n        m (object): leafmap.Map.\n    \"\"\"\n    from .plotlymap import basemaps\n\n    m = canvas.map\n    layer_count = len(m.layout.mapbox.layers)\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n\n    map_widget.layout.width = map_min_width\n\n    value = \"Esri.WorldTopoMap\"\n    m.add_basemap(value)\n\n    dropdown = widgets.Dropdown(\n        options=list(basemaps.keys()),\n        value=value,\n        layout=widgets.Layout(width=\"200px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the basemap widget\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    basemap_widget = widgets.HBox([dropdown, close_btn])\n    container_widget.children = [basemap_widget]\n\n    def on_click(change):\n        basemap_name = change[\"new\"]\n        m.layout.mapbox.layers = m.layout.mapbox.layers[:layer_count]\n        m.add_basemap(basemap_name)\n\n    dropdown.observe(on_click, \"value\")\n\n    def close_click(change):\n        container_widget.children = []\n        basemap_widget.close()\n        map_widget.layout.width = map_max_width\n        canvas.toolbar_reset()\n        canvas.toolbar_button.value = False\n\n    close_btn.on_click(close_click)\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.plotly_search_basemaps","title":"<code>plotly_search_basemaps(canvas)</code>","text":"<p>The widget for search XYZ tile services.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The Plotly Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def plotly_search_basemaps(canvas):\n    \"\"\"The widget for search XYZ tile services.\n\n    Args:\n        m (plotlymap.Map, optional): The Plotly Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    m = canvas.map\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n    map_widget.layout.width = \"75%\"\n\n    # map_widget.layout.width = map_min_width\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Search Quick Map Services (QMS)\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    providers = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"XYZ Tile:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Search keyword:\",\n        placeholder=\"OpenStreetMap\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    def search_callback(change):\n        providers.options = []\n        if keyword.value != \"\":\n            tiles = search_xyz_services(keyword=keyword.value)\n            if checkbox.value:\n                tiles = tiles + search_qms(keyword=keyword.value)\n            providers.options = tiles\n\n    keyword.on_submit(search_callback)\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    def providers_change(change):\n        if change[\"new\"] != \"\":\n            provider = change[\"new\"]\n            if provider is not None:\n                if provider.startswith(\"qms\"):\n                    with output:\n                        output.outputs = ()\n                        print(\"Adding data. Please wait...\")\n                    name = provider[4:]\n                    qms_provider = TileProvider.from_qms(name)\n                    url = qms_provider.build_url()\n                    attribution = qms_provider.attribution\n                    m.add_tile_layer(url, name, attribution)\n                    output.outputs = ()\n                elif provider.startswith(\"xyz\"):\n                    name = provider[4:]\n                    xyz_provider = xyz.flatten()[name]\n                    url = xyz_provider.build_url()\n                    attribution = xyz_provider.attribution\n                    if xyz_provider.requires_token():\n                        with output:\n                            output.outputs = ()\n                            print(f\"{provider} requires an API Key.\")\n                    m.add_tile_layer(url, name, attribution)\n\n    providers.observe(providers_change, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        keyword,\n        providers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            providers.options = []\n            output.outputs = ()\n            if keyword.value != \"\":\n                tiles = search_xyz_services(keyword=keyword.value)\n                if checkbox.value:\n                    tiles = tiles + search_qms(keyword=keyword.value)\n                providers.options = tiles\n            else:\n                with output:\n                    print(\"Please enter a search keyword.\")\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            providers.options = []\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    container_widget.children = [toolbar_widget]\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.plotly_toolbar","title":"<code>plotly_toolbar(canvas)</code>","text":"<p>Creates the main toolbar and adds it to the map.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>plotlymap.Map</code> <p>The plotly Map object.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def plotly_toolbar(\n    canvas,\n):\n    \"\"\"Creates the main toolbar and adds it to the map.\n\n    Args:\n        m (plotlymap.Map): The plotly Map object.\n    \"\"\"\n    m = canvas.map\n    map_min_width = canvas.map_min_width\n    map_max_width = canvas.map_max_width\n    map_refresh = canvas.map_refresh\n    map_widget = canvas.map_widget\n\n    if not map_refresh:\n        width = int(map_min_width.replace(\"%\", \"\"))\n        if width &gt; 90:\n            map_min_width = \"90%\"\n\n    tools = {\n        \"map\": {\n            \"name\": \"basemap\",\n            \"tooltip\": \"Change basemap\",\n        },\n        \"search\": {\n            \"name\": \"search_xyz\",\n            \"tooltip\": \"Search XYZ tile services\",\n        },\n        \"gears\": {\n            \"name\": \"whitebox\",\n            \"tooltip\": \"WhiteboxTools for local geoprocessing\",\n        },\n        \"folder-open\": {\n            \"name\": \"vector\",\n            \"tooltip\": \"Open local vector/raster data\",\n        },\n        \"picture-o\": {\n            \"name\": \"raster\",\n            \"tooltip\": \"Open COG/STAC dataset\",\n        },\n        \"question\": {\n            \"name\": \"help\",\n            \"tooltip\": \"Get help\",\n        },\n    }\n\n    icons = list(tools.keys())\n    tooltips = [item[\"tooltip\"] for item in list(tools.values())]\n\n    icon_width = \"32px\"\n    icon_height = \"32px\"\n    n_cols = 3\n    n_rows = math.ceil(len(icons) / n_cols)\n\n    toolbar_grid = widgets.GridBox(\n        children=[\n            widgets.ToggleButton(\n                layout=widgets.Layout(\n                    width=\"auto\", height=\"auto\", padding=\"0px 0px 0px 4px\"\n                ),\n                button_style=\"primary\",\n                icon=icons[i],\n                tooltip=tooltips[i],\n            )\n            for i in range(len(icons))\n        ],\n        layout=widgets.Layout(\n            width=\"115px\",\n            grid_template_columns=(icon_width + \" \") * n_cols,\n            grid_template_rows=(icon_height + \" \") * n_rows,\n            grid_gap=\"1px 1px\",\n            padding=\"5px\",\n        ),\n    )\n    canvas.toolbar = toolbar_grid\n\n    def tool_callback(change):\n        if change[\"new\"]:\n            current_tool = change[\"owner\"]\n            for tool in toolbar_grid.children:\n                if tool is not current_tool:\n                    tool.value = False\n            tool = change[\"owner\"]\n            tool_name = tools[tool.icon][\"name\"]\n            canvas.container_widget.children = []\n\n            if tool_name == \"basemap\":\n                plotly_basemap_gui(canvas)\n            elif tool_name == \"search_xyz\":\n                plotly_search_basemaps(canvas)\n            elif tool_name == \"whitebox\":\n                plotly_whitebox_gui(canvas)\n            elif tool_name == \"vector\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"raster\":\n                plotly_tool_template(canvas)\n            elif tool_name == \"help\":\n                import webbrowser\n\n                webbrowser.open_new_tab(\"https://leafmap.org\")\n                tool.value = False\n        else:\n            canvas.container_widget.children = []\n            map_widget.layout.width = map_max_width\n\n    for tool in toolbar_grid.children:\n        tool.observe(tool_callback, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    canvas.toolbar_button = toolbar_button\n\n    layers_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Layers\",\n        icon=\"server\",\n        layout=widgets.Layout(height=\"28px\", width=\"72px\"),\n    )\n    canvas.layers_button = layers_button\n\n    toolbar_widget = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_header.children = [layers_button, toolbar_button]\n    toolbar_footer = widgets.VBox(layout=widgets.Layout(overflow=\"hidden\"))\n    toolbar_footer.children = [toolbar_grid]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            # map_widget.layout.width = \"85%\"\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                layers_button.value = False\n                # map_widget.layout.width = map_max_width\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            map_widget.layout.width = map_min_width\n            if map_refresh:\n                with map_widget:\n                    map_widget.outputs = ()\n                    display(m)\n            layers_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            canvas.toolbar_reset()\n            map_widget.layout.width = map_max_width\n            if not layers_button.value:\n                toolbar_widget.children = [toolbar_button]\n            if map_refresh:\n                with map_widget:\n                    map_widget.outputs = ()\n                    display(m)\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def layers_btn_click(change):\n        if change[\"new\"]:\n            layer_names = list(m.get_layers().keys())\n            layers_hbox = []\n            all_layers_chk = widgets.Checkbox(\n                value=True,\n                description=\"All layers on/off\",\n                indent=False,\n                layout=widgets.Layout(height=\"18px\", padding=\"0px 8px 25px 8px\"),\n            )\n            all_layers_chk.layout.width = \"30ex\"\n            layers_hbox.append(all_layers_chk)\n\n            layer_chk_dict = {}\n\n            for name in layer_names:\n                if name in m.get_tile_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.layout.mapbox.layers[index]\n                elif name in m.get_data_layers():\n                    index = m.find_layer_index(name)\n                    layer = m.data[index]\n\n                layer_chk = widgets.Checkbox(\n                    value=layer.visible,\n                    description=name,\n                    indent=False,\n                    layout=widgets.Layout(height=\"18px\"),\n                )\n                layer_chk.layout.width = \"25ex\"\n                layer_chk_dict[name] = layer_chk\n\n                if hasattr(layer, \"opacity\"):\n                    opacity = layer.opacity\n                elif hasattr(layer, \"marker\"):\n                    opacity = layer.marker.opacity\n                else:\n                    opacity = 1.0\n\n                layer_opacity = widgets.FloatSlider(\n                    value=opacity,\n                    description_tooltip=name,\n                    min=0,\n                    max=1,\n                    step=0.01,\n                    readout=False,\n                    layout=widgets.Layout(width=\"80px\"),\n                )\n\n                layer_settings = widgets.ToggleButton(\n                    icon=\"gear\",\n                    tooltip=name,\n                    layout=widgets.Layout(\n                        width=\"25px\", height=\"25px\", padding=\"0px 0px 0px 5px\"\n                    ),\n                )\n\n                def layer_chk_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_visibility(change[\"owner\"].description, True)\n                    else:\n                        m.set_layer_visibility(change[\"owner\"].description, False)\n\n                layer_chk.observe(layer_chk_change, \"value\")\n\n                def layer_opacity_change(change):\n                    if change[\"new\"]:\n                        m.set_layer_opacity(\n                            change[\"owner\"].description_tooltip, change[\"new\"]\n                        )\n\n                layer_opacity.observe(layer_opacity_change, \"value\")\n\n                hbox = widgets.HBox(\n                    [layer_chk, layer_settings, layer_opacity],\n                    layout=widgets.Layout(padding=\"0px 8px 0px 8px\"),\n                )\n                layers_hbox.append(hbox)\n\n            def all_layers_chk_changed(change):\n                if change[\"new\"]:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, True)\n                        layer_chk_dict[name].value = True\n                else:\n                    for name in layer_names:\n                        m.set_layer_visibility(name, False)\n                        layer_chk_dict[name].value = False\n\n            all_layers_chk.observe(all_layers_chk_changed, \"value\")\n\n            toolbar_footer.children = layers_hbox\n            toolbar_button.value = False\n        else:\n            toolbar_footer.children = [toolbar_grid]\n\n    layers_button.observe(layers_btn_click, \"value\")\n\n    return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.plotly_whitebox_gui","title":"<code>plotly_whitebox_gui(canvas)</code>","text":"<p>Display a GUI for the whitebox tool.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>plotlymap.Canvas</code> <p>Map canvas.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def plotly_whitebox_gui(canvas):\n    \"\"\"Display a GUI for the whitebox tool.\n\n    Args:\n        canvas (plotlymap.Canvas): Map canvas.\n    \"\"\"\n    import whiteboxgui.whiteboxgui as wbt\n\n    container_widget = canvas.container_widget\n    map_widget = canvas.map_widget\n    map_width = \"25%\"\n    map_widget.layout.width = map_width\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    # style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gears\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    tools_dict = wbt.get_wbt_dict()\n    wbt_toolbox = wbt.build_toolbox(\n        tools_dict,\n        max_width=\"800px\",\n        max_height=\"500px\",\n        sandbox_path=os.getcwd(),\n    )\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        wbt_toolbox,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            map_widget.layout.width = map_width\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n                map_widget.layout.width = canvas.map_max_width\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            map_widget.layout.width = map_width\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n            map_widget.layout.width = canvas.map_max_width\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            canvas.toolbar_reset()\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = True\n    container_widget.children = [toolbar_widget]\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.save_map","title":"<code>save_map(m)</code>","text":"<p>Saves the map as HTML, JPG, or PNG.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leafmap Map object.</p> required Source code in <code>leafmap/toolbar.py</code> <pre><code>def save_map(m):\n    \"\"\"Saves the map as HTML, JPG, or PNG.\n\n    Args:\n        m (leafmap.Map): The leafmap Map object.\n    \"\"\"\n    import time\n\n    tool_output = widgets.Output()\n    m.tool_output = tool_output\n    tool_output.outputs = ()\n    save_map_widget = widgets.VBox()\n\n    save_type = widgets.ToggleButtons(\n        options=[\"HTML\", \"PNG\", \"JPG\"],\n        tooltips=[\n            \"Save the map as an HTML file\",\n            \"Take a screenshot and save as a PNG file\",\n            \"Take a screenshot and save as a JPG file\",\n        ],\n    )\n\n    file_chooser = FileChooser(\n        os.getcwd(), sandbox_path=m.sandbox_path, layout=widgets.Layout(width=\"454px\")\n    )\n    file_chooser.default_filename = \"my_map.html\"\n    file_chooser.use_dir_icons = True\n\n    ok_cancel = widgets.ToggleButtons(\n        value=None,\n        options=[\"OK\", \"Cancel\", \"Close\"],\n        tooltips=[\"OK\", \"Cancel\", \"Close\"],\n        button_style=\"primary\",\n    )\n\n    def save_type_changed(change):\n        ok_cancel.value = None\n        # file_chooser.reset()\n        file_chooser.default_path = os.getcwd()\n        if change[\"new\"] == \"HTML\":\n            file_chooser.default_filename = \"my_map.html\"\n        elif change[\"new\"] == \"PNG\":\n            file_chooser.default_filename = \"my_map.png\"\n        elif change[\"new\"] == \"JPG\":\n            file_chooser.default_filename = \"my_map.jpg\"\n        save_map_widget.children = [save_type, file_chooser]\n\n    def chooser_callback(chooser):\n        save_map_widget.children = [save_type, file_chooser, ok_cancel]\n\n    def ok_cancel_clicked(change):\n        if change[\"new\"] == \"OK\":\n            file_path = file_chooser.selected\n            ext = os.path.splitext(file_path)[1]\n            if save_type.value == \"HTML\" and ext.upper() == \".HTML\":\n                tool_output.outputs = ()\n                m.to_html(file_path)\n            elif save_type.value == \"PNG\" and ext.upper() == \".PNG\":\n                tool_output.outputs = ()\n                m.toolbar_button.value = False\n                if m.save_map_control is not None:\n                    m.remove_control(m.save_map_control)\n                    m.save_map_control = None\n                time.sleep(2)\n                screen_capture(outfile=file_path)\n            elif save_type.value == \"JPG\" and ext.upper() == \".JPG\":\n                tool_output.outputs = ()\n                m.toolbar_button.value = False\n                if m.save_map_control is not None:\n                    m.remove_control(m.save_map_control)\n                    m.save_map_control = None\n                time.sleep(2)\n                screen_capture(outfile=file_path)\n            else:\n                label = widgets.Label(\n                    value=\"The selected file extension does not match the selected exporting type.\"\n                )\n                save_map_widget.children = [save_type, file_chooser, label]\n        elif change[\"new\"] == \"Cancel\":\n            tool_output.outputs = ()\n            file_chooser.reset()\n        elif change[\"new\"] == \"Close\":\n            if m.save_map_control is not None:\n                m.remove_control(m.save_map_control)\n                m.save_map_control = None\n        ok_cancel.value = None\n        m.toolbar_reset()\n\n    save_type.observe(save_type_changed, names=\"value\")\n    ok_cancel.observe(ok_cancel_clicked, names=\"value\")\n\n    file_chooser.register_callback(chooser_callback)\n\n    save_map_widget.children = [save_type, file_chooser]\n    save_map_control = ipyleaflet.WidgetControl(\n        widget=save_map_widget, position=\"topright\"\n    )\n    m.add(save_map_control)\n    m.save_map_control = save_map_control\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.search_basemaps","title":"<code>search_basemaps(m)</code>","text":"<p>The widget for search XYZ tile services.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def search_basemaps(m):\n    \"\"\"The widget for search XYZ tile services.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import xyzservices.providers as xyz\n    from xyzservices import TileProvider\n\n    layers = m.layers\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Search Quick Map Services (QMS)\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    providers = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"XYZ Tile:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    keyword = widgets.Text(\n        value=\"\",\n        description=\"Search keyword:\",\n        placeholder=\"OpenStreetMap\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    def search_callback(change):\n        providers.options = []\n        if keyword.value != \"\":\n            tiles = search_xyz_services(keyword=keyword.value)\n            if checkbox.value:\n                tiles = tiles + search_qms(keyword=keyword.value)\n            providers.options = tiles\n\n    keyword.on_submit(search_callback)\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Reset\", \"Close\"],\n        tooltips=[\"Search\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    def providers_change(change):\n        if change[\"new\"] != \"\":\n            provider = change[\"new\"]\n            if provider is not None:\n                if provider.startswith(\"qms\"):\n                    with output:\n                        output.outputs = ()\n                        print(\"Adding data. Please wait...\")\n                    name = provider[4:]\n                    qms_provider = TileProvider.from_qms(name)\n                    url = qms_provider.build_url()\n                    attribution = qms_provider.attribution\n                    m.layers = layers\n                    m.add_tile_layer(url, name, attribution)\n                    output.outputs = ()\n                elif provider.startswith(\"xyz\"):\n                    name = provider[4:]\n                    xyz_provider = xyz.flatten()[name]\n                    url = xyz_provider.build_url()\n                    attribution = xyz_provider.attribution\n                    m.layers = layers\n                    if xyz_provider.requires_token():\n                        with output:\n                            output.outputs = ()\n                            print(f\"{provider} requires an API Key.\")\n                    m.add_tile_layer(url, name, attribution)\n\n    providers.observe(providers_change, \"value\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        keyword,\n        providers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            providers.options = []\n            if keyword.value != \"\":\n                tiles = search_xyz_services(keyword=keyword.value)\n                if checkbox.value:\n                    tiles = tiles + search_qms(keyword=keyword.value)\n                providers.options = tiles\n            with output:\n                output.outputs = ()\n                # print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            keyword.value = \"\"\n            providers.options = []\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.search_geojson_gui","title":"<code>search_geojson_gui(m)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def search_geojson_gui(m):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    if len(m.geojson_layers) &gt; 0:\n        geojson_layer_group = ipyleaflet.LayerGroup()\n        for geojson_layer in m.geojson_layers:\n            geojson_layer_group.add(geojson_layer)\n        if not hasattr(m, \"geojson_layer_group\"):\n            setattr(m, \"geojson_layer_group\", geojson_layer_group)\n        else:\n            m.geojson_layer_group = geojson_layer_group\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"search-plus\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    layer_options = []\n    if len(m.geojson_layers) &gt; 0:\n        layer_options = [layer.name for layer in m.geojson_layers]\n\n    layers = widgets.Dropdown(\n        options=layer_options,\n        value=None,\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    attributes = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Attribute:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    if len(m.geojson_layers) == 0:\n        with output:\n            print(\"Please add vector data layers to the map before using this tool.\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        layers,\n        attributes,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def layer_change(change):\n        if change[\"new\"]:\n            for layer in m.geojson_layers:\n                if layer.name == change[\"new\"]:\n                    df = geojson_to_df(layer.data)\n                    attributes.options = list(df.columns)\n\n    layers.observe(layer_change, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                if len(m.geojson_layers) &gt; 0 and m.search_control is not None:\n                    m.search_control.marker.visible = False\n                    m.remove_control(m.search_control)\n                    m.search_control = None\n                    m.geojson_layer_group.clear_layers()\n                    delattr(m, \"geojson_layer_group\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            if len(m.geojson_layers) &gt; 0 and attributes.value is not None:\n                if m.search_control is None:\n                    geojson_control = ipyleaflet.SearchControl(\n                        position=\"topleft\",\n                        layer=m.geojson_layer_group,\n                        property_name=attributes.value,\n                        marker=ipyleaflet.Marker(\n                            icon=ipyleaflet.AwesomeIcon(\n                                name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n                            )\n                        ),\n                    )\n                    m.add(geojson_control)\n                    m.search_control = geojson_control\n                else:\n                    m.search_control.property_name = attributes.value\n            with output:\n                output.outputs = ()\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n            layers.value = None\n            attributes.value = None\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n                if len(m.geojson_layers) &gt; 0 and m.search_control is not None:\n                    m.search_control.marker.visible = False\n                    m.remove_control(m.search_control)\n                    m.search_control = None\n                    if hasattr(m, \"geojson_layer_group\"):\n                        m.geojson_layer_group.clear_layers()\n                        delattr(m, \"geojson_layer_group\")\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.select_table_gui","title":"<code>select_table_gui(m=None)</code>","text":"<p>GUI for selecting layers to display attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def select_table_gui(m=None):\n    \"\"\"GUI for selecting layers to display attribute table.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"table\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    layer_options = []\n    if len(m.geojson_layers) &gt; 0:\n        layer_options = [layer.name for layer in m.geojson_layers]\n\n    layers = widgets.Dropdown(\n        options=layer_options,\n        value=None,\n        description=\"Layer:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    if len(m.geojson_layers) == 0:\n        with output:\n            print(\"Please add vector data layers to the map before using this tool.\")\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        layers,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            if len(m.geojson_layers) &gt; 0 and layers.value is not None:\n                if hasattr(m, \"table_control\"):\n                    m.remove_control(m.table_control)\n                lyr_index = layers.options.index(layers.value)\n                data = m.geojson_layers[lyr_index].data\n                df = geojson_to_df(data)\n                show_table_gui(m, df)\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n            layers.value = None\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.show_table_gui","title":"<code>show_table_gui(m, df)</code>","text":"<p>Open the attribute table GUI.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def show_table_gui(m, df):\n    \"\"\"Open the attribute table GUI.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import ipysheet\n\n    widget_width = \"560px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    # style = {\"description_width\": \"initial\"}\n\n    sheet = ipysheet.from_dataframe(df.head(10))\n\n    output = widgets.Output(\n        layout=widgets.Layout(\n            width=widget_width,\n            padding=padding,\n        )\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Show all rows\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=\"115px\"),\n    )\n\n    sheet.layout.width = output.layout.width\n\n    def checkbox_clicked(change):\n        output.outputs = ()\n\n        if change[\"new\"]:\n            sheet = ipysheet.from_dataframe(df)\n        else:\n            sheet = ipysheet.from_dataframe(df.head(10))\n\n        sheet.layout.max_width = output.layout.width\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n        sheet.layout.max_height = output.layout.height\n        if sheet.layout.height &gt; output.layout.max_height:\n            sheet.layout.height = output.layout.max_height\n        with output:\n            display(sheet)\n\n    checkbox.observe(checkbox_clicked, \"value\")\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Minimize window\",\n        icon=\"window-minimize\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    toolbar_widget = widgets.VBox()\n    m.table_widget = toolbar_widget\n    m.table_output = output\n\n    reset_btn = widgets.Button(\n        tooltip=\"Reset the plot\",\n        icon=\"home\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    def reset_btn_clicked(b):\n        output.layout.width = widget_width\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n\n    reset_btn.on_click(reset_btn_clicked)\n\n    fullscreen_btn = widgets.Button(\n        tooltip=\"Fullscreen the attribute table\",\n        icon=\"arrows-alt\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    def fullscreen_btn_clicked(b):\n        output.layout.width = \"1000px\"\n        output.layout.max_height = str(int(m.layout.height[:-2]) - 220) + \"px\"\n\n        sheet.layout.width = output.layout.width\n        with output:\n            output.outputs = ()\n            display(sheet)\n\n    fullscreen_btn.on_click(fullscreen_btn_clicked)\n\n    width_btn = widgets.Button(\n        tooltip=\"Change table width\",\n        icon=\"arrows-h\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    height_btn = widgets.Button(\n        tooltip=\"Change table height\",\n        icon=\"arrows-v\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 0px\"),\n    )\n\n    width_slider = widgets.IntSlider(\n        value=560,\n        min=550,\n        max=1500,\n        step=10,\n        description=\"\",\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    width_slider_label = widgets.Label(\n        value=\"560\", layout=widgets.Layout(padding=\"0px 10px 0px 0px\")\n    )\n    # widgets.jslink((width_slider, \"value\"), (width_slider_label, \"value\"))\n\n    def width_changed(change):\n        if change[\"new\"]:\n            width_slider_label.value = str(width_slider.value)\n            output.layout.width = str(width_slider.value) + \"px\"\n\n            if checkbox.value:\n                sheet = ipysheet.from_dataframe(df)\n            else:\n                sheet = ipysheet.from_dataframe(df.head(10))\n            sheet.layout.width = output.layout.width\n            with output:\n                output.outputs = ()\n                display(sheet)\n\n    width_slider.observe(width_changed, \"value\")\n\n    height_slider = widgets.IntSlider(\n        value=250,\n        min=200,\n        max=1000,\n        step=10,\n        description=\"\",\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style={\"description_width\": \"initial\"},\n    )\n\n    height_slider_label = widgets.Label(value=\"250\")\n    # widgets.jslink((height_slider, \"value\"), (height_slider_label, \"value\"))\n\n    def height_changed(change):\n        if change[\"new\"]:\n            height_slider_label.value = str(height_slider.value)\n            output.layout.max_height = str(height_slider.value) + \"px\"\n            if checkbox.value:\n                sheet = ipysheet.from_dataframe(df)\n            else:\n                sheet = ipysheet.from_dataframe(df.head(10))\n\n            sheet.layout.height = output.layout.max_height\n            with output:\n                output.outputs = ()\n                display(sheet)\n\n    height_slider.observe(height_changed, \"value\")\n\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [\n        close_button,\n        toolbar_button,\n        reset_btn,\n        fullscreen_btn,\n        width_btn,\n        width_slider,\n        width_slider_label,\n        height_btn,\n        height_slider,\n        height_slider_label,\n        checkbox,\n    ]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            toolbar_button.icon = \"window-minimize\"\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n                toolbar_button.icon = \"window-maximize\"\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            toolbar_button.icon = \"window-minimize\"\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.icon = \"window-maximize\"\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.table_control is not None and m.table_control in m.controls:\n                    m.remove_control(m.table_control)\n                    m.table_control = None\n                    delattr(m, \"table_control\")\n\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    with output:\n        display(sheet)\n\n    toolbar_button.value = True\n    if m is not None:\n        table_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if table_control not in m.controls:\n            m.add(table_control)\n            m.table_control = table_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.split_basemaps","title":"<code>split_basemaps(m, layers_dict=None, left_name=None, right_name=None, width='120px', **kwargs)</code>","text":"<p>Create a split-panel map for visualizing two maps.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ipyleaflet.Map</code> <p>An ipyleaflet map object.</p> required <code>layers_dict</code> <code>dict</code> <p>A dictionary of TileLayers. Defaults to None.</p> <code>None</code> <code>left_name</code> <code>str</code> <p>The default value of the left dropdown list. Defaults to None.</p> <code>None</code> <code>right_name</code> <code>str</code> <p>The default value of the right dropdown list. Defaults to None.</p> <code>None</code> <code>width</code> <code>str</code> <p>The width of the dropdown list. Defaults to \"120px\".</p> <code>'120px'</code> Source code in <code>leafmap/toolbar.py</code> <pre><code>def split_basemaps(\n    m,\n    layers_dict: Optional[Dict] = None,\n    left_name=None,\n    right_name=None,\n    width=\"120px\",\n    **kwargs,\n):\n    \"\"\"Create a split-panel map for visualizing two maps.\n\n    Args:\n        m (ipyleaflet.Map): An ipyleaflet map object.\n        layers_dict (dict, optional): A dictionary of TileLayers. Defaults to None.\n        left_name (str, optional): The default value of the left dropdown list. Defaults to None.\n        right_name (str, optional): The default value of the right dropdown list. Defaults to None.\n        width (str, optional): The width of the dropdown list. Defaults to \"120px\".\n    \"\"\"\n    from .basemaps import wms_tiles\n    from .leafmap import basemaps, get_basemap\n\n    controls = m.controls\n    layers = m.layers\n    m.clear_controls()\n\n    add_zoom = True\n    add_fullscreen = True\n\n    if layers_dict is None:\n        keys = []\n        tmp_keys = list(basemaps.keys())\n        for key in tmp_keys:\n            if key not in wms_tiles:\n                keys.append(key)\n    else:\n        keys = list(layers_dict.keys())\n\n    if layers_dict is None:\n        if left_name is None:\n            left_name = \"ROADMAP\"\n        if right_name is None:\n            right_name = \"HYBRID\"\n    else:\n        if left_name is None:\n            left_name = keys[0]\n        if right_name is None:\n            right_name = keys[-1]\n\n    if layers_dict is None:\n        if isinstance(left_name, str):\n            left_layer = get_basemap(left_name)\n\n        if isinstance(right_name, str):\n            right_layer = get_basemap(right_name)\n    else:\n        left_layer = layers_dict[left_name]\n        right_layer = layers_dict[right_name]\n\n    control = ipyleaflet.SplitMapControl(left_layer=left_layer, right_layer=right_layer)\n    m.add(control)\n    m.dragging = False\n\n    left_dropdown = widgets.Dropdown(\n        options=keys, value=left_name, layout=widgets.Layout(width=width)\n    )\n\n    left_control = ipyleaflet.WidgetControl(widget=left_dropdown, position=\"topleft\")\n    m.add(left_control)\n\n    right_dropdown = widgets.Dropdown(\n        options=keys, value=right_name, layout=widgets.Layout(width=width)\n    )\n\n    right_control = ipyleaflet.WidgetControl(widget=right_dropdown, position=\"topright\")\n    m.add(right_control)\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        # button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            m.controls = controls\n            m.clear_layers()\n            m.layers = layers\n\n    close_button.observe(close_btn_click, \"value\")\n    close_control = ipyleaflet.WidgetControl(\n        widget=close_button, position=\"bottomright\"\n    )\n    m.add(close_control)\n\n    if add_zoom:\n        m.add(ipyleaflet.ZoomControl())\n    if add_fullscreen:\n        m.add(ipyleaflet.FullScreenControl())\n    m.add(ipyleaflet.ScaleControl(position=\"bottomleft\"))\n\n    split_control = None\n    for ctrl in m.controls:\n        if isinstance(ctrl, ipyleaflet.SplitMapControl):\n            split_control = ctrl\n            break\n\n    def left_change(change):\n        if layers_dict is None:\n            split_control.left_layer.url = get_basemap(left_dropdown.value).url\n        else:\n            split_control.left_layer.url = layers_dict[left_dropdown.value].url\n\n    left_dropdown.observe(left_change, \"value\")\n\n    def right_change(change):\n        if layers_dict is None:\n            split_control.right_layer.url = get_basemap(right_dropdown.value).url\n        else:\n            split_control.right_layer.url = layers_dict[right_dropdown.value].url\n\n    right_dropdown.observe(right_change, \"value\")\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.stac_custom_gui","title":"<code>stac_custom_gui(m, button_width='85px', **kwargs)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>button_width</code> <code>str</code> <p>The button width. Defaults to \"85px\".</p> <code>'85px'</code> <code>**kwargs</code> <p>Additional keyword arguments that will be passed to the pystac Client.open() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def stac_custom_gui(m, button_width: Optional[str] = \"85px\", **kwargs):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        button_width (str, optional): The button width. Defaults to \"85px\".\n        **kwargs: Additional keyword arguments that will be passed to the pystac Client.open() function.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n\n    if hasattr(m, \"_STAC_CATALOGS\") and isinstance(m._STAC_CATALOGS, dict):\n        catalogs = m._STAC_CATALOGS\n    else:\n        raise ValueError(\"Please set the STAC catalogs first.\")\n\n    if not hasattr(m, \"_STAC_COLLECTIONS\"):\n        m._STAC_COLLECTIONS = {}\n\n    if len(catalogs) == 0:\n        raise ValueError(\"Please set the STAC catalogs first.\")\n\n    catalog_ids = list(catalogs.keys())\n\n    widget_width = \"450px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    MAX_ITEMS = 20\n    if \"MAX_ITEMS\" in os.environ:\n        MAX_ITEMS = int(os.environ[\"MAX_ITEMS\"])\n\n    stac_data = []\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Discver STAC Catalog\",\n        icon=\"stack-exchange\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    catalog = widgets.Dropdown(\n        options=catalog_ids,\n        value=catalog_ids[0],\n        description=\"Catalog:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    endpoint = widgets.Text(\n        value=catalogs[catalog.value],\n        description=\"URL:\",\n        tooltip=\"STAC Catalog URL\",\n        placeholder=\"Enter a STAC URL, e.g., https://earth-search.aws.element84.com/v1\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n\n    band_names = []\n\n    item = widgets.Dropdown(\n        options=[],\n        description=\"Item:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    vis_option = widgets.Dropdown(\n        options=[\"1 band (Grayscale)\", \"3 bands (RGB)\"],\n        value=\"3 bands (RGB)\",\n        description=\"Visualization:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"STAC Layer\",\n        description=\"Layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    gray_band = widgets.Dropdown(\n        options=band_names,\n        value=None,\n        description=\"Band:\",\n        tooltip=\"Select a band for visualization\",\n        style=style,\n        layout=widgets.Layout(width=\"227px\", padding=padding),\n    )\n\n    palette_options = list_palettes(lowercase=True)\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"Palette:\",\n        layout=widgets.Layout(width=\"223px\", padding=padding),\n        style=style,\n    )\n\n    band_box = widgets.HBox([red, green, blue])\n\n    def vis_option_changed(change):\n        if change[\"new\"] == \"1 band (Grayscale)\":\n            band_box.children = [gray_band, palette]\n        else:\n            band_box.children = [red, green, blue]\n\n    vis_option.observe(vis_option_changed, names=\"value\")\n\n    max_items = widgets.Text(\n        value=\"20\",\n        description=\"Max items:\",\n        placeholder=\"Maximum number of items to return from the STAC API\",\n        tooltip=\"Maximum number of items to return from the STAC API\",\n        style=style,\n        layout=widgets.Layout(width=\"130px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"113px\", padding=padding),\n    )\n\n    more_label = widgets.Label(\n        \"More options:\",\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n        style=style,\n    )\n\n    add_footprints = widgets.Checkbox(\n        value=True,\n        description=\"Add image footprints\",\n        indent=False,\n        layout=widgets.Layout(width=\"170px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    query_params_text = \"Additional parameters to query the STAC API, for example: {'query': {'eo:cloud_cover':{'lt':10}}}\"\n    query_params = widgets.Textarea(\n        value=\"\",\n        placeholder=query_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text = \"Additional parameters to visualize imagery, for example: {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5'], 'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    def reset_options():\n        \"\"\"Reset the options to their default values.\"\"\"\n        catalog.value = catalog_ids[0]\n        collection.options = []\n        collection.value = None\n        endpoint.value = catalogs[catalog.value]\n        start_date.value = None\n        end_date.value = None\n        item.options = []\n        item.value = None\n        layer_name.value = \"\"\n        max_items.value = \"20\"\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n        add_params.value = \"\"\n        reset_bands()\n        vis_option.value = \"3 bands (RGB)\"\n        output.outputs = ()\n\n    params_widget = widgets.VBox()\n\n    more_options = widgets.VBox()\n    more_options.children = [\n        widgets.HBox([more_label, add_footprints, checkbox]),\n        params_widget,\n    ]\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Collections\", \"Items\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Collections\", \"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = button_width\n\n    dataset_widget = widgets.VBox()\n\n    dataset_widget.children = [endpoint, collection]\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        catalog,\n        dataset_widget,\n        widgets.HBox([start_date, end_date]),\n        item,\n        vis_option,\n        band_box,\n        more_options,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def update_bands():\n        excluded = [\n            \"index\",\n            \"metadata\",\n            \"mtl.json\",\n            \"mtl.txt\",\n            \"mtl.xml\",\n            \"qa\",\n            \"qa-browse\",\n            \"QA\",\n            \"rendered_preview\",\n            \"tilejson\",\n            \"tir-browse\",\n            \"vnir-browse\",\n            \"xml\",\n            \"documentation\",\n        ]\n\n        if len(stac_data) &gt; 0:\n            bnames = stac_data[0][item.value][\"bands\"]\n        else:\n            bnames = []\n\n        bnames = [b for b in bnames if b not in excluded]\n\n        red.options = bnames\n        green.options = bnames\n        blue.options = bnames\n\n        if len(bnames) &gt;= 3:\n            vis_option.value = \"3 bands (RGB)\"\n            palette.value = None\n            gray_band.options = bnames\n\n            default_bands = set_default_bands(bnames)\n            try:\n                red.value = default_bands[0]\n                green.value = default_bands[1]\n                blue.value = default_bands[2]\n            except Exception as e:\n                red.value = None\n                green.value = None\n                blue.value = None\n        elif len(bnames) &gt;= 1:\n            vis_option.value = \"1 band (Grayscale)\"\n            gray_band.options = bnames\n            gray_band.value = bnames[0]\n            red.value = bnames[0]\n            green.value = bnames[0]\n            blue.value = bnames[0]\n\n    def reset_bands():\n        red.options = []\n        green.options = []\n        blue.options = []\n        gray_band.options = []\n        red.value = None\n        green.value = None\n        blue.value = None\n        gray_band.value = None\n\n    def catalog_changed(change):\n        if change[\"new\"]:\n            endpoint.value = catalogs[catalog.value]\n            collection.options = []\n            collection.value = None\n            item.options = []\n            item.value = None\n            if catalog.value in m._STAC_COLLECTIONS:\n                collection.options = m._STAC_COLLECTIONS[catalog.value]\n                collection.value = m._STAC_COLLECTIONS[catalog.value][0]\n            reset_bands()\n\n    catalog.observe(catalog_changed, names=\"value\")\n\n    def endpoint_changed(change):\n        with output:\n            output.outputs = ()\n            output.clear_output()\n            print(\"Retrieving collections...\")\n            try:\n                if endpoint.value is not None:\n                    collection.options = []\n                    collection.value = None\n\n                    collections = stac_collections(\n                        endpoint.value, return_ids=True, get_root=False, **kwargs\n                    )\n                    if collections:\n                        collections.sort()\n                        collection.options = collections\n                        collection.value = collections[0]\n                        output.clear_output()\n                        output.outputs = ()\n                    else:\n                        print(\"No collections found.\")\n                else:\n                    print(\"No URL provided.\")\n                reset_bands()\n\n            except Exception as e:\n                print(e)\n\n    endpoint.on_submit(endpoint_changed)\n\n    def collection_changed(change):\n        if change[\"new\"]:\n            reset_bands()\n            item.options = []\n            item.value = None\n\n    collection.observe(collection_changed, names=\"value\")\n\n    def item_changed(change):\n        if change[\"new\"]:\n            layer_name.value = item.value\n\n    item.observe(item_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [\n                layer_name,\n                widgets.HBox([max_items, vmin, vmax, nodata]),\n                query_params,\n                add_params,\n            ]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Collections\":\n            collection.options = []\n            with output:\n                output.outputs = ()\n                print(\"Retrieving collections...\")\n                try:\n                    if endpoint.value is not None:\n                        if (\n                            endpoint.value == catalogs[catalog.value]\n                            and catalog.value in m._STAC_COLLECTIONS\n                        ):\n                            collections = m._STAC_COLLECTIONS[catalog.value]\n                        else:\n                            collections = stac_collections(\n                                endpoint.value, return_ids=True, **kwargs\n                            )\n\n                        if collections:\n                            collections.sort()\n                            collection.options = collections\n                            collection.value = collections[0]\n\n                            m._STAC_COLLECTIONS[catalog.value] = collections\n                            output.clear_output()\n                            output.outputs = ()\n                        else:\n                            print(\"No collections found.\")\n                    else:\n                        print(\"No URL provided.\")\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Items\":\n            with output:\n                output.outputs = ()\n                if endpoint.value is not None:\n                    if start_date.value is not None and end_date.value is not None:\n                        datetime = str(start_date.value) + \"/\" + str(end_date.value)\n                    elif start_date.value is not None:\n                        datetime = str(start_date.value) + \"/..\"\n                    elif end_date.value is not None:\n                        datetime = \"../\" + str(end_date.value)\n                    else:\n                        datetime = None\n\n                    if m is not None:\n                        if m.user_roi is not None:\n                            intersects = m.user_roi[\"geometry\"]\n                        else:\n                            intersects = bbox_to_geojson(m.bounds)\n\n                    else:\n                        intersects = None\n\n                    if (\n                        checkbox.value\n                        and query_params.value.strip().startswith(\"{\")\n                        and query_params.value.strip().endswith(\"}\")\n                    ):\n                        query = eval(query_params.value)\n                    elif query_params.value.strip() == \"\":\n                        query = {}\n                    else:\n                        print(\n                            \"Invalid query parameters. It must be a dictionary with keys such as 'query', 'sortby', 'filter', 'fields'\"\n                        )\n                        query = {}\n\n                print(\"Retrieving items...\")\n                try:\n                    if collection.value is None:\n                        output.outputs = ()\n                        print(\"Please click on 'Collections' to retrieve collections.\")\n                    else:\n                        item.options = []\n                        item.value = None\n                        reset_bands()\n                        search = stac_search(\n                            url=endpoint.value,\n                            collections=[collection.value],\n                            max_items=int(max_items.value),\n                            intersects=intersects,\n                            datetime=datetime,\n                            **query,\n                            **kwargs,\n                        )\n                        search_dict = stac_search_to_dict(search)\n                        item.options = list(search_dict.keys())\n                        item.value = list(search_dict.keys())[0]\n                        setattr(m, \"stac_search\", search)\n                        setattr(m, \"stac_dict\", search_dict)\n                        setattr(m, \"stac_items\", stac_search_to_list(search))\n\n                        if add_footprints.value and m is not None:\n                            gdf = stac_search_to_gdf(search)\n                            style = {\n                                \"stroke\": True,\n                                \"color\": \"#3388ff\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#000000\",\n                                \"fillOpacity\": 0,\n                            }\n                            hover_style = {\"weight\": 4}\n                            m.add_gdf(\n                                gdf,\n                                style=style,\n                                hover_style=hover_style,\n                                layer_name=\"Footprints\",\n                                zoom_to_layer=False,\n                                info_mode=\"on_click\",\n                            )\n                            setattr(m, \"stac_gdf\", gdf)\n\n                        stac_data.clear()\n                        stac_data.append(search_dict)\n                        update_bands()\n                        output.clear_output()\n                        output.outputs = ()\n                except NotImplementedError as e:\n                    print(e)\n\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Display\":\n            with output:\n                output.outputs = ()\n\n                if item.value and m is not None:\n                    print(\"Loading data...\")\n\n                    if (\n                        checkbox.value\n                        and add_params.value.strip().startswith(\"{\")\n                        and add_params.value.strip().endswith(\"}\")\n                    ):\n                        vis_params = eval(add_params.value)\n                    else:\n                        vis_params = {}\n\n                    if (\n                        vis_option.value == \"1 band (Grayscale)\"\n                        and (palette.value is not None)\n                    ) or (palette.value and \"expression\" in vis_params):\n                        vis_params[\"colormap_name\"] = palette.value\n                    elif (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) &gt; 1\n                        and \"expression\" not in vis_params\n                    ):\n                        palette.value = None\n                        print(\"Palette can only be set for single band images.\")\n\n                    if vmax.value and not vmin.value:\n                        vmin.value = \"0\"\n\n                    if vmin.value and vmax.value:\n                        vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                    if nodata.value:\n                        vis_params[\"nodata\"] = nodata.value\n\n                    if vis_option.value == \"1 band (Grayscale)\":\n                        assets = gray_band.value\n                    else:\n                        assets = f\"{red.value},{green.value},{blue.value}\"\n\n                    try:\n                        if \"Planetary Computer\" in catalog.value:\n                            output.outputs = ()\n                            m.add_stac_layer(\n                                collection=collection.value,\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(\n                                m,\n                                \"stac_item\",\n                                m.stac_dict[item.value],\n                            )\n                            m.stac_item[\"collection\"] = collection.value\n\n                        else:\n                            output.outputs = ()\n                            m.add_stac_layer(\n                                url=stac_data[0][item.value][\"href\"],\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(m, \"stac_item\", m.stac_dict[item.value])\n                            if \"rescale\" in m.layers[-1].url:\n                                output.outputs = ()\n\n                        output.clear_output()\n                    except Exception as e:\n                        print(e)\n\n                else:\n                    print(\"Please click on 'Items' to retrieve items.\")\n                    buttons.value = None\n\n        elif change[\"new\"] == \"Reset\":\n            reset_options()\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = True\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.stac_gui","title":"<code>stac_gui(m, position='topright', opened=True, **kwargs)</code>","text":"<p>Generates a tool GUI template using ipywidgets.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def stac_gui(\n    m,\n    position: Optional[str] = \"topright\",\n    opened: Optional[bool] = True,\n    **kwargs,\n):\n    \"\"\"Generates a tool GUI template using ipywidgets.\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    import pandas as pd\n\n    if os.environ.get(\"STAC_CATALOGS\") is not None:\n        try:\n            source = eval(os.environ.get(\"STAC_CATALOGS\"))\n            m.set_catalog_source(source)\n        except Exception as e:\n            print(e)\n            print(\"Invalid STAC_CATALOGS environment variable.\")\n\n    if hasattr(m, \"_STAC_CATALOGS\"):\n        stac_custom_gui(m, **kwargs)\n        return\n\n    widget_width = \"450px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n    MAX_ITEMS = 20\n    if \"MAX_ITEMS\" in os.environ:\n        MAX_ITEMS = int(os.environ[\"MAX_ITEMS\"])\n\n    catalog_path = download_data_catalogs()\n    aws_open_data_path = os.path.join(catalog_path, \"aws_stac_catalogs.tsv\")\n    gee_path = os.path.join(catalog_path, \"gee_catalog.tsv\")\n    pc_path = os.path.join(catalog_path, \"pc_catalog.tsv\")\n    nasa_path = os.path.join(catalog_path, \"nasa_cmr_catalog.tsv\")\n    stac_index_path = os.path.join(catalog_path, \"stac_catalogs.tsv\")\n    stac_data = []\n\n    stac_info = {\n        \"AWS Open Data\": {\n            \"filename\": aws_open_data_path,\n            \"name\": \"Name\",\n            \"url\": \"Endpoint\",\n            \"description\": \"Description\",\n        },\n        \"Google Earth Engine\": {\n            \"filename\": gee_path,\n            \"name\": \"id\",\n            \"url\": \"url\",\n            \"description\": \"title\",\n        },\n        \"Microsoft Planetary Computer\": {\n            \"filename\": pc_path,\n            \"name\": \"title\",\n            \"url\": \"link\",\n            \"description\": \"description\",\n        },\n        \"NASA Common Metadata Repository\": {\n            \"filename\": nasa_path,\n            \"name\": \"id\",\n            \"url\": \"url\",\n            \"description\": \"title\",\n        },\n        \"STAC Index Catalogs\": {\n            \"filename\": stac_index_path,\n            \"name\": \"title\",\n            \"url\": \"url\",\n            \"description\": \"summary\",\n        },\n        \"Custom STAC API Endpoint\": {\n            \"filename\": \"\",\n            \"name\": \"\",\n            \"url\": \"\",\n            \"description\": \"\",\n        },\n    }\n\n    connections = list(stac_info.keys())\n\n    output = widgets.Output(\n        layout=widgets.Layout(width=widget_width, padding=padding, overflow=\"auto\")\n    )\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Discver STAC Catalog\",\n        icon=\"stack-exchange\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    connection = widgets.Dropdown(\n        options=connections,\n        value=\"AWS Open Data\",\n        description=\"Catalog:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n    datasets = df[stac_info[connection.value][\"name\"]].tolist()\n\n    dataset = widgets.Dropdown(\n        options=datasets,\n        value=\"Sentinel-2 Cloud-Optimized GeoTIFFs\",\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    description = widgets.Text(\n        value=\"Sentinel-2 Level 2A scenes and metadata\",\n        description=\"Description:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    http_url = widgets.Text(\n        value=\"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a\",\n        description=\"URL:\",\n        tooltip=\"STAC Catalog URL\",\n        placeholder=\"Enter a STAC URL, e.g., https://earth-search.aws.element84.com/v1\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    custom_dataset = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Dataset:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    start_date = widgets.DatePicker(\n        description=\"Start date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n    end_date = widgets.DatePicker(\n        description=\"End date:\",\n        disabled=False,\n        style=style,\n        layout=widgets.Layout(width=\"225px\", padding=padding),\n    )\n\n    collection = widgets.Dropdown(\n        options=[],\n        value=None,\n        description=\"Collection:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_names = [\"red\", \"green\", \"blue\"]\n\n    item = widgets.Dropdown(\n        options=[],\n        description=\"Item:\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    layer_name = widgets.Text(\n        value=\"STAC Layer\",\n        description=\"Layer name:\",\n        tooltip=\"Enter a layer name for the selected file\",\n        style=style,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n    )\n\n    band_width = \"149px\"\n    red = widgets.Dropdown(\n        options=band_names,\n        value=\"red\",\n        description=\"Red:\",\n        tooltip=\"Select a band for the red channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    green = widgets.Dropdown(\n        options=band_names,\n        value=\"green\",\n        description=\"Green:\",\n        tooltip=\"Select a band for the green channel\",\n        style=style,\n        layout=widgets.Layout(width=\"148px\", padding=padding),\n    )\n\n    blue = widgets.Dropdown(\n        options=band_names,\n        value=\"blue\",\n        description=\"Blue:\",\n        tooltip=\"Select a band for the blue channel\",\n        style=style,\n        layout=widgets.Layout(width=band_width, padding=padding),\n    )\n\n    max_items = widgets.Text(\n        value=\"20\",\n        description=\"Max items:\",\n        placeholder=\"Maximum number of items to return from the STAC API\",\n        tooltip=\"Maximum number of items to return from the STAC API\",\n        style=style,\n        layout=widgets.Layout(width=\"130px\", padding=padding),\n    )\n\n    vmin = widgets.Text(\n        value=None,\n        description=\"vmin:\",\n        tooltip=\"Minimum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    vmax = widgets.Text(\n        value=None,\n        description=\"vmax:\",\n        tooltip=\"Maximum value of the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"100px\", padding=padding),\n    )\n\n    nodata = widgets.Text(\n        value=None,\n        description=\"Nodata:\",\n        tooltip=\"Nodata the raster to visualize\",\n        style=style,\n        layout=widgets.Layout(width=\"113px\", padding=padding),\n    )\n\n    palette_options = list_palettes(lowercase=True)\n    palette = widgets.Dropdown(\n        options=palette_options,\n        value=None,\n        description=\"palette:\",\n        layout=widgets.Layout(width=\"180px\", padding=padding),\n        style=style,\n    )\n\n    add_footprints = widgets.Checkbox(\n        value=True,\n        description=\"Add footprints\",\n        indent=False,\n        layout=widgets.Layout(width=\"120px\", padding=padding),\n        style=style,\n    )\n\n    checkbox = widgets.Checkbox(\n        value=False,\n        description=\"Additional params\",\n        indent=False,\n        layout=widgets.Layout(width=\"154px\", padding=padding),\n        style=style,\n    )\n\n    query_params_text = \"Additional parameters to query the STAC API, for example: {'query': {'eo:cloud_cover':{'lt':10}}}\"\n    query_params = widgets.Textarea(\n        value=\"\",\n        placeholder=query_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    add_params_text = \"Additional parameters to visualize imagery, for example: {'palette': ['#006633', '#E5FFCC', '#662A00', '#D8D8D8', '#F5F5F5'], 'expression': '(SR_B5-SR_B4)/(SR_B5+SR_B4)'}\"\n    add_params = widgets.Textarea(\n        value=\"\",\n        placeholder=add_params_text,\n        layout=widgets.Layout(width=\"454px\", padding=padding),\n        style=style,\n    )\n\n    def reset_options(reset_url=True):\n        \"\"\"Reset the options to their default values.\"\"\"\n        connection.value = \"AWS Open Data\"\n        dataset.options = datasets\n        dataset.value = \"Sentinel-2 Cloud-Optimized GeoTIFFs\"\n        http_url.value = (\n            \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a\"\n        )\n        start_date.value = None\n        end_date.value = None\n        item.options = []\n        item.value = None\n        layer_name.value = \"\"\n        red.options = [\"red\", \"green\", \"blue\"]\n        green.options = [\"red\", \"green\", \"blue\"]\n        blue.options = [\"red\", \"green\", \"blue\"]\n        red.value = \"red\"\n        green.value = \"green\"\n        blue.value = \"blue\"\n        max_items.value = \"20\"\n        vmin.value = \"\"\n        vmax.value = \"\"\n        nodata.value = \"\"\n        palette.value = None\n        add_params.value = \"\"\n        output.outputs = ()\n\n    params_widget = widgets.VBox()\n\n    raster_options = widgets.VBox()\n    raster_options.children = [\n        widgets.HBox([red, green, blue]),\n        widgets.HBox([palette, add_footprints, checkbox]),\n        params_widget,\n    ]\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Search\", \"Display\", \"Reset\", \"Close\"],\n        tooltips=[\"Get Items\", \"Display Image\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"65px\"\n\n    dataset_widget = widgets.VBox()\n    dataset_widget.children = [\n        dataset,\n        description,\n        http_url,\n    ]\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        connection,\n        dataset_widget,\n        widgets.HBox([start_date, end_date]),\n        item,\n        raster_options,\n        buttons,\n        output,\n    ]\n\n    toolbar_event = ipyevents.Event(\n        source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    )\n\n    def update_bands():\n        if len(stac_data) &gt; 0:\n            bnames = stac_data[0][item.value][\"bands\"]\n        else:\n            bnames = []\n\n        red.options = bnames\n        green.options = bnames\n        blue.options = bnames\n\n        default_bands = set_default_bands(bnames)\n        try:\n            red.value = default_bands[0]\n            green.value = default_bands[1]\n            blue.value = default_bands[2]\n        except Exception as e:\n            red.value = None\n            green.value = None\n            blue.value = None\n\n    def connection_changed(change):\n        if change[\"new\"]:\n            if connection.value != \"Custom STAC API Endpoint\":\n                df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n                datasets = df[stac_info[connection.value][\"name\"]].tolist()\n                dataset.options = datasets\n                dataset.value = datasets[0]\n                dataset_widget.children = [dataset, description, http_url]\n            else:\n                http_url.value = \"https://earth-search.aws.element84.com/v1\"\n                dataset_widget.children = [http_url, custom_dataset]\n                with output:\n                    print(\"Enter a STAC API endpoint and press Enter to list datasets\")\n\n    connection.observe(connection_changed, names=\"value\")\n\n    def dataset_changed(change):\n        if change[\"new\"]:\n            if connection.value != \"Custom STAC API Endpoint\":\n                df = pd.read_csv(stac_info[connection.value][\"filename\"], sep=\"\\t\")\n                df = df[df[stac_info[connection.value][\"name\"]] == dataset.value]\n                description.value = df[\n                    stac_info[connection.value][\"description\"]\n                ].tolist()[0]\n                http_url.value = df[stac_info[connection.value][\"url\"]].tolist()[0]\n                item.options = []\n                custom_dataset.options = []\n                stac_data.clear()\n                update_bands()\n\n    dataset.observe(dataset_changed, names=\"value\")\n\n    def http_url_changed(change):\n        with output:\n            output.outputs = ()\n            print(\"Searching...\")\n            try:\n                if connection.value == \"Custom STAC API Endpoint\":\n                    custom_collections = stac_collections(\n                        http_url.value, return_ids=True\n                    )\n                    if custom_collections:\n                        custom_dataset.options = custom_collections\n\n                        collection_id = http_url.value.split(\"/\")[-1]\n                        if collection_id in custom_collections:\n                            custom_dataset.value = collection_id\n\n                    else:\n                        custom_dataset.options = []\n\n                else:\n                    custom_cols = stac_collections(http_url.value, return_ids=True)\n                    item.options = custom_cols\n                    stac_data.clear()\n                update_bands()\n                output.outputs = ()\n            except Exception as e:\n                print(e)\n\n    http_url.on_submit(http_url_changed)\n\n    def item_changed(change):\n        if change[\"new\"]:\n            layer_name.value = item.value\n            with output:\n                update_bands()\n\n            if dataset.value == \"Sentinel-2 Cloud-Optimized GeoTIFFs\":\n                vmin.value = \"0\"\n                vmax.value = \"3000\"\n            else:\n                vmin.value = \"\"\n                vmax.value = \"\"\n\n    item.observe(item_changed, names=\"value\")\n\n    def checkbox_changed(change):\n        if change[\"new\"]:\n            params_widget.children = [\n                layer_name,\n                widgets.HBox([max_items, vmin, vmax, nodata]),\n                query_params,\n                add_params,\n            ]\n        else:\n            params_widget.children = []\n\n    checkbox.observe(checkbox_changed, names=\"value\")\n\n    def handle_toolbar_event(event):\n        if event[\"type\"] == \"mouseenter\":\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        elif event[\"type\"] == \"mouseleave\":\n            if not toolbar_button.value:\n                toolbar_widget.children = [toolbar_button]\n                toolbar_button.value = False\n                close_button.value = False\n\n    toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Search\":\n            with output:\n                output.outputs = ()\n                if http_url.value is not None:\n                    if start_date.value is not None and end_date.value is not None:\n                        datetime = str(start_date.value) + \"/\" + str(end_date.value)\n                    elif start_date.value is not None:\n                        datetime = str(start_date.value) + \"/..\"\n                    elif end_date.value is not None:\n                        datetime = \"../\" + str(end_date.value)\n                    else:\n                        datetime = None\n\n                    if m is not None:\n                        if m.user_roi is not None:\n                            intersects = m.user_roi[\"geometry\"]\n                        else:\n                            intersects = bbox_to_geojson(m.bounds)\n\n                    else:\n                        intersects = None\n\n                    if (\n                        checkbox.value\n                        and query_params.value.strip().startswith(\"{\")\n                        and query_params.value.strip().endswith(\"}\")\n                    ):\n                        query = eval(query_params.value)\n                    elif query_params.value.strip() == \"\":\n                        query = {}\n                    else:\n                        print(\n                            \"Invalid query parameters. It must be a dictionary with keys such as 'query', 'sortby', 'filter', 'fields'\"\n                        )\n                        query = {}\n\n                print(\"Retrieving items...\")\n                try:\n                    if connection.value in [\n                        \"Google Earth Engine\",\n                        \"NASA Common Metadata Repository\",\n                    ]:\n                        output.outputs = ()\n                        print(f\"{connection.value} is not supported yet.\")\n                    else:\n                        if connection.value == \"Custom STAC API Endpoint\":\n                            search = stac_search(\n                                url=http_url.value,\n                                max_items=int(max_items.value),\n                                intersects=intersects,\n                                datetime=datetime,\n                                collections=custom_dataset.value,\n                                **query,\n                            )\n\n                        else:\n                            search = stac_search(\n                                url=http_url.value,\n                                max_items=int(max_items.value),\n                                intersects=intersects,\n                                datetime=datetime,\n                                **query,\n                            )\n                        search_dict = stac_search_to_dict(search)\n                        item.options = list(search_dict.keys())\n                        setattr(m, \"stac_search\", search)\n                        setattr(m, \"stac_dict\", search_dict)\n                        setattr(m, \"stac_items\", stac_search_to_list(search))\n\n                        if add_footprints.value and m is not None:\n                            gdf = stac_search_to_gdf(search)\n                            style = {\n                                \"stroke\": True,\n                                \"color\": \"#000000\",\n                                \"weight\": 2,\n                                \"opacity\": 1,\n                                \"fill\": True,\n                                \"fillColor\": \"#000000\",\n                                \"fillOpacity\": 0,\n                            }\n                            hover_style = {\"fillOpacity\": 0.3}\n                            m.add_gdf(\n                                gdf,\n                                style=style,\n                                hover_style=hover_style,\n                                layer_name=\"Footprints\",\n                                zoom_to_layer=False,\n                            )\n                            setattr(m, \"stac_gdf\", gdf)\n\n                        stac_data.clear()\n                        stac_data.append(search_dict)\n                        update_bands()\n                        output.outputs = ()\n                except NotImplementedError as e:\n                    print(e)\n\n                except Exception as e:\n                    print(e)\n\n        elif change[\"new\"] == \"Display\":\n            with output:\n                output.outputs = ()\n\n                if item.value and m is not None:\n                    print(\"Loading data...\")\n\n                    if (\n                        checkbox.value\n                        and add_params.value.strip().startswith(\"{\")\n                        and add_params.value.strip().endswith(\"}\")\n                    ):\n                        vis_params = eval(add_params.value)\n                    else:\n                        vis_params = {}\n\n                    if (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) == 1\n                    ) or (palette.value and \"expression\" in vis_params):\n                        vis_params[\"colormap_name\"] = palette.value\n                    elif (\n                        palette.value\n                        and len(set([red.value, green.value, blue.value])) &gt; 1\n                        and \"expression\" not in vis_params\n                    ):\n                        palette.value = None\n                        print(\"Palette can only be set for single band images.\")\n\n                    if vmin.value and vmax.value:\n                        vis_params[\"rescale\"] = f\"{vmin.value},{vmax.value}\"\n\n                    if nodata.value:\n                        vis_params[\"nodata\"] = nodata.value\n\n                    if len(set([red.value, green.value, blue.value])) == 1:\n                        assets = red.value\n                    else:\n                        assets = f\"{red.value},{green.value},{blue.value}\"\n\n                    try:\n                        if connection.value == \"Microsoft Planetary Computer\":\n                            m.add_stac_layer(\n                                collection=http_url.value.split(\"/\")[-1],\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(\n                                m,\n                                \"stac_item\",\n                                m.stac_dict[item.value],\n                            )\n                            m.stac_item[\"collection\"] = http_url.value.split(\"/\")[-1]\n\n                        else:\n                            m.add_stac_layer(\n                                url=stac_data[0][item.value][\"href\"],\n                                item=item.value,\n                                assets=assets,\n                                name=layer_name.value,\n                                fit_bounds=False,\n                                **vis_params,\n                            )\n                            setattr(m, \"stac_item\", m.stac_dict[item.value])\n                        output.outputs = ()\n                    except Exception as e:\n                        print(e)\n\n                else:\n                    print(\"Please click on the search button first.\")\n                    buttons.value = None\n\n        elif change[\"new\"] == \"Reset\":\n            reset_options()\n\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.time_slider","title":"<code>time_slider(m, layers=None, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary containing a set of XYZ tile layers.</p> <code>None</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the layer. Defaults to False.</p> <code>False</code> Source code in <code>leafmap/toolbar.py</code> <pre><code>def time_slider(\n    m,\n    layers: Optional[Union[Dict, List, str]] = None,\n    labels: Optional[List] = None,\n    time_interval: Optional[int] = 1,\n    position: Optional[str] = \"bottomright\",\n    slider_length: Optional[str] = \"150px\",\n    zoom_to_layer: Optional[bool] = False,\n    **kwargs,\n):\n    \"\"\"Adds a time slider to the map.\n\n    Args:\n        layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n        labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n        time_interval (int, optional): Time interval in seconds. Defaults to 1.\n        position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n        slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n        zoom_to_layer (bool, optional): Whether to zoom to the extent of the layer. Defaults to False.\n\n    \"\"\"\n    import time\n    import threading\n\n    bounds = None\n\n    if isinstance(layers, str):\n        layers = find_files(layers, ext=\"*.tif\", recursive=False)\n\n    if isinstance(layers, list):\n        if zoom_to_layer:\n            layer0 = layers[0]\n            _, tile_client = get_local_tile_layer(\n                layer0,\n                return_client=True,\n            )\n\n            bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n            bounds = (\n                bounds[2],\n                bounds[0],\n                bounds[3],\n                bounds[1],\n            )  # [minx, miny, maxx, maxy]\n            m.zoom_to_bounds(bounds)\n\n        layers = images_to_tiles(layers, names=labels, **kwargs)\n\n    if not isinstance(layers, dict):\n        raise TypeError(\"The layers must be a dictionary.\")\n\n    if len(layers) == 0:\n        layers = planet_monthly_tiles()\n\n    if labels is None:\n        labels = list(layers.keys())\n    if len(labels) != len(layers):\n        raise ValueError(\"The length of labels is not equal to that of layers.\")\n\n    slider = widgets.IntSlider(\n        min=1,\n        max=len(labels),\n        readout=False,\n        continuous_update=False,\n        layout=widgets.Layout(width=slider_length),\n    )\n    label = widgets.Label(\n        value=labels[0], layout=widgets.Layout(padding=\"0px 5px 0px 5px\")\n    )\n\n    play_btn = widgets.Button(\n        icon=\"play\",\n        tooltip=\"Play the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    pause_btn = widgets.Button(\n        icon=\"pause\",\n        tooltip=\"Pause the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    close_btn = widgets.Button(\n        icon=\"times\",\n        tooltip=\"Close the time slider\",\n        button_style=\"primary\",\n        layout=widgets.Layout(width=\"32px\"),\n    )\n\n    play_chk = widgets.Checkbox(value=False)\n\n    slider_widget = widgets.HBox([label, slider, play_btn, pause_btn, close_btn])\n\n    def play_click(b):\n        play_chk.value = True\n\n        def work(slider):\n            while play_chk.value:\n                if slider.value &lt; len(labels):\n                    slider.value += 1\n                else:\n                    slider.value = 1\n                time.sleep(time_interval)\n\n        thread = threading.Thread(target=work, args=(slider,))\n        thread.start()\n\n    def pause_click(b):\n        play_chk.value = False\n\n    play_btn.on_click(play_click)\n    pause_btn.on_click(pause_click)\n\n    keys = list(layers.keys())\n    layer = layers[keys[0]]\n    m.add(layer)\n\n    def slider_changed(change):\n        m.default_style = {\"cursor\": \"wait\"}\n        index = slider.value - 1\n        label.value = labels[index]\n        layer.url = layers[label.value].url\n        layer.name = layers[label.value].name\n        m.default_style = {\"cursor\": \"default\"}\n\n    slider.observe(slider_changed, \"value\")\n\n    def close_click(b):\n        play_chk.value = False\n        m.toolbar_reset()\n\n        if m.slider_ctrl is not None and m.slider_ctrl in m.controls:\n            m.remove_control(m.slider_ctrl)\n        slider_widget.close()\n\n    close_btn.on_click(close_click)\n\n    slider_ctrl = ipyleaflet.WidgetControl(widget=slider_widget, position=position)\n    m.add(slider_ctrl)\n    m.slider_ctrl = slider_ctrl\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.tool_header_template","title":"<code>tool_header_template(m, opened=True)</code>","text":"<p>Create a toolbar widget.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>geemap.Map</code> <p>The geemap.Map instance. Defaults to None.</p> required <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> Source code in <code>leafmap/toolbar.py</code> <pre><code>def tool_header_template(m, opened: Optional[bool] = True):\n    \"\"\"Create a toolbar widget.\n\n    Args:\n        m (geemap.Map, optional): The geemap.Map instance. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n    \"\"\"\n\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        buttons,\n        output,\n    ]\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"toolbar/#leafmap.toolbar.tool_template","title":"<code>tool_template(m, opened=True)</code>","text":"<p>Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>leafmap.Map</code> <p>The leaflet Map object. Defaults to None.</p> required <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ipywidgets</code> <p>The tool GUI widget.</p> Source code in <code>leafmap/toolbar.py</code> <pre><code>def tool_template(m, opened: Optional[bool] = True):\n    \"\"\"Generates a tool GUI template using ipywidgets. Icons can be found at https://fontawesome.com/v4/icons\n\n    Args:\n        m (leafmap.Map, optional): The leaflet Map object. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n\n    Returns:\n        ipywidgets: The tool GUI widget.\n    \"\"\"\n    widget_width = \"250px\"\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n    style = {\"description_width\": \"initial\"}\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"gear\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"),\n    )\n\n    checkbox = widgets.Checkbox(\n        description=\"Checkbox\",\n        indent=False,\n        layout=widgets.Layout(padding=padding, width=widget_width),\n    )\n\n    dropdown = widgets.Dropdown(\n        options=[\"Option 1\", \"Option 2\", \"Option 3\"],\n        value=None,\n        description=\"Dropdown:\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n        style=style,\n    )\n\n    int_slider = widgets.IntSlider(\n        min=1,\n        max=100,\n        description=\"Int Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"220px\", padding=padding),\n        style=style,\n    )\n\n    int_slider_label = widgets.Label(str(int_slider.value))\n\n    def update_int_slider(change):\n        int_slider_label.value = str(change[\"new\"])\n\n    int_slider.observe(update_int_slider, \"value\")\n\n    float_slider = widgets.FloatSlider(\n        min=1,\n        max=100,\n        description=\"Float Slider: \",\n        readout=False,\n        continuous_update=True,\n        layout=widgets.Layout(width=\"210px\", padding=padding),\n        style=style,\n    )\n\n    float_slider_label = widgets.Label(str(float_slider.value))\n\n    def update_float_slider(change):\n        float_slider_label.value = str(change[\"new\"])\n\n    float_slider.observe(update_float_slider, \"value\")\n\n    color = widgets.ColorPicker(\n        concise=False,\n        description=\"Color:\",\n        value=\"white\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    text = widgets.Text(\n        value=\"\",\n        description=\"Textbox:\",\n        placeholder=\"Placeholder\",\n        style=style,\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    textarea = widgets.Textarea(\n        placeholder=\"Placeholder\",\n        layout=widgets.Layout(width=widget_width, padding=padding),\n    )\n\n    buttons = widgets.ToggleButtons(\n        value=None,\n        options=[\"Apply\", \"Reset\", \"Close\"],\n        tooltips=[\"Apply\", \"Reset\", \"Close\"],\n        button_style=\"primary\",\n    )\n    buttons.style.button_width = \"80px\"\n\n    output = widgets.Output(layout=widgets.Layout(width=widget_width, padding=padding))\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    toolbar_header.children = [close_button, toolbar_button]\n    toolbar_footer = widgets.VBox()\n    toolbar_footer.children = [\n        checkbox,\n        widgets.HBox([int_slider, int_slider_label]),\n        widgets.HBox([float_slider, float_slider_label]),\n        dropdown,\n        text,\n        color,\n        textarea,\n        buttons,\n        output,\n    ]\n\n    # toolbar_event = ipyevents.Event(\n    #     source=toolbar_widget, watched_events=[\"mouseenter\", \"mouseleave\"]\n    # )\n\n    # def handle_toolbar_event(event):\n    #     if event[\"type\"] == \"mouseenter\":\n    #         toolbar_widget.children = [toolbar_header, toolbar_footer]\n    #     elif event[\"type\"] == \"mouseleave\":\n    #         if not toolbar_button.value:\n    #             toolbar_widget.children = [toolbar_button]\n    #             toolbar_button.value = False\n    #             close_button.value = False\n\n    # toolbar_event.on_dom_event(handle_toolbar_event)\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n        else:\n            if not close_button.value:\n                toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    def button_clicked(change):\n        if change[\"new\"] == \"Apply\":\n            with output:\n                output.outputs = ()\n                print(\"Running ...\")\n        elif change[\"new\"] == \"Reset\":\n            textarea.value = \"\"\n            output.outputs = ()\n        elif change[\"new\"] == \"Close\":\n            if m is not None:\n                m.toolbar_reset()\n                if m.tool_control is not None and m.tool_control in m.controls:\n                    m.remove_control(m.tool_control)\n                    m.tool_control = None\n            toolbar_widget.close()\n\n        buttons.value = None\n\n    buttons.observe(button_clicked, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=\"topright\"\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n            m.tool_control = toolbar_control\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#workshops","title":"Workshops","text":"<ul> <li>FOSS4G 2021 - Using Leafmap for Geospatial Analysis and Data Visualization (notebook)</li> <li>SIGSPATIAL 2021 - Interactive Mapping and Geospatial Analysis with Leafmap &amp; Jupyter (notebook)</li> <li>YouthMappers 2021 - Interactive Mapping and Geospatial Analysis with Leafmap and Jupyter (notebook)</li> </ul>"},{"location":"tutorials/#tutorials_1","title":"Tutorials","text":"<ol> <li>Introducing the leafmap Python package for interactive mapping (video | gif | notebook)</li> <li>Using basemaps in leafmap (video | gif | notebook)</li> <li>Using Cloud Optimized GeoTIFF (COG) and SpatioTemporal Asset Catalog (STAC) (notebook)</li> <li>Creating a virtual mosaic of Cloud Optimized GeoTIFFs (COG) (notebook)</li> <li>Loading local raster datasets with leafmap (notebook)</li> <li>Adding custom legends to the map (notebook)</li> <li>Adding custom colorbars to the map (notebook)</li> <li>Using WhiteboxTools with leafmap (notebook)</li> <li>Converting CSV to points (notebook)</li> <li>Adding local vector data (e.g., shp, geojson, kml) to the map (notebook)</li> <li>Creating linked maps for visualizing multiple maps simultaneously (notebook)</li> <li>Creating a split-panel map with only one line of code (notebook)</li> <li>Adding a GeoPandas GeoDataFrame to the map with a single line of code (notebook)</li> <li>Adding data from a PostGIS database to the map (notebook)</li> <li>Downloading OpenStreetMap data with a single line of code (notebook)</li> <li>Using HERE Map Widget for Jupyter as a plotting backend (notebook)</li> <li>Adding vector tile layers to the map (notebook)</li> <li>Adding a point layer with popup attributes to the map (notebook)</li> <li>Saving maps as a html file (notebook)</li> <li>Adding Planet global monthly and quarterly mosaic (notebook)</li> <li>Using timeseries inspector with a single click (notebook)</li> <li>Using time slider for visualizing timeseries images (notebook)</li> <li>Creating colormaps with a single line of code (notebook)</li> <li>Creating heat map from csv (notebook)</li> <li>Creating a population heat map with a colorbar and map title (notebook)</li> <li>Creating an interactive map using the kepler.gl plotting backend (notebook)</li> <li>Creating a basemap gallery (notebook)</li> <li>Publishing maps with a single line of code (notebook)</li> <li>Using the pydeck plotting backend (notebook)</li> <li>Using U.S. Census data (notebook)</li> <li>Searching basemaps with xyzservices (notebook)</li> <li>Loading local raster datasets and Cloud Optimized GeoTIFF (COG) (notebook)</li> <li>Adding image overlay to the map (notebook)</li> <li>Adding points from xy data (e.g., CSV, Pandas DataFrame) (notebook)</li> <li>Adding circle markers from xy data (e.g., CSV, Pandas DataFrame) (notebook)</li> <li>Adding labels to the map (notebook)</li> <li>Adding Planetary Computer STAC item to the map (notebook)</li> <li>Using the plotly plotting backend (notebook)</li> <li>Getting pixel values using the Inspector tool (notebook)</li> <li>Using the interactive plotly toolbar GUI (notebook)</li> <li>Loading COG/STAC items using the raster GUI (notebook)</li> <li>Creating Cloud Optimized GeoTIFF (COG) (notebook)</li> <li>Searching for locations and features in vector data (notebook)</li> <li>Opening vector data attribute table without coding (notebook)</li> <li>Creating vector data interactively without coding (notebook)</li> <li>Editing existing vector data interactively without coding (notebook)</li> <li>Converting numpy array to COG (notebook)</li> <li>Visualizing LiDAR data in 3D with only one line of code (notebook)</li> <li>Creating a split-panel map with folium (notebook)</li> <li>Creating a marker cluster with custom icons (notebook)</li> <li>Clipping an image by mask (notebook)</li> <li>Visualizing NetCDF data (notebook)</li> <li>Creating choropleth maps with a variety of classification schemes (notebook)</li> <li>Plotting elevation data in 3D without only one line of code (notebook)</li> <li>LiDAR data analysis and visualization with whitebox and leafmap (notebook)</li> <li>Downloading 10-m National Elevation Dataset (NED) with only one line of code (notebook)</li> <li>Download data from The National Map (notebook)</li> <li>Creating interactive maps with bokeh (notebook)</li> <li>Creating legends using leafmap with only one line of code (notebook)</li> <li>Adding text, images, HTML, and widgets to the map (notebook)</li> <li>Creating an animated GIF from a vector dataset (notebook)</li> <li>Adding colorbars to a folium map (notebook)</li> <li>Using leafmap with ArcGIS Pro (notebook)</li> <li>Searching open geospatial datasets using STAC API (notebook)</li> <li>Visualizing raster datasets interactively in SageMaker Studio Lab (notebook)</li> <li>Developing interactive web apps with gradio and leafmap (notebook)</li> <li>Visualizing Maxar Open Data with Leafmap (notebook)</li> <li>Searching and visualizing OpenAerialMap imagery with leafmap (notebook)</li> <li>Visualizing Maxar Open Data for the 2023 Turkey-Syria Earthquake (notebook)</li> <li>Calculating zonal statistics - summarizing geospatial raster datasets based on vector geometries (notebook)</li> <li>Loading geospatial datasets from an AWS S3 bucket (notebook)</li> <li>Creating timelapse animations from satellite imagery timeseries (notebook)</li> <li>Searching Geospatial Data Interactively with Custom STAC API Endpoints (notebook)</li> <li>Downloading maps tiles and converting them to a GeoTIFF file (notebook)</li> <li>Segmenting satellite imagery with the Segment Anything Model (notebook)</li> <li>Comparing images with an interactive slider (notebook)</li> <li>Splitting a raster dataset into multiple tiles (notebook)</li> <li>Interactive Extraction and Visualization of AWS Open Geospatial Data (notebook)</li> <li>Visualizing time series images interactively with a time slider (notebook)</li> <li>Visualizing solar radiation data from Google Solar API (notebook)</li> <li>Downloading Microsoft and Google Building Footprints (notebook)</li> <li>Visualizing PMTiles with leafmap (notebook)</li> <li>Visualizing large vector datasets with lonboard (notebook)</li> <li>Reading GeoParquet files and visualizing vector data interactively (notebook)</li> <li>How to search and download GEDI L4A dataset interactively (notebook)</li> <li>Adding markers to the map (notebook)</li> <li>Cloud-based geoprocessing with Actinia (notebook)</li> <li>Searching and downloading NASA Earth science data products (notebook)</li> <li>Visualizing in-memory raster datasets and image arrays (notebook)</li> <li>Querying pixel values with the interactive pixel inspector (notebook)</li> <li>Visualizing raster data interactively (notebook)</li> <li>Creating 3D maps with the MapLibre mapping backend (notebook)</li> <li>Visualizing PMTiles with Leafmap and MapLibre (notebook)</li> </ol>"},{"location":"tutorials/#demo","title":"Demo","text":""},{"location":"usage/","title":"Usage","text":"<p>You can try out leafmap by using Goolge Colab () or Binder () without having to install anything on your computer.</p>"},{"location":"usage/#launch-jupyter-notebook","title":"Launch Jupyter notebook","text":"<pre><code>conda activate geo\njupyter notebook\n</code></pre>"},{"location":"usage/#use-ipyleaflet-plotting-backend","title":"Use ipyleaflet plotting backend","text":"<pre><code>import leafmap\n</code></pre>"},{"location":"usage/#use-folium-plotting-backend","title":"Use folium plotting backend","text":"<pre><code>import leafmap.foliumap as leafmap\n</code></pre>"},{"location":"usage/#create-an-interactive-map","title":"Create an interactive map","text":"<pre><code>m = leafmap.Map(center=(40, -100), zoom=4)\nm\n</code></pre>"},{"location":"usage/#customize-map-height","title":"Customize map height","text":"<pre><code>m = leafmap.Map(height=\"450px\")\nm\n</code></pre>"},{"location":"usage/#set-control-visibility","title":"Set control visibility","text":"<pre><code>m = leafmap.Map(draw_control=False, measure_control=False, fullscreen_control=False, attribution_control=True)\nm\n</code></pre>"},{"location":"usage/#change-basemaps","title":"Change basemaps","text":"<pre><code>m = leafmap.Map(google_map=\"TERRAIN\")\nm.add_basemap(\"HYBRID\")\nm\n</code></pre>"},{"location":"usage/#add-xyz-tile-layer","title":"Add XYZ tile layer","text":"<pre><code>m = leafmap.Map()\nm.add_tile_layer(url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\", name=\"Google Satellite\", attribution=\"Google\")\nm\n</code></pre>"},{"location":"usage/#add-wms-tile-layer","title":"Add WMS tile layer","text":"<pre><code>m = leafmap.Map()\nnaip_url = 'https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?'\nm.add_wms_layer(url=naip_url, layers='0', name='NAIP Imagery', format='image/png', shown=True)\nm\n</code></pre>"},{"location":"usage/#use-here-map-widget-for-jupyter-plotting-backend","title":"Use HERE Map Widget for Jupyter plotting backend","text":""},{"location":"usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>A HERE developer account, free and available under HERE Developer Portal</li> <li>An API key from the HERE Developer Portal</li> <li>Export API key into environment variable <code>HEREMAPS_API_KEY</code></li> </ul> <pre><code>export HEREMAPS_API_KEY=YOUR-ACTUAL-API-KEY\n</code></pre> <pre><code>import leafmap.heremap as leafmap\n</code></pre>"},{"location":"usage/#create-an-interactive-map_1","title":"Create an interactive map","text":"<pre><code>import os\napi_key = os.environ.get(\"HEREMAPS_API_KEY\") # read api_key from environment variable.\nm = leafmap.Map(api_key=api_key, center=(40, -100), zoom=4)\nm\n</code></pre>"},{"location":"assets/","title":"Credits","text":"<p>Credits to Khalil Misbah for the original design of the leafmap logo.</p> <p></p>"},{"location":"assets/archive/","title":"Credits","text":"<p>Credits to Iban Ameztoy for designing the first leafmap logo.</p> <p></p>"},{"location":"data/","title":"Index","text":""},{"location":"data/#data-sources","title":"Data Sources","text":"<p>Some datasets contained in the repository were downloaded from various sources. Credits to the original owners of the datasets.</p> <p>The following datasets are downloaded from https://github.com/keplergl/kepler.gl/tree/master/bindings/kepler.gl-jupyter/notebooks</p> <ul> <li>hex_data.csv</li> <li>hex_config.json</li> <li>sf_zip_geo.json</li> </ul>"},{"location":"maplibre/3d_buildings/","title":"3d buildings","text":"<p>Display buildings in 3D</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Display buildings in 3D.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/basic-v2/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/basic-v2/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.0066, 40.7135], zoom=16, pitch=45, bearing=-17, style=style)\nsource = {\n    \"url\": f\"https://api.maptiler.com/tiles/v3/tiles.json?key={MAPTILER_KEY}\",\n    \"type\": \"vector\",\n}\n\nlayer = {\n    \"id\": \"3d-buildings\",\n    \"source\": \"openmaptiles\",\n    \"source-layer\": \"building\",\n    \"type\": \"fill-extrusion\",\n    \"min-zoom\": 15,\n    \"paint\": {\n        \"fill-extrusion-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"get\", \"render_height\"],\n            0,\n            \"lightgray\",\n            200,\n            \"royalblue\",\n            400,\n            \"lightblue\",\n        ],\n        \"fill-extrusion-height\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"zoom\"],\n            15,\n            0,\n            16,\n            [\"get\", \"render_height\"],\n        ],\n        \"fill-extrusion-base\": [\n            \"case\",\n            [\"&gt;=\", [\"get\", \"zoom\"], 16],\n            [\"get\", \"render_min_height\"],\n            0,\n        ],\n    },\n}\nm.add_source(\"openmaptiles\", source)\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-74.0066, 40.7135], zoom=16, pitch=45, bearing=-17, style=style) source = {     \"url\": f\"https://api.maptiler.com/tiles/v3/tiles.json?key={MAPTILER_KEY}\",     \"type\": \"vector\", }  layer = {     \"id\": \"3d-buildings\",     \"source\": \"openmaptiles\",     \"source-layer\": \"building\",     \"type\": \"fill-extrusion\",     \"min-zoom\": 15,     \"paint\": {         \"fill-extrusion-color\": [             \"interpolate\",             [\"linear\"],             [\"get\", \"render_height\"],             0,             \"lightgray\",             200,             \"royalblue\",             400,             \"lightblue\",         ],         \"fill-extrusion-height\": [             \"interpolate\",             [\"linear\"],             [\"zoom\"],             15,             0,             16,             [\"get\", \"render_height\"],         ],         \"fill-extrusion-base\": [             \"case\",             [\"&gt;=\", [\"get\", \"zoom\"], 16],             [\"get\", \"render_min_height\"],             0,         ],     }, } m.add_source(\"openmaptiles\", source) m.add_layer(layer) m <p></p>"},{"location":"maplibre/3d_indoor_mapping/","title":"3d indoor mapping","text":"<p>Extrude polygons for 3D indoor mapping</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Extrude polygons for 3D indoor mapping.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(\n    center=(-87.61694, 41.86625), zoom=17, pitch=40, bearing=20, style=\"positron\"\n)\nm.add_basemap(\"OpenStreetMap.Mapnik\")\ndata = \"https://maplibre.org/maplibre-gl-js/docs/assets/indoor-3d-map.geojson\"\nm.add_geojson(\n    data,\n    layer_type=\"fill-extrusion\",\n    name=\"floorplan\",\n    paint={\n        \"fill-extrusion-color\": [\"get\", \"color\"],\n        \"fill-extrusion-height\": [\"get\", \"height\"],\n        \"fill-extrusion-base\": [\"get\", \"base_height\"],\n        \"fill-extrusion-opacity\": 0.5,\n    },\n)\nm\n</pre> m = leafmap.Map(     center=(-87.61694, 41.86625), zoom=17, pitch=40, bearing=20, style=\"positron\" ) m.add_basemap(\"OpenStreetMap.Mapnik\") data = \"https://maplibre.org/maplibre-gl-js/docs/assets/indoor-3d-map.geojson\" m.add_geojson(     data,     layer_type=\"fill-extrusion\",     name=\"floorplan\",     paint={         \"fill-extrusion-color\": [\"get\", \"color\"],         \"fill-extrusion-height\": [\"get\", \"height\"],         \"fill-extrusion-base\": [\"get\", \"base_height\"],         \"fill-extrusion-opacity\": 0.5,     }, ) m <p></p>"},{"location":"maplibre/3d_terrain/","title":"3d terrain","text":"<p>3D Terrain</p> <p>This source code of this example is adapted from the MapLibre GL JS example - 3D Terrain.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>style = {\n    \"version\": 8,\n    \"sources\": {\n        \"osm\": {\n            \"type\": \"raster\",\n            \"tiles\": [\"https://a.tile.openstreetmap.org/{z}/{x}/{y}.png\"],\n            \"tileSize\": 256,\n            \"attribution\": \"&amp;copy; OpenStreetMap Contributors\",\n            \"maxzoom\": 19,\n        },\n        \"terrainSource\": {\n            \"type\": \"raster-dem\",\n            \"url\": \"https://demotiles.maplibre.org/terrain-tiles/tiles.json\",\n            \"tileSize\": 256,\n        },\n        \"hillshadeSource\": {\n            \"type\": \"raster-dem\",\n            \"url\": \"https://demotiles.maplibre.org/terrain-tiles/tiles.json\",\n            \"tileSize\": 256,\n        },\n    },\n    \"layers\": [\n        {\"id\": \"osm\", \"type\": \"raster\", \"source\": \"osm\"},\n        {\n            \"id\": \"hills\",\n            \"type\": \"hillshade\",\n            \"source\": \"hillshadeSource\",\n            \"layout\": {\"visibility\": \"visible\"},\n            \"paint\": {\"hillshade-shadow-color\": \"#473B24\"},\n        },\n    ],\n    \"terrain\": {\"source\": \"terrainSource\", \"exaggeration\": 1},\n}\n</pre> style = {     \"version\": 8,     \"sources\": {         \"osm\": {             \"type\": \"raster\",             \"tiles\": [\"https://a.tile.openstreetmap.org/{z}/{x}/{y}.png\"],             \"tileSize\": 256,             \"attribution\": \"\u00a9 OpenStreetMap Contributors\",             \"maxzoom\": 19,         },         \"terrainSource\": {             \"type\": \"raster-dem\",             \"url\": \"https://demotiles.maplibre.org/terrain-tiles/tiles.json\",             \"tileSize\": 256,         },         \"hillshadeSource\": {             \"type\": \"raster-dem\",             \"url\": \"https://demotiles.maplibre.org/terrain-tiles/tiles.json\",             \"tileSize\": 256,         },     },     \"layers\": [         {\"id\": \"osm\", \"type\": \"raster\", \"source\": \"osm\"},         {             \"id\": \"hills\",             \"type\": \"hillshade\",             \"source\": \"hillshadeSource\",             \"layout\": {\"visibility\": \"visible\"},             \"paint\": {\"hillshade-shadow-color\": \"#473B24\"},         },     ],     \"terrain\": {\"source\": \"terrainSource\", \"exaggeration\": 1}, } In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[11.39085, 47.27574], zoom=12, pitch=52, style=style)\nm\n</pre> m = leafmap.Map(center=[11.39085, 47.27574], zoom=12, pitch=52, style=style) m <p></p> In\u00a0[6]: Copied! <pre>m = leafmap.Map(\n    center=[-122.19861, 46.21168], zoom=13, pitch=60, bearing=150, style=\"3d-terrain\"\n)\nm\n</pre> m = leafmap.Map(     center=[-122.19861, 46.21168], zoom=13, pitch=60, bearing=150, style=\"3d-terrain\" ) m <pre>An API key is required to use the 3D terrain feature.\n</pre> <p></p>"},{"location":"maplibre/_template/","title":"template","text":"<p>MapLibre Example</p> <p>This source code of this example is adapted from the MapLibre GL JS example - maplibre_xxx.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3, style=style)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3, style=style) m"},{"location":"maplibre/add_a_marker/","title":"Add a marker","text":"<p>Add a default marker</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a default marker.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=[12.550343, 55.665957], zoom=8, style=\"positron\")\nm.add_marker(lng_lat=[12.550343, 55.665957])\nm\n</pre> m = leafmap.Map(center=[12.550343, 55.665957], zoom=8, style=\"positron\") m.add_marker(lng_lat=[12.550343, 55.665957]) m <p></p>"},{"location":"maplibre/add_deckgl_layer/","title":"Add deckgl layer","text":"<p>Add deck.gl layers</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Create deck.gl layer using REST API.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(\n    style=\"positron\",\n    center=(-122.4, 37.74),\n    zoom=12,\n    pitch=40,\n)\ndeck_grid_layer = {\n    \"@@type\": \"GridLayer\",\n    \"id\": \"GridLayer\",\n    \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-bike-parking.json\",\n    \"extruded\": True,\n    \"getPosition\": \"@@=COORDINATES\",\n    \"getColorWeight\": \"@@=SPACES\",\n    \"getElevationWeight\": \"@@=SPACES\",\n    \"elevationScale\": 4,\n    \"cellSize\": 200,\n    \"pickable\": True,\n}\n\nm.add_deck_layers([deck_grid_layer], tooltip=\"Number of points: {{ count }}\")\nm\n</pre> m = leafmap.Map(     style=\"positron\",     center=(-122.4, 37.74),     zoom=12,     pitch=40, ) deck_grid_layer = {     \"@@type\": \"GridLayer\",     \"id\": \"GridLayer\",     \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-bike-parking.json\",     \"extruded\": True,     \"getPosition\": \"@@=COORDINATES\",     \"getColorWeight\": \"@@=SPACES\",     \"getElevationWeight\": \"@@=SPACES\",     \"elevationScale\": 4,     \"cellSize\": 200,     \"pickable\": True, }  m.add_deck_layers([deck_grid_layer], tooltip=\"Number of points: {{ count }}\") m <p></p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(\n    style=\"positron\",\n    center=(49.254, -123.13),\n    zoom=11,\n    pitch=45,\n)\ndeck_grid_layer = {\n    \"@@type\": \"GeoJsonLayer\",\n    \"id\": \"GeoJsonLayer\",\n    \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/geojson/vancouver-blocks.json\",\n    \"opacity\": 0.8,\n    \"stroked\": False,\n    \"filled\": True,\n    \"extruded\": True,\n    \"wireframe\": True,\n    \"getElevation\": \"@@=properties.valuePerSqm / 20\",\n    \"getFillColor\": [255, 255, \"@@=properties.growth * 255\"],\n    \"getLineColor\": [255, 255, 255],\n}\nm.add_deck_layers([deck_grid_layer])\nm\n</pre> m = leafmap.Map(     style=\"positron\",     center=(49.254, -123.13),     zoom=11,     pitch=45, ) deck_grid_layer = {     \"@@type\": \"GeoJsonLayer\",     \"id\": \"GeoJsonLayer\",     \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/geojson/vancouver-blocks.json\",     \"opacity\": 0.8,     \"stroked\": False,     \"filled\": True,     \"extruded\": True,     \"wireframe\": True,     \"getElevation\": \"@@=properties.valuePerSqm / 20\",     \"getFillColor\": [255, 255, \"@@=properties.growth * 255\"],     \"getLineColor\": [255, 255, 255], } m.add_deck_layers([deck_grid_layer]) m <p></p> In\u00a0[5]: Copied! <pre>import requests\n</pre> import requests In\u00a0[6]: Copied! <pre>data = requests.get(\n    \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson\"\n).json()\n</pre> data = requests.get(     \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson\" ).json() In\u00a0[7]: Copied! <pre>m = leafmap.Map(\n    style=\"positron\",\n    center=(51.47, 0.45),\n    zoom=4,\n    pitch=30,\n)\ndeck_geojson_layer = {\n    \"@@type\": \"GeoJsonLayer\",\n    \"id\": \"airports\",\n    \"data\": data,\n    \"filled\": True,\n    \"pointRadiusMinPixels\": 2,\n    \"pointRadiusScale\": 2000,\n    \"getPointRadius\": \"@@=11 - properties.scalerank\",\n    \"getFillColor\": [200, 0, 80, 180],\n    \"autoHighlight\": True,\n    \"pickable\": True,\n}\n\ndeck_arc_layer = {\n    \"@@type\": \"ArcLayer\",\n    \"id\": \"arcs\",\n    \"data\": [\n        feature\n        for feature in data[\"features\"]\n        if feature[\"properties\"][\"scalerank\"] &lt; 4\n    ],\n    \"getSourcePosition\": [-0.4531566, 51.4709959],  # London\n    \"getTargetPosition\": \"@@=geometry.coordinates\",\n    \"getSourceColor\": [0, 128, 200],\n    \"getTargetColor\": [200, 0, 80],\n    \"getWidth\": 2,\n    \"pickable\": True,\n}\n\nm.add_deck_layers(\n    [deck_geojson_layer, deck_arc_layer],\n    tooltip={\n        \"airports\": \"{{ &amp;properties.name }}\",\n        \"arcs\": \"gps_code: {{ properties.gps_code }}\",\n    },\n)\nm\n</pre> m = leafmap.Map(     style=\"positron\",     center=(51.47, 0.45),     zoom=4,     pitch=30, ) deck_geojson_layer = {     \"@@type\": \"GeoJsonLayer\",     \"id\": \"airports\",     \"data\": data,     \"filled\": True,     \"pointRadiusMinPixels\": 2,     \"pointRadiusScale\": 2000,     \"getPointRadius\": \"@@=11 - properties.scalerank\",     \"getFillColor\": [200, 0, 80, 180],     \"autoHighlight\": True,     \"pickable\": True, }  deck_arc_layer = {     \"@@type\": \"ArcLayer\",     \"id\": \"arcs\",     \"data\": [         feature         for feature in data[\"features\"]         if feature[\"properties\"][\"scalerank\"] &lt; 4     ],     \"getSourcePosition\": [-0.4531566, 51.4709959],  # London     \"getTargetPosition\": \"@@=geometry.coordinates\",     \"getSourceColor\": [0, 128, 200],     \"getTargetColor\": [200, 0, 80],     \"getWidth\": 2,     \"pickable\": True, }  m.add_deck_layers(     [deck_geojson_layer, deck_arc_layer],     tooltip={         \"airports\": \"{{ &amp;properties.name }}\",         \"arcs\": \"gps_code: {{ properties.gps_code }}\",     }, ) m <p></p>"},{"location":"maplibre/add_image/","title":"Add image","text":"<p>Add an icon to the map</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add an icon to the map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[0.349419, -1.80921], zoom=3, style=style)\nimage = \"https://upload.wikimedia.org/wikipedia/commons/7/7c/201408_cat.png\"\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}}\n        ],\n    },\n}\n\nlayer = {\n    \"id\": \"points\",\n    \"type\": \"symbol\",\n    \"source\": \"point\",\n    \"layout\": {\n        \"icon-image\": \"cat\",\n        \"icon-size\": 0.25,\n        \"text-field\": \"I love kitty!\",\n        \"text-font\": [\"Open Sans Regular\"],\n        \"text-offset\": [0, 3],\n        \"text-anchor\": \"top\",\n    },\n}\nm.add_image(\"cat\", image)\nm.add_source(\"point\", source)\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[0.349419, -1.80921], zoom=3, style=style) image = \"https://upload.wikimedia.org/wikipedia/commons/7/7c/201408_cat.png\" source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}}         ],     }, }  layer = {     \"id\": \"points\",     \"type\": \"symbol\",     \"source\": \"point\",     \"layout\": {         \"icon-image\": \"cat\",         \"icon-size\": 0.25,         \"text-field\": \"I love kitty!\",         \"text-font\": [\"Open Sans Regular\"],         \"text-offset\": [0, 3],         \"text-anchor\": \"top\",     }, } m.add_image(\"cat\", image) m.add_source(\"point\", source) m.add_layer(layer) m <p></p>"},{"location":"maplibre/add_image_generated/","title":"Add image generated","text":"<p>Add a generated icon to the map</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a generated icon to the map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport numpy as np\nimport leafmap.maplibregl as leafmap\n</pre> import os import numpy as np import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre># Generate the icon data\nwidth = 64  # The image will be 64 pixels square\nheight = 64\nbytes_per_pixel = 4  # Each pixel is represented by 4 bytes: red, green, blue, and alpha\ndata = np.zeros((width, width, bytes_per_pixel), dtype=np.uint8)\n\nfor x in range(width):\n    for y in range(width):\n        data[y, x, 0] = int((y / width) * 255)  # red\n        data[y, x, 1] = int((x / width) * 255)  # green\n        data[y, x, 2] = 128  # blue\n        data[y, x, 3] = 255  # alpha\n\n# Flatten the data array\nflat_data = data.flatten()\n\n# Create the image dictionary\nimage_dict = {\n    \"width\": width,\n    \"height\": height,\n    \"data\": flat_data.tolist(),\n}\n\nm = leafmap.Map(center=[0, 0], zoom=1, style=style)\nm.add_image(\"gradient\", image_dict)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}}\n        ],\n    },\n}\n\nlayer = {\n    \"id\": \"points\",\n    \"type\": \"symbol\",\n    \"source\": \"point\",\n    \"layout\": {\"icon-image\": \"gradient\"},\n}\n\nm.add_source(\"point\", source)\nm.add_layer(layer)\nm\n</pre> # Generate the icon data width = 64  # The image will be 64 pixels square height = 64 bytes_per_pixel = 4  # Each pixel is represented by 4 bytes: red, green, blue, and alpha data = np.zeros((width, width, bytes_per_pixel), dtype=np.uint8)  for x in range(width):     for y in range(width):         data[y, x, 0] = int((y / width) * 255)  # red         data[y, x, 1] = int((x / width) * 255)  # green         data[y, x, 2] = 128  # blue         data[y, x, 3] = 255  # alpha  # Flatten the data array flat_data = data.flatten()  # Create the image dictionary image_dict = {     \"width\": width,     \"height\": height,     \"data\": flat_data.tolist(), }  m = leafmap.Map(center=[0, 0], zoom=1, style=style) m.add_image(\"gradient\", image_dict) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}}         ],     }, }  layer = {     \"id\": \"points\",     \"type\": \"symbol\",     \"source\": \"point\",     \"layout\": {\"icon-image\": \"gradient\"}, }  m.add_source(\"point\", source) m.add_layer(layer) m <p></p>"},{"location":"maplibre/animate_a_line/","title":"Animate a line","text":"<p>Animate a line</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Animate a line.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport pandas as pd\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import pandas as pd import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/world/animated_line_data.csv\"\ndf = pd.read_csv(url)\ndf_sample = df.sample(n=1000, random_state=1).sort_index()\ndf_sample.loc[len(df_sample)] = df.iloc[-1]\ndf_sample.head()\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/world/animated_line_data.csv\" df = pd.read_csv(url) df_sample = df.sample(n=1000, random_state=1).sort_index() df_sample.loc[len(df_sample)] = df.iloc[-1] df_sample.head() Out[5]: x y 38 1.266667 3.532592 44 1.466667 4.088553 45 1.500000 4.181139 58 1.933333 5.382508 82 2.733333 7.586668 In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=0.5, style=style)\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\"type\": \"Feature\", \"geometry\": {\"type\": \"LineString\", \"coordinates\": [[0, 0]]}}\n    ],\n}\nsource = {\"type\": \"geojson\", \"data\": geojson}\nm.add_source(\"line\", source)\nlayer = {\n    \"id\": \"line-animation\",\n    \"type\": \"line\",\n    \"source\": \"line\",\n    \"layout\": {\"line-cap\": \"round\", \"line-join\": \"round\"},\n    \"paint\": {\"line-color\": \"#ed6498\", \"line-width\": 5, \"line-opacity\": 0.8},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=0.5, style=style) geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {\"type\": \"Feature\", \"geometry\": {\"type\": \"LineString\", \"coordinates\": [[0, 0]]}}     ], } source = {\"type\": \"geojson\", \"data\": geojson} m.add_source(\"line\", source) layer = {     \"id\": \"line-animation\",     \"type\": \"line\",     \"source\": \"line\",     \"layout\": {\"line-cap\": \"round\", \"line-join\": \"round\"},     \"paint\": {\"line-color\": \"#ed6498\", \"line-width\": 5, \"line-opacity\": 0.8}, } m.add_layer(layer) m In\u00a0[7]: Copied! <pre>run_times = 2\nfor i in range(run_times):\n    geojson[\"features\"][0][\"geometry\"][\"coordinates\"] = [[0, 0]]\n    for row in df_sample.itertuples():\n        time.sleep(0.005)\n        geojson[\"features\"][0][\"geometry\"][\"coordinates\"].append([row.x, row.y])\n        m.set_data(\"line\", geojson)\n</pre> run_times = 2 for i in range(run_times):     geojson[\"features\"][0][\"geometry\"][\"coordinates\"] = [[0, 0]]     for row in df_sample.itertuples():         time.sleep(0.005)         geojson[\"features\"][0][\"geometry\"][\"coordinates\"].append([row.x, row.y])         m.set_data(\"line\", geojson) <p></p>"},{"location":"maplibre/animate_camera_around_point/","title":"Animate camera around point","text":"<p>Animate map camera around a point</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Animate map camera around a point.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-87.62712, 41.89033], zoom=15, pitch=45, style=style)\nlayers = m.get_style_layers()\nfor layer in layers:\n    if layer[\"type\"] == \"symbol\" and (\"text-field\" in layer[\"layout\"]):\n        m.remove_layer(layer[\"id\"])\nlayer = {\n    \"id\": \"3d-buildings\",\n    \"source\": \"composite\",\n    \"source-layer\": \"building\",\n    \"filter\": [\"==\", \"extrude\", \"true\"],\n    \"type\": \"fill-extrusion\",\n    \"min_zoom\": 15,\n    \"paint\": {\n        \"fill-extrusion-color\": \"#aaa\",\n        \"fill-extrusion-height\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"zoom\"],\n            15,\n            0,\n            15.05,\n            [\"get\", \"height\"],\n        ],\n        \"fill-extrusion-base\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"zoom\"],\n            15,\n            0,\n            15.05,\n            [\"get\", \"min_height\"],\n        ],\n        \"fill-extrusion-opacity\": 0.6,\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-87.62712, 41.89033], zoom=15, pitch=45, style=style) layers = m.get_style_layers() for layer in layers:     if layer[\"type\"] == \"symbol\" and (\"text-field\" in layer[\"layout\"]):         m.remove_layer(layer[\"id\"]) layer = {     \"id\": \"3d-buildings\",     \"source\": \"composite\",     \"source-layer\": \"building\",     \"filter\": [\"==\", \"extrude\", \"true\"],     \"type\": \"fill-extrusion\",     \"min_zoom\": 15,     \"paint\": {         \"fill-extrusion-color\": \"#aaa\",         \"fill-extrusion-height\": [             \"interpolate\",             [\"linear\"],             [\"zoom\"],             15,             0,             15.05,             [\"get\", \"height\"],         ],         \"fill-extrusion-base\": [             \"interpolate\",             [\"linear\"],             [\"zoom\"],             15,             0,             15.05,             [\"get\", \"min_height\"],         ],         \"fill-extrusion-opacity\": 0.6,     }, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>for degree in range(0, 360, 1):\n    m.rotate_to(degree, {\"duration\": 0})\n    time.sleep(0.1)\n</pre> for degree in range(0, 360, 1):     m.rotate_to(degree, {\"duration\": 0})     time.sleep(0.1) <p></p>"},{"location":"maplibre/animate_images/","title":"Animate images","text":"<p>Animate a series of images</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Animate a series of images.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-75.789, 41.874], zoom=5, min_zoom=4, max_zoom=6, style=style)\n\n\ndef get_path(index):\n    return f\"https://maplibre.org/maplibre-gl-js/docs/assets/radar{index}.gif\"\n\n\nsource = {\n    \"type\": \"image\",\n    \"url\": get_path(0),\n    \"coordinates\": [\n        [-80.425, 46.437],\n        [-71.516, 46.437],\n        [-71.516, 37.936],\n        [-80.425, 37.936],\n    ],\n}\nm.add_source(\"radar\", source)\n\nlayer = {\n    \"id\": \"radar-layer\",\n    \"type\": \"raster\",\n    \"source\": \"radar\",\n    \"paint\": {\"raster-fade-duration\": 0},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-75.789, 41.874], zoom=5, min_zoom=4, max_zoom=6, style=style)   def get_path(index):     return f\"https://maplibre.org/maplibre-gl-js/docs/assets/radar{index}.gif\"   source = {     \"type\": \"image\",     \"url\": get_path(0),     \"coordinates\": [         [-80.425, 46.437],         [-71.516, 46.437],         [-71.516, 37.936],         [-80.425, 37.936],     ], } m.add_source(\"radar\", source)  layer = {     \"id\": \"radar-layer\",     \"type\": \"raster\",     \"source\": \"radar\",     \"paint\": {\"raster-fade-duration\": 0}, } m.add_layer(layer) m <p>The following step does not work properly yet. Will revisit this when it becomes possible.</p> In\u00a0[6]: Copied! <pre>for i in range(5):\n    time.sleep(1)\n    source = {\n        \"type\": \"image\",\n        \"url\": get_path(i),\n        \"coordinates\": [\n            [-80.425, 46.437],\n            [-71.516, 46.437],\n            [-71.516, 37.936],\n            [-80.425, 37.936],\n        ],\n    }\n    m.set_data(\"radar\", source)\n</pre> for i in range(5):     time.sleep(1)     source = {         \"type\": \"image\",         \"url\": get_path(i),         \"coordinates\": [             [-80.425, 46.437],             [-71.516, 46.437],             [-71.516, 37.936],             [-80.425, 37.936],         ],     }     m.set_data(\"radar\", source) <p></p>"},{"location":"maplibre/animate_point_along_line/","title":"Animate point along line","text":"<p>Animate a point</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Animate a point.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import math\nimport os\nimport time\nimport leafmap.maplibregl as leafmap\n</pre> import math import os import time import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>def point_on_circle(angle, radius):\n    return {\n        \"type\": \"Point\",\n        \"coordinates\": [math.cos(angle) * radius, math.sin(angle) * radius],\n    }\n</pre> def point_on_circle(angle, radius):     return {         \"type\": \"Point\",         \"coordinates\": [math.cos(angle) * radius, math.sin(angle) * radius],     } In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2, style=style)\nradius = 20\nsource = {\"type\": \"geojson\", \"data\": point_on_circle(0, radius)}\nm.add_source(\"point\", source)\nlayer = {\n    \"id\": \"point\",\n    \"source\": \"point\",\n    \"type\": \"circle\",\n    \"paint\": {\"circle-radius\": 10, \"circle-color\": \"#007cbf\"},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2, style=style) radius = 20 source = {\"type\": \"geojson\", \"data\": point_on_circle(0, radius)} m.add_source(\"point\", source) layer = {     \"id\": \"point\",     \"source\": \"point\",     \"type\": \"circle\",     \"paint\": {\"circle-radius\": 10, \"circle-color\": \"#007cbf\"}, } m.add_layer(layer) m In\u00a0[7]: Copied! <pre>def animate_marker(duration, frame_rate, radius):\n    start_time = time.time()\n    while (time.time() - start_time) &lt; duration:\n        timestamp = (time.time() - start_time) * 1000  # Convert to milliseconds\n        angle = timestamp / 1000  # Divisor controls the animation speed\n        point = point_on_circle(angle, radius)\n        m.set_data(\"point\", point)\n        # Wait for the next frame\n        time.sleep(1 / frame_rate)\n</pre> def animate_marker(duration, frame_rate, radius):     start_time = time.time()     while (time.time() - start_time) &lt; duration:         timestamp = (time.time() - start_time) * 1000  # Convert to milliseconds         angle = timestamp / 1000  # Divisor controls the animation speed         point = point_on_circle(angle, radius)         m.set_data(\"point\", point)         # Wait for the next frame         time.sleep(1 / frame_rate) In\u00a0[8]: Copied! <pre>duration = 10  # Duration of the animation in seconds\nframe_rate = 30  # Frames per second\n</pre> duration = 10  # Duration of the animation in seconds frame_rate = 30  # Frames per second In\u00a0[9]: Copied! <pre>animate_marker(duration, frame_rate, radius)\n</pre> animate_marker(duration, frame_rate, radius) <p></p>"},{"location":"maplibre/animate_point_along_route/","title":"Animate point along route","text":"<p>Animate a point along a route</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Animate a point along a route.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport requests\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import requests import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3, style=style)\nurl = \"https://github.com/opengeos/datasets/releases/download/us/arc_with_bearings.geojson\"\ngeojson = requests.get(url).json()\nbearings = geojson[\"features\"][0][\"properties\"][\"bearings\"]\ncoordinates = geojson[\"features\"][0][\"geometry\"][\"coordinates\"][:-1]\nm.add_geojson(geojson, name=\"route\")\n\norigin = [-122.414, 37.776]\ndestination = [-77.032, 38.913]\n\npoint = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": origin},\n        }\n    ],\n}\nsource = {\"type\": \"geojson\", \"data\": point}\nm.add_source(\"point\", source)\nlayer = {\n    \"id\": \"point\",\n    \"source\": \"point\",\n    \"type\": \"symbol\",\n    \"layout\": {\n        \"icon-image\": \"airport_15\",\n        \"icon-rotate\": [\"get\", \"bearing\"],\n        \"icon-rotation-alignment\": \"map\",\n        \"icon-overlap\": \"always\",\n        \"icon-ignore-placement\": True,\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3, style=style) url = \"https://github.com/opengeos/datasets/releases/download/us/arc_with_bearings.geojson\" geojson = requests.get(url).json() bearings = geojson[\"features\"][0][\"properties\"][\"bearings\"] coordinates = geojson[\"features\"][0][\"geometry\"][\"coordinates\"][:-1] m.add_geojson(geojson, name=\"route\")  origin = [-122.414, 37.776] destination = [-77.032, 38.913]  point = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": origin},         }     ], } source = {\"type\": \"geojson\", \"data\": point} m.add_source(\"point\", source) layer = {     \"id\": \"point\",     \"source\": \"point\",     \"type\": \"symbol\",     \"layout\": {         \"icon-image\": \"airport_15\",         \"icon-rotate\": [\"get\", \"bearing\"],         \"icon-rotation-alignment\": \"map\",         \"icon-overlap\": \"always\",         \"icon-ignore-placement\": True,     }, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>for index, coordinate in enumerate(coordinates):\n    point[\"features\"][0][\"geometry\"][\"coordinates\"] = coordinate\n    point[\"features\"][0][\"properties\"][\"bearing\"] = bearings[index]\n    m.set_data(\"point\", point)\n    time.sleep(0.05)\n</pre> for index, coordinate in enumerate(coordinates):     point[\"features\"][0][\"geometry\"][\"coordinates\"] = coordinate     point[\"features\"][0][\"properties\"][\"bearing\"] = bearings[index]     m.set_data(\"point\", point)     time.sleep(0.05) <p></p>"},{"location":"maplibre/attribution_position/","title":"Attribution position","text":"<p>Change the default position for attribution</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Change the default position for attribution.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style, controls={})\nm.add_control(\"attribution\", position=\"top-left\")\nm\n</pre> m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style, controls={}) m.add_control(\"attribution\", position=\"top-left\") m <p></p>"},{"location":"maplibre/center_on_symbol/","title":"Center on symbol","text":"<p>Center the map on a clicked symbol</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Center the map on a clicked symbol.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\nimport ipywidgets as widgets\n</pre> import os import leafmap.maplibregl as leafmap import ipywidgets as widgets <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-90.96, -0.47], zoom=7.5, style=style)\nimage = \"https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png\"\nm.add_image(\"custom-marker\", image)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"properties\": {},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [-91.395263671875, -0.9145729757782163],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"properties\": {},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [-90.32958984375, -0.6344474832838974],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"properties\": {},\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [-91.34033203125, 0.01647949196029245],\n                },\n            },\n        ],\n    },\n}\nm.add_source(\"points\", source)\nlayer = {\n    \"id\": \"symbols\",\n    \"type\": \"symbol\",\n    \"source\": \"points\",\n    \"layout\": {\"icon-image\": \"custom-marker\"},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-90.96, -0.47], zoom=7.5, style=style) image = \"https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png\" m.add_image(\"custom-marker\", image) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"properties\": {},                 \"geometry\": {                     \"type\": \"Point\",                     \"coordinates\": [-91.395263671875, -0.9145729757782163],                 },             },             {                 \"type\": \"Feature\",                 \"properties\": {},                 \"geometry\": {                     \"type\": \"Point\",                     \"coordinates\": [-90.32958984375, -0.6344474832838974],                 },             },             {                 \"type\": \"Feature\",                 \"properties\": {},                 \"geometry\": {                     \"type\": \"Point\",                     \"coordinates\": [-91.34033203125, 0.01647949196029245],                 },             },         ],     }, } m.add_source(\"points\", source) layer = {     \"id\": \"symbols\",     \"type\": \"symbol\",     \"source\": \"points\",     \"layout\": {\"icon-image\": \"custom-marker\"}, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>output = widgets.Output()\n\n\ndef log_lng_lat(lng_lat):\n    with output:\n        output.clear_output()\n        print(lng_lat.new)\n        m.fly_to(lng_lat.new[\"lng\"], lng_lat.new[\"lat\"])\n\n\nm.observe(log_lng_lat, \"clicked\")\noutput\n</pre> output = widgets.Output()   def log_lng_lat(lng_lat):     with output:         output.clear_output()         print(lng_lat.new)         m.fly_to(lng_lat.new[\"lng\"], lng_lat.new[\"lat\"])   m.observe(log_lng_lat, \"clicked\") output <p></p>"},{"location":"maplibre/change_building_color/","title":"Change building color","text":"<p>Change building color based on zoom level</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Change building color based on zoom level.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-90.73414, 14.55524], zoom=13, style=style)\nm.set_paint_property(\n    \"building\",\n    \"fill-color\",\n    [\"interpolate\", [\"exponential\", 0.5], [\"zoom\"], 15, \"#e2714b\", 22, \"#eee695\"],\n)\nm.set_paint_property(\n    \"building\",\n    \"fill-opacity\",\n    [\"interpolate\", [\"exponential\", 0.5], [\"zoom\"], 15, 0, 22, 1],\n)\nm\n</pre> m = leafmap.Map(center=[-90.73414, 14.55524], zoom=13, style=style) m.set_paint_property(     \"building\",     \"fill-color\",     [\"interpolate\", [\"exponential\", 0.5], [\"zoom\"], 15, \"#e2714b\", 22, \"#eee695\"], ) m.set_paint_property(     \"building\",     \"fill-opacity\",     [\"interpolate\", [\"exponential\", 0.5], [\"zoom\"], 15, 0, 22, 1], ) m In\u00a0[6]: Copied! <pre>m.add_call(\"zoomTo\", 19, {\"duration\": 9000})\n</pre> m.add_call(\"zoomTo\", 19, {\"duration\": 9000}) <p></p>"},{"location":"maplibre/change_case_of_labels/","title":"Change case of labels","text":"<p>Change the case of labels</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Change the case of labels.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-116.231, 43.604], zoom=11, style=style)\ngeojson = {\n    \"type\": \"geojson\",\n    \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/boise.geojson\",\n}\nm.add_source(\"off-leash-areas\", geojson)\nlayer = {\n    \"id\": \"off-leash-areas\",\n    \"type\": \"symbol\",\n    \"source\": \"off-leash-areas\",\n    \"layout\": {\n        \"icon-image\": \"dog-park-11\",\n        \"text-field\": [\n            \"format\",\n            [\"upcase\", [\"get\", \"FacilityName\"]],\n            {\"font-scale\": 0.8},\n            \"\\n\",\n            {},\n            [\"downcase\", [\"get\", \"Comments\"]],\n            {\"font-scale\": 0.6},\n        ],\n        \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],\n        \"text-offset\": [0, 0.6],\n        \"text-anchor\": \"top\",\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-116.231, 43.604], zoom=11, style=style) geojson = {     \"type\": \"geojson\",     \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/boise.geojson\", } m.add_source(\"off-leash-areas\", geojson) layer = {     \"id\": \"off-leash-areas\",     \"type\": \"symbol\",     \"source\": \"off-leash-areas\",     \"layout\": {         \"icon-image\": \"dog-park-11\",         \"text-field\": [             \"format\",             [\"upcase\", [\"get\", \"FacilityName\"]],             {\"font-scale\": 0.8},             \"\\n\",             {},             [\"downcase\", [\"get\", \"Comments\"]],             {\"font-scale\": 0.6},         ],         \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],         \"text-offset\": [0, 0.6],         \"text-anchor\": \"top\",     }, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/cloud_optimized_geotiff/","title":"Cloud optimized geotiff","text":"<p>Visualize Cloud Optimized GeoTIFF (COG)</p> <p>This notebook demonstrates how to visualize Cloud Optimized GeoTIFF (COG) files using the TiTiler demo endpoint (titiler.xyz). Please be gentle with the demo endpoint.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/satellite/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/satellite/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(style=style)\nbefore = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\nafter = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\"\n)\nm.add_cog_layer(before, name=\"Before\", attribution=\"Maxar\")\nm.add_cog_layer(after, name=\"After\", attribution=\"Maxar\", fit_bounds=True)\nm\n</pre> m = leafmap.Map(style=style) before = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) after = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\" ) m.add_cog_layer(before, name=\"Before\", attribution=\"Maxar\") m.add_cog_layer(after, name=\"After\", attribution=\"Maxar\", fit_bounds=True) m <p></p> In\u00a0[6]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() In\u00a0[7]: Copied! <pre>m = leafmap.Map(style=style)\ndem = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\"\nm.add_cog_layer(dem, name=\"DEM\", colormap_name=\"terrain\", fit_bounds=True)\nm\n</pre> m = leafmap.Map(style=style) dem = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\" m.add_cog_layer(dem, name=\"DEM\", colormap_name=\"terrain\", fit_bounds=True) m In\u00a0[8]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p>"},{"location":"maplibre/cluster/","title":"Cluster","text":"<p>Create and style clusters</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Create and style clusters.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-103.59179, 40.66995], zoom=3, style=style)\ndata = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\"\nsource_args = {\n    \"cluster\": True,\n    \"cluster_radius\": 50,\n    \"cluster_min_points\": 2,\n    \"cluster_max_zoom\": 14,\n    \"cluster_properties\": {\n        \"maxMag\": [\"max\", [\"get\", \"mag\"]],\n        \"minMag\": [\"min\", [\"get\", \"mag\"]],\n    },\n}\n\nm.add_geojson(\n    data,\n    layer_type=\"circle\",\n    name=\"earthquake-circles\",\n    filter=[\"!\", [\"has\", \"point_count\"]],\n    paint={\"circle-color\": \"darkblue\"},\n    source_args=source_args,\n)\n\nm.add_geojson(\n    data,\n    layer_type=\"circle\",\n    name=\"earthquake-clusters\",\n    filter=[\"has\", \"point_count\"],\n    paint={\n        \"circle-color\": [\n            \"step\",\n            [\"get\", \"point_count\"],\n            \"#51bbd6\",\n            100,\n            \"#f1f075\",\n            750,\n            \"#f28cb1\",\n        ],\n        \"circle-radius\": [\"step\", [\"get\", \"point_count\"], 20, 100, 30, 750, 40],\n    },\n    source_args=source_args,\n)\n\nm.add_geojson(\n    data,\n    layer_type=\"symbol\",\n    name=\"earthquake-labels\",\n    filter=[\"has\", \"point_count\"],\n    layout={\n        \"text-field\": [\"get\", \"point_count_abbreviated\"],\n        \"text-size\": 12,\n    },\n    source_args=source_args,\n)\nm\n</pre> m = leafmap.Map(center=[-103.59179, 40.66995], zoom=3, style=style) data = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\" source_args = {     \"cluster\": True,     \"cluster_radius\": 50,     \"cluster_min_points\": 2,     \"cluster_max_zoom\": 14,     \"cluster_properties\": {         \"maxMag\": [\"max\", [\"get\", \"mag\"]],         \"minMag\": [\"min\", [\"get\", \"mag\"]],     }, }  m.add_geojson(     data,     layer_type=\"circle\",     name=\"earthquake-circles\",     filter=[\"!\", [\"has\", \"point_count\"]],     paint={\"circle-color\": \"darkblue\"},     source_args=source_args, )  m.add_geojson(     data,     layer_type=\"circle\",     name=\"earthquake-clusters\",     filter=[\"has\", \"point_count\"],     paint={         \"circle-color\": [             \"step\",             [\"get\", \"point_count\"],             \"#51bbd6\",             100,             \"#f1f075\",             750,             \"#f28cb1\",         ],         \"circle-radius\": [\"step\", [\"get\", \"point_count\"], 20, 100, 30, 750, 40],     },     source_args=source_args, )  m.add_geojson(     data,     layer_type=\"symbol\",     name=\"earthquake-labels\",     filter=[\"has\", \"point_count\"],     layout={         \"text-field\": [\"get\", \"point_count_abbreviated\"],         \"text-size\": 12,     },     source_args=source_args, ) m In\u00a0[6]: Copied! <pre>m.set_center(-103.59179, 40.66995, 3)\n</pre> m.set_center(-103.59179, 40.66995, 3) <p></p>"},{"location":"maplibre/color_switcher/","title":"Color switcher","text":"<p>Change a layer's color with buttons</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Change a layer's color with buttons.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[12.338, 45.4385], zoom=17, style=style)\nm\n</pre> m = leafmap.Map(center=[12.338, 45.4385], zoom=17, style=style) m In\u00a0[6]: Copied! <pre>m.style_layer_interact(id=\"water\")\n</pre> m.style_layer_interact(id=\"water\") <p></p>"},{"location":"maplibre/custom_marker/","title":"Custom marker","text":"<p>Customize marker icon image</p> <p>The list of available icons can be found here.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport requests\nimport leafmap.maplibregl as leafmap\n</pre> import os import requests import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>url = (\n    \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\"\n)\ngeojson = requests.get(url).json()\n</pre> url = (     \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\" ) geojson = requests.get(url).json() In\u00a0[6]: Copied! <pre>m = leafmap.Map(style=style)\nsource = {\"type\": \"geojson\", \"data\": geojson}\n\nlayer = {\n    \"id\": \"cities\",\n    \"type\": \"symbol\",\n    \"source\": \"point\",\n    \"layout\": {\n        \"icon-image\": \"marker_15\",\n        \"icon-size\": 1,\n    },\n}\nm.add_source(\"point\", source)\nm.add_layer(layer)\nm.add_popup(\"cities\")\nm\n</pre> m = leafmap.Map(style=style) source = {\"type\": \"geojson\", \"data\": geojson}  layer = {     \"id\": \"cities\",     \"type\": \"symbol\",     \"source\": \"point\",     \"layout\": {         \"icon-image\": \"marker_15\",         \"icon-size\": 1,     }, } m.add_source(\"point\", source) m.add_layer(layer) m.add_popup(\"cities\") m <p></p>"},{"location":"maplibre/data_driven_lines/","title":"Data driven lines","text":"<p>Style lines with a data-driven property</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Style lines with a data-driven property.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-122.483831, 37.828826], zoom=16, style=style)\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"color\": \"#F7455D\"},\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4833858013153, 37.829607404976734],\n                    [-122.4830961227417, 37.82932776098012],\n                    [-122.4830746650696, 37.82932776098012],\n                    [-122.48218417167662, 37.82889558180985],\n                    [-122.48218417167662, 37.82890193740421],\n                    [-122.48221099376678, 37.82868372835086],\n                    [-122.4822163581848, 37.82868372835086],\n                    [-122.48205006122589, 37.82801003030873],\n                ],\n            },\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"color\": \"#33C9EB\"},\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.48393028974533, 37.829471820141016],\n                    [-122.48395174741744, 37.82940826466351],\n                    [-122.48395174741744, 37.829412501697064],\n                    [-122.48423874378203, 37.829357420242125],\n                    [-122.48422533273697, 37.829361657278575],\n                    [-122.48459815979002, 37.8293425906126],\n                    [-122.48458743095398, 37.8293447091313],\n                    [-122.4847564101219, 37.82932776098012],\n                    [-122.48474299907684, 37.829331998018276],\n                    [-122.4849334359169, 37.829298101706186],\n                    [-122.48492807149889, 37.82930022022615],\n                    [-122.48509705066681, 37.82920488676767],\n                    [-122.48509168624878, 37.82920912381288],\n                    [-122.48520433902739, 37.82905870855876],\n                    [-122.48519897460936, 37.82905870855876],\n                    [-122.4854403734207, 37.828594749716714],\n                    [-122.48543500900269, 37.82860534241688],\n                    [-122.48571664094925, 37.82808206121068],\n                    [-122.48570591211319, 37.82809689109353],\n                    [-122.4858346581459, 37.82797189627337],\n                    [-122.48582661151886, 37.82797825194729],\n                    [-122.4859634041786, 37.82788503534145],\n                    [-122.48595803976059, 37.82788927246246],\n                    [-122.48605459928514, 37.82786596829394],\n                ],\n            },\n        },\n    ],\n}\nsource = {\"type\": \"geojson\", \"data\": geojson}\nm.add_source(\"lines\", source)\n# Use a get expression (https://maplibre.org/maplibre-style-spec/expressions/#get)\n# to set the line-color to a feature property value.\nlayer = {\n    \"id\": \"lines\",\n    \"type\": \"line\",\n    \"source\": \"lines\",\n    \"paint\": {\"line-width\": 3, \"line-color\": [\"get\", \"color\"]},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-122.483831, 37.828826], zoom=16, style=style) geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {\"color\": \"#F7455D\"},             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4833858013153, 37.829607404976734],                     [-122.4830961227417, 37.82932776098012],                     [-122.4830746650696, 37.82932776098012],                     [-122.48218417167662, 37.82889558180985],                     [-122.48218417167662, 37.82890193740421],                     [-122.48221099376678, 37.82868372835086],                     [-122.4822163581848, 37.82868372835086],                     [-122.48205006122589, 37.82801003030873],                 ],             },         },         {             \"type\": \"Feature\",             \"properties\": {\"color\": \"#33C9EB\"},             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.48393028974533, 37.829471820141016],                     [-122.48395174741744, 37.82940826466351],                     [-122.48395174741744, 37.829412501697064],                     [-122.48423874378203, 37.829357420242125],                     [-122.48422533273697, 37.829361657278575],                     [-122.48459815979002, 37.8293425906126],                     [-122.48458743095398, 37.8293447091313],                     [-122.4847564101219, 37.82932776098012],                     [-122.48474299907684, 37.829331998018276],                     [-122.4849334359169, 37.829298101706186],                     [-122.48492807149889, 37.82930022022615],                     [-122.48509705066681, 37.82920488676767],                     [-122.48509168624878, 37.82920912381288],                     [-122.48520433902739, 37.82905870855876],                     [-122.48519897460936, 37.82905870855876],                     [-122.4854403734207, 37.828594749716714],                     [-122.48543500900269, 37.82860534241688],                     [-122.48571664094925, 37.82808206121068],                     [-122.48570591211319, 37.82809689109353],                     [-122.4858346581459, 37.82797189627337],                     [-122.48582661151886, 37.82797825194729],                     [-122.4859634041786, 37.82788503534145],                     [-122.48595803976059, 37.82788927246246],                     [-122.48605459928514, 37.82786596829394],                 ],             },         },     ], } source = {\"type\": \"geojson\", \"data\": geojson} m.add_source(\"lines\", source) # Use a get expression (https://maplibre.org/maplibre-style-spec/expressions/#get) # to set the line-color to a feature property value. layer = {     \"id\": \"lines\",     \"type\": \"line\",     \"source\": \"lines\",     \"paint\": {\"line-width\": 3, \"line-color\": [\"get\", \"color\"]}, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/disable_scroll_zoom/","title":"Disable scroll zoom","text":"<p>Disable scroll zoom</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Disable scroll zoom.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-122.65, 45.52], zoom=9, scroll_zoom=False, style=style)\nm\n</pre> m = leafmap.Map(center=[-122.65, 45.52], zoom=9, scroll_zoom=False, style=style) m <p></p>"},{"location":"maplibre/display_rich_text/","title":"Display rich text","text":"<p>Display and style rich text labels</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Display and style rich text labels.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[9.49, 49.01], zoom=4, style=style)\n\nm.set_layout_property(\n    \"label_country\",\n    \"text-field\",\n    [\n        \"format\",\n        [\"get\", \"name_en\"],\n        {\"font-scale\": 1.2},\n        \"\\n\",\n        {},\n        [\"get\", \"name\"],\n        {\n            \"font-scale\": 0.8,\n            \"text-font\": [\n                \"literal\",\n                [\"DIN Offc Pro Italic\", \"Arial Unicode MS Regular\"],\n            ],\n        },\n    ],\n)\n\nm\n</pre> m = leafmap.Map(center=[9.49, 49.01], zoom=4, style=style)  m.set_layout_property(     \"label_country\",     \"text-field\",     [         \"format\",         [\"get\", \"name_en\"],         {\"font-scale\": 1.2},         \"\\n\",         {},         [\"get\", \"name\"],         {             \"font-scale\": 0.8,             \"text-font\": [                 \"literal\",                 [\"DIN Offc Pro Italic\", \"Arial Unicode MS Regular\"],             ],         },     ], )  m <p></p>"},{"location":"maplibre/drag_a_marker/","title":"Drag a marker","text":"<p>Create a draggable Marker</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Create a draggable Marker.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2, style=style)\nm.add_marker(lng_lat=[0, 0], options={\"draggable\": True})\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2, style=style) m.add_marker(lng_lat=[0, 0], options={\"draggable\": True}) m <p></p>"},{"location":"maplibre/fallback_image/","title":"Fallback image","text":"<p>Use a fallback image</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Use a fallback image.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77, 38.75], zoom=5, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [-77.03238901390978, 38.913188059745586],\n                },\n                \"properties\": {\"title\": \"Washington DC\", \"icon\": \"monument\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-79.9959, 40.4406]},\n                \"properties\": {\"title\": \"Pittsburgh\", \"icon\": \"bridges\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-76.2859, 36.8508]},\n                \"properties\": {\"title\": \"Norfolk\", \"icon\": \"harbor\"},\n            },\n        ],\n    },\n}\nm.add_source(\"points\", source)\nlayer = {\n    \"id\": \"points\",\n    \"type\": \"symbol\",\n    \"source\": \"points\",\n    \"layout\": {\n        \"icon-image\": [\n            \"coalesce\",\n            [\"image\", [\"concat\", [\"get\", \"icon\"], \"_15\"]],\n            [\"image\", \"marker_15\"],\n        ],\n        \"text-field\": [\"get\", \"title\"],\n        \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],\n        \"text-offset\": [0, 0.6],\n        \"text-anchor\": \"top\",\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-77, 38.75], zoom=5, style=style) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {                     \"type\": \"Point\",                     \"coordinates\": [-77.03238901390978, 38.913188059745586],                 },                 \"properties\": {\"title\": \"Washington DC\", \"icon\": \"monument\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-79.9959, 40.4406]},                 \"properties\": {\"title\": \"Pittsburgh\", \"icon\": \"bridges\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-76.2859, 36.8508]},                 \"properties\": {\"title\": \"Norfolk\", \"icon\": \"harbor\"},             },         ],     }, } m.add_source(\"points\", source) layer = {     \"id\": \"points\",     \"type\": \"symbol\",     \"source\": \"points\",     \"layout\": {         \"icon-image\": [             \"coalesce\",             [\"image\", [\"concat\", [\"get\", \"icon\"], \"_15\"]],             [\"image\", \"marker_15\"],         ],         \"text-field\": [\"get\", \"title\"],         \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],         \"text-offset\": [0, 0.6],         \"text-anchor\": \"top\",     }, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/fill_pattern/","title":"Fill pattern","text":"<p>Add a pattern to a polygon</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a pattern to a polygon.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(zoom=1, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"Feature\",\n        \"properties\": {},\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [[[-30, -25], [-30, 35], [30, 35], [30, -25], [-30, -25]]],\n        },\n    },\n}\nm.add_source(\"source\", source)\nurl = \"https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Cat_silhouette.svg/64px-Cat_silhouette.svg.png\"\nm.add_image(\"pattern\", url)\nlayer = {\n    \"id\": \"pattern-layer\",\n    \"type\": \"fill\",\n    \"source\": \"source\",\n    \"paint\": {\"fill-pattern\": \"pattern\"},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(zoom=1, style=style) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"Feature\",         \"properties\": {},         \"geometry\": {             \"type\": \"Polygon\",             \"coordinates\": [[[-30, -25], [-30, 35], [30, 35], [30, -25], [-30, -25]]],         },     }, } m.add_source(\"source\", source) url = \"https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Cat_silhouette.svg/64px-Cat_silhouette.svg.png\" m.add_image(\"pattern\", url) layer = {     \"id\": \"pattern-layer\",     \"type\": \"fill\",     \"source\": \"source\",     \"paint\": {\"fill-pattern\": \"pattern\"}, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/fit_bounds/","title":"Fit bounds","text":"<p>Fit a map to a bounding box</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Fit a map to a bounding box.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style)\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style) m <p>Fit to Kenya.</p> In\u00a0[6]: Copied! <pre>bounds = [[32.958984, -5.353521], [43.50585, 5.615985]]\nm.fit_bounds(bounds)\n</pre> bounds = [[32.958984, -5.353521], [43.50585, 5.615985]] m.fit_bounds(bounds) <p></p>"},{"location":"maplibre/fly_to/","title":"Fly to","text":"<p>Fly to a location</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Fly to a location.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-2.242467, 53.478122], zoom=9, style=style)\nm\n</pre> m = leafmap.Map(center=[-2.242467, 53.478122], zoom=9, style=style) m In\u00a0[6]: Copied! <pre>m.fly_to(lon=-73.983609, lat=40.754368, zoom=12)\n</pre> m.fly_to(lon=-73.983609, lat=40.754368, zoom=12) <p></p>"},{"location":"maplibre/fly_to_options/","title":"Fly to options","text":"<p>Slowly fly to a location</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Slowly fly to a location.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style)\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style) m In\u00a0[6]: Copied! <pre>options = {\n    \"lon\": 74.5,\n    \"lat\": 40,\n    \"zoom\": 9,\n    \"bearing\": 0,\n    \"speed\": 0.2,\n    \"curve\": 1,\n    \"essential\": True,\n}\n\nm.fly_to(**options)\n</pre> options = {     \"lon\": 74.5,     \"lat\": 40,     \"zoom\": 9,     \"bearing\": 0,     \"speed\": 0.2,     \"curve\": 1,     \"essential\": True, }  m.fly_to(**options) <p></p>"},{"location":"maplibre/fullscreen/","title":"Fullscreen","text":"<p>View a fullscreen map</p> <p>This source code of this example is adapted from the MapLibre GL JS example - View a fullscreen map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[11.255, 43.77], zoom=13, style=style, controls={})\nm.add_control(\"navigation\", position=\"top-left\")\nm.add_control(\"fullscreen\", position=\"top-right\")\nm\n</pre> m = leafmap.Map(center=[11.255, 43.77], zoom=13, style=style, controls={}) m.add_control(\"navigation\", position=\"top-left\") m.add_control(\"fullscreen\", position=\"top-right\") m <p></p>"},{"location":"maplibre/geojson_layer_in_stack/","title":"Geojson layer in stack","text":"<p>Add a new layer below labels</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a new layer below labels.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-88.137343, 35.137451], zoom=4, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_urban_areas.geojson\",\n}\nm.add_source(\"urban-areas\", source)\nfirst_symbol_layer = m.find_first_symbol_layer()\nlayer = {\n    \"id\": \"urban-areas-fill\",\n    \"type\": \"fill\",\n    \"source\": \"urban-areas\",\n    \"layout\": {},\n    \"paint\": {\"fill-color\": \"#f08\", \"fill-opacity\": 0.4},\n}\nm.add_layer(layer, before_id=first_symbol_layer[\"id\"])\nm\n</pre> m = leafmap.Map(center=[-88.137343, 35.137451], zoom=4, style=style) source = {     \"type\": \"geojson\",     \"data\": \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_urban_areas.geojson\", } m.add_source(\"urban-areas\", source) first_symbol_layer = m.find_first_symbol_layer() layer = {     \"id\": \"urban-areas-fill\",     \"type\": \"fill\",     \"source\": \"urban-areas\",     \"layout\": {},     \"paint\": {\"fill-color\": \"#f08\", \"fill-opacity\": 0.4}, } m.add_layer(layer, before_id=first_symbol_layer[\"id\"]) m <p></p>"},{"location":"maplibre/geojson_line/","title":"Geojson line","text":"<p>Add a GeoJSON line</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a GeoJSON line.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-122.486052, 37.830348], zoom=15, style=style)\n\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"Feature\",\n        \"properties\": {},\n        \"geometry\": {\n            \"type\": \"LineString\",\n            \"coordinates\": [\n                [-122.48369693756104, 37.83381888486939],\n                [-122.48348236083984, 37.83317489144141],\n                [-122.48339653015138, 37.83270036637107],\n                [-122.48356819152832, 37.832056363179625],\n                [-122.48404026031496, 37.83114119107971],\n                [-122.48404026031496, 37.83049717427869],\n                [-122.48348236083984, 37.829920943955045],\n                [-122.48356819152832, 37.82954808664175],\n                [-122.48507022857666, 37.82944639795659],\n                [-122.48610019683838, 37.82880236636284],\n                [-122.48695850372314, 37.82931081282506],\n                [-122.48700141906738, 37.83080223556934],\n                [-122.48751640319824, 37.83168351665737],\n                [-122.48803138732912, 37.832158048267786],\n                [-122.48888969421387, 37.83297152392784],\n                [-122.48987674713133, 37.83263257682617],\n                [-122.49043464660643, 37.832937629287755],\n                [-122.49125003814696, 37.832429207817725],\n                [-122.49163627624512, 37.832564787218985],\n                [-122.49223709106445, 37.83337825839438],\n                [-122.49378204345702, 37.83368330777276],\n            ],\n        },\n    },\n}\n\nlayer = {\n    \"id\": \"route\",\n    \"type\": \"line\",\n    \"source\": \"route\",\n    \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},\n    \"paint\": {\"line-color\": \"#888\", \"line-width\": 8},\n}\nm.add_source(\"route\", source)\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-122.486052, 37.830348], zoom=15, style=style)  source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"Feature\",         \"properties\": {},         \"geometry\": {             \"type\": \"LineString\",             \"coordinates\": [                 [-122.48369693756104, 37.83381888486939],                 [-122.48348236083984, 37.83317489144141],                 [-122.48339653015138, 37.83270036637107],                 [-122.48356819152832, 37.832056363179625],                 [-122.48404026031496, 37.83114119107971],                 [-122.48404026031496, 37.83049717427869],                 [-122.48348236083984, 37.829920943955045],                 [-122.48356819152832, 37.82954808664175],                 [-122.48507022857666, 37.82944639795659],                 [-122.48610019683838, 37.82880236636284],                 [-122.48695850372314, 37.82931081282506],                 [-122.48700141906738, 37.83080223556934],                 [-122.48751640319824, 37.83168351665737],                 [-122.48803138732912, 37.832158048267786],                 [-122.48888969421387, 37.83297152392784],                 [-122.48987674713133, 37.83263257682617],                 [-122.49043464660643, 37.832937629287755],                 [-122.49125003814696, 37.832429207817725],                 [-122.49163627624512, 37.832564787218985],                 [-122.49223709106445, 37.83337825839438],                 [-122.49378204345702, 37.83368330777276],             ],         },     }, }  layer = {     \"id\": \"route\",     \"type\": \"line\",     \"source\": \"route\",     \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},     \"paint\": {\"line-color\": \"#888\", \"line-width\": 8}, } m.add_source(\"route\", source) m.add_layer(layer) m <p></p>"},{"location":"maplibre/geojson_points/","title":"Geojson points","text":"<p>Draw GeoJSON points</p> <p>Draw points from a GeoJSON collection to a map.</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Draw GeoJSON points.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>MAPTILER_KEY = os.environ.get(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/positron/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = os.environ.get(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/positron/style.json?key={MAPTILER_KEY}\" In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=1, style=style)\nimage = \"https://maplibre.org/maplibre-gl-js/docs/assets/osgeo-logo.png\"\nm.add_image(\"custom-marker\", image)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.4933, 13.7551]},\n                \"properties\": {\"year\": \"2004\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [6.6523, 46.5535]},\n                \"properties\": {\"year\": \"2006\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-123.3596, 48.4268]},\n                \"properties\": {\"year\": \"2007\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [18.4264, -33.9224]},\n                \"properties\": {\"year\": \"2008\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [151.195, -33.8552]},\n                \"properties\": {\"year\": \"2009\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [2.1404, 41.3925]},\n                \"properties\": {\"year\": \"2010\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-104.8548, 39.7644]},\n                \"properties\": {\"year\": \"2011\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-1.1665, 52.9539]},\n                \"properties\": {\"year\": \"2013\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.6544, 45.5428]},\n                \"properties\": {\"year\": \"2014\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [126.974, 37.5651]},\n                \"properties\": {\"year\": \"2015\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [7.1112, 50.7255]},\n                \"properties\": {\"year\": \"2016\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-71.0314, 42.3539]},\n                \"properties\": {\"year\": \"2017\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [39.2794, -6.8173]},\n                \"properties\": {\"year\": \"2018\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [26.0961, 44.4379]},\n                \"properties\": {\"year\": \"2019\"},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-114.0879, 51.0279]},\n                \"properties\": {\"year\": \"2020\"},\n            },\n        ],\n    },\n}\n\nm.add_source(\"conferences\", source)\nlayer = {\n    \"id\": \"conferences\",\n    \"type\": \"symbol\",\n    \"source\": \"conferences\",\n    \"layout\": {\n        \"icon-image\": \"custom-marker\",\n        \"text-field\": [\"get\", \"year\"],\n        \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],\n        \"text-offset\": [0, 1.25],\n        \"text-anchor\": \"top\",\n    },\n}\n\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=1, style=style) image = \"https://maplibre.org/maplibre-gl-js/docs/assets/osgeo-logo.png\" m.add_image(\"custom-marker\", image) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.4933, 13.7551]},                 \"properties\": {\"year\": \"2004\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [6.6523, 46.5535]},                 \"properties\": {\"year\": \"2006\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-123.3596, 48.4268]},                 \"properties\": {\"year\": \"2007\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [18.4264, -33.9224]},                 \"properties\": {\"year\": \"2008\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [151.195, -33.8552]},                 \"properties\": {\"year\": \"2009\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [2.1404, 41.3925]},                 \"properties\": {\"year\": \"2010\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-104.8548, 39.7644]},                 \"properties\": {\"year\": \"2011\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-1.1665, 52.9539]},                 \"properties\": {\"year\": \"2013\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.6544, 45.5428]},                 \"properties\": {\"year\": \"2014\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [126.974, 37.5651]},                 \"properties\": {\"year\": \"2015\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [7.1112, 50.7255]},                 \"properties\": {\"year\": \"2016\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-71.0314, 42.3539]},                 \"properties\": {\"year\": \"2017\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [39.2794, -6.8173]},                 \"properties\": {\"year\": \"2018\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [26.0961, 44.4379]},                 \"properties\": {\"year\": \"2019\"},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-114.0879, 51.0279]},                 \"properties\": {\"year\": \"2020\"},             },         ],     }, }  m.add_source(\"conferences\", source) layer = {     \"id\": \"conferences\",     \"type\": \"symbol\",     \"source\": \"conferences\",     \"layout\": {         \"icon-image\": \"custom-marker\",         \"text-field\": [\"get\", \"year\"],         \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],         \"text-offset\": [0, 1.25],         \"text-anchor\": \"top\",     }, }  m.add_layer(layer) m <p></p>"},{"location":"maplibre/geojson_polygon/","title":"Geojson polygon","text":"<p>Add a GeoJSON polygon</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a GeoJSON polygon.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-68.137343, 45.137451], zoom=5, style=style)\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-67.13734351262877, 45.137451890638886],\n                [-66.96466, 44.8097],\n                [-68.03252, 44.3252],\n                [-69.06, 43.98],\n                [-70.11617, 43.68405],\n                [-70.64573401557249, 43.090083319667144],\n                [-70.75102474636725, 43.08003225358635],\n                [-70.79761105007827, 43.21973948828747],\n                [-70.98176001655037, 43.36789581966826],\n                [-70.94416541205806, 43.46633942318431],\n                [-71.08482, 45.3052400000002],\n                [-70.6600225491012, 45.46022288673396],\n                [-70.30495378282376, 45.914794623389355],\n                [-70.00014034695016, 46.69317088478567],\n                [-69.23708614772835, 47.44777598732787],\n                [-68.90478084987546, 47.184794623394396],\n                [-68.23430497910454, 47.35462921812177],\n                [-67.79035274928509, 47.066248887716995],\n                [-67.79141211614706, 45.702585354182816],\n                [-67.13734351262877, 45.137451890638886],\n            ]\n        ],\n    },\n}\nsource = {\"type\": \"geojson\", \"data\": geojson}\nm.add_source(\"maine\", source)\nlayer = {\n    \"id\": \"maine\",\n    \"type\": \"fill\",\n    \"source\": \"maine\",\n    \"layout\": {},\n    \"paint\": {\"fill-color\": \"#088\", \"fill-opacity\": 0.8},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-68.137343, 45.137451], zoom=5, style=style) geojson = {     \"type\": \"Feature\",     \"geometry\": {         \"type\": \"Polygon\",         \"coordinates\": [             [                 [-67.13734351262877, 45.137451890638886],                 [-66.96466, 44.8097],                 [-68.03252, 44.3252],                 [-69.06, 43.98],                 [-70.11617, 43.68405],                 [-70.64573401557249, 43.090083319667144],                 [-70.75102474636725, 43.08003225358635],                 [-70.79761105007827, 43.21973948828747],                 [-70.98176001655037, 43.36789581966826],                 [-70.94416541205806, 43.46633942318431],                 [-71.08482, 45.3052400000002],                 [-70.6600225491012, 45.46022288673396],                 [-70.30495378282376, 45.914794623389355],                 [-70.00014034695016, 46.69317088478567],                 [-69.23708614772835, 47.44777598732787],                 [-68.90478084987546, 47.184794623394396],                 [-68.23430497910454, 47.35462921812177],                 [-67.79035274928509, 47.066248887716995],                 [-67.79141211614706, 45.702585354182816],                 [-67.13734351262877, 45.137451890638886],             ]         ],     }, } source = {\"type\": \"geojson\", \"data\": geojson} m.add_source(\"maine\", source) layer = {     \"id\": \"maine\",     \"type\": \"fill\",     \"source\": \"maine\",     \"layout\": {},     \"paint\": {\"fill-color\": \"#088\", \"fill-opacity\": 0.8}, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[-68.137343, 45.137451], zoom=5, style=style)\npaint = {\"fill-color\": \"#088\", \"fill-opacity\": 0.8}\nm.add_geojson(geojson, layer_type=\"fill\", paint=paint)\nm\n</pre> m = leafmap.Map(center=[-68.137343, 45.137451], zoom=5, style=style) paint = {\"fill-color\": \"#088\", \"fill-opacity\": 0.8} m.add_geojson(geojson, layer_type=\"fill\", paint=paint) m <p></p>"},{"location":"maplibre/geopandas/","title":"Geopandas","text":"<p>Add a GeoPandas GeoDataFrame to the map</p> <p>The following notebook demonstrates how to add a GeoPandas GeoDataFrame to the map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport geopandas as gpd\nimport leafmap.maplibregl as leafmap\n</pre> import os import geopandas as gpd import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3, style=style)\nurl = \"https://github.com/opengeos/datasets/releases/download/us/us_states.geojson\"\ngdf = gpd.read_file(url)\npaint = {\n    \"fill-color\": \"#3388ff\",\n    \"fill-opacity\": 0.8,\n    \"fill-outline-color\": \"#ffffff\",\n}\nm.add_gdf(gdf, layer_type=\"fill\", name=\"States\", paint=paint)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3, style=style) url = \"https://github.com/opengeos/datasets/releases/download/us/us_states.geojson\" gdf = gpd.read_file(url) paint = {     \"fill-color\": \"#3388ff\",     \"fill-opacity\": 0.8,     \"fill-outline-color\": \"#ffffff\", } m.add_gdf(gdf, layer_type=\"fill\", name=\"States\", paint=paint) m <p></p>"},{"location":"maplibre/heatmap_layer/","title":"Heatmap layer","text":"<p>Create a heatmap layer</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Create a heatmap layer.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-120, 50], zoom=2, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson\",\n}\nm.add_source(\"earthquakes\", source)\nlayer = {\n    \"id\": \"earthquakes-heat\",\n    \"type\": \"heatmap\",\n    \"source\": \"earthquakes\",\n    \"maxzoom\": 9,\n    \"paint\": {\n        # Increase the heatmap weight based on frequency and property magnitude\n        \"heatmap-weight\": [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 0, 0, 6, 1],\n        # Increase the heatmap color weight weight by zoom level\n        # heatmap-intensity is a multiplier on top of heatmap-weight\n        \"heatmap-intensity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 0, 1, 9, 3],\n        # Color ramp for heatmap.  Domain is 0 (low) to 1 (high).\n        # Begin color ramp at 0-stop with a 0-transparency color\n        # to create a blur-like effect.\n        \"heatmap-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"heatmap-density\"],\n            0,\n            \"rgba(33,102,172,0)\",\n            0.2,\n            \"rgb(103,169,207)\",\n            0.4,\n            \"rgb(209,229,240)\",\n            0.6,\n            \"rgb(253,219,199)\",\n            0.8,\n            \"rgb(239,138,98)\",\n            1,\n            \"rgb(178,24,43)\",\n        ],\n        # Adjust the heatmap radius by zoom level\n        \"heatmap-radius\": [\"interpolate\", [\"linear\"], [\"zoom\"], 0, 2, 9, 20],\n        # Transition from heatmap to circle layer by zoom level\n        \"heatmap-opacity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 7, 1, 9, 0],\n    },\n}\nm.add_layer(layer, before_id=\"waterway\")\nlayer2 = {\n    \"id\": \"earthquakes-point\",\n    \"type\": \"circle\",\n    \"source\": \"earthquakes\",\n    \"minzoom\": 7,\n    \"paint\": {\n        # Size circle radius by earthquake magnitude and zoom level\n        \"circle-radius\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"zoom\"],\n            7,\n            [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 1, 1, 6, 4],\n            16,\n            [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 1, 5, 6, 50],\n        ],\n        # Color circle by earthquake magnitude\n        \"circle-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"get\", \"mag\"],\n            1,\n            \"rgba(33,102,172,0)\",\n            2,\n            \"rgb(103,169,207)\",\n            3,\n            \"rgb(209,229,240)\",\n            4,\n            \"rgb(253,219,199)\",\n            5,\n            \"rgb(239,138,98)\",\n            6,\n            \"rgb(178,24,43)\",\n        ],\n        \"circle-stroke-color\": \"white\",\n        \"circle-stroke-width\": 1,\n        # Transition from heatmap to circle layer by zoom level\n        \"circle-opacity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 7, 0, 8, 1],\n    },\n}\nm.add_layer(layer2, before_id=\"waterway\")\nm\n</pre> m = leafmap.Map(center=[-120, 50], zoom=2, style=style) source = {     \"type\": \"geojson\",     \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson\", } m.add_source(\"earthquakes\", source) layer = {     \"id\": \"earthquakes-heat\",     \"type\": \"heatmap\",     \"source\": \"earthquakes\",     \"maxzoom\": 9,     \"paint\": {         # Increase the heatmap weight based on frequency and property magnitude         \"heatmap-weight\": [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 0, 0, 6, 1],         # Increase the heatmap color weight weight by zoom level         # heatmap-intensity is a multiplier on top of heatmap-weight         \"heatmap-intensity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 0, 1, 9, 3],         # Color ramp for heatmap.  Domain is 0 (low) to 1 (high).         # Begin color ramp at 0-stop with a 0-transparency color         # to create a blur-like effect.         \"heatmap-color\": [             \"interpolate\",             [\"linear\"],             [\"heatmap-density\"],             0,             \"rgba(33,102,172,0)\",             0.2,             \"rgb(103,169,207)\",             0.4,             \"rgb(209,229,240)\",             0.6,             \"rgb(253,219,199)\",             0.8,             \"rgb(239,138,98)\",             1,             \"rgb(178,24,43)\",         ],         # Adjust the heatmap radius by zoom level         \"heatmap-radius\": [\"interpolate\", [\"linear\"], [\"zoom\"], 0, 2, 9, 20],         # Transition from heatmap to circle layer by zoom level         \"heatmap-opacity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 7, 1, 9, 0],     }, } m.add_layer(layer, before_id=\"waterway\") layer2 = {     \"id\": \"earthquakes-point\",     \"type\": \"circle\",     \"source\": \"earthquakes\",     \"minzoom\": 7,     \"paint\": {         # Size circle radius by earthquake magnitude and zoom level         \"circle-radius\": [             \"interpolate\",             [\"linear\"],             [\"zoom\"],             7,             [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 1, 1, 6, 4],             16,             [\"interpolate\", [\"linear\"], [\"get\", \"mag\"], 1, 5, 6, 50],         ],         # Color circle by earthquake magnitude         \"circle-color\": [             \"interpolate\",             [\"linear\"],             [\"get\", \"mag\"],             1,             \"rgba(33,102,172,0)\",             2,             \"rgb(103,169,207)\",             3,             \"rgb(209,229,240)\",             4,             \"rgb(253,219,199)\",             5,             \"rgb(239,138,98)\",             6,             \"rgb(178,24,43)\",         ],         \"circle-stroke-color\": \"white\",         \"circle-stroke-width\": 1,         # Transition from heatmap to circle layer by zoom level         \"circle-opacity\": [\"interpolate\", [\"linear\"], [\"zoom\"], 7, 0, 8, 1],     }, } m.add_layer(layer2, before_id=\"waterway\") m <p></p>"},{"location":"maplibre/interactive_false/","title":"Interactive false","text":"<p>Display a non-interactive map</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Display a non-interactive map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=9, interactive=False, style=style, controls={})\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=9, interactive=False, style=style, controls={}) m <p></p>"},{"location":"maplibre/jump_to/","title":"Jump to","text":"<p>Jump to a series of locations</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Jump to a series of locations.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[100.507, 13.745], zoom=9, style=style)\n\ncities = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.507, 13.745]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [98.993, 18.793]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [99.838, 19.924]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.812, 17.408]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.458, 7.001]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.905, 12.935]},\n        },\n    ],\n}\nm\n</pre> m = leafmap.Map(center=[100.507, 13.745], zoom=9, style=style)  cities = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.507, 13.745]},         },         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [98.993, 18.793]},         },         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [99.838, 19.924]},         },         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.812, 17.408]},         },         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.458, 7.001]},         },         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [100.905, 12.935]},         },     ], } m In\u00a0[6]: Copied! <pre>for index, city in enumerate(cities[\"features\"]):\n    time.sleep(2)\n    coords = city[\"geometry\"][\"coordinates\"]\n    m.jump_to({\"center\": coords})\n</pre> for index, city in enumerate(cities[\"features\"]):     time.sleep(2)     coords = city[\"geometry\"][\"coordinates\"]     m.jump_to({\"center\": coords}) <p></p>"},{"location":"maplibre/language_switch/","title":"Language switch","text":"<p>Change a map's language</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Change a map's language.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\nimport ipywidgets as widgets\n</pre> import os import leafmap.maplibregl as leafmap import ipywidgets as widgets <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/basic/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[16.05, 48], zoom=3, style=style)\nlanguages = {\n    \"English\": \"en\",\n    \"French\": \"fr\",\n    \"German\": \"de\",\n    \"Italian\": \"it\",\n    \"Spanish\": \"es\",\n    \"Russian\": \"ru\",\n    \"Chinese\": \"zh\",\n    \"Japanese\": \"ja\",\n    \"Korean\": \"ko\",\n}\ndropdown = widgets.Dropdown(options=languages, description=\"Language:\")\n\n\ndef change_language(change):\n    m.set_layout_property(\n        \"label_country\", \"text-field\", [\"get\", f\"name:{dropdown.value}\"]\n    )\n\n\ndropdown.observe(change_language, names=\"value\")\nm\n</pre> m = leafmap.Map(center=[16.05, 48], zoom=3, style=style) languages = {     \"English\": \"en\",     \"French\": \"fr\",     \"German\": \"de\",     \"Italian\": \"it\",     \"Spanish\": \"es\",     \"Russian\": \"ru\",     \"Chinese\": \"zh\",     \"Japanese\": \"ja\",     \"Korean\": \"ko\", } dropdown = widgets.Dropdown(options=languages, description=\"Language:\")   def change_language(change):     m.set_layout_property(         \"label_country\", \"text-field\", [\"get\", f\"name:{dropdown.value}\"]     )   dropdown.observe(change_language, names=\"value\") m In\u00a0[6]: Copied! <pre>dropdown\n</pre> dropdown <p></p>"},{"location":"maplibre/line_gradient/","title":"Line gradient","text":"<p>Create a gradient line using an expression</p> <p>Use the line-gradient paint property and an expression to visualize distance from the starting point of a line.</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Create a gradient line using an expression.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77.035, 38.875], zoom=12, style=style)\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"coordinates\": [\n                    [-77.044211, 38.852924],\n                    [-77.045659, 38.860158],\n                    [-77.044232, 38.862326],\n                    [-77.040879, 38.865454],\n                    [-77.039936, 38.867698],\n                    [-77.040338, 38.86943],\n                    [-77.04264, 38.872528],\n                    [-77.03696, 38.878424],\n                    [-77.032309, 38.87937],\n                    [-77.030056, 38.880945],\n                    [-77.027645, 38.881779],\n                    [-77.026946, 38.882645],\n                    [-77.026942, 38.885502],\n                    [-77.028054, 38.887449],\n                    [-77.02806, 38.892088],\n                    [-77.03364, 38.892108],\n                    [-77.033643, 38.899926],\n                ],\n                \"type\": \"LineString\",\n            },\n        }\n    ],\n}\nsource = {\"type\": \"geojson\", \"lineMetrics\": True, \"data\": geojson}\nm.add_source(\"line\", source)\n\nlayer = {\n    \"type\": \"line\",\n    \"source\": \"line\",\n    \"id\": \"line\",\n    \"paint\": {\n        \"line-color\": \"red\",\n        \"line-width\": 14,\n        \"line-gradient\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"line-progress\"],\n            0,\n            \"blue\",\n            0.1,\n            \"royalblue\",\n            0.3,\n            \"cyan\",\n            0.5,\n            \"lime\",\n            0.7,\n            \"yellow\",\n            1,\n            \"red\",\n        ],\n    },\n    \"layout\": {\"line-cap\": \"round\", \"line-join\": \"round\"},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-77.035, 38.875], zoom=12, style=style)  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"coordinates\": [                     [-77.044211, 38.852924],                     [-77.045659, 38.860158],                     [-77.044232, 38.862326],                     [-77.040879, 38.865454],                     [-77.039936, 38.867698],                     [-77.040338, 38.86943],                     [-77.04264, 38.872528],                     [-77.03696, 38.878424],                     [-77.032309, 38.87937],                     [-77.030056, 38.880945],                     [-77.027645, 38.881779],                     [-77.026946, 38.882645],                     [-77.026942, 38.885502],                     [-77.028054, 38.887449],                     [-77.02806, 38.892088],                     [-77.03364, 38.892108],                     [-77.033643, 38.899926],                 ],                 \"type\": \"LineString\",             },         }     ], } source = {\"type\": \"geojson\", \"lineMetrics\": True, \"data\": geojson} m.add_source(\"line\", source)  layer = {     \"type\": \"line\",     \"source\": \"line\",     \"id\": \"line\",     \"paint\": {         \"line-color\": \"red\",         \"line-width\": 14,         \"line-gradient\": [             \"interpolate\",             [\"linear\"],             [\"line-progress\"],             0,             \"blue\",             0.1,             \"royalblue\",             0.3,             \"cyan\",             0.5,             \"lime\",             0.7,             \"yellow\",             1,             \"red\",         ],     },     \"layout\": {\"line-cap\": \"round\", \"line-join\": \"round\"}, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/live_geojson/","title":"Live geojson","text":"<p>Add live realtime data</p> <p>Use realtime GeoJSON data streams to move a symbol on your map.</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add live realtime data.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport requests\nimport time\nimport leafmap.maplibregl as leafmap\n</pre> import os import requests import time import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[0, 20], zoom=1, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}},\n}\nm.add_source(\"drone\", source)\n\nlayer = {\n    \"id\": \"drone\",\n    \"type\": \"symbol\",\n    \"source\": \"drone\",\n    \"layout\": {\"icon-image\": \"rocket_15\"},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[0, 20], zoom=1, style=style) source = {     \"type\": \"geojson\",     \"data\": {\"type\": \"Feature\", \"geometry\": {\"type\": \"Point\", \"coordinates\": [0, 0]}}, } m.add_source(\"drone\", source)  layer = {     \"id\": \"drone\",     \"type\": \"symbol\",     \"source\": \"drone\",     \"layout\": {\"icon-image\": \"rocket_15\"}, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>def update_location(num_times, time_interval):\n    url = \"https://www.random.org/decimal-fractions/?num=2&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new\"\n    for _ in range(num_times):\n        response = requests.get(url)\n        data = response.text\n        data = data.strip().split(\"\\n\")\n        # Takes the two random numbers between 0 and 1 and converts them to degrees\n        lat, lon = float(data[0]) * 180 - 90, float(data[1]) * 180 - 90\n        geojson = {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [lon, lat]},\n        }\n        m.set_data(\"drone\", geojson)\n        time.sleep(time_interval)\n</pre> def update_location(num_times, time_interval):     url = \"https://www.random.org/decimal-fractions/?num=2&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new\"     for _ in range(num_times):         response = requests.get(url)         data = response.text         data = data.strip().split(\"\\n\")         # Takes the two random numbers between 0 and 1 and converts them to degrees         lat, lon = float(data[0]) * 180 - 90, float(data[1]) * 180 - 90         geojson = {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [lon, lat]},         }         m.set_data(\"drone\", geojson)         time.sleep(time_interval) In\u00a0[7]: Copied! <pre>update_location(20, 0.5)\n</pre> update_location(20, 0.5) <p></p>"},{"location":"maplibre/live_update_feature/","title":"Live update feature","text":"<p>Update a feature in realtime</p> <p>Change an existing feature on your map in real-time by updating its data.</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Update a feature in realtime.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport time\nimport geopandas as gpd\nimport leafmap.maplibregl as leafmap\n</pre> import os import time import geopandas as gpd import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[-122.019807, 45.632433], zoom=14, pitch=60, style=\"3d-terrain\")\nm\n</pre> m = leafmap.Map(center=[-122.019807, 45.632433], zoom=14, pitch=60, style=\"3d-terrain\") m <pre>An API key is required to use the 3D terrain feature.\n</pre> In\u00a0[5]: Copied! <pre>url = \"https://maplibre.org/maplibre-gl-js/docs/assets/hike.geojson\"\ngdf = gpd.read_file(url)\ncoordinates = list(gdf.geometry[0].coords)\nprint(coordinates[:5])\n</pre> url = \"https://maplibre.org/maplibre-gl-js/docs/assets/hike.geojson\" gdf = gpd.read_file(url) coordinates = list(gdf.geometry[0].coords) print(coordinates[:5]) <pre>[(-122.019807, 45.632433), (-122.019767, 45.632453), (-122.01971, 45.632472), (-122.01971, 45.632505), (-122.019739, 45.632531)]\n</pre> In\u00a0[6]: Copied! <pre>source = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"Feature\",\n        \"geometry\": {\"type\": \"LineString\", \"coordinates\": [coordinates[0]]},\n    },\n}\nm.add_source(\"trace\", source)\nlayer = {\n    \"id\": \"trace\",\n    \"type\": \"line\",\n    \"source\": \"trace\",\n    \"paint\": {\"line-color\": \"yellow\", \"line-opacity\": 0.75, \"line-width\": 5},\n}\nm.add_layer(layer)\nm.jump_to({\"center\": coordinates[0], \"zoom\": 14})\nm.set_pitch(30)\n</pre> source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"Feature\",         \"geometry\": {\"type\": \"LineString\", \"coordinates\": [coordinates[0]]},     }, } m.add_source(\"trace\", source) layer = {     \"id\": \"trace\",     \"type\": \"line\",     \"source\": \"trace\",     \"paint\": {\"line-color\": \"yellow\", \"line-opacity\": 0.75, \"line-width\": 5}, } m.add_layer(layer) m.jump_to({\"center\": coordinates[0], \"zoom\": 14}) m.set_pitch(30) In\u00a0[7]: Copied! <pre>for coord in coordinates:\n    time.sleep(0.005)\n    source[\"data\"][\"geometry\"][\"coordinates\"].append(coord)\n    m.set_data(\"trace\", source[\"data\"])\n    m.pan_to(coord)\n</pre> for coord in coordinates:     time.sleep(0.005)     source[\"data\"][\"geometry\"][\"coordinates\"].append(coord)     m.set_data(\"trace\", source[\"data\"])     m.pan_to(coord) <p></p>"},{"location":"maplibre/local_geojson/","title":"Local geojson","text":"<p>View local GeoJSON</p> <p>This source code of this example is adapted from the MapLibre GL JS example - View local GeoJSON.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3) m In\u00a0[4]: Copied! <pre>m.open_geojson()\n</pre> m.open_geojson() <p></p>"},{"location":"maplibre/local_raster/","title":"Local raster","text":"<p>Visualize local raster datasets</p> <p>This notebook demonstrates how to visualize local raster datasets with localtileserver.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\"\nfilepath = \"landsat.tif\"\nleafmap.download_file(url, filepath)\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\" filepath = \"landsat.tif\" leafmap.download_file(url, filepath) <pre>Downloading...\nFrom: https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\nTo: /home/runner/work/leafmap/leafmap/docs/maplibre/landsat.tif\n</pre> <pre>\r  0%|          | 0.00/10.1M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10.1M/10.1M [00:00&lt;00:00, 152MB/s]</pre> <pre>\n</pre> Out[5]: <pre>'/home/runner/work/leafmap/leafmap/docs/maplibre/landsat.tif'</pre> In\u00a0[6]: Copied! <pre>m = leafmap.Map(style=style)\nm.add_raster(filepath, indexes=[3, 2, 1], vmin=0, vmax=100, name=\"Landsat-321\")\nm.add_raster(filepath, indexes=[4, 3, 2], vmin=0, vmax=100, name=\"Landsat-432\")\nm\n</pre> m = leafmap.Map(style=style) m.add_raster(filepath, indexes=[3, 2, 1], vmin=0, vmax=100, name=\"Landsat-321\") m.add_raster(filepath, indexes=[4, 3, 2], vmin=0, vmax=100, name=\"Landsat-432\") m In\u00a0[7]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[8]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\"\nfilepath = \"srtm90.tif\"\nleafmap.download_file(url, filepath)\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\" filepath = \"srtm90.tif\" leafmap.download_file(url, filepath) <pre>Downloading...\nFrom: https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\nTo: /home/runner/work/leafmap/leafmap/docs/maplibre/srtm90.tif\n</pre> <pre>\r  0%|          | 0.00/16.6M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16.6M/16.6M [00:00&lt;00:00, 239MB/s]</pre> <pre>\n</pre> Out[8]: <pre>'/home/runner/work/leafmap/leafmap/docs/maplibre/srtm90.tif'</pre> In\u00a0[9]: Copied! <pre>m = leafmap.Map(style=style)\nm.add_raster(filepath, colormap=\"terrain\", name=\"DEM\")\nm\n</pre> m = leafmap.Map(style=style) m.add_raster(filepath, colormap=\"terrain\", name=\"DEM\") m In\u00a0[10]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p>"},{"location":"maplibre/locate_user/","title":"Locate user","text":"<p>Locate the user</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Locate the user.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-96, 37.8], zoom=3, style=style, controls={})\nm.add_control(\"geolocate\", position=\"top-right\")\nm\n</pre> m = leafmap.Map(center=[-96, 37.8], zoom=3, style=style, controls={}) m.add_control(\"geolocate\", position=\"top-right\") m <p></p>"},{"location":"maplibre/map_tiles/","title":"Map tiles","text":"<p>Add a raster tile source</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a raster tile source.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>style = {\n    \"version\": 8,\n    \"sources\": {\n        \"raster-tiles\": {\n            \"type\": \"raster\",\n            \"tiles\": [\n                \"https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg\"\n            ],\n            \"tileSize\": 256,\n            \"attribution\": 'Map tiles by &lt;a target=\"_blank\" href=\"https://stamen.com\"&gt;Stamen Design&lt;/a&gt;; Hosting by &lt;a href=\"https://stadiamaps.com/\" target=\"_blank\"&gt;Stadia Maps&lt;/a&gt;. Data &amp;copy; &lt;a href=\"https://www.openstreetmap.org/about\" target=\"_blank\"&gt;OpenStreetMap&lt;/a&gt; contributors',\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"simple-tiles\",\n            \"type\": \"raster\",\n            \"source\": \"raster-tiles\",\n            \"minzoom\": 0,\n            \"maxzoom\": 22,\n        }\n    ],\n}\n</pre> style = {     \"version\": 8,     \"sources\": {         \"raster-tiles\": {             \"type\": \"raster\",             \"tiles\": [                 \"https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg\"             ],             \"tileSize\": 256,             \"attribution\": 'Map tiles by Stamen Design; Hosting by Stadia Maps. Data \u00a9 OpenStreetMap contributors',         }     },     \"layers\": [         {             \"id\": \"simple-tiles\",             \"type\": \"raster\",             \"source\": \"raster-tiles\",             \"minzoom\": 0,             \"maxzoom\": 22,         }     ], } In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=2, style=style)\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=2, style=style) m <p></p>"},{"location":"maplibre/mouse_position/","title":"Mouse position","text":"<p>Get coordinates of the mouse pointer</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Get coordinates of the mouse pointer.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport ipywidgets as widgets\nimport leafmap.maplibregl as leafmap\n</pre> import os import ipywidgets as widgets import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style)\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style) m In\u00a0[6]: Copied! <pre>m.clicked\n</pre> m.clicked Out[6]: <pre>{}</pre> In\u00a0[7]: Copied! <pre>output = widgets.Output()\n\n\ndef log_lng_lat(lng_lat):\n    with output:\n        output.clear_output()\n        print(lng_lat.new)\n\n\nm.observe(log_lng_lat, names=\"clicked\")\noutput\n</pre> output = widgets.Output()   def log_lng_lat(lng_lat):     with output:         output.clear_output()         print(lng_lat.new)   m.observe(log_lng_lat, names=\"clicked\") output <p></p>"},{"location":"maplibre/multiple_geometries/","title":"Multiple geometries","text":"<p>Add multiple geometries from one GeoJSON source</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add multiple geometries from one GeoJSON source.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-121.403732, 40.492392], zoom=10, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                        [\n                            [-121.353637, 40.584978],\n                            [-121.284551, 40.584758],\n                            [-121.275349, 40.541646],\n                            [-121.246768, 40.541017],\n                            [-121.251343, 40.423383],\n                            [-121.32687, 40.423768],\n                            [-121.360619, 40.43479],\n                            [-121.363694, 40.409124],\n                            [-121.439713, 40.409197],\n                            [-121.439711, 40.423791],\n                            [-121.572133, 40.423548],\n                            [-121.577415, 40.550766],\n                            [-121.539486, 40.558107],\n                            [-121.520284, 40.572459],\n                            [-121.487219, 40.550822],\n                            [-121.446951, 40.56319],\n                            [-121.370644, 40.563267],\n                            [-121.353637, 40.584978],\n                        ]\n                    ],\n                },\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.415061, 40.506229]},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.505184, 40.488084]},\n            },\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.354465, 40.488737]},\n            },\n        ],\n    },\n}\nm.add_source(\"national-park\", source)\n\npolygon_layer = {\n    \"id\": \"park-boundary\",\n    \"type\": \"fill\",\n    \"source\": \"national-park\",\n    \"paint\": {\"fill-color\": \"#888888\", \"fill-opacity\": 0.4},\n    \"filter\": [\"==\", \"$type\", \"Polygon\"],\n}\npoint_layer = {\n    \"id\": \"park-volcanoes\",\n    \"type\": \"circle\",\n    \"source\": \"national-park\",\n    \"paint\": {\"circle-radius\": 6, \"circle-color\": \"#B42222\"},\n    \"filter\": [\"==\", \"$type\", \"Point\"],\n}\nm.add_layer(polygon_layer)\nm.add_layer(point_layer)\nm\n</pre> m = leafmap.Map(center=[-121.403732, 40.492392], zoom=10, style=style) source = {     \"type\": \"geojson\",     \"data\": {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {                     \"type\": \"Polygon\",                     \"coordinates\": [                         [                             [-121.353637, 40.584978],                             [-121.284551, 40.584758],                             [-121.275349, 40.541646],                             [-121.246768, 40.541017],                             [-121.251343, 40.423383],                             [-121.32687, 40.423768],                             [-121.360619, 40.43479],                             [-121.363694, 40.409124],                             [-121.439713, 40.409197],                             [-121.439711, 40.423791],                             [-121.572133, 40.423548],                             [-121.577415, 40.550766],                             [-121.539486, 40.558107],                             [-121.520284, 40.572459],                             [-121.487219, 40.550822],                             [-121.446951, 40.56319],                             [-121.370644, 40.563267],                             [-121.353637, 40.584978],                         ]                     ],                 },             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.415061, 40.506229]},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.505184, 40.488084]},             },             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-121.354465, 40.488737]},             },         ],     }, } m.add_source(\"national-park\", source)  polygon_layer = {     \"id\": \"park-boundary\",     \"type\": \"fill\",     \"source\": \"national-park\",     \"paint\": {\"fill-color\": \"#888888\", \"fill-opacity\": 0.4},     \"filter\": [\"==\", \"$type\", \"Polygon\"], } point_layer = {     \"id\": \"park-volcanoes\",     \"type\": \"circle\",     \"source\": \"national-park\",     \"paint\": {\"circle-radius\": 6, \"circle-color\": \"#B42222\"},     \"filter\": [\"==\", \"$type\", \"Point\"], } m.add_layer(polygon_layer) m.add_layer(point_layer) m <p></p>"},{"location":"maplibre/navigation/","title":"Navigation","text":"<p>VDisplay map navigation controls</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Display map navigation controls.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style, controls={})\nm.add_control(\"navigation\", position=\"top-right\")\nm\n</pre> m = leafmap.Map(center=[-74.5, 40], zoom=9, style=style, controls={}) m.add_control(\"navigation\", position=\"top-right\") m <p></p>"},{"location":"maplibre/overview/","title":"Overview","text":"<p>This directory contains examples of using MapLibre with Leafmap. The source code for each example is adapted from the MapLibre documentation. Credits to the original authors.</p>"},{"location":"maplibre/overview/#display-buildings-in-3d","title":"Display buildings in 3D","text":"<p>Use extrusions to display buildings' height in 3D.</p> <p></p>"},{"location":"maplibre/overview/#extrude-polygons-for-3d-indoor-mapping","title":"Extrude polygons for 3D indoor mapping","text":"<p>Create a 3D indoor map with the fill-extrude-height paint property.</p> <p></p>"},{"location":"maplibre/overview/#3d-terrain","title":"3D Terrain","text":"<p>Go beyond hillshade and show elevation in actual 3D.</p> <p></p>"},{"location":"maplibre/overview/#add-a-default-marker","title":"Add a default marker","text":"<p>Add a default marker to the map.</p> <p></p>"},{"location":"maplibre/overview/#add-deckgl-layers","title":"Add deck.gl layers","text":"<p>Add deck.gl layers to the map.</p> <p></p>"},{"location":"maplibre/overview/#add-an-icon-to-the-map","title":"Add an icon to the map","text":"<p>Add an icon to the map from an external URL and use it in a symbol layer.</p> <p></p>"},{"location":"maplibre/overview/#add-a-generated-icon-to-the-map","title":"Add a generated icon to the map","text":"<p>Add an icon to the map that was generated at runtime.</p> <p></p>"},{"location":"maplibre/overview/#animate-a-line","title":"Animate a line","text":"<p>Animate a line by updating a GeoJSON source on each frame.</p> <p></p>"},{"location":"maplibre/overview/#animate-map-camera-around-a-point","title":"Animate map camera around a point","text":"<p>Animate the map camera around a point.</p> <p></p>"},{"location":"maplibre/overview/#animate-a-series-of-images","title":"Animate a series of images","text":"<p>Use a series of image sources to create an animation.</p> <p></p>"},{"location":"maplibre/overview/#animate-a-point","title":"Animate a point","text":"<p>Animate the position of a point by updating a GeoJSON source on each frame.</p> <p></p>"},{"location":"maplibre/overview/#animate-a-point-along-a-route","title":"Animate a point along a route","text":"<p>Animate a point along the distance of a line.</p> <p></p>"},{"location":"maplibre/overview/#change-the-default-position-for-attribution","title":"Change the default position for attribution","text":"<p>Place attribution in the top-left position when initializing a map.</p> <p></p>"},{"location":"maplibre/overview/#center-the-map-on-a-clicked-symbol","title":"Center the map on a clicked symbol","text":"<p>Use events and flyTo to center the map on a symbol.</p> <p></p>"},{"location":"maplibre/overview/#change-building-color-based-on-zoom-level","title":"Change building color based on zoom level","text":"<p>Use the interpolate expression to ease-in the building layer and smoothly fade from one color to the next.</p> <p></p>"},{"location":"maplibre/overview/#change-the-case-of-labels","title":"Change the case of labels","text":"<p>Use the upcase and downcase expressions to change the case of labels.</p> <p></p>"},{"location":"maplibre/overview/#cloud-optimized-geotiff-cog","title":"Cloud Optimized GeoTIFF (COG)","text":"<p>Visualize Cloud Optimized GeoTIFF (COG) files with TiTiler.</p> <p></p>"},{"location":"maplibre/overview/#create-and-style-clusters","title":"Create and style clusters","text":"<p>Use MapLibre GL JS' built-in functions to visualize points as clusters.</p> <p></p>"},{"location":"maplibre/overview/#change-a-layers-color-with-buttons","title":"Change a layer's color with buttons","text":"<p>Use setPaintProperty to change a layer's fill color.</p> <p></p>"},{"location":"maplibre/overview/#customize-marker-icon-image","title":"Customize marker icon image","text":"<p>Use the icon-image property to change the icon image of a marker.</p> <p></p>"},{"location":"maplibre/overview/#style-lines-with-a-data-driven-property","title":"Style lines with a data-driven property","text":"<p>Create a visualization with a data expression for line-color.</p> <p></p>"},{"location":"maplibre/overview/#disable-scroll-zoom","title":"Disable scroll zoom","text":"<p>Prevent scroll from zooming a map.</p> <p></p>"},{"location":"maplibre/overview/#display-and-style-rich-text-labels","title":"Display and style rich text labels","text":"<p>Use the format expression to display country labels in both English and in the local language.</p> <p></p>"},{"location":"maplibre/overview/#create-a-draggable-marker","title":"Create a draggable Marker","text":"<p>Drag the marker to a new location on a map and populate its coordinates in a display.</p> <p></p>"},{"location":"maplibre/overview/#use-a-fallback-image","title":"Use a fallback image","text":"<p>Use a coalesce expression to display another image when a requested image is not available.</p> <p></p>"},{"location":"maplibre/overview/#add-a-pattern-to-a-polygon","title":"Add a pattern to a polygon","text":"<p>Use fill-pattern to draw a polygon from a repeating image pattern.</p> <p></p>"},{"location":"maplibre/overview/#fit-a-map-to-a-bounding-box","title":"Fit a map to a bounding box","text":"<p>Fit the map to a specific area, regardless of the pixel size of the map.</p> <p></p>"},{"location":"maplibre/overview/#fly-to-a-location","title":"Fly to a location","text":"<p>Use flyTo to smoothly interpolate between locations.</p> <p></p>"},{"location":"maplibre/overview/#slowly-fly-to-a-location","title":"Slowly fly to a location","text":"<p>Use flyTo with flyOptions to slowly zoom to a location.</p> <p></p>"},{"location":"maplibre/overview/#view-a-fullscreen-map","title":"View a fullscreen map","text":"<p>Toggle between current view and fullscreen mode.</p> <p></p>"},{"location":"maplibre/overview/#add-a-new-layer-below-labels","title":"Add a new layer below labels","text":"<p>Use the second argument of addLayer to add a layer below labels.</p> <p></p>"},{"location":"maplibre/overview/#add-a-geojson-line","title":"Add a GeoJSON line","text":"<p>Add a GeoJSON line to a map using addSource, then style it using addLayer\u2019s paint properties.</p> <p></p>"},{"location":"maplibre/overview/#draw-geojson-points","title":"Draw GeoJSON points","text":"<p>Draw points from a GeoJSON collection to a map.</p> <p></p>"},{"location":"maplibre/overview/#add-a-geojson-polygon","title":"Add a GeoJSON polygon","text":"<p>Style a polygon with the fill layer type.</p> <p></p>"},{"location":"maplibre/overview/#add-a-geopandas-geodataframe","title":"Add a GeoPandas GeoDataFrame","text":"<p>Add a GeoPandas GeoDataFrame to a map.</p> <p></p>"},{"location":"maplibre/overview/#create-a-heatmap-layer","title":"Create a heatmap layer","text":"<p>Visualize earthquake frequency by location using a heatmap layer.</p> <p></p>"},{"location":"maplibre/overview/#display-a-non-interactive-map","title":"Display a non-interactive map","text":"<p>Disable interactivity to create a static map.</p> <p></p>"},{"location":"maplibre/overview/#jump-to-a-series-of-locations","title":"Jump to a series of locations","text":"<p>Use the jumpTo function to showcase multiple locations.</p> <p></p>"},{"location":"maplibre/overview/#change-a-maps-language","title":"Change a map's language","text":"<p>Use setLayoutProperty to switch languages dynamically.</p> <p></p>"},{"location":"maplibre/overview/#create-a-gradient-line-using-an-expression","title":"Create a gradient line using an expression","text":"<p>Use the line-gradient paint property and an expression to visualize distance from the starting point of a line.</p> <p></p>"},{"location":"maplibre/overview/#add-live-realtime-data","title":"Add live realtime data","text":"<p>Use realtime GeoJSON data streams to move a symbol on your map.</p> <p></p>"},{"location":"maplibre/overview/#update-a-feature-in-realtime","title":"Update a feature in realtime","text":"<p>Change an existing feature on your map in real-time by updating its data.</p> <p></p>"},{"location":"maplibre/overview/#view-local-geojson","title":"View local GeoJSON","text":"<p>View local GeoJSON without server upload.</p> <p></p>"},{"location":"maplibre/overview/#view-local-raster-datasets","title":"View local raster datasets","text":"<p>View local raster datasets with localtileserver</p> <p></p>"},{"location":"maplibre/overview/#locate-the-user","title":"Locate the user","text":"<p>Geolocate the user and then track their current location on the map using the GeolocateControl.</p> <p></p>"},{"location":"maplibre/overview/#add-a-raster-tile-source","title":"Add a raster tile source","text":"<p>Add a third-party raster source to the map.</p> <p></p>"},{"location":"maplibre/overview/#get-coordinates-of-the-mouse-pointer","title":"Get coordinates of the mouse pointer","text":"<p>Show mouse position on hover with pixel and latitude and longitude coordinates.</p> <p></p>"},{"location":"maplibre/overview/#add-multiple-geometries-from-one-geojson-source","title":"Add multiple geometries from one GeoJSON source","text":"<p>Add a polygon and circle layer from the same GeoJSON source.</p> <p></p>"},{"location":"maplibre/overview/#display-map-navigation-controls","title":"Display map navigation controls","text":"<p>Add zoom and rotation controls to the map.</p> <p></p>"},{"location":"maplibre/overview/#pmtiles-source-and-protocol","title":"PMTiles source and protocol","text":"<p>Uses the PMTiles plugin and protocol to present a map.</p> <p></p>"},{"location":"maplibre/overview/#restrict-map-panning-to-an-area","title":"Restrict map panning to an area","text":"<p>Prevent a map from being panned to a different place by setting max_bounds.</p> <p></p>"},{"location":"maplibre/overview/#display-a-satellite-map","title":"Display a satellite map","text":"<p>Display a satellite raster baselayer.</p> <p></p>"},{"location":"maplibre/overview/#set-pitch-and-bearing","title":"Set pitch and bearing","text":"<p>Initialize a map with pitch and bearing camera options.</p> <p></p>"},{"location":"maplibre/overview/#visualize-spatiotemporal-asset-catalog-stac","title":"Visualize SpatioTemporal Asset Catalog (STAC)","text":"<p>Visualize SpatioTemporal Asset Catalog (STAC) items with TiTiler.</p> <p></p>"},{"location":"maplibre/overview/#variable-label-placement","title":"Variable label placement","text":"<p>Use text-variable-anchor to allow high priority labels to shift position to stay on the map.</p> <p></p>"},{"location":"maplibre/overview/#variable-label-placement-with-offset","title":"Variable label placement with offset","text":"<p>Use text-variable-anchor-offset to allow high priority labels to shift position to stay on the map.</p> <p></p>"},{"location":"maplibre/overview/#add-a-vector-tile-source","title":"Add a vector tile source","text":"<p>Add a vector source to a map.</p> <p></p>"},{"location":"maplibre/overview/#add-a-video","title":"Add a video","text":"<p>Display a video on top of a satellite raster baselayer.</p> <p></p>"},{"location":"maplibre/overview/#visualize-population-density","title":"Visualize population density","text":"<p>Use a variable binding expression to calculate and display population density.</p> <p></p>"},{"location":"maplibre/overview/#add-a-wms-source","title":"Add a WMS source","text":"<p>Add an external Web Map Service raster layer to the map using addSource's tiles option.</p> <p></p>"},{"location":"maplibre/overview/#fit-to-the-bounds-of-a-linestring","title":"Fit to the bounds of a LineString","text":"<p>Get the bounds of a LineString.</p> <p></p>"},{"location":"maplibre/pmtiles/","title":"Pmtiles","text":"<p>PMTiles source and protocol</p> <p>This source code of this example is adapted from the MapLibre GL JS example - mPMTiles source and protocol.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U \"leafmap[maplibre]\"\n</pre> # %pip install -U \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['earth', 'natural', 'land', 'water', 'physical_line', 'buildings', 'physical_point', 'places', 'roads', 'transit', 'pois', 'boundaries', 'mask']\nbounds: [11.154026, 43.7270125, 11.3289395, 43.8325455]\n</pre> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"landuse\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"steelblue\"},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"black\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map()  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"landuse\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"steelblue\"},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"black\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m In\u00a0[5]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> <p>You can also visualize Overture data. Inspired by overture-maps.</p> In\u00a0[6]: Copied! <pre>url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['admins', 'buildings', 'places', 'roads']\nbounds: [3.295898, 50.746884, 7.245483, 53.5762]\n</pre> In\u00a0[7]: Copied! <pre>m = leafmap.Map(height=\"800px\")\nm.add_basemap(\"Esri.WorldImagery\")\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        # {\n        #     \"id\": \"admins\",\n        #     \"source\": \"example_source\",\n        #     \"source-layer\": \"admins\",\n        #     \"type\": \"fill\",\n        #     \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},\n        # },\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"places\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"places\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"#FB8072\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map(height=\"800px\") m.add_basemap(\"Esri.WorldImagery\")  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         # {         #     \"id\": \"admins\",         #     \"source\": \"example_source\",         #     \"source-layer\": \"admins\",         #     \"type\": \"fill\",         #     \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},         # },         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},         },         {             \"id\": \"places\",             \"source\": \"example_source\",             \"source-layer\": \"places\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"#FB8072\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m In\u00a0[8]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[9]: Copied! <pre>url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['building_footprints']\nbounds: [-160.221701, -55.9756776, 166.709685, 74.7731168]\n</pre> In\u00a0[10]: Copied! <pre>m = leafmap.Map(center=[0, 20], zoom=2, height=\"600px\")\nm.add_basemap(\"Google Hybrid\", visible=False)\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"building_footprints\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map(center=[0, 20], zoom=2, height=\"600px\") m.add_basemap(\"Google Hybrid\", visible=False)  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"building_footprints\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m <pre>Basemap can only be one of the following:\n  OpenStreetMap\n  Esri.WorldStreetMap\n  Esri.WorldImagery\n  Esri.WorldTopoMap\n  FWS NWI Wetlands\n  FWS NWI Wetlands Raster\n  NLCD 2021 CONUS Land Cover\n  NLCD 2019 CONUS Land Cover\n  NLCD 2016 CONUS Land Cover\n  NLCD 2013 CONUS Land Cover\n  NLCD 2011 CONUS Land Cover\n  NLCD 2008 CONUS Land Cover\n  NLCD 2006 CONUS Land Cover\n  NLCD 2004 CONUS Land Cover\n  NLCD 2001 CONUS Land Cover\n  USGS NAIP Imagery\n  USGS NAIP Imagery False Color\n  USGS NAIP Imagery NDVI\n  USGS Hydrography\n  USGS 3DEP Elevation\n  ESA Worldcover 2020\n  ESA Worldcover 2020 S2 FCC\n  ESA Worldcover 2020 S2 TCC\n  ESA Worldcover 2021\n  ESA Worldcover 2021 S2 FCC\n  ESA Worldcover 2021 S2 TCC\n  BaseMapDE.Color\n  BaseMapDE.Grey\n  BasemapAT.basemap\n  BasemapAT.grau\n  BasemapAT.highdpi\n  BasemapAT.orthofoto\n  BasemapAT.overlay\n  BasemapAT.surface\n  BasemapAT.terrain\n  CartoDB.DarkMatter\n  CartoDB.DarkMatterNoLabels\n  CartoDB.DarkMatterOnlyLabels\n  CartoDB.Positron\n  CartoDB.PositronNoLabels\n  CartoDB.PositronOnlyLabels\n  CartoDB.Voyager\n  CartoDB.VoyagerLabelsUnder\n  CartoDB.VoyagerNoLabels\n  CartoDB.VoyagerOnlyLabels\n  CyclOSM\n  Esri.AntarcticBasemap\n  Esri.AntarcticImagery\n  Esri.ArcticImagery\n  Esri.ArcticOceanBase\n  Esri.ArcticOceanReference\n  Esri.DeLorme\n  Esri.NatGeoWorldMap\n  Esri.OceanBasemap\n  Esri.WorldGrayCanvas\n  Esri.WorldPhysical\n  Esri.WorldShadedRelief\n  Esri.WorldTerrain\n  FreeMapSK\n  Gaode.Normal\n  Gaode.Satellite\n  HikeBike.HikeBike\n  HikeBike.HillShading\n  JusticeMap.americanIndian\n  JusticeMap.asian\n  JusticeMap.black\n  JusticeMap.hispanic\n  JusticeMap.income\n  JusticeMap.multi\n  JusticeMap.nonWhite\n  JusticeMap.plurality\n  JusticeMap.white\n  MtbMap\n  NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief\n  NASAGIBS.BlueMarble3031\n  NASAGIBS.BlueMarble3413\n  NASAGIBS.BlueMarbleBathymetry3031\n  NASAGIBS.BlueMarbleBathymetry3413\n  NASAGIBS.MEaSUREsIceVelocity3031\n  NASAGIBS.MEaSUREsIceVelocity3413\n  NASAGIBS.ModisAquaBands721CR\n  NASAGIBS.ModisAquaTrueColorCR\n  NASAGIBS.ModisTerraAOD\n  NASAGIBS.ModisTerraBands367CR\n  NASAGIBS.ModisTerraBands721CR\n  NASAGIBS.ModisTerraChlorophyll\n  NASAGIBS.ModisTerraLSTDay\n  NASAGIBS.ModisTerraSnowCover\n  NASAGIBS.ModisTerraTrueColorCR\n  NASAGIBS.ViirsEarthAtNight2012\n  NASAGIBS.ViirsTrueColorCR\n  OPNVKarte\n  OneMapSG.Default\n  OneMapSG.Grey\n  OneMapSG.LandLot\n  OneMapSG.Night\n  OneMapSG.Original\n  OpenAIP\n  OpenFireMap\n  OpenRailwayMap\n  OpenSeaMap\n  OpenSnowMap.pistes\n  OpenStreetMap.BZH\n  OpenStreetMap.BlackAndWhite\n  OpenStreetMap.CH\n  OpenStreetMap.DE\n  OpenStreetMap.HOT\n  OpenStreetMap.Mapnik\n  OpenTopoMap\n  SafeCast\n  Stadia.AlidadeSatellite\n  Stadia.AlidadeSmooth\n  Stadia.AlidadeSmoothDark\n  Stadia.OSMBright\n  Stadia.Outdoors\n  Stadia.StamenTerrain\n  Stadia.StamenTerrainBackground\n  Stadia.StamenTerrainLabels\n  Stadia.StamenTerrainLines\n  Stadia.StamenToner\n  Stadia.StamenTonerBackground\n  Stadia.StamenTonerLabels\n  Stadia.StamenTonerLines\n  Stadia.StamenTonerLite\n  Stadia.StamenWatercolor\n  Strava.All\n  Strava.Ride\n  Strava.Run\n  Strava.Water\n  Strava.Winter\n  SwissFederalGeoportal.JourneyThroughTime\n  SwissFederalGeoportal.NationalMapColor\n  SwissFederalGeoportal.NationalMapGrey\n  SwissFederalGeoportal.SWISSIMAGE\n  TopPlusOpen.Color\n  TopPlusOpen.Grey\n  USGS.USImagery\n  USGS.USImageryTopo\n  USGS.USTopo\n  WaymarkedTrails.cycling\n  WaymarkedTrails.hiking\n  WaymarkedTrails.mtb\n  WaymarkedTrails.riding\n  WaymarkedTrails.skating\n  WaymarkedTrails.slopes\n  nlmaps.grijs\n  nlmaps.luchtfoto\n  nlmaps.pastel\n  nlmaps.standaard\n  nlmaps.water\n</pre> In\u00a0[11]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[12]: Copied! <pre>url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\"\nleafmap.download_file(url, \"buildings.geojson\")\n</pre> url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\" leafmap.download_file(url, \"buildings.geojson\") <pre>Downloading...\nFrom: https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\nTo: /home/runner/work/leafmap/leafmap/docs/maplibre/buildings.geojson\n</pre> <pre>\r  0%|          | 0.00/2.77M [00:00&lt;?, ?B/s]</pre> <pre>\r12.8MB [00:00, 170MB/s]                    </pre> <pre>\n</pre> Out[12]: <pre>'/home/runner/work/leafmap/leafmap/docs/maplibre/buildings.geojson'</pre> <p>Convert vector to PMTiles.</p> In\u00a0[13]: Copied! <pre>pmtiles = \"buildings.pmtiles\"\nleafmap.geojson_to_pmtiles(\n    \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True\n)\n</pre> pmtiles = \"buildings.pmtiles\" leafmap.geojson_to_pmtiles(     \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True ) <pre>Error: tippecanoe is not installed.\nYou can install it using conda with the following command:\nconda install -c conda-forge tippecanoe\n</pre> <p>Start a HTTP Sever</p> In\u00a0[14]: Copied! <pre>leafmap.start_server(port=8000)\n</pre> leafmap.start_server(port=8000) In\u00a0[15]: Copied! <pre>url = f\"http://127.0.0.1:8000/{pmtiles}\"\n# leafmap.pmtiles_metadata(url)\n</pre> url = f\"http://127.0.0.1:8000/{pmtiles}\" # leafmap.pmtiles_metadata(url) <p>Display the PMTiles on the map.</p> In\u00a0[16]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Google Hybrid\")\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=0.8,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Google Hybrid\") style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=0.8,     tooltip=True, ) m <pre>Basemap can only be one of the following:\n  OpenStreetMap\n  Esri.WorldStreetMap\n  Esri.WorldImagery\n  Esri.WorldTopoMap\n  FWS NWI Wetlands\n  FWS NWI Wetlands Raster\n  NLCD 2021 CONUS Land Cover\n  NLCD 2019 CONUS Land Cover\n  NLCD 2016 CONUS Land Cover\n  NLCD 2013 CONUS Land Cover\n  NLCD 2011 CONUS Land Cover\n  NLCD 2008 CONUS Land Cover\n  NLCD 2006 CONUS Land Cover\n  NLCD 2004 CONUS Land Cover\n  NLCD 2001 CONUS Land Cover\n  USGS NAIP Imagery\n  USGS NAIP Imagery False Color\n  USGS NAIP Imagery NDVI\n  USGS Hydrography\n  USGS 3DEP Elevation\n  ESA Worldcover 2020\n  ESA Worldcover 2020 S2 FCC\n  ESA Worldcover 2020 S2 TCC\n  ESA Worldcover 2021\n  ESA Worldcover 2021 S2 FCC\n  ESA Worldcover 2021 S2 TCC\n  BaseMapDE.Color\n  BaseMapDE.Grey\n  BasemapAT.basemap\n  BasemapAT.grau\n  BasemapAT.highdpi\n  BasemapAT.orthofoto\n  BasemapAT.overlay\n  BasemapAT.surface\n  BasemapAT.terrain\n  CartoDB.DarkMatter\n  CartoDB.DarkMatterNoLabels\n  CartoDB.DarkMatterOnlyLabels\n  CartoDB.Positron\n  CartoDB.PositronNoLabels\n  CartoDB.PositronOnlyLabels\n  CartoDB.Voyager\n  CartoDB.VoyagerLabelsUnder\n  CartoDB.VoyagerNoLabels\n  CartoDB.VoyagerOnlyLabels\n  CyclOSM\n  Esri.AntarcticBasemap\n  Esri.AntarcticImagery\n  Esri.ArcticImagery\n  Esri.ArcticOceanBase\n  Esri.ArcticOceanReference\n  Esri.DeLorme\n  Esri.NatGeoWorldMap\n  Esri.OceanBasemap\n  Esri.WorldGrayCanvas\n  Esri.WorldPhysical\n  Esri.WorldShadedRelief\n  Esri.WorldTerrain\n  FreeMapSK\n  Gaode.Normal\n  Gaode.Satellite\n  HikeBike.HikeBike\n  HikeBike.HillShading\n  JusticeMap.americanIndian\n  JusticeMap.asian\n  JusticeMap.black\n  JusticeMap.hispanic\n  JusticeMap.income\n  JusticeMap.multi\n  JusticeMap.nonWhite\n  JusticeMap.plurality\n  JusticeMap.white\n  MtbMap\n  NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief\n  NASAGIBS.BlueMarble3031\n  NASAGIBS.BlueMarble3413\n  NASAGIBS.BlueMarbleBathymetry3031\n  NASAGIBS.BlueMarbleBathymetry3413\n  NASAGIBS.MEaSUREsIceVelocity3031\n  NASAGIBS.MEaSUREsIceVelocity3413\n  NASAGIBS.ModisAquaBands721CR\n  NASAGIBS.ModisAquaTrueColorCR\n  NASAGIBS.ModisTerraAOD\n  NASAGIBS.ModisTerraBands367CR\n  NASAGIBS.ModisTerraBands721CR\n  NASAGIBS.ModisTerraChlorophyll\n  NASAGIBS.ModisTerraLSTDay\n  NASAGIBS.ModisTerraSnowCover\n  NASAGIBS.ModisTerraTrueColorCR\n  NASAGIBS.ViirsEarthAtNight2012\n  NASAGIBS.ViirsTrueColorCR\n  OPNVKarte\n  OneMapSG.Default\n  OneMapSG.Grey\n  OneMapSG.LandLot\n  OneMapSG.Night\n  OneMapSG.Original\n  OpenAIP\n  OpenFireMap\n  OpenRailwayMap\n  OpenSeaMap\n  OpenSnowMap.pistes\n  OpenStreetMap.BZH\n  OpenStreetMap.BlackAndWhite\n  OpenStreetMap.CH\n  OpenStreetMap.DE\n  OpenStreetMap.HOT\n  OpenStreetMap.Mapnik\n  OpenTopoMap\n  SafeCast\n  Stadia.AlidadeSatellite\n  Stadia.AlidadeSmooth\n  Stadia.AlidadeSmoothDark\n  Stadia.OSMBright\n  Stadia.Outdoors\n  Stadia.StamenTerrain\n  Stadia.StamenTerrainBackground\n  Stadia.StamenTerrainLabels\n  Stadia.StamenTerrainLines\n  Stadia.StamenToner\n  Stadia.StamenTonerBackground\n  Stadia.StamenTonerLabels\n  Stadia.StamenTonerLines\n  Stadia.StamenTonerLite\n  Stadia.StamenWatercolor\n  Strava.All\n  Strava.Ride\n  Strava.Run\n  Strava.Water\n  Strava.Winter\n  SwissFederalGeoportal.JourneyThroughTime\n  SwissFederalGeoportal.NationalMapColor\n  SwissFederalGeoportal.NationalMapGrey\n  SwissFederalGeoportal.SWISSIMAGE\n  TopPlusOpen.Color\n  TopPlusOpen.Grey\n  USGS.USImagery\n  USGS.USImageryTopo\n  USGS.USTopo\n  WaymarkedTrails.cycling\n  WaymarkedTrails.hiking\n  WaymarkedTrails.mtb\n  WaymarkedTrails.riding\n  WaymarkedTrails.skating\n  WaymarkedTrails.slopes\n  nlmaps.grijs\n  nlmaps.luchtfoto\n  nlmaps.pastel\n  nlmaps.standaard\n  nlmaps.water\nHTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /buildings.pmtiles (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x7f31b82f5510&gt;: Failed to establish a new connection: [Errno 111] Connection refused'))\n</pre> In\u00a0[17]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p>"},{"location":"maplibre/pmtiles/#remote-pmtiles","title":"Remote PMTiles\u00b6","text":""},{"location":"maplibre/pmtiles/#protomaps-sample-data","title":"Protomaps sample data\u00b6","text":""},{"location":"maplibre/pmtiles/#overture-data","title":"Overture data\u00b6","text":""},{"location":"maplibre/pmtiles/#source-cooperative","title":"Source Cooperative\u00b6","text":"<p>Google-Microsoft Open Buildings - combined by VIDA</p>"},{"location":"maplibre/pmtiles/#local-pmtiles","title":"Local PMTiles\u00b6","text":"<p>tippecanoe is required to convert vector data to pmtiles. Install it with <code>conda install -c conda-forge tippecanoe</code>.</p> <p>Download building footprints of Derna, Libya.</p>"},{"location":"maplibre/restrict_bounds/","title":"Restrict bounds","text":"<p>Restrict map panning to an area</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Restrict map panning to an area .</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>bounds = [\n    [-74.04728500751165, 40.68392799015035],\n    [-73.91058699000139, 40.87764500765852],\n]\n</pre> bounds = [     [-74.04728500751165, 40.68392799015035],     [-73.91058699000139, 40.87764500765852], ] In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[-73.9978, 40.7209], zoom=13, max_bounds=bounds, style=style)\nm\n</pre> m = leafmap.Map(center=[-73.9978, 40.7209], zoom=13, max_bounds=bounds, style=style) m <p></p>"},{"location":"maplibre/satellite_map/","title":"Satellite map","text":"<p>Display a satellite map</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Display a satellite map.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/hybrid/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/hybrid/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[137.9150899566626, 36.25956997955441], zoom=9, style=style)\nm\n</pre> m = leafmap.Map(center=[137.9150899566626, 36.25956997955441], zoom=9, style=style) m <p></p> In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[137.9150899566626, 36.25956997955441], zoom=9)\nm.add_basemap(\"Esri.WorldImagery\")\nm\n</pre> m = leafmap.Map(center=[137.9150899566626, 36.25956997955441], zoom=9) m.add_basemap(\"Esri.WorldImagery\") m In\u00a0[7]: Copied! <pre>m.add_basemap()\n</pre> m.add_basemap() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"maplibre/set_pitch_bearing/","title":"Set pitch bearing","text":"<p>Set pitch and bearing</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Set pitch and bearing.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(\n    center=[-73.5804, 45.53483], zoom=10, pitch=60, bearing=-60, style=style\n)\nm\n</pre> m = leafmap.Map(     center=[-73.5804, 45.53483], zoom=10, pitch=60, bearing=-60, style=style ) m <p></p>"},{"location":"maplibre/stac/","title":"Stac","text":"<p>Visualize SpatioTemporal Asset Catalog (STAC)</p> <p>This notebook demonstrates how to visualize  SpatioTemporal Asset Catalog (STAC) items using the TiTiler demo endpoint (titiler.xyz). Please be gentle with the demo endpoint.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(style=style)\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\", vmin=0, vmax=150)\nm.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"RGB\", vmin=0, vmax=150)\nm\n</pre> m = leafmap.Map(style=style) url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\", vmin=0, vmax=150) m.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"RGB\", vmin=0, vmax=150) m In\u00a0[6]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[7]: Copied! <pre>collection = \"landsat-8-c2-l2\"\nitem = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> collection = \"landsat-8-c2-l2\" item = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[8]: Copied! <pre>leafmap.stac_assets(collection=collection, item=item, titiler_endpoint=\"pc\")\n</pre> leafmap.stac_assets(collection=collection, item=item, titiler_endpoint=\"pc\") Out[8]: <pre>['SR_B1',\n 'SR_B2',\n 'SR_B3',\n 'SR_B4',\n 'SR_B5',\n 'SR_B6',\n 'SR_B7',\n 'ST_QA',\n 'ST_B10',\n 'ST_DRAD',\n 'ST_EMIS',\n 'ST_EMSD',\n 'ST_TRAD',\n 'ST_URAD',\n 'QA_PIXEL',\n 'ST_ATRAN',\n 'ST_CDIST',\n 'QA_RADSAT',\n 'SR_QA_AEROSOL']</pre> In\u00a0[9]: Copied! <pre>m = leafmap.Map(style=style)\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    assets=[\"SR_B5\", \"SR_B4\", \"SR_B3\"],\n    name=\"Color infrared\",\n)\nm\n</pre> m = leafmap.Map(style=style) m.add_stac_layer(     collection=collection,     item=item,     assets=[\"SR_B5\", \"SR_B4\", \"SR_B3\"],     name=\"Color infrared\", ) m"},{"location":"maplibre/variable_label_placement/","title":"Variable label placement","text":"<p>Variable label placement</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Variable label placement.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style)\n\nplaces = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Ford's Theater\", \"icon\": \"theatre\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.038659, 38.931567]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"The Gaslight\", \"icon\": \"theatre\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.003168, 38.894651]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Horrible Harry's\", \"icon\": \"bar\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.090372, 38.881189]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Bike Party\", \"icon\": \"bicycle\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.052477, 38.943951]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Rockabilly Rockstars\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.031706, 38.914581]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"District Drum Tribe\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.020945, 38.878241]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Motown Memories\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.007481, 38.876516]},\n        },\n    ],\n}\nsource = {\"type\": \"geojson\", \"data\": places}\nm.add_source(\"places\", source)\n\nlayer = {\n    \"id\": \"poi-labels\",\n    \"type\": \"symbol\",\n    \"source\": \"places\",\n    \"layout\": {\n        \"text-field\": [\"get\", \"description\"],\n        \"text-variable-anchor\": [\"top\", \"bottom\", \"left\", \"right\"],\n        \"text-radial-offset\": 0.5,\n        \"text-justify\": \"auto\",\n        \"icon-image\": [\"concat\", [\"get\", \"icon\"], \"_15\"],\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style)  places = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Ford's Theater\", \"icon\": \"theatre\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.038659, 38.931567]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"The Gaslight\", \"icon\": \"theatre\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.003168, 38.894651]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Horrible Harry's\", \"icon\": \"bar\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.090372, 38.881189]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Bike Party\", \"icon\": \"bicycle\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.052477, 38.943951]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Rockabilly Rockstars\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.031706, 38.914581]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"District Drum Tribe\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.020945, 38.878241]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Motown Memories\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.007481, 38.876516]},         },     ], } source = {\"type\": \"geojson\", \"data\": places} m.add_source(\"places\", source)  layer = {     \"id\": \"poi-labels\",     \"type\": \"symbol\",     \"source\": \"places\",     \"layout\": {         \"text-field\": [\"get\", \"description\"],         \"text-variable-anchor\": [\"top\", \"bottom\", \"left\", \"right\"],         \"text-radial-offset\": 0.5,         \"text-justify\": \"auto\",         \"icon-image\": [\"concat\", [\"get\", \"icon\"], \"_15\"],     }, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>m.rotate_to(bearing=180, options={\"duration\": 10000})\n</pre> m.rotate_to(bearing=180, options={\"duration\": 10000}) <p></p>"},{"location":"maplibre/variable_offset_label_placement/","title":"Variable offset label placement","text":"<p>Variable label placement with offset</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Variable label placement with offset.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style)\n\nplaces = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Ford's Theater\", \"icon\": \"theatre\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.038659, 38.931567]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"The Gaslight\", \"icon\": \"theatre\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.003168, 38.894651]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Horrible Harry's\", \"icon\": \"bar\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.090372, 38.881189]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Bike Party\", \"icon\": \"bicycle\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.052477, 38.943951]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Rockabilly Rockstars\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.031706, 38.914581]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"District Drum Tribe\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.020945, 38.878241]},\n        },\n        {\n            \"type\": \"Feature\",\n            \"properties\": {\"description\": \"Motown Memories\", \"icon\": \"music\"},\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.007481, 38.876516]},\n        },\n    ],\n}\nsource = {\"type\": \"geojson\", \"data\": places}\nm.add_source(\"places\", source)\n\nlayer = {\n    \"id\": \"poi-labels\",\n    \"type\": \"symbol\",\n    \"source\": \"places\",\n    \"layout\": {\n        \"text-field\": [\"get\", \"description\"],\n        \"text-variable-anchor-offset\": [\n            \"top\",\n            [0, 1],\n            \"bottom\",\n            [0, -2],\n            \"left\",\n            [1, 0],\n            \"right\",\n            [-2, 0],\n        ],\n        \"text-justify\": \"auto\",\n        \"icon-image\": [\"concat\", [\"get\", \"icon\"], \"_15\"],\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-77.04, 38.907], zoom=11, style=style)  places = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Ford's Theater\", \"icon\": \"theatre\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.038659, 38.931567]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"The Gaslight\", \"icon\": \"theatre\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.003168, 38.894651]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Horrible Harry's\", \"icon\": \"bar\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.090372, 38.881189]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Bike Party\", \"icon\": \"bicycle\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.052477, 38.943951]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Rockabilly Rockstars\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.031706, 38.914581]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"District Drum Tribe\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.020945, 38.878241]},         },         {             \"type\": \"Feature\",             \"properties\": {\"description\": \"Motown Memories\", \"icon\": \"music\"},             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-77.007481, 38.876516]},         },     ], } source = {\"type\": \"geojson\", \"data\": places} m.add_source(\"places\", source)  layer = {     \"id\": \"poi-labels\",     \"type\": \"symbol\",     \"source\": \"places\",     \"layout\": {         \"text-field\": [\"get\", \"description\"],         \"text-variable-anchor-offset\": [             \"top\",             [0, 1],             \"bottom\",             [0, -2],             \"left\",             [1, 0],             \"right\",             [-2, 0],         ],         \"text-justify\": \"auto\",         \"icon-image\": [\"concat\", [\"get\", \"icon\"], \"_15\"],     }, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>m.rotate_to(bearing=180, options={\"duration\": 10000})\n</pre> m.rotate_to(bearing=180, options={\"duration\": 10000}) <p></p>"},{"location":"maplibre/vector_tile/","title":"Vector tile","text":"<p>Add a vector tile source</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a vector tile source.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-122.447303, 37.753574], zoom=13, style=style)\nsource = {\n    \"type\": \"vector\",\n    \"url\": f\"https://api.maptiler.com/tiles/contours/tiles.json?key={MAPTILER_KEY}\",\n}\nlayer = {\n    \"id\": \"terrain-data\",\n    \"type\": \"line\",\n    \"source\": \"contours\",\n    \"source-layer\": \"contour\",\n    \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},\n    \"paint\": {\"line-color\": \"#ff69b4\", \"line-width\": 1},\n}\nm.add_source(\"contours\", source)\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-122.447303, 37.753574], zoom=13, style=style) source = {     \"type\": \"vector\",     \"url\": f\"https://api.maptiler.com/tiles/contours/tiles.json?key={MAPTILER_KEY}\", } layer = {     \"id\": \"terrain-data\",     \"type\": \"line\",     \"source\": \"contours\",     \"source-layer\": \"contour\",     \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},     \"paint\": {\"line-color\": \"#ff69b4\", \"line-width\": 1}, } m.add_source(\"contours\", source) m.add_layer(layer) m <p></p>"},{"location":"maplibre/video_on_a_map/","title":"Video on a map","text":"<p>Add a video</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a video.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") In\u00a0[5]: Copied! <pre>style = {\n    \"version\": 8,\n    \"sources\": {\n        \"satellite\": {\n            \"type\": \"raster\",\n            \"url\": f\"https://api.maptiler.com/tiles/satellite/tiles.json?key={MAPTILER_KEY}\",\n            \"tileSize\": 256,\n        },\n        \"video\": {\n            \"type\": \"video\",\n            \"urls\": [\n                \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",\n                \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",\n            ],\n            \"coordinates\": [\n                [-122.51596391201019, 37.56238816766053],\n                [-122.51467645168304, 37.56410183312965],\n                [-122.51309394836426, 37.563391708549425],\n                [-122.51423120498657, 37.56161849366671],\n            ],\n        },\n    },\n    \"layers\": [\n        {\n            \"id\": \"background\",\n            \"type\": \"background\",\n            \"paint\": {\"background-color\": \"rgb(4,7,14)\"},\n        },\n        {\"id\": \"satellite\", \"type\": \"raster\", \"source\": \"satellite\"},\n        {\"id\": \"video\", \"type\": \"raster\", \"source\": \"video\"},\n    ],\n}\n</pre> style = {     \"version\": 8,     \"sources\": {         \"satellite\": {             \"type\": \"raster\",             \"url\": f\"https://api.maptiler.com/tiles/satellite/tiles.json?key={MAPTILER_KEY}\",             \"tileSize\": 256,         },         \"video\": {             \"type\": \"video\",             \"urls\": [                 \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",                 \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",             ],             \"coordinates\": [                 [-122.51596391201019, 37.56238816766053],                 [-122.51467645168304, 37.56410183312965],                 [-122.51309394836426, 37.563391708549425],                 [-122.51423120498657, 37.56161849366671],             ],         },     },     \"layers\": [         {             \"id\": \"background\",             \"type\": \"background\",             \"paint\": {\"background-color\": \"rgb(4,7,14)\"},         },         {\"id\": \"satellite\", \"type\": \"raster\", \"source\": \"satellite\"},         {\"id\": \"video\", \"type\": \"raster\", \"source\": \"video\"},     ], } In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[-122.514426, 37.562984], zoom=17, bearing=-96, style=style)\nm\n</pre> m = leafmap.Map(center=[-122.514426, 37.562984], zoom=17, bearing=-96, style=style) m <p></p>"},{"location":"maplibre/visualize_population_density/","title":"Visualize population density","text":"<p>Visualize population density</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Visualize population density.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[30.0222, -1.9596], zoom=7, style=style)\nsource = {\n    \"type\": \"geojson\",\n    \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/rwanda-provinces.geojson\",\n}\nm.add_source(\"rwanda-provinces\", source)\nlayer = {\n    \"id\": \"rwanda-provinces\",\n    \"type\": \"fill\",\n    \"source\": \"rwanda-provinces\",\n    \"layout\": {},\n    \"paint\": {\n        \"fill-color\": [\n            \"let\",\n            \"density\",\n            [\"/\", [\"get\", \"population\"], [\"get\", \"sq-km\"]],\n            [\n                \"interpolate\",\n                [\"linear\"],\n                [\"zoom\"],\n                8,\n                [\n                    \"interpolate\",\n                    [\"linear\"],\n                    [\"var\", \"density\"],\n                    274,\n                    [\"to-color\", \"#edf8e9\"],\n                    1551,\n                    [\"to-color\", \"#006d2c\"],\n                ],\n                10,\n                [\n                    \"interpolate\",\n                    [\"linear\"],\n                    [\"var\", \"density\"],\n                    274,\n                    [\"to-color\", \"#eff3ff\"],\n                    1551,\n                    [\"to-color\", \"#08519c\"],\n                ],\n            ],\n        ],\n        \"fill-opacity\": 0.7,\n    },\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[30.0222, -1.9596], zoom=7, style=style) source = {     \"type\": \"geojson\",     \"data\": \"https://maplibre.org/maplibre-gl-js/docs/assets/rwanda-provinces.geojson\", } m.add_source(\"rwanda-provinces\", source) layer = {     \"id\": \"rwanda-provinces\",     \"type\": \"fill\",     \"source\": \"rwanda-provinces\",     \"layout\": {},     \"paint\": {         \"fill-color\": [             \"let\",             \"density\",             [\"/\", [\"get\", \"population\"], [\"get\", \"sq-km\"]],             [                 \"interpolate\",                 [\"linear\"],                 [\"zoom\"],                 8,                 [                     \"interpolate\",                     [\"linear\"],                     [\"var\", \"density\"],                     274,                     [\"to-color\", \"#edf8e9\"],                     1551,                     [\"to-color\", \"#006d2c\"],                 ],                 10,                 [                     \"interpolate\",                     [\"linear\"],                     [\"var\", \"density\"],                     274,                     [\"to-color\", \"#eff3ff\"],                     1551,                     [\"to-color\", \"#08519c\"],                 ],             ],         ],         \"fill-opacity\": 0.7,     }, } m.add_layer(layer) m <p></p>"},{"location":"maplibre/wms_source/","title":"Wms source","text":"<p>Add a WMS source</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Add a WMS source.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-74.5447, 40.6892], zoom=8, style=style)\n\nsource = {\n    \"type\": \"raster\",\n    \"tiles\": [\n        \"https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&amp;format=image/png&amp;service=WMS&amp;version=1.1.1&amp;request=GetMap&amp;srs=EPSG:3857&amp;transparent=true&amp;width=256&amp;height=256&amp;layers=Natural2015\"\n    ],\n    \"tileSize\": 256,\n}\nlayer = {\n    \"id\": \"wms-test-layer\",\n    \"type\": \"raster\",\n    \"source\": \"wms-test-source\",\n    \"paint\": {},\n}\nm.add_source(\"wms-test-source\", source)\nm.add_layer(layer, before_id=\"aeroway_fill\")\nm\n</pre> m = leafmap.Map(center=[-74.5447, 40.6892], zoom=8, style=style)  source = {     \"type\": \"raster\",     \"tiles\": [         \"https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&amp;format=image/png&amp;service=WMS&amp;version=1.1.1&amp;request=GetMap&amp;srs=EPSG:3857&amp;transparent=true&amp;width=256&amp;height=256&amp;layers=Natural2015\"     ],     \"tileSize\": 256, } layer = {     \"id\": \"wms-test-layer\",     \"type\": \"raster\",     \"source\": \"wms-test-source\",     \"paint\": {}, } m.add_source(\"wms-test-source\", source) m.add_layer(layer, before_id=\"aeroway_fill\") m <p></p>"},{"location":"maplibre/zoom_to_linestring/","title":"Zoom to linestring","text":"<p>Fit to the bounds of a LineString</p> <p>This source code of this example is adapted from the MapLibre GL JS example - Fit to the bounds of a LineString.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import os\nimport leafmap.maplibregl as leafmap\n</pre> import os import leafmap.maplibregl as leafmap <p>To run this notebook, you will need an API key from MapTiler. Once you have the API key, you can set it as an environment variable in your notebook or script as follows:</p> In\u00a0[3]: Copied! <pre># os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\"\n</pre> # os.environ[\"MAPTILER_KEY\"] = \"YOUR_API_KEY\" In\u00a0[4]: Copied! <pre>MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\")\nstyle = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\"\n</pre> MAPTILER_KEY = leafmap.get_api_key(\"MAPTILER_KEY\") style = f\"https://api.maptiler.com/maps/streets/style.json?key={MAPTILER_KEY}\" In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[-77.0214, 38.897], zoom=12, style=style)\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"properties\": {},\n                \"coordinates\": [\n                    [-77.0366048812866, 38.89873175227713],\n                    [-77.03364372253417, 38.89876515143842],\n                    [-77.03364372253417, 38.89549195896866],\n                    [-77.02982425689697, 38.89549195896866],\n                    [-77.02400922775269, 38.89387200688839],\n                    [-77.01519012451172, 38.891416957534204],\n                    [-77.01521158218382, 38.892068305429156],\n                    [-77.00813055038452, 38.892051604275686],\n                    [-77.00832366943358, 38.89143365883688],\n                    [-77.00818419456482, 38.89082405874451],\n                    [-77.00815200805664, 38.88989712255097],\n                ],\n            },\n        }\n    ],\n}\n\nm.add_source(\"LineString\", {\"type\": \"geojson\", \"data\": geojson})\nlayer = {\n    \"id\": \"LineString\",\n    \"type\": \"line\",\n    \"source\": \"LineString\",\n    \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},\n    \"paint\": {\"line-color\": \"#BF93E4\", \"line-width\": 5},\n}\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map(center=[-77.0214, 38.897], zoom=12, style=style)  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"properties\": {},                 \"coordinates\": [                     [-77.0366048812866, 38.89873175227713],                     [-77.03364372253417, 38.89876515143842],                     [-77.03364372253417, 38.89549195896866],                     [-77.02982425689697, 38.89549195896866],                     [-77.02400922775269, 38.89387200688839],                     [-77.01519012451172, 38.891416957534204],                     [-77.01521158218382, 38.892068305429156],                     [-77.00813055038452, 38.892051604275686],                     [-77.00832366943358, 38.89143365883688],                     [-77.00818419456482, 38.89082405874451],                     [-77.00815200805664, 38.88989712255097],                 ],             },         }     ], }  m.add_source(\"LineString\", {\"type\": \"geojson\", \"data\": geojson}) layer = {     \"id\": \"LineString\",     \"type\": \"line\",     \"source\": \"LineString\",     \"layout\": {\"line-join\": \"round\", \"line-cap\": \"round\"},     \"paint\": {\"line-color\": \"#BF93E4\", \"line-width\": 5}, } m.add_layer(layer) m In\u00a0[6]: Copied! <pre>bounds = leafmap.geojson_bounds(geojson)\nbounds\n</pre> bounds = leafmap.geojson_bounds(geojson) bounds Out[6]: <pre>[-77.0366048812866, 38.88989712255097, -77.00813055038452, 38.89876515143842]</pre> In\u00a0[7]: Copied! <pre>m.fit_bounds(bounds)\n</pre> m.fit_bounds(bounds) <p></p>"},{"location":"notebooks/00_key_features/","title":"Usage","text":"In\u00a0[1]: Copied! <pre># !pip install leafmap geopandas pycrs osmnx\n</pre> # !pip install leafmap geopandas pycrs osmnx In\u00a0[2]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=4)\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=4) m Out[3]: In\u00a0[4]: Copied! <pre>m = leafmap.Map(height=\"400px\", width=\"800px\")\nm\n</pre> m = leafmap.Map(height=\"400px\", width=\"800px\") m Out[4]: In\u00a0[5]: Copied! <pre>m = leafmap.Map(\n    draw_control=False,\n    measure_control=False,\n    fullscreen_control=False,\n    attribution_control=True,\n)\nm\n</pre> m = leafmap.Map(     draw_control=False,     measure_control=False,     fullscreen_control=False,     attribution_control=True, ) m Out[5]: In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m Out[6]: In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m Out[7]: In\u00a0[8]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nnaip_url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url=naip_url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019\",\n    attribution=\"MRLC\",\n    format=\"image/png\",\n    shown=True,\n)\nm.add_legend(title=\"NLCD Land Cover Type\", builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) naip_url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url=naip_url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019\",     attribution=\"MRLC\",     format=\"image/png\",     shown=True, ) m.add_legend(title=\"NLCD Land Cover Type\", builtin_legend=\"NLCD\") m Out[8]: In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" m.add_cog_layer(url, name=\"Fire (pre-event)\") m Out[9]: In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m Out[10]: In\u00a0[11]: Copied! <pre>m = leafmap.Map()\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2016_Land_Cover_L48\",\n    name=\"NLCD 2016 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2016_Land_Cover_L48\",     name=\"NLCD 2016 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\") m Out[11]: In\u00a0[12]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"USGS 3DEP Elevation\")\ncolors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nvmin = 0\nvmax = 4000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"USGS 3DEP Elevation\") colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] vmin = 0 vmax = 4000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m Out[12]: In\u00a0[13]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\") m Out[13]: In\u00a0[14]: Copied! <pre># Add a GeoJSON with random filled color to the map.\nm = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nstyle = {\"fillOpacity\": 0.5}\nm.add_geojson(\n    url,\n    layer_name=\"Countries\",\n    style=style,\n    fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"],\n)\nm\n</pre> # Add a GeoJSON with random filled color to the map. m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" style = {\"fillOpacity\": 0.5} m.add_geojson(     url,     layer_name=\"Countries\",     style=style,     fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"], ) m Out[14]: In\u00a0[15]: Copied! <pre># Use custom style and hover_style functions.\nm = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\nhover_style = {\"fillOpacity\": 0.7}\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> # Use custom style and hover_style functions. m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" style = {     \"stroke\": True,     \"color\": \"#0000ff\",     \"weight\": 2,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#0000ff\",     \"fillOpacity\": 0.1, } hover_style = {\"fillOpacity\": 0.7} m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m Out[15]: In\u00a0[16]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, layer_name=\"Countries\") m <pre>Downloading...\nFrom: https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/cache/shp/countries.zip\n</pre> <pre>\r  0%|          | 0.00/132k [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 132k/132k [00:00&lt;00:00, 12.2MB/s]</pre> <pre>\n</pre> <pre>Extracting files...\n</pre> Out[16]: In\u00a0[17]: Copied! <pre>try:\n    import geopandas\nexcept ImportError:\n    print(\"Installing geopandas ...\")\n    subprocess.check_call([\"python\", \"-m\", \"pip\", \"install\", \"geopandas\"])\n</pre> try:     import geopandas except ImportError:     print(\"Installing geopandas ...\")     subprocess.check_call([\"python\", \"-m\", \"pip\", \"install\", \"geopandas\"]) In\u00a0[18]: Copied! <pre>m = leafmap.Map()\nin_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\nm\n</pre> m = leafmap.Map() in_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\" m.add_kml(in_kml, layer_name=\"US States KML\") m <pre>Downloading...\nFrom: https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/us_states.kml\n</pre> <pre>\r  0%|          | 0.00/29.8k [00:00&lt;?, ?B/s]</pre> <pre>\r95.4kB [00:00, 134MB/s]                    </pre> <pre>\n</pre> Out[18]: In\u00a0[19]: Copied! <pre>import geopandas as gpd\n\nm = leafmap.Map()\ngdf = gpd.read_file(\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\n)\nm.add_gdf(gdf, layer_name=\"Cable lines\")\nm\n</pre> import geopandas as gpd  m = leafmap.Map() gdf = gpd.read_file(     \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" ) m.add_gdf(gdf, layer_name=\"Cable lines\") m Out[19]: In\u00a0[20]: Copied! <pre>m = leafmap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m = leafmap.Map() in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) In\u00a0[21]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nvmin = 0\nvmax = 10000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\")\nm\n</pre> colors = [\"blue\", \"lime\", \"red\"] vmin = 0 vmax = 10000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\") m Out[21]: In\u00a0[22]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Esri.NatGeoWorldMap\") m Out[22]: In\u00a0[23]: Copied! <pre>m.to_html(\"mymap.html\")\n</pre> m.to_html(\"mymap.html\") In\u00a0[24]: Copied! <pre>os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[25]: Copied! <pre>m = leafmap.Map()\nm.add_planet_by_month(year=2020, month=8)\nm.add_planet_by_quarter(year=2019, quarter=2)\nm\n</pre> m = leafmap.Map() m.add_planet_by_month(year=2020, month=8) m.add_planet_by_quarter(year=2019, quarter=2) m Out[25]:"},{"location":"notebooks/00_key_features/#key-features","title":"Key Features\u00b6","text":"<p>You can try out leafmap by using the cloud-computing platforms below without having to install anything on your computer:</p> <p> </p>"},{"location":"notebooks/00_key_features/#install-leafmap","title":"Install leafmap\u00b6","text":""},{"location":"notebooks/00_key_features/#use-ipyleaflet-plotting-backend","title":"Use ipyleaflet plotting backend\u00b6","text":""},{"location":"notebooks/00_key_features/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/00_key_features/#customize-map-height","title":"Customize map height\u00b6","text":""},{"location":"notebooks/00_key_features/#set-control-visibility","title":"Set control visibility\u00b6","text":""},{"location":"notebooks/00_key_features/#change-basemaps","title":"Change basemaps\u00b6","text":""},{"location":"notebooks/00_key_features/#add-xyz-tile-layer","title":"Add XYZ tile layer\u00b6","text":""},{"location":"notebooks/00_key_features/#add-wms-tile-layer","title":"Add WMS tile layer\u00b6","text":""},{"location":"notebooks/00_key_features/#add-cog-layer","title":"Add COG layer\u00b6","text":""},{"location":"notebooks/00_key_features/#add-stac-layer","title":"Add STAC layer\u00b6","text":""},{"location":"notebooks/00_key_features/#add-legend","title":"Add legend\u00b6","text":""},{"location":"notebooks/00_key_features/#add-colorbar","title":"Add colorbar\u00b6","text":""},{"location":"notebooks/00_key_features/#add-geojson","title":"Add GeoJSON\u00b6","text":""},{"location":"notebooks/00_key_features/#add-shapefile","title":"Add shapefile\u00b6","text":""},{"location":"notebooks/00_key_features/#add-kml","title":"Add KML\u00b6","text":""},{"location":"notebooks/00_key_features/#add-geodataframe","title":"Add GeoDataFrame\u00b6","text":""},{"location":"notebooks/00_key_features/#create-heat-map","title":"Create heat map\u00b6","text":""},{"location":"notebooks/00_key_features/#save-map-to-html","title":"Save map to HTML\u00b6","text":""},{"location":"notebooks/00_key_features/#add-planet-imagery","title":"Add Planet imagery\u00b6","text":""},{"location":"notebooks/01_leafmap_intro/","title":"01 leafmap intro","text":"<p>Introducing the leafmap Python package for interactive mapping</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p><code>leafmap</code> has four plotting backends: folium, ipyleaflet, here-map, and kepler.gl. Note that the backends do not offer equal functionality. Some interactive functionality in <code>ipyleaflet</code> might not be available in other plotting backends. To use a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> <li><code>import leafmap.kepler as leafmap</code></li> </ul> In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[3]: <p>Specify the default map center and zoom level.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[50, 19], zoom=4)  # center=[lat, lon]\nm\n</pre> m = leafmap.Map(center=[50, 19], zoom=4)  # center=[lat, lon] m Out[4]: <p>Set the visibility of map controls.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(\n    draw_control=False,\n    measure_control=False,\n    fullscreen_control=False,\n    attribution_control=True,\n)\nm\n</pre> m = leafmap.Map(     draw_control=False,     measure_control=False,     fullscreen_control=False,     attribution_control=True, ) m Out[5]: <p>Change the map width and height.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map(height=\"450px\", width=\"800px\")\nm\n</pre> m = leafmap.Map(height=\"450px\", width=\"800px\") m Out[6]: <p>Use the <code>ipyleaflet</code> plotting backend.</p> In\u00a0[7]: Copied! <pre>import leafmap.leafmap as leafmap\n</pre> import leafmap.leafmap as leafmap In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Use the <code>folium</code> plotting backend.</p> In\u00a0[9]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[10]:"},{"location":"notebooks/02_using_basemaps/","title":"02 using basemaps","text":"<p>Using basemaps in leafmap</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Specify a Google basemap to use, can be one of [\"ROADMAP\", \"TERRAIN\", \"SATELLITE\", \"HYBRID\"].</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"HYBRID\")\nm\n</pre> m = leafmap.Map(google_map=\"HYBRID\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"TERRAIN\")\nm\n</pre> m = leafmap.Map(google_map=\"TERRAIN\") m <p>Add a basemap using the <code>add_basemap()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"HYBRID\")\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"HYBRID\") m.add_basemap(\"Esri.NatGeoWorldMap\") m <p>Add an XYZ tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m <p>Add a WMS tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nnaip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True\n)\nm\n</pre> m = leafmap.Map() naip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\" m.add_wms_layer(     url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True ) m <p>Add a legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"HYBRID\")\n\nurl1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\"\nm.add_wms_layer(\n    url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\"\n)\n\nurl2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\"\n)\n\nm.add_legend(builtin_legend=\"NWI\")\nm\n</pre> m = leafmap.Map(google_map=\"HYBRID\")  url1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\" m.add_wms_layer(     url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\" )  url2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\" m.add_wms_layer(     url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\" )  m.add_legend(builtin_legend=\"NWI\") m"},{"location":"notebooks/03_cog_stac/","title":"03 cog stac","text":"<p>Using Cloud Optimized GeoTIFF (COG) and SpatioTemporal Asset Catalog (STAC)</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>Working with Cloud Optimized GeoTIFF (COG)</p> <p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> <li>https://www.digitalglobe.com/ecosystem/open-data</li> <li>https://earthexplorer.usgs.gov/</li> </ul> <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A List of COGs can be found here.</p> <p></p> In\u00a0[2]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[3]: Copied! <pre># Use the TiTiler demo endpoint. Replace this if needed.\nos.environ[\"TITILER_ENDPOINT\"] = \"https://titiler.xyz\"\n</pre> # Use the TiTiler demo endpoint. Replace this if needed. os.environ[\"TITILER_ENDPOINT\"] = \"https://titiler.xyz\" <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>Map = leafmap.Map()\n</pre> Map = leafmap.Map() In\u00a0[5]: Copied! <pre>url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n</pre> url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" <p>Retrieve the bounding box coordinates of the COG file.</p> In\u00a0[6]: Copied! <pre>leafmap.cog_bounds(url)\n</pre> leafmap.cog_bounds(url) Out[6]: <pre>[22.599490732206565, 32.75052266794987, 22.65706605051743, 32.79916288270382]</pre> <p>Retrieve the centroid coordinates of the COG file.</p> In\u00a0[7]: Copied! <pre>leafmap.cog_center(url)\n</pre> leafmap.cog_center(url) Out[7]: <pre>(22.628278391361995, 32.774842775326846)</pre> <p>Retrieve the band names of the COG file.</p> In\u00a0[8]: Copied! <pre>leafmap.cog_bands(url)\n</pre> leafmap.cog_bands(url) Out[8]: <pre>['b1', 'b2', 'b3']</pre> <p>Retrieves the tile layer URL of the COG file.</p> In\u00a0[9]: Copied! <pre>leafmap.cog_tile(url)\n</pre> leafmap.cog_tile(url) Out[9]: <pre>'https://titiler.xyz/cog/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?url=https%3A%2F%2Fgithub.com%2Fopengeos%2Fdata%2Freleases%2Fdownload%2Fraster%2FLibya-2023-07-01.tif&amp;bidx=1&amp;bidx=2&amp;bidx=3&amp;rescale=41.0%2C235.0&amp;rescale=45.0%2C216.0&amp;rescale=40.0%2C197.0'</pre> <p>Add a COG layer to the map.</p> In\u00a0[10]: Copied! <pre>Map.add_cog_layer(url, name=\"Fire (pre-event)\")\n</pre> Map.add_cog_layer(url, name=\"Fire (pre-event)\") In\u00a0[11]: Copied! <pre>url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n</pre> url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" In\u00a0[12]: Copied! <pre>Map.add_cog_layer(url2, name=\"Fire (post-event)\")\n</pre> Map.add_cog_layer(url2, name=\"Fire (post-event)\") In\u00a0[13]: Copied! <pre>Map\n</pre> Map Out[13]: <p>Working with  SpatioTemporal Asset Catalog (STAC)</p> <p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc. More information about STAC can be found at https://stacspec.org/</p> <p>Some publicly available SpatioTemporal Asset Catalog (STAC):</p> <ul> <li>https://stacindex.org</li> </ul> <p>For this demo, we will use STAC assets from https://stacindex.org/catalogs/spot-orthoimages-canada-2005#/?t=catalogs</p> <p>Create an interactive map.</p> In\u00a0[14]: Copied! <pre>Map = leafmap.Map()\n</pre> Map = leafmap.Map() In\u00a0[15]: Copied! <pre>url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n</pre> url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" <p>Retrieve the bounding box coordinates of the STAC file.</p> In\u00a0[16]: Copied! <pre>leafmap.stac_bounds(url)\n</pre> leafmap.stac_bounds(url) Out[16]: <pre>[-111.6453245, 60.59892389999882, -110.1583693, 61.30928879999903]</pre> <p>Retrieve the centroid coordinates of the STAC file.</p> In\u00a0[17]: Copied! <pre>leafmap.stac_center(url)\n</pre> leafmap.stac_center(url) Out[17]: <pre>(-110.90184690000001, 60.95410634999892)</pre> <p>Retrieve the band names of the STAC file.</p> In\u00a0[18]: Copied! <pre>leafmap.stac_bands(url)\n</pre> leafmap.stac_bands(url) Out[18]: <pre>['pan', 'B1', 'B2', 'B3', 'B4']</pre> <p>Retrieve the tile layer URL of the STAC file.</p> In\u00a0[19]: Copied! <pre>leafmap.stac_tile(url, bands=[\"B3\", \"B2\", \"B1\"])\n</pre> leafmap.stac_tile(url, bands=[\"B3\", \"B2\", \"B1\"]) Out[19]: <pre>'https://titiler.xyz/stac/tiles/WebMercatorQuad/{z}/{x}/{y}@1x?url=https%3A%2F%2Fcanada-spot-ortho.s3.amazonaws.com%2Fcanada_spot_orthoimages%2Fcanada_spot5_orthoimages%2FS5_2007%2FS5_11055_6057_20070622%2FS5_11055_6057_20070622.json&amp;assets=B3&amp;assets=B2&amp;assets=B1&amp;rescale=23.0%2C168.0'</pre> <p>Add a STAC layer to the map.</p> In\u00a0[20]: Copied! <pre>Map.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\")\n</pre> Map.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\") In\u00a0[21]: Copied! <pre>Map.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\n</pre> Map.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") In\u00a0[22]: Copied! <pre>Map\n</pre> Map Out[22]:"},{"location":"notebooks/04_cog_mosaic/","title":"04 cog mosaic","text":"<p>Creating a virtual mosaic of Cloud Optimized GeoTIFFs (COG)</p> <p>Uncomment the following line to install leafmap if needed.</p> <p>Important Note: This notebook no longer works. The <code>add_cog_mosaic()</code> has been removed from leafmap. See https://github.com/opengeos/leafmap/issues/180</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A List of COGs can be found at:</p> <ul> <li>Pre-event: https://github.com/opengeos/leafmap/blob/master/examples/data/cog_pre_event.txt</li> <li>Post-event: https://github.com/opengeos/leafmap/blob/master/examples/data/cog_post_event.txt</li> </ul> In\u00a0[5]: Copied! <pre>pre_fire_url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cog_pre_event.txt\"\n</pre> pre_fire_url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cog_pre_event.txt\" <p>Create an XYZ tile layer based on a txt file containing a list of COG URLs.</p> In\u00a0[6]: Copied! <pre># leafmap.cog_mosaic_from_file(pre_fire_url)\n</pre> # leafmap.cog_mosaic_from_file(pre_fire_url) In\u00a0[7]: Copied! <pre>post_fire_url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cog_post_event.txt\"\n</pre> post_fire_url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cog_post_event.txt\" In\u00a0[8]: Copied! <pre># leafmap.cog_mosaic_from_file(post_fire_url)\n</pre> # leafmap.cog_mosaic_from_file(post_fire_url) <p>Add a COG mosaic tile layer to the map.</p> In\u00a0[9]: Copied! <pre># m.add_cog_mosaic_from_file(pre_fire_url, name=\"Pre-event\", show_footprints=True)  #This line might take a while to run\n</pre> # m.add_cog_mosaic_from_file(pre_fire_url, name=\"Pre-event\", show_footprints=True)  #This line might take a while to run In\u00a0[10]: Copied! <pre># m.add_cog_mosaic_from_file(post_fire_url, name=\"Post-event\", show_footprints=True)   #This line might take a while to run\n</pre> # m.add_cog_mosaic_from_file(post_fire_url, name=\"Post-event\", show_footprints=True)   #This line might take a while to run In\u00a0[11]: Copied! <pre>pre_event_tile = (\n    \"https://titiler.xyz/mosaicjson/anonymous.layer_pqmra/tiles/{z}/{x}/{y}@1x?\"\n)\nm.add_tile_layer(pre_event_tile, name=\"Pre-event\", attribution=\"Maxar\")\n</pre> pre_event_tile = (     \"https://titiler.xyz/mosaicjson/anonymous.layer_pqmra/tiles/{z}/{x}/{y}@1x?\" ) m.add_tile_layer(pre_event_tile, name=\"Pre-event\", attribution=\"Maxar\") In\u00a0[12]: Copied! <pre>post_event_tile = (\n    \"https://titiler.xyz/mosaicjson/anonymous.layer_qdano/tiles/{z}/{x}/{y}@1x?\"\n)\nm.add_tile_layer(post_event_tile, name=\"Post-event\", attribution=\"Maxar\")\n</pre> post_event_tile = (     \"https://titiler.xyz/mosaicjson/anonymous.layer_qdano/tiles/{z}/{x}/{y}@1x?\" ) m.add_tile_layer(post_event_tile, name=\"Post-event\", attribution=\"Maxar\") In\u00a0[13]: Copied! <pre>m.set_center(-122.0828, 37.0317, 11)\n</pre> m.set_center(-122.0828, 37.0317, 11) In\u00a0[14]: Copied! <pre>m\n</pre> m Out[14]:"},{"location":"notebooks/05_load_raster/","title":"05 load raster","text":"<p>Loading local raster datasets with leafmap</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>To follow this tutorial, you need to install the leafmap and xarray_leaflet Python packages. Use the following conda commands to create a conda env and install packages. Note that <code>xarray_leaflet</code> does not work properly on Windows (source). Also, the <code>add_raster</code> function is only available for the ipyleaflet plotting backend. Therefore, Google Colab is not supported. Use the binder link above instead.</p> <ul> <li><code>conda create -n gee python</code></li> <li><code>conda activate gee</code></li> <li><code>conda install mamba -c conda-forge</code></li> <li><code>mamba install leafmap xarray_leaflet -c conda-forge</code></li> </ul> <p>Use the ipyleaflet plotting backend. The folium plotting backend does not support the <code>add_raster</code> function.</p> In\u00a0[2]: Copied! <pre>import os\nimport leafmap.leafmap as leafmap\n</pre> import os import leafmap.leafmap as leafmap <p>Specify input raster datasets</p> In\u00a0[3]: Copied! <pre>landsat = \"landsat.tif\"\ndem = \"dem.tif\"\n</pre> landsat = \"landsat.tif\" dem = \"dem.tif\" <p>Download samples raster datasets</p> <p>More datasets can be downloaded from https://viewer.nationalmap.gov/basic/</p> In\u00a0[4]: Copied! <pre>url1 = \"https://open.gishub.org/data/raster/landsat7.tif\"\nurl2 = \"https://open.gishub.org/data/raster/srtm90.tif\"\nsatellite = leafmap.download_file(url1, \"landsat.tif\")\ndem = leafmap.download_file(url2, \"dem.tif\")\n</pre> url1 = \"https://open.gishub.org/data/raster/landsat7.tif\" url2 = \"https://open.gishub.org/data/raster/srtm90.tif\" satellite = leafmap.download_file(url1, \"landsat.tif\") dem = leafmap.download_file(url2, \"dem.tif\") <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/landsat7.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif\n</pre> <pre>\r  0%|          | 0.00/4.87M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4.87M/4.87M [00:00&lt;00:00, 127MB/s]</pre> <pre>\n</pre> <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/srtm90.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif\n</pre> <pre>\r  0%|          | 0.00/16.6M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16.6M/16.6M [00:00&lt;00:00, 219MB/s]</pre> <pre>\n</pre> <p>Create an interactive map</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add local raster datasets to the map</p> <p>More colormap can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html</p> In\u00a0[6]: Copied! <pre>m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\n</pre> m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") In\u00a0[7]: Copied! <pre>m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\")\n</pre> m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\") <p>Display the map</p> In\u00a0[8]: Copied! <pre>m\n</pre> m"},{"location":"notebooks/06_legend/","title":"06 legend","text":"<p>Adding custom legends to the map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>List available built-in legends.</p> In\u00a0[3]: Copied! <pre>legends = leafmap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = leafmap.builtin_legends for legend in legends:     print(legend) <pre>NLCD\nNWI\nMODIS/051/MCD12Q1\nGLOBCOVER\nJAXA/PALSAR\nMODIS/006/MCD12Q1\nOxford\nAAFC/ACI\nCOPERNICUS/CORINE/V20/100m\nCOPERNICUS/Landcover/100m/Proba-V/Global\nUSDA/NASS/CDL\nESA_WorldCover\n</pre> <p>National Land Cover Database (NLCD)</p> <p>https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD</p> <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>Map = leafmap.Map()\n</pre> Map = leafmap.Map() <p>Add a WMS layer and built-in legend to the map.</p> In\u00a0[5]: Copied! <pre>url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\"\nMap.add_wms_layer(\n    url,\n    layers=\"NLCD_2016_Land_Cover_L48\",\n    name=\"NLCD 2016 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nMap.add_legend(builtin_legend=\"NLCD\")\n\nMap\n</pre> url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\" Map.add_wms_layer(     url,     layers=\"NLCD_2016_Land_Cover_L48\",     name=\"NLCD 2016 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) Map.add_legend(builtin_legend=\"NLCD\")  Map Out[5]: <p>Add National Wetlands Inventory to the map.</p> In\u00a0[6]: Copied! <pre>Map = leafmap.Map(google_map=\"HYBRID\")\n\nurl1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\"\nMap.add_wms_layer(\n    url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\"\n)\n\nurl2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\"\nMap.add_wms_layer(\n    url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\"\n)\n\nMap.add_legend(builtin_legend=\"NWI\")\nMap\n</pre> Map = leafmap.Map(google_map=\"HYBRID\")  url1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\" Map.add_wms_layer(     url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\" )  url2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\" Map.add_wms_layer(     url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\" )  Map.add_legend(builtin_legend=\"NWI\") Map Out[6]: <p>Add custom legends</p> <p>There are two ways you can add custom legends:</p> <ol> <li>Define legend labels and colors</li> <li>Define legend dictionary</li> </ol> <p>Define legend keys and colors</p> In\u00a0[7]: Copied! <pre>Map = leafmap.Map()\n\nlabels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n# color can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]\n\nMap.add_legend(title=\"Legend\", labels=labels, colors=colors)\nMap\n</pre> Map = leafmap.Map()  labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"] # color can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"] # colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]  Map.add_legend(title=\"Legend\", labels=labels, colors=colors) Map Out[7]: <p>Define a legend dictionary.</p> In\u00a0[8]: Copied! <pre>Map = leafmap.Map()\n\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\"\nMap.add_wms_layer(\n    url,\n    layers=\"NLCD_2016_Land_Cover_L48\",\n    name=\"NLCD 2016 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = leafmap.Map()  url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2016_Land_Cover_L48/wms?\" Map.add_wms_layer(     url,     layers=\"NLCD_2016_Land_Cover_L48\",     name=\"NLCD 2016 CONUS Land Cover\",     format=\"image/png\",     transparent=True, )  legend_dict = {     \"11 Open Water\": \"466b9f\",     \"12 Perennial Ice/Snow\": \"d1def8\",     \"21 Developed, Open Space\": \"dec5c5\",     \"22 Developed, Low Intensity\": \"d99282\",     \"23 Developed, Medium Intensity\": \"eb0000\",     \"24 Developed High Intensity\": \"ab0000\",     \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",     \"41 Deciduous Forest\": \"68ab5f\",     \"42 Evergreen Forest\": \"1c5f2c\",     \"43 Mixed Forest\": \"b5c58f\",     \"51 Dwarf Scrub\": \"af963c\",     \"52 Shrub/Scrub\": \"ccb879\",     \"71 Grassland/Herbaceous\": \"dfdfc2\",     \"72 Sedge/Herbaceous\": \"d1d182\",     \"73 Lichens\": \"a3cc51\",     \"74 Moss\": \"82ba9e\",     \"81 Pasture/Hay\": \"dcd939\",     \"82 Cultivated Crops\": \"ab6c28\",     \"90 Woody Wetlands\": \"b8d9eb\",     \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\", }  Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map Out[8]:"},{"location":"notebooks/07_colorbar/","title":"07 colorbar","text":"<p>Adding custom colorbars to the map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>Continuous colorbar</p> In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add a WMS layer to the map</p> In\u00a0[3]: Copied! <pre>Map = leafmap.Map()\n\nurl = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\"\nMap.add_wms_layer(\n    url,\n    layers=\"3DEPElevation:Hillshade Elevation Tinted\",\n    name=\"USGS 3DEP Elevation\",\n    format=\"image/png\",\n    transparent=True,\n)\n</pre> Map = leafmap.Map()  url = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\" Map.add_wms_layer(     url,     layers=\"3DEPElevation:Hillshade Elevation Tinted\",     name=\"USGS 3DEP Elevation\",     format=\"image/png\",     transparent=True, ) <p>Add a continuous colorbar with a custom palette to the map.</p> In\u00a0[4]: Copied! <pre>colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nvmin = 0\nvmax = 4000\n\nMap.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\n\nMap\n</pre> colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] vmin = 0 vmax = 4000  Map.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)  Map Out[4]: <p>Categorical colorbar</p> <p>Add a WMS layer to the map</p> In\u00a0[5]: Copied! <pre>Map = leafmap.Map()\n\nurl = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\"\nMap.add_wms_layer(\n    url,\n    layers=\"3DEPElevation:Hillshade Elevation Tinted\",\n    name=\"USGS 3DEP Elevation\",\n    format=\"image/png\",\n    transparent=True,\n)\n</pre> Map = leafmap.Map()  url = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\" Map.add_wms_layer(     url,     layers=\"3DEPElevation:Hillshade Elevation Tinted\",     name=\"USGS 3DEP Elevation\",     format=\"image/png\",     transparent=True, ) <p>Add a categorical colorbar with a custom palette to the map.</p> In\u00a0[6]: Copied! <pre>colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nvmin = 0\nvmax = 4000\n\nMap.add_colorbar(colors=colors, vmin=vmin, vmax=vmax, categorical=True, step=4)\nMap\n</pre> colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] vmin = 0 vmax = 4000  Map.add_colorbar(colors=colors, vmin=vmin, vmax=vmax, categorical=True, step=4) Map Out[6]:"},{"location":"notebooks/08_whitebox/","title":"08 whitebox","text":"<p>Using WhiteboxTools with leafmap</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Download a sample DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\ndem = os.path.join(out_dir, \"dem.tif\")\ndem_url = (\n    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n)\nleafmap.download_file(dem_url, \"dem.tif\", unzip=False)\n</pre> out_dir = os.getcwd() dem = os.path.join(out_dir, \"dem.tif\") dem_url = (     \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" ) leafmap.download_file(dem_url, \"dem.tif\", unzip=False) <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>Map = leafmap.Map()\nMap\n</pre> Map = leafmap.Map() Map <p>Use the built-in toolbox to perform geospatial analysis. For example, you can perform depression filling using the sample DEM dataset downloaded in the above step.</p> <p></p> <p>Display the toolbox using the default mode.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui()\n</pre> leafmap.whiteboxgui() <p>Display the toolbox using the collapsible tree mode. Note that the tree mode does not support Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui(tree=True)\n</pre> leafmap.whiteboxgui(tree=True) <p>Perform geospatial analysis using the whitebox package.</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport pkg_resources\n</pre> import os import pkg_resources In\u00a0[\u00a0]: Copied! <pre>wbt = leafmap.WhiteboxTools()\nwbt.verbose = False\n</pre> wbt = leafmap.WhiteboxTools() wbt.verbose = False In\u00a0[\u00a0]: Copied! <pre># identify the sample data directory of the package\ndata_dir = os.path.dirname(pkg_resources.resource_filename(\"whitebox\", \"testdata/\"))\nwbt.set_working_dir(data_dir)\n\nwbt.feature_preserving_smoothing(\"DEM.tif\", \"smoothed.tif\", filter=9)\nwbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")\n</pre> # identify the sample data directory of the package data_dir = os.path.dirname(pkg_resources.resource_filename(\"whitebox\", \"testdata/\")) wbt.set_working_dir(data_dir)  wbt.feature_preserving_smoothing(\"DEM.tif\", \"smoothed.tif\", filter=9) wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")"},{"location":"notebooks/09_csv_to_points/","title":"09 csv to points","text":"<p>Converting CSV to points</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook example requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>import os\nimport leafmap.leafmap as leafmap\n</pre> import os import leafmap.leafmap as leafmap <p>Read a CSV as a Pandas DataFrame.</p> In\u00a0[3]: Copied! <pre>in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\"\n</pre> in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\" In\u00a0[4]: Copied! <pre>df = leafmap.csv_to_df(in_csv)\ndf\n</pre> df = leafmap.csv_to_df(in_csv) df Out[4]: id name country latitude longitude population 0 1 Bombo UGA 0.58330 32.53330 75000 1 2 Fort Portal UGA 0.67100 30.27500 42670 2 3 Potenza ITA 40.64200 15.79900 69060 3 4 Campobasso ITA 41.56300 14.65600 50762 4 5 Aosta ITA 45.73700 7.31500 34062 ... ... ... ... ... ... ... 1244 1245 Rio de Janeiro BRA -22.92502 -43.22502 11748000 1245 1246 Sao Paulo BRA -23.55868 -46.62502 18845000 1246 1247 Sydney AUS -33.92001 151.18518 4630000 1247 1248 Singapore SGP 1.29303 103.85582 5183700 1248 1249 Hong Kong CHN 22.30498 114.18501 7206000 <p>1249 rows \u00d7 6 columns</p> <p>Create a point layer from a CSV file containing lat/long information.</p> In\u00a0[5]: Copied! <pre>Map = leafmap.Map()\nMap.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\")\nMap\n</pre> Map = leafmap.Map() Map.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\") Map <p>Set the output directory.</p> In\u00a0[6]: Copied! <pre>out_dir = os.path.expanduser(\"~/Downloads\")\nif not os.path.exists(out_dir):\n    os.makedirs(out_dir)\nout_shp = os.path.join(out_dir, \"world_cities.shp\")\n</pre> out_dir = os.path.expanduser(\"~/Downloads\") if not os.path.exists(out_dir):     os.makedirs(out_dir) out_shp = os.path.join(out_dir, \"world_cities.shp\") <p>Convert a CSV file containing lat/long information to a shapefile.</p> In\u00a0[7]: Copied! <pre>leafmap.csv_to_shp(in_csv, out_shp)\n</pre> leafmap.csv_to_shp(in_csv, out_shp) In\u00a0[8]: Copied! <pre>out_geojson = os.path.join(out_dir, \"world_cities.geojson\")\nleafmap.csv_to_geojson(in_csv, out_geojson)\n</pre> out_geojson = os.path.join(out_dir, \"world_cities.geojson\") leafmap.csv_to_geojson(in_csv, out_geojson) <p>Convert a CSV file containing lat/long information to a GeoPandas GeoDataFrame.</p> In\u00a0[9]: Copied! <pre># gdf = leafmap.csv_to_gdf(in_csv)\n# gdf\n</pre> # gdf = leafmap.csv_to_gdf(in_csv) # gdf"},{"location":"notebooks/10_add_vector/","title":"10 add vector","text":"<p>Adding local vector data (e.g., shp, geojson, kml) to the map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[3]: <p>This demo is based on the ipyleaflet plotting backend. The folium plotting backend does not have the interactive GUI for loading local vector data.</p> <p></p> <p>Add a GeoJSON to the map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\n\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\")\n\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2)  in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\")  m Out[4]: <p>Add a GeoJSON with random filled color to the map.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m Out[5]: <p>Use the <code>style_callback</code>function for assigning a random color to each polygon.</p> In\u00a0[6]: Copied! <pre>import random\n\nm = leafmap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\n\ndef random_color(feature):\n    return {\n        \"color\": \"black\",\n        \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),\n    }\n\n\nm.add_geojson(url, layer_name=\"Countries\", style_callback=random_color)\nm\n</pre> import random  m = leafmap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"   def random_color(feature):     return {         \"color\": \"black\",         \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),     }   m.add_geojson(url, layer_name=\"Countries\", style_callback=random_color) m Out[6]: <p>Use custom <code>style</code> and <code>hover_style</code> functions.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\n\nhover_style = {\"fillOpacity\": 0.7}\n\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"  style = {     \"stroke\": True,     \"color\": \"#0000ff\",     \"weight\": 2,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#0000ff\",     \"fillOpacity\": 0.1, }  hover_style = {\"fillOpacity\": 0.7}  m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m Out[7]: <p>Add a shapefile to the map.</p> In\u00a0[8]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\n\nin_shp = \"../data/countries.shp\"\nm.add_shp(in_shp, layer_name=\"Countries\")\n\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2)  in_shp = \"../data/countries.shp\" m.add_shp(in_shp, layer_name=\"Countries\")  m Out[8]: <p>Add a KML to the map.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map()\n\nin_kml = \"../data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\n\nm\n</pre> m = leafmap.Map()  in_kml = \"../data/us_states.kml\" m.add_kml(in_kml, layer_name=\"US States KML\")  m Out[9]: <p>The <code>add_vector</code> function supports any vector data format supported by GeoPandas.</p> In\u00a0[10]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_vector(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_vector(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m Out[10]: In\u00a0[11]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() In\u00a0[12]: Copied! <pre>in_shp = \"../data/countries.shp\"\nin_geojson = \"../data/us_states.json\"\nin_kml = \"../data/us_states.kml\"\n</pre> in_shp = \"../data/countries.shp\" in_geojson = \"../data/us_states.json\" in_kml = \"../data/us_states.kml\" In\u00a0[13]: Copied! <pre>m.add_shp(in_shp, layer_name=\"Shapefile\")\n</pre> m.add_shp(in_shp, layer_name=\"Shapefile\") In\u00a0[14]: Copied! <pre>m.add_geojson(in_geojson, layer_name=\"GeoJSON\")\n</pre> m.add_geojson(in_geojson, layer_name=\"GeoJSON\") In\u00a0[15]: Copied! <pre>m.add_kml(in_kml, layer_name=\"KML\")\n</pre> m.add_kml(in_kml, layer_name=\"KML\") In\u00a0[16]: Copied! <pre>m\n</pre> m Out[16]:"},{"location":"notebooks/11_linked_maps/","title":"11 linked maps","text":"<p>Creating linked maps for visualizing multiple maps simultaneously</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook example requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>import leafmap.leafmap as leafmap\n</pre> import leafmap.leafmap as leafmap <p>Print out the list of available basemaps.</p> In\u00a0[3]: Copied! <pre>print(leafmap.basemaps.keys())\n</pre> print(leafmap.basemaps.keys()) <pre>dict_keys(['OpenStreetMap', 'Esri.WorldStreetMap', 'Esri.WorldImagery', 'Esri.WorldTopoMap', 'FWS NWI Wetlands', 'FWS NWI Wetlands Raster', 'NLCD 2021 CONUS Land Cover', 'NLCD 2019 CONUS Land Cover', 'NLCD 2016 CONUS Land Cover', 'NLCD 2013 CONUS Land Cover', 'NLCD 2011 CONUS Land Cover', 'NLCD 2008 CONUS Land Cover', 'NLCD 2006 CONUS Land Cover', 'NLCD 2004 CONUS Land Cover', 'NLCD 2001 CONUS Land Cover', 'USGS NAIP Imagery', 'USGS NAIP Imagery False Color', 'USGS NAIP Imagery NDVI', 'USGS Hydrography', 'USGS 3DEP Elevation', 'ESA Worldcover 2020', 'ESA Worldcover 2020 S2 FCC', 'ESA Worldcover 2020 S2 TCC', 'ESA Worldcover 2021', 'ESA Worldcover 2021 S2 FCC', 'ESA Worldcover 2021 S2 TCC', 'BaseMapDE.Color', 'BaseMapDE.Grey', 'BasemapAT.basemap', 'BasemapAT.grau', 'BasemapAT.highdpi', 'BasemapAT.orthofoto', 'BasemapAT.overlay', 'BasemapAT.surface', 'BasemapAT.terrain', 'CartoDB.DarkMatter', 'CartoDB.DarkMatterNoLabels', 'CartoDB.DarkMatterOnlyLabels', 'CartoDB.Positron', 'CartoDB.PositronNoLabels', 'CartoDB.PositronOnlyLabels', 'CartoDB.Voyager', 'CartoDB.VoyagerLabelsUnder', 'CartoDB.VoyagerNoLabels', 'CartoDB.VoyagerOnlyLabels', 'CyclOSM', 'Esri.AntarcticBasemap', 'Esri.AntarcticImagery', 'Esri.ArcticImagery', 'Esri.ArcticOceanBase', 'Esri.ArcticOceanReference', 'Esri.DeLorme', 'Esri.NatGeoWorldMap', 'Esri.OceanBasemap', 'Esri.WorldGrayCanvas', 'Esri.WorldPhysical', 'Esri.WorldShadedRelief', 'Esri.WorldTerrain', 'FreeMapSK', 'Gaode.Normal', 'Gaode.Satellite', 'HikeBike.HikeBike', 'HikeBike.HillShading', 'JusticeMap.americanIndian', 'JusticeMap.asian', 'JusticeMap.black', 'JusticeMap.hispanic', 'JusticeMap.income', 'JusticeMap.multi', 'JusticeMap.nonWhite', 'JusticeMap.plurality', 'JusticeMap.white', 'MtbMap', 'NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief', 'NASAGIBS.BlueMarble3031', 'NASAGIBS.BlueMarble3413', 'NASAGIBS.BlueMarbleBathymetry3031', 'NASAGIBS.BlueMarbleBathymetry3413', 'NASAGIBS.MEaSUREsIceVelocity3031', 'NASAGIBS.MEaSUREsIceVelocity3413', 'NASAGIBS.ModisAquaBands721CR', 'NASAGIBS.ModisAquaTrueColorCR', 'NASAGIBS.ModisTerraAOD', 'NASAGIBS.ModisTerraBands367CR', 'NASAGIBS.ModisTerraBands721CR', 'NASAGIBS.ModisTerraChlorophyll', 'NASAGIBS.ModisTerraLSTDay', 'NASAGIBS.ModisTerraSnowCover', 'NASAGIBS.ModisTerraTrueColorCR', 'NASAGIBS.ViirsEarthAtNight2012', 'NASAGIBS.ViirsTrueColorCR', 'OPNVKarte', 'OneMapSG.Default', 'OneMapSG.Grey', 'OneMapSG.LandLot', 'OneMapSG.Night', 'OneMapSG.Original', 'OpenAIP', 'OpenFireMap', 'OpenRailwayMap', 'OpenSeaMap', 'OpenSnowMap.pistes', 'OpenStreetMap.BZH', 'OpenStreetMap.BlackAndWhite', 'OpenStreetMap.CH', 'OpenStreetMap.DE', 'OpenStreetMap.HOT', 'OpenStreetMap.Mapnik', 'OpenTopoMap', 'SafeCast', 'Stadia.AlidadeSatellite', 'Stadia.AlidadeSmooth', 'Stadia.AlidadeSmoothDark', 'Stadia.OSMBright', 'Stadia.Outdoors', 'Stadia.StamenTerrain', 'Stadia.StamenTerrainBackground', 'Stadia.StamenTerrainLabels', 'Stadia.StamenTerrainLines', 'Stadia.StamenToner', 'Stadia.StamenTonerBackground', 'Stadia.StamenTonerLabels', 'Stadia.StamenTonerLines', 'Stadia.StamenTonerLite', 'Stadia.StamenWatercolor', 'Strava.All', 'Strava.Ride', 'Strava.Run', 'Strava.Water', 'Strava.Winter', 'SwissFederalGeoportal.JourneyThroughTime', 'SwissFederalGeoportal.NationalMapColor', 'SwissFederalGeoportal.NationalMapGrey', 'SwissFederalGeoportal.SWISSIMAGE', 'TopPlusOpen.Color', 'TopPlusOpen.Grey', 'USGS.USImagery', 'USGS.USImageryTopo', 'USGS.USTopo', 'WaymarkedTrails.cycling', 'WaymarkedTrails.hiking', 'WaymarkedTrails.mtb', 'WaymarkedTrails.riding', 'WaymarkedTrails.skating', 'WaymarkedTrails.slopes', 'nlmaps.grijs', 'nlmaps.luchtfoto', 'nlmaps.pastel', 'nlmaps.standaard', 'nlmaps.water'])\n</pre> <p>Specify the number of rows and columns to create a linked map. The <code>layers</code> parameter accepts a list of two XYZ tile layers, which can be chosen from the basemap names, or any custom XYZ tile layer.</p> In\u00a0[4]: Copied! <pre>layers = [\"ROADMAP\", \"HYBRID\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"ROADMAP\", \"HYBRID\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) <p></p> In\u00a0[5]: Copied! <pre>layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) <p></p> <p>Create a 2 * 2 linked map to visualize land cover change. Specify the <code>center</code> and <code>zoom</code> parameters to change the default map center and zoom level.</p> In\u00a0[6]: Copied! <pre>layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]]\nlabels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]]\nleafmap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    layers=layers,\n    labels=labels,\n    center=[36.1, -115.2],\n    zoom=9,\n)\n</pre> layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]] labels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]] leafmap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     layers=layers,     labels=labels,     center=[36.1, -115.2],     zoom=9, ) <p></p>"},{"location":"notebooks/12_split_map/","title":"12 split map","text":"<p>Creating a split-panel map with only one line of code</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook example requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>import leafmap.leafmap as leafmap\n</pre> import leafmap.leafmap as leafmap <p>Print out the list of available basemaps.</p> In\u00a0[3]: Copied! <pre>print(leafmap.basemaps.keys())\n</pre> print(leafmap.basemaps.keys()) <pre>dict_keys(['OpenStreetMap', 'Esri.WorldStreetMap', 'Esri.WorldImagery', 'Esri.WorldTopoMap', 'FWS NWI Wetlands', 'FWS NWI Wetlands Raster', 'NLCD 2021 CONUS Land Cover', 'NLCD 2019 CONUS Land Cover', 'NLCD 2016 CONUS Land Cover', 'NLCD 2013 CONUS Land Cover', 'NLCD 2011 CONUS Land Cover', 'NLCD 2008 CONUS Land Cover', 'NLCD 2006 CONUS Land Cover', 'NLCD 2004 CONUS Land Cover', 'NLCD 2001 CONUS Land Cover', 'USGS NAIP Imagery', 'USGS NAIP Imagery False Color', 'USGS NAIP Imagery NDVI', 'USGS Hydrography', 'USGS 3DEP Elevation', 'ESA Worldcover 2020', 'ESA Worldcover 2020 S2 FCC', 'ESA Worldcover 2020 S2 TCC', 'ESA Worldcover 2021', 'ESA Worldcover 2021 S2 FCC', 'ESA Worldcover 2021 S2 TCC', 'BaseMapDE.Color', 'BaseMapDE.Grey', 'BasemapAT.basemap', 'BasemapAT.grau', 'BasemapAT.highdpi', 'BasemapAT.orthofoto', 'BasemapAT.overlay', 'BasemapAT.surface', 'BasemapAT.terrain', 'CartoDB.DarkMatter', 'CartoDB.DarkMatterNoLabels', 'CartoDB.DarkMatterOnlyLabels', 'CartoDB.Positron', 'CartoDB.PositronNoLabels', 'CartoDB.PositronOnlyLabels', 'CartoDB.Voyager', 'CartoDB.VoyagerLabelsUnder', 'CartoDB.VoyagerNoLabels', 'CartoDB.VoyagerOnlyLabels', 'CyclOSM', 'Esri.AntarcticBasemap', 'Esri.AntarcticImagery', 'Esri.ArcticImagery', 'Esri.ArcticOceanBase', 'Esri.ArcticOceanReference', 'Esri.DeLorme', 'Esri.NatGeoWorldMap', 'Esri.OceanBasemap', 'Esri.WorldGrayCanvas', 'Esri.WorldPhysical', 'Esri.WorldShadedRelief', 'Esri.WorldTerrain', 'FreeMapSK', 'Gaode.Normal', 'Gaode.Satellite', 'HikeBike.HikeBike', 'HikeBike.HillShading', 'JusticeMap.americanIndian', 'JusticeMap.asian', 'JusticeMap.black', 'JusticeMap.hispanic', 'JusticeMap.income', 'JusticeMap.multi', 'JusticeMap.nonWhite', 'JusticeMap.plurality', 'JusticeMap.white', 'MtbMap', 'NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief', 'NASAGIBS.BlueMarble3031', 'NASAGIBS.BlueMarble3413', 'NASAGIBS.BlueMarbleBathymetry3031', 'NASAGIBS.BlueMarbleBathymetry3413', 'NASAGIBS.MEaSUREsIceVelocity3031', 'NASAGIBS.MEaSUREsIceVelocity3413', 'NASAGIBS.ModisAquaBands721CR', 'NASAGIBS.ModisAquaTrueColorCR', 'NASAGIBS.ModisTerraAOD', 'NASAGIBS.ModisTerraBands367CR', 'NASAGIBS.ModisTerraBands721CR', 'NASAGIBS.ModisTerraChlorophyll', 'NASAGIBS.ModisTerraLSTDay', 'NASAGIBS.ModisTerraSnowCover', 'NASAGIBS.ModisTerraTrueColorCR', 'NASAGIBS.ViirsEarthAtNight2012', 'NASAGIBS.ViirsTrueColorCR', 'OPNVKarte', 'OneMapSG.Default', 'OneMapSG.Grey', 'OneMapSG.LandLot', 'OneMapSG.Night', 'OneMapSG.Original', 'OpenAIP', 'OpenFireMap', 'OpenRailwayMap', 'OpenSeaMap', 'OpenSnowMap.pistes', 'OpenStreetMap.BZH', 'OpenStreetMap.BlackAndWhite', 'OpenStreetMap.CH', 'OpenStreetMap.DE', 'OpenStreetMap.HOT', 'OpenStreetMap.Mapnik', 'OpenTopoMap', 'SafeCast', 'Stadia.AlidadeSatellite', 'Stadia.AlidadeSmooth', 'Stadia.AlidadeSmoothDark', 'Stadia.OSMBright', 'Stadia.Outdoors', 'Stadia.StamenTerrain', 'Stadia.StamenTerrainBackground', 'Stadia.StamenTerrainLabels', 'Stadia.StamenTerrainLines', 'Stadia.StamenToner', 'Stadia.StamenTonerBackground', 'Stadia.StamenTonerLabels', 'Stadia.StamenTonerLines', 'Stadia.StamenTonerLite', 'Stadia.StamenWatercolor', 'Strava.All', 'Strava.Ride', 'Strava.Run', 'Strava.Water', 'Strava.Winter', 'SwissFederalGeoportal.JourneyThroughTime', 'SwissFederalGeoportal.NationalMapColor', 'SwissFederalGeoportal.NationalMapGrey', 'SwissFederalGeoportal.SWISSIMAGE', 'TopPlusOpen.Color', 'TopPlusOpen.Grey', 'USGS.USImagery', 'USGS.USImageryTopo', 'USGS.USTopo', 'WaymarkedTrails.cycling', 'WaymarkedTrails.hiking', 'WaymarkedTrails.mtb', 'WaymarkedTrails.riding', 'WaymarkedTrails.skating', 'WaymarkedTrails.slopes', 'nlmaps.grijs', 'nlmaps.luchtfoto', 'nlmaps.pastel', 'nlmaps.standaard', 'nlmaps.water'])\n</pre> <p>Create a split-panel map by specifying the <code>left_layer</code> and <code>right_layer</code>, which can be chosen from the basemap names, or any custom XYZ tile layer.</p> In\u00a0[4]: Copied! <pre>leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\")\n</pre> leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\") <p>Hide the zoom control from the map.</p> In\u00a0[5]: Copied! <pre>leafmap.split_map(\n    left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False\n)\n</pre> leafmap.split_map(     left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False ) <p>Add labels to the map and change the default map center and zoom level.</p> In\u00a0[6]: Copied! <pre>leafmap.split_map(\n    left_layer=\"NLCD 2001 CONUS Land Cover\",\n    right_layer=\"NLCD 2016 CONUS Land Cover\",\n    left_label=\"2001\",\n    right_label=\"2016\",\n    label_position=\"bottom\",\n    center=[36.1, -114.9],\n    zoom=10,\n)\n</pre> leafmap.split_map(     left_layer=\"NLCD 2001 CONUS Land Cover\",     right_layer=\"NLCD 2016 CONUS Land Cover\",     left_label=\"2001\",     right_label=\"2016\",     label_position=\"bottom\",     center=[36.1, -114.9],     zoom=10, ) <p></p>"},{"location":"notebooks/13_geopandas/","title":"13 geopandas","text":"<p>Adding a GeoPandas GeoDataFrame to the map with a single line of code</p> <p>Uncomment the following line to install leafmap if needed. You can also use conda to create a new environment to install geopandas and leafmap.</p> <pre><code>conda create geo -n python=3.8\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap -c conda-forge\n</code></pre> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install geopandas\n</pre> # !pip install geopandas In\u00a0[3]: Copied! <pre>import leafmap\nimport geopandas as gpd\n</pre> import leafmap import geopandas as gpd In\u00a0[4]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>Use GeoPandas to read a GeoJSON from an HTTP URL and return it as a GeoDataFrame.</p> <p>Sample data: https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson</p> In\u00a0[5]: Copied! <pre>gdf = gpd.read_file(\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\n)\n</pre> gdf = gpd.read_file(     \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" ) <p>Add a GeoDataFrame to the map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Cable lines\") m Out[6]: <p>The following example requires the ipyleaflet plotting backend.</p> In\u00a0[7]: Copied! <pre>import leafmap.leafmap as leafmap  # for ipyleaflet only\n</pre> import leafmap.leafmap as leafmap  # for ipyleaflet only <p>Read the GeoPandas sample dataset as a GeoDataFrame.</p> In\u00a0[8]: Copied! <pre>path_to_data = gpd.datasets.get_path(\"nybb\")\ngdf = gpd.read_file(path_to_data)\ngdf\n</pre> path_to_data = gpd.datasets.get_path(\"nybb\") gdf = gpd.read_file(path_to_data) gdf Out[8]: BoroCode BoroName Shape_Leng Shape_Area geometry 0 5 Staten Island 330470.010332 1.623820e+09 MULTIPOLYGON (((970217.022 145643.332, 970227.... 1 4 Queens 896344.047763 3.045213e+09 MULTIPOLYGON (((1029606.077 156073.814, 102957... 2 3 Brooklyn 741080.523166 1.937479e+09 MULTIPOLYGON (((1021176.479 151374.797, 102100... 3 1 Manhattan 359299.096471 6.364715e+08 MULTIPOLYGON (((981219.056 188655.316, 980940.... 4 2 Bronx 464392.991824 1.186925e+09 MULTIPOLYGON (((1012821.806 229228.265, 101278... <p>Convert the GeoDataFrame to GeoJSON. Users can then use <code>add_geojson()</code> to add the GeoJSON to the map. Alternatively, users can directly use the <code>add_gdf()</code> function to add a GeoDataFrame to the map. Note you when hovering the mouse over the layer, an information box is shown at the lower right corner of the map. This feature is only available for the ipyleaflet plotting backend.</p> In\u00a0[9]: Copied! <pre>geojson = leafmap.gdf_to_geojson(gdf, epsg=\"4326\")\n# geojson\n</pre> geojson = leafmap.gdf_to_geojson(gdf, epsg=\"4326\") # geojson <p>One can provide a list of colors (<code>fill_colors</code>) to randomly fill the polygons.</p> In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"])\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"]) m <p></p>"},{"location":"notebooks/14_postgis/","title":"14 postgis","text":"<p>Adding data from a PostGIS database to the map</p> <p>Setting up the conda env:</p> <pre><code>conda create -n geo python=3.8\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap sqlalchemy psycopg2 -c conda-forge\n</code></pre> <p>Sample dataset:</p> <ul> <li>nyc_data.zip (Watch this video to load data into PostGIS)</li> </ul> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>Connecting to the database</p> In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>You can directly pass in the user name and password to access the database. Alternative, you can define environment variables. The default environment variables for user and password are <code>SQL_USER</code> and <code>SQL_PASSWORD</code>, respectively.</p> <p>The <code>try...except...</code> statements are only used for building the documentation website (https://leafmap.org) because the PostGIS database is not available on GitHub. If you are running the notebook with Jupyter installed locally and PostGIS set up properly, you don't need these <code>try...except...</code> statements.</p> In\u00a0[3]: Copied! <pre>try:\n    con = leafmap.connect_postgis(\n        database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True\n    )\nexcept:\n    pass\n</pre> try:     con = leafmap.connect_postgis(         database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True     ) except:     pass <p>Create a GeoDataFrame from a sql query.</p> In\u00a0[4]: Copied! <pre>sql = \"SELECT * FROM nyc_neighborhoods\"\n</pre> sql = \"SELECT * FROM nyc_neighborhoods\" In\u00a0[5]: Copied! <pre>try:\n    gdf = leafmap.read_postgis(sql, con)\n    display(gdf)\nexcept:\n    pass\n</pre> try:     gdf = leafmap.read_postgis(sql, con)     display(gdf) except:     pass <p>Display the GeoDataFrame on the interactive map.</p> In\u00a0[6]: Copied! <pre>try:\n    m = leafmap.Map()\n    m.add_gdf_from_postgis(\n        sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]\n    )\n    display(m)\nexcept:\n    pass\n</pre> try:     m = leafmap.Map()     m.add_gdf_from_postgis(         sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]     )     display(m) except:     pass <p></p>"},{"location":"notebooks/15_openstreetmap/","title":"15 openstreetmap","text":"<p>Downloading OpenStreetMap data with a single line of code</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre># !pip install geopandas osmnx\n</pre> # !pip install geopandas osmnx In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add OSM data of place(s) by name or ID to the map. Note that the leafmap custom layer control does not support GeoJSON, we need to use the ipyleaflet built-in layer control.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\") m <p>Show OSM feature tags.</p> <p>https://wiki.openstreetmap.org/wiki/Map_features</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.osm_tags_list()\n</pre> # leafmap.osm_tags_list() <p>Add OSM entities within some distance N, S, E, W of address to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\",\n    tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},\n    dist=1000,\n    layer_name=\"NYC buildings\",\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\",     tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},     dist=1000,     layer_name=\"NYC buildings\", ) m <p>Add OSM entities within a N, S, E, W bounding box to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nnorth, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965\nm.add_osm_from_bbox(\n    north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) north, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965 m.add_osm_from_bbox(     north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\" ) m <p>Add OSM entities within some distance N, S, E, W of a point to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(46.7808, -96.0156),\n    tags={\"natural\": \"water\"},\n    dist=10000,\n    layer_name=\"Lakes\",\n)\nm\n</pre> m = leafmap.Map(     center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(46.7808, -96.0156),     tags={\"natural\": \"water\"},     dist=10000,     layer_name=\"Lakes\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(39.9170, 116.3908),\n    tags={\"building\": True, \"natural\": \"water\"},\n    dist=1000,\n    layer_name=\"Beijing\",\n)\nm\n</pre> m = leafmap.Map(     center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(39.9170, 116.3908),     tags={\"building\": True, \"natural\": \"water\"},     dist=1000,     layer_name=\"Beijing\", ) m <p>Add OSM entities within the current map view to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.set_center(-73.9854, 40.7500, 16)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.set_center(-73.9854, 40.7500, 16) m <p>The <code>add_osm_from_view()</code> is only available for the ipyleaflet plotting backend.</p> In\u00a0[\u00a0]: Copied! <pre># m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n</pre> # m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\") <p>Create a GeoPandas GeoDataFrame from place.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"})\ngdf\n</pre> gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"}) gdf"},{"location":"notebooks/16_heremap/","title":"16 heremap","text":"<p>Using HERE Map Widget for Jupyter as a plotting backend</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap.heremap as leafmap\n</pre> import os import leafmap.heremap as leafmap In\u00a0[\u00a0]: Copied! <pre># Read api_key from environment\n\napi_key = os.environ[\"HEREMAPS_API_KEY\"]\n</pre> # Read api_key from environment  api_key = os.environ[\"HEREMAPS_API_KEY\"] <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key)\nm\n</pre> m = leafmap.Map(api_key=api_key) m <p>Specify the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[50, 19], zoom=4)  # center=[lat, lon]\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[50, 19], zoom=4)  # center=[lat, lon] m <p>Set the visibility of map controls.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, fullscreen_control=False)\nm\n</pre> m = leafmap.Map(api_key=api_key, fullscreen_control=False) m <p>Change the map width and height.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, height=\"450px\")\nm\n</pre> m = leafmap.Map(api_key=api_key, height=\"450px\") m <p>Use built-in basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, basemap=\"HERE_RASTER_TERRAIN_MAP\")\nm\n</pre> m = leafmap.Map(api_key=api_key, basemap=\"HERE_RASTER_TERRAIN_MAP\") m <p>Zoom to map to a bounding box [South, West, North, East].</p> In\u00a0[\u00a0]: Copied! <pre>m.zoom_to_bounds((-9.0882278, -55.3228175, 168.2249543, 72.2460938))  #\n</pre> m.zoom_to_bounds((-9.0882278, -55.3228175, 168.2249543, 72.2460938))  # In\u00a0[\u00a0]: Copied! <pre>m.add_basemap(basemap=\"Esri.WorldTopoMap\")\n</pre> m.add_basemap(basemap=\"Esri.WorldTopoMap\") <p>Add a custom XYZ tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, layers_control=True)\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map(api_key=api_key, layers_control=True) m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m <p>Add a GeoJSON from an HTTP URL to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2, layers_control=True)\n\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\")\n\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2, layers_control=True)  in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\")  m <p>Add a local GeoJSON file to the map.</p> In\u00a0[\u00a0]: Copied! <pre>import json\n\nm = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)\nwith open(\"../data/countries.geojson\") as fh:\n    geo = json.load(fh)\nm.add_geojson(geo, layer_name=\"Countries\")\nm\n</pre> import json  m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2) with open(\"../data/countries.geojson\") as fh:     geo = json.load(fh) m.add_geojson(geo, layer_name=\"Countries\") m <p>Customize style for the GeoJSON layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\nstyle = {\n    \"fillColor\": \"rgba(0, 0, 255, 0.2)\",\n    \"strokeColor\": \"blue\",\n}\n\nhover_style = {\"fillColor\": \"rgba(0, 0, 255, 0.7)\"}\n\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"  style = {     \"fillColor\": \"rgba(0, 0, 255, 0.2)\",     \"strokeColor\": \"blue\", }  hover_style = {\"fillColor\": \"rgba(0, 0, 255, 0.7)\"}  m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m In\u00a0[\u00a0]: Copied! <pre>in_shp = \"../data/countries.shp\"\nin_geojson = \"../data/us_states.json\"\nin_kml = \"../data/us_states.kml\"\n</pre> in_shp = \"../data/countries.shp\" in_geojson = \"../data/us_states.json\" in_kml = \"../data/us_states.kml\" <p>Add a shapefile to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)\nm.add_shp(in_shp, layer_name=\"Shapefile\")\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2) m.add_shp(in_shp, layer_name=\"Shapefile\") m <p>Add a KML file to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[40.273502, -86.126976], zoom=4)\nm.add_kml(in_kml, layer_name=\"KML\")\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[40.273502, -86.126976], zoom=4) m.add_kml(in_kml, layer_name=\"KML\") m <p>The add_vector function supports any vector data format supported by GeoPandas.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_vector(url, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_vector(url, layer_name=\"Countries\") m <p>Customize the style of point layers.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)\n\nurl = \"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson\"\npoint_style = {\n    \"strokeColor\": \"white\",\n    \"lineWidth\": 1,\n    \"fillColor\": \"red\",\n    \"fillOpacity\": 0.7,\n    \"radius\": 5,\n}\nm.add_geojson(url, layer_name=\"Countries\", point_style=point_style, default_popup=True)\nm\n</pre> m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=2)  url = \"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_month.geojson\" point_style = {     \"strokeColor\": \"white\",     \"lineWidth\": 1,     \"fillColor\": \"red\",     \"fillOpacity\": 0.7,     \"radius\": 5, } m.add_geojson(url, layer_name=\"Countries\", point_style=point_style, default_popup=True) m In\u00a0[\u00a0]: Copied! <pre>import geopandas\nimport json\nimport os\n\ncountries = geopandas.read_file(geopandas.datasets.get_path(\"naturalearth_cities\"))\npoint_style = {\n    \"strokeColor\": \"white\",\n    \"lineWidth\": 1,\n    \"fillColor\": \"blue\",\n    \"fillOpacity\": 0.7,\n    \"radius\": 5,\n}\n\nm = leafmap.Map(api_key=api_key, center=[0, 0], zoom=3)\nm.add_gdf(countries, zoom_to_layer=False, point_style=point_style, default_popup=True)\nm\n</pre> import geopandas import json import os  countries = geopandas.read_file(geopandas.datasets.get_path(\"naturalearth_cities\")) point_style = {     \"strokeColor\": \"white\",     \"lineWidth\": 1,     \"fillColor\": \"blue\",     \"fillOpacity\": 0.7,     \"radius\": 5, }  m = leafmap.Map(api_key=api_key, center=[0, 0], zoom=3) m.add_gdf(countries, zoom_to_layer=False, point_style=point_style, default_popup=True) m"},{"location":"notebooks/16_heremap/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before you run the below cells make sure you have:</p> <ul> <li><p>A HERE developer account, free and available under HERE Developer Portal</p> </li> <li><p>An API key from the HERE Developer Portal</p> </li> <li><p>Export API key into environment variable <code>HEREMAPS_API_KEY</code></p> <pre>export HEREMAPS_API_KEY=YOUR-ACTUAL-API-KEY\n</pre> </li> </ul>"},{"location":"notebooks/16_heremap/#here-default-basemap","title":"HERE default basemap\u00b6","text":""},{"location":"notebooks/16_heremap/#basemaps","title":"Basemaps\u00b6","text":""},{"location":"notebooks/16_heremap/#zoom-to-bounds","title":"zoom to bounds\u00b6","text":""},{"location":"notebooks/16_heremap/#add-vector-data","title":"Add vector data\u00b6","text":"<p>How to add GeoJSON to the map</p>"},{"location":"notebooks/16_heremap/#point-style-for-geojson","title":"Point style for GeoJSON\u00b6","text":""},{"location":"notebooks/17_vector_tile_layer/","title":"17 vector tile layer","text":"<p>Adding a vector tile layer to the map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook example requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=(52.204793, 360.121558), zoom=9)\n</pre> m = leafmap.Map(center=(52.204793, 360.121558), zoom=9) <p>The URL to the vector tile.</p> In\u00a0[4]: Copied! <pre>url = \"https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=gCZXZglvRQa6sB2z7JzL1w\"\n</pre> url = \"https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=gCZXZglvRQa6sB2z7JzL1w\" <p>Attribution of the vector tile.</p> In\u00a0[5]: Copied! <pre>attribution = \"Nextzen\"\n</pre> attribution = \"Nextzen\" <p>One can customize the vector tile layer style if needed. More info can be found at https://ipyleaflet.readthedocs.io/en/latest/layers/vector_tile.html</p> <p>Conditional styling (example here) currently works only with folium. Use:</p> <pre>import leafmap.foliumap as leafmap\n</pre> In\u00a0[6]: Copied! <pre>water_style = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#06cccc\",\n    color=\"#06cccc\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\nwaterway_style = dict(\n    weight=1, fillColor=\"#2375e0\", color=\"#2375e0\", fillOpacity=0.2, opacity=0.4\n)\n\nadmin_style = dict(\n    weight=1, fillColor=\"pink\", color=\"pink\", fillOpacity=0.2, opacity=0.4\n)\n\nlandcover_style = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#53e033\",\n    color=\"#53e033\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\nlanduse_style = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#e5b404\",\n    color=\"#e5b404\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\npark_style = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#84ea5b\",\n    color=\"#84ea5b\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\nboundary_style = dict(\n    weight=1, fillColor=\"#c545d3\", color=\"#c545d3\", fillOpacity=0.2, opacity=0.4\n)\n\n\naeroway = dict(\n    weight=1, fillColor=\"#51aeb5\", color=\"#51aeb5\", fillOpacity=0.2, opacity=0.4\n)\n\nroad = dict(\n    weight=1, fillColor=\"#f2b648\", color=\"#f2b648\", fillOpacity=0.2, opacity=0.4\n)\n\ntransit = dict(\n    weight=0.5, fillColor=\"#f2b648\", color=\"#f2b648\", fillOpacity=0.2, opacity=0.4\n)\n\nbuildings = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#2b2b2b\",\n    color=\"#2b2b2b\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\nwater_name = dict(\n    weight=1, fillColor=\"#022c5b\", color=\"#022c5b\", fillOpacity=0.2, opacity=0.4\n)\n\ntransportation_name = dict(\n    weight=1, fillColor=\"#bc6b38\", color=\"#bc6b38\", fillOpacity=0.2, opacity=0.4\n)\n\nplace = dict(\n    weight=1, fillColor=\"#f20e93\", color=\"#f20e93\", fillOpacity=0.2, opacity=0.4\n)\n\nhousenumber = dict(\n    weight=1, fillColor=\"#ef4c8b\", color=\"#ef4c8b\", fillOpacity=0.2, opacity=0.4\n)\n\npoi = dict(weight=1, fillColor=\"#3bb50a\", color=\"#3bb50a\", fillOpacity=0.2, opacity=0.4)\n\nearth = dict(\n    fill=\"true\",\n    weight=1,\n    fillColor=\"#c0c0c0\",\n    color=\"#c0c0c0\",\n    fillOpacity=0.2,\n    opacity=0.4,\n)\n\nvector_tile_layer_styles = dict(\n    water=water_style,\n    waterway=waterway_style,\n    admin=admin_style,\n    andcover=landcover_style,\n    landuse=landuse_style,\n    park=park_style,\n    boundaries=boundary_style,\n    aeroway=aeroway,\n    roads=road,\n    transit=transit,\n    buildings=buildings,\n    water_name=water_name,\n    transportation_name=transportation_name,\n    places=place,\n    housenumber=housenumber,\n    pois=poi,\n    earth=earth,\n)\n</pre> water_style = dict(     fill=\"true\",     weight=1,     fillColor=\"#06cccc\",     color=\"#06cccc\",     fillOpacity=0.2,     opacity=0.4, )  waterway_style = dict(     weight=1, fillColor=\"#2375e0\", color=\"#2375e0\", fillOpacity=0.2, opacity=0.4 )  admin_style = dict(     weight=1, fillColor=\"pink\", color=\"pink\", fillOpacity=0.2, opacity=0.4 )  landcover_style = dict(     fill=\"true\",     weight=1,     fillColor=\"#53e033\",     color=\"#53e033\",     fillOpacity=0.2,     opacity=0.4, )  landuse_style = dict(     fill=\"true\",     weight=1,     fillColor=\"#e5b404\",     color=\"#e5b404\",     fillOpacity=0.2,     opacity=0.4, )  park_style = dict(     fill=\"true\",     weight=1,     fillColor=\"#84ea5b\",     color=\"#84ea5b\",     fillOpacity=0.2,     opacity=0.4, )  boundary_style = dict(     weight=1, fillColor=\"#c545d3\", color=\"#c545d3\", fillOpacity=0.2, opacity=0.4 )   aeroway = dict(     weight=1, fillColor=\"#51aeb5\", color=\"#51aeb5\", fillOpacity=0.2, opacity=0.4 )  road = dict(     weight=1, fillColor=\"#f2b648\", color=\"#f2b648\", fillOpacity=0.2, opacity=0.4 )  transit = dict(     weight=0.5, fillColor=\"#f2b648\", color=\"#f2b648\", fillOpacity=0.2, opacity=0.4 )  buildings = dict(     fill=\"true\",     weight=1,     fillColor=\"#2b2b2b\",     color=\"#2b2b2b\",     fillOpacity=0.2,     opacity=0.4, )  water_name = dict(     weight=1, fillColor=\"#022c5b\", color=\"#022c5b\", fillOpacity=0.2, opacity=0.4 )  transportation_name = dict(     weight=1, fillColor=\"#bc6b38\", color=\"#bc6b38\", fillOpacity=0.2, opacity=0.4 )  place = dict(     weight=1, fillColor=\"#f20e93\", color=\"#f20e93\", fillOpacity=0.2, opacity=0.4 )  housenumber = dict(     weight=1, fillColor=\"#ef4c8b\", color=\"#ef4c8b\", fillOpacity=0.2, opacity=0.4 )  poi = dict(weight=1, fillColor=\"#3bb50a\", color=\"#3bb50a\", fillOpacity=0.2, opacity=0.4)  earth = dict(     fill=\"true\",     weight=1,     fillColor=\"#c0c0c0\",     color=\"#c0c0c0\",     fillOpacity=0.2,     opacity=0.4, )  vector_tile_layer_styles = dict(     water=water_style,     waterway=waterway_style,     admin=admin_style,     andcover=landcover_style,     landuse=landuse_style,     park=park_style,     boundaries=boundary_style,     aeroway=aeroway,     roads=road,     transit=transit,     buildings=buildings,     water_name=water_name,     transportation_name=transportation_name,     places=place,     housenumber=housenumber,     pois=poi,     earth=earth, ) <p>Add the vector tile layer to the map.</p> In\u00a0[7]: Copied! <pre>m.add_vector_tile_layer(url, vector_tile_layer_styles, attribution=attribution)\nm\n</pre> m.add_vector_tile_layer(url, vector_tile_layer_styles, attribution=attribution) m"},{"location":"notebooks/18_point_layer/","title":"18 point layer","text":"<p>Adding a point layer with popup attributes to the map</p> <p>The notebook requires the ipyleaflet plotting backend. Folium is not supported. The point dataset can be any geopandas-supported file stored locally or online.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Use the toolbar GUI to open a point-type vector dataset.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Display a single popup attribute.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_point_layer(\"../data/us_cities.geojson\", popup=\"name\", layer_name=\"US Cities\")\nm\n</pre> m = leafmap.Map() m.add_point_layer(\"../data/us_cities.geojson\", popup=\"name\", layer_name=\"US Cities\") m <p>Display multiple popup attributes.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\"\nm.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\")\nm\n</pre> m = leafmap.Map() url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\" m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\") m <p></p>"},{"location":"notebooks/19_map_to_html/","title":"19 map to html","text":"<p>Saving maps as a html file</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"HYBRID\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"HYBRID\") m <pre>Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\n</pre> Out[3]: <p>Specify the output HTML file name to save the map as a web page.</p> In\u00a0[4]: Copied! <pre>m.to_html(\"mymap.html\")\n</pre> m.to_html(\"mymap.html\") <p>If the output HTML file name is not provided, the function will return a string containing contain the source code of the HTML file.</p> In\u00a0[5]: Copied! <pre>html = m.to_html()\n</pre> html = m.to_html() In\u00a0[6]: Copied! <pre># print(html)\n</pre> # print(html)"},{"location":"notebooks/20_planet_imagery/","title":"20 planet imagery","text":"<p>Adding Planet global monthly and quarterly mosaic</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>First, you need to sign up a Planet account and get an API key. See https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p> In\u00a0[3]: Copied! <pre># os.environ[\"PLANET_API_KEY\"] = \"12345\"\n</pre> # os.environ[\"PLANET_API_KEY\"] = \"12345\" <p>Determine the tile format based on the plotting backend being use. It can be either ipyleaflet or folium.</p> In\u00a0[4]: Copied! <pre>tile_format = \"ipyleaflet\"\n\nif os.environ.get(\"USE_MKDOCS\") is not None:\n    tile_format = \"folium\"\n</pre> tile_format = \"ipyleaflet\"  if os.environ.get(\"USE_MKDOCS\") is not None:     tile_format = \"folium\" <p>Generate Planet quarterly imagery URLs.</p> In\u00a0[5]: Copied! <pre># leafmap.planet_quarterly()\n</pre> # leafmap.planet_quarterly() <p>Generate Planet monthly imagery URLs.</p> In\u00a0[6]: Copied! <pre># leafmap.planet_monthly()\n</pre> # leafmap.planet_monthly() <p>Generates Planet bi-annual and monthly imagery URLs.</p> In\u00a0[7]: Copied! <pre># leafmap.planet_catalog()\n</pre> # leafmap.planet_catalog() <p>Generate Planet quarterly imagery TileLayer.</p> In\u00a0[8]: Copied! <pre>quarterly_tiles = leafmap.planet_quarterly_tiles(tile_format=tile_format)\n</pre> quarterly_tiles = leafmap.planet_quarterly_tiles(tile_format=tile_format) <p>Generate Planet monthly imagery TileLayer.</p> In\u00a0[9]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles(tile_format=tile_format)\n</pre> monthly_tiles = leafmap.planet_monthly_tiles(tile_format=tile_format) <p>Print out the quarterly tile URLs.</p> In\u00a0[10]: Copied! <pre>for tile in quarterly_tiles:\n    print(tile)\n</pre> for tile in quarterly_tiles:     print(tile) <pre>Planet_2016q1\nPlanet_2016q2\nPlanet_2016q3\nPlanet_2016q4\nPlanet_2017q1\nPlanet_2017q2\nPlanet_2017q3\nPlanet_2017q4\nPlanet_2018q1\nPlanet_2018q2\nPlanet_2018q3\nPlanet_2018q4\nPlanet_2019q1\nPlanet_2019q2\nPlanet_2019q3\nPlanet_2019q4\nPlanet_2020q1\nPlanet_2020q2\nPlanet_2020q3\nPlanet_2020q4\nPlanet_2021q1\nPlanet_2021q2\nPlanet_2021q3\nPlanet_2021q4\nPlanet_2022q1\nPlanet_2022q2\nPlanet_2022q3\nPlanet_2022q4\nPlanet_2023q1\nPlanet_2023q2\nPlanet_2023q3\nPlanet_2023q4\nPlanet_2024q1\n</pre> <p>Print out the monthly tile URLs.</p> In\u00a0[11]: Copied! <pre>for tile in monthly_tiles:\n    print(tile)\n</pre> for tile in monthly_tiles:     print(tile) <pre>Planet_2016_01\nPlanet_2016_02\nPlanet_2016_03\nPlanet_2016_04\nPlanet_2016_05\nPlanet_2016_06\nPlanet_2016_07\nPlanet_2016_08\nPlanet_2016_09\nPlanet_2016_10\nPlanet_2016_11\nPlanet_2016_12\nPlanet_2017_01\nPlanet_2017_02\nPlanet_2017_03\nPlanet_2017_04\nPlanet_2017_05\nPlanet_2017_06\nPlanet_2017_07\nPlanet_2017_08\nPlanet_2017_09\nPlanet_2017_10\nPlanet_2017_11\nPlanet_2017_12\nPlanet_2018_01\nPlanet_2018_02\nPlanet_2018_03\nPlanet_2018_04\nPlanet_2018_05\nPlanet_2018_06\nPlanet_2018_07\nPlanet_2018_08\nPlanet_2018_09\nPlanet_2018_10\nPlanet_2018_11\nPlanet_2018_12\nPlanet_2019_01\nPlanet_2019_02\nPlanet_2019_03\nPlanet_2019_04\nPlanet_2019_05\nPlanet_2019_06\nPlanet_2019_07\nPlanet_2019_08\nPlanet_2019_09\nPlanet_2019_10\nPlanet_2019_11\nPlanet_2019_12\nPlanet_2020_01\nPlanet_2020_02\nPlanet_2020_03\nPlanet_2020_04\nPlanet_2020_05\nPlanet_2020_06\nPlanet_2020_07\nPlanet_2020_08\nPlanet_2020_09\nPlanet_2020_10\nPlanet_2020_11\nPlanet_2020_12\nPlanet_2021_01\nPlanet_2021_02\nPlanet_2021_03\nPlanet_2021_04\nPlanet_2021_05\nPlanet_2021_06\nPlanet_2021_07\nPlanet_2021_08\nPlanet_2021_09\nPlanet_2021_10\nPlanet_2021_11\nPlanet_2021_12\nPlanet_2022_01\nPlanet_2022_02\nPlanet_2022_03\nPlanet_2022_04\nPlanet_2022_05\nPlanet_2022_06\nPlanet_2022_07\nPlanet_2022_08\nPlanet_2022_09\nPlanet_2022_10\nPlanet_2022_11\nPlanet_2022_12\nPlanet_2023_01\nPlanet_2023_02\nPlanet_2023_03\nPlanet_2023_04\nPlanet_2023_05\nPlanet_2023_06\nPlanet_2023_07\nPlanet_2023_08\nPlanet_2023_09\nPlanet_2023_10\nPlanet_2023_11\nPlanet_2023_12\nPlanet_2024_01\nPlanet_2024_02\nPlanet_2024_03\nPlanet_2024_04\nPlanet_2024_05\n</pre> <p>Add a Planet monthly mosaic by specifying year and month.</p> In\u00a0[12]: Copied! <pre>m = leafmap.Map()\nm.add_planet_by_month(year=2020, month=8)\nm\n</pre> m = leafmap.Map() m.add_planet_by_month(year=2020, month=8) m Out[12]: <p>Add a Planet quarterly mosaic by specifying year and quarter.</p> In\u00a0[13]: Copied! <pre>m = leafmap.Map()\nm.add_planet_by_quarter(year=2019, quarter=2)\nm\n</pre> m = leafmap.Map() m.add_planet_by_quarter(year=2019, quarter=2) m Out[13]:"},{"location":"notebooks/21_ts_inspector/","title":"21 ts inspector","text":"<p>Using timeseries inspector with a single click</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>import os\nfrom leafmap import leafmap\n</pre> import os from leafmap import leafmap In\u00a0[3]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>First, you need to sign up a Planet account and get an API key. See https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p> In\u00a0[4]: Copied! <pre># os.environ[\"PLANET_API_KEY\"] = \"12345\"\n</pre> # os.environ[\"PLANET_API_KEY\"] = \"12345\" <p>Create a list of Planet monthly mosaic tile layers.</p> In\u00a0[5]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles()\n</pre> monthly_tiles = leafmap.planet_monthly_tiles() <p>Use the timeseries inspector to visualize images side by side with a split-panel map.</p> In\u00a0[6]: Copied! <pre>leafmap.ts_inspector(monthly_tiles)\n</pre> leafmap.ts_inspector(monthly_tiles) <p>Create a list of Planet quarterly mosaic tile layers.</p> In\u00a0[7]: Copied! <pre>quarterly_tiles = leafmap.planet_quarterly_tiles()\n</pre> quarterly_tiles = leafmap.planet_quarterly_tiles() <p>Use the timeseries inspector to visualize images side by side with a split-panel map.</p> In\u00a0[8]: Copied! <pre>leafmap.ts_inspector(quarterly_tiles)\n</pre> leafmap.ts_inspector(quarterly_tiles) <p>Create a list of Planet quarterly and monthly mosaic tile layers.</p> In\u00a0[9]: Copied! <pre>tiles = leafmap.planet_tiles()\n</pre> tiles = leafmap.planet_tiles() <p>Use the timeseries inspector to visualize images side by side with a split-panel map.</p> In\u00a0[10]: Copied! <pre>leafmap.ts_inspector(tiles)\n</pre> leafmap.ts_inspector(tiles) <p>Use the toolbar GUI to activate the timeseries inspector.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p></p>"},{"location":"notebooks/22_time_slider/","title":"22 time slider","text":"<p>Using time slider for visualizing timeseries images</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>First, you need to sign up a Planet account and get an API key. See https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p> In\u00a0[3]: Copied! <pre># os.environ[\"PLANET_API_KEY\"] = \"12345\"\n</pre> # os.environ[\"PLANET_API_KEY\"] = \"12345\" <p></p> <p>Specify the map center and zoom level.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[38.2659, -103.2447], zoom=13)\nm\n</pre> m = leafmap.Map(center=[38.2659, -103.2447], zoom=13) m <p>Use the time slider to visualize Planet quarterly mosaic.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nlayers_dict = leafmap.planet_quarterly_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map() layers_dict = leafmap.planet_quarterly_tiles() m.add_time_slider(layers_dict, time_interval=1) m <p>Use the time slider to visualize basemaps.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.clear_layers()\nlayers_dict = leafmap.basemap_xyz_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map() m.clear_layers() layers_dict = leafmap.basemap_xyz_tiles() m.add_time_slider(layers_dict, time_interval=1) m <p>Use the time slider to visualize COG assets found within STAC items.</p> In\u00a0[7]: Copied! <pre>import ipyleaflet\nimport json\nimport requests\n\nstac_api = \"https://earth-search.aws.element84.com/v0\"\nsearch_endpoint = f\"{stac_api}/search\"\n\ncollection = \"sentinel-s2-l2a-cogs\"\npayload = {\n    \"bbox\": [\n        -102.83340454101562,\n        49.77860375256143,\n        -102.41043090820312,\n        50.05273014900257,\n    ],\n    \"datetime\": \"2021-07-01T00:00:00Z/2021-10-01T12:31:12Z\",\n    \"collections\": [collection],\n    \"limit\": 10,\n    \"query\": {\"eo:cloud_cover\": {\"gte\": 0, \"lte\": 10}},\n}\n\nheaders = {\"Content-Type\": \"application/json\"}\n\nresponse = requests.request(\n    \"POST\", search_endpoint, headers=headers, data=json.dumps(payload)\n)\n\nfeatures = response.json()[\"features\"]\nfeatures.sort(key=lambda x: x[\"properties\"][\"datetime\"], reverse=False)\n\nlayers_dict = {}\nfor feature in features:\n    feature_id = feature[\"id\"]\n    print(feature_id)\n\n    url = leafmap.stac_tile(\n        f\"{stac_api}/collections/{collection}/items/{feature_id}\", bands=[\"visual\"]\n    )\n    tile_layer = ipyleaflet.TileLayer(\n        url=url,\n        name=feature_id,\n    )\n    layers_dict[feature_id] = tile_layer\n\nm = leafmap.Map(center=[50.093079, -103.152825], zoom=11)\nm.add_time_slider(layers_dict, time_interval=2)\nm\n</pre> import ipyleaflet import json import requests  stac_api = \"https://earth-search.aws.element84.com/v0\" search_endpoint = f\"{stac_api}/search\"  collection = \"sentinel-s2-l2a-cogs\" payload = {     \"bbox\": [         -102.83340454101562,         49.77860375256143,         -102.41043090820312,         50.05273014900257,     ],     \"datetime\": \"2021-07-01T00:00:00Z/2021-10-01T12:31:12Z\",     \"collections\": [collection],     \"limit\": 10,     \"query\": {\"eo:cloud_cover\": {\"gte\": 0, \"lte\": 10}}, }  headers = {\"Content-Type\": \"application/json\"}  response = requests.request(     \"POST\", search_endpoint, headers=headers, data=json.dumps(payload) )  features = response.json()[\"features\"] features.sort(key=lambda x: x[\"properties\"][\"datetime\"], reverse=False)  layers_dict = {} for feature in features:     feature_id = feature[\"id\"]     print(feature_id)      url = leafmap.stac_tile(         f\"{stac_api}/collections/{collection}/items/{feature_id}\", bands=[\"visual\"]     )     tile_layer = ipyleaflet.TileLayer(         url=url,         name=feature_id,     )     layers_dict[feature_id] = tile_layer  m = leafmap.Map(center=[50.093079, -103.152825], zoom=11) m.add_time_slider(layers_dict, time_interval=2) m <pre>S2A_13UFR_20210710_0_L2A\n</pre> <pre>S2B_13UFR_20210715_0_L2A\n</pre> <pre>S2B_13UFR_20210718_0_L2A\n</pre> <pre>S2A_13UFR_20210723_0_L2A\n</pre> <pre>S2B_13UFR_20210725_0_L2A\n</pre> <pre>S2A_13UFR_20210730_0_L2A\n</pre> <pre>S2B_13UFR_20210814_0_L2A\n</pre> <pre>S2A_13UFR_20210908_0_L2A\n</pre> <pre>S2A_13UFR_20210918_0_L2A\n</pre> <pre>S2A_13UFR_20210928_0_L2A\n</pre>"},{"location":"notebooks/23_colormaps/","title":"23 colormaps","text":"<p>Creating colormaps with a single line of code</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>This notebook requires the ipyleaflet plotting backend. Folium is not supported.</p> In\u00a0[2]: Copied! <pre>from leafmap import leafmap\nimport leafmap.colormaps as cm\n</pre> from leafmap import leafmap import leafmap.colormaps as cm <p>Color palette for DEM data.</p> In\u00a0[3]: Copied! <pre>cm.palettes.dem\n</pre> cm.palettes.dem Out[3]: <pre>('006633', 'E5FFCC', '662A00', 'D8D8D8', 'F5F5F5')</pre> <p>Show the DEM palette.</p> In\u00a0[4]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.dem, axis_off=True)\n</pre> cm.plot_colormap(colors=cm.palettes.dem, axis_off=True) <p>Color palette for NDVI data.</p> In\u00a0[5]: Copied! <pre>cm.palettes.ndvi\n</pre> cm.palettes.ndvi Out[5]: <pre>('FFFFFF',\n 'CE7E45',\n 'DF923D',\n 'F1B555',\n 'FCD163',\n '99B718',\n '74A901',\n '66A000',\n '529400',\n '3E8601',\n '207401',\n '056201',\n '004C00',\n '023B01',\n '012E01',\n '011D01',\n '011301')</pre> <p>Show the NDVI palette.</p> In\u00a0[6]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.ndvi)\n</pre> cm.plot_colormap(colors=cm.palettes.ndvi) <p>Specify the number of classes for a palette.</p> In\u00a0[7]: Copied! <pre>cm.get_palette(\"terrain\", n_class=8)\n</pre> cm.get_palette(\"terrain\", n_class=8) Out[7]: <pre>['333399',\n '0393f9',\n '25d36d',\n 'b5f08a',\n 'dad085',\n '92735e',\n 'b7a39f',\n 'ffffff']</pre> <p>Show the terrain palette with 8 classes.</p> In\u00a0[8]: Copied! <pre>cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8))\n</pre> cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8)) <p>Create a palette with custom colors, label, and font size.</p> In\u00a0[9]: Copied! <pre>cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12)\n</pre> cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12) <p>Create a discrete color palette.</p> In\u00a0[10]: Copied! <pre>cm.plot_colormap(\n    colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12\n)\n</pre> cm.plot_colormap(     colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12 ) <p>Specify the width and height for the palette.</p> In\u00a0[11]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=1000, ) <p>Change the orentation of the colormap to be vertical.</p> In\u00a0[12]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=1000, ) <p>Add a horizontal colorbar to an interactive map.</p> In\u00a0[13]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=4000, ) m <p></p> <p>Add a vertical colorbar to an interactive map.</p> In\u00a0[14]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=4000, ) m <p>Show all available colormaps.</p> In\u00a0[15]: Copied! <pre>cm.plot_colormaps(width=12, height=0.4)\n</pre> cm.plot_colormaps(width=12, height=0.4)"},{"location":"notebooks/24_heatmap/","title":"24 heatmap","text":"<p>Creating heat maps from csv</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>Specify the file path to the CSV. It can either be a file locally or on the Internet.</p> In\u00a0[2]: Copied! <pre>filepath = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\n</pre> filepath = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" <p>Use the ipyleaflet plotting backend.</p> In\u00a0[3]: Copied! <pre>import leafmap.leafmap as leafmap\n</pre> import leafmap.leafmap as leafmap <p>Specify the <code>latitude</code>, <code>longitude</code>, and <code>value</code> columns to create the heat map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_heatmap(\n    filepath,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> m = leafmap.Map() m.add_heatmap(     filepath,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m <p>Use the folium plotting backend.</p> In\u00a0[5]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Specify the <code>latitude</code>, <code>longitude</code>, and <code>value</code> columns to create the heat map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_heatmap(\n    filepath,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> m = leafmap.Map() m.add_heatmap(     filepath,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m Out[6]:"},{"location":"notebooks/25_map_title/","title":"25 map title","text":"<p>Creating a population heat map with a colorbar and map title</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>The notebook requires the folium plotting backend. ipyleaflet is not supported.</p> In\u00a0[2]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Creates an interactive folium map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Specify the <code>latitude</code>, <code>longitude</code>, and <code>value</code> columns to create the heat map.</p> In\u00a0[4]: Copied! <pre>in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\n</pre> in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" <p>Specify the file path to the CSV. It can either be a file locally or on the Internet.</p> In\u00a0[5]: Copied! <pre>m.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) <p>Adds a colorbar to the map.</p> In\u00a0[6]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nvmin = 0\nvmax = 10000\n\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\n</pre> colors = [\"blue\", \"lime\", \"red\"] vmin = 0 vmax = 10000  m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) <p>Adds a title to the map.</p> In\u00a0[7]: Copied! <pre>m.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\")\n</pre> m.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\") In\u00a0[8]: Copied! <pre>m\n</pre> m Out[8]: <p>Save the map as an HTML.</p> In\u00a0[9]: Copied! <pre>m.to_html(\"heatmap.html\")\n</pre> m.to_html(\"heatmap.html\")"},{"location":"notebooks/26_kepler_gl/","title":"26 kepler gl","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap.kepler as leafmap\n</pre> import leafmap.kepler as leafmap <p>Create an interactive map. You can specify various parameters to initialize the map, such as <code>center</code>, <code>zoom</code>, <code>height</code>, and <code>widescreen</code>.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=2, height=600, widescreen=False)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=2, height=600, widescreen=False) m <p>Save the map to an interactive html. To hide the side panel and disable map customization. Set <code>read_only=False</code></p> In\u00a0[4]: Copied! <pre>m.to_html(outfile=\"../html/kepler.html\", read_only=False)\n</pre> m.to_html(outfile=\"../html/kepler.html\", read_only=False) <p>Display the interactive map in a notebook cell.</p> In\u00a0[5]: Copied! <pre># m.static_map(width=950, height=600, read_only=True)\n</pre> # m.static_map(width=950, height=600, read_only=True) <p>Add a CSV to the map. If you have a map config file, you can directly apply config to the map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[37.7621, -122.4143], zoom=12)\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_data.csv\"\nconfig = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_config.json\"\nm.add_csv(in_csv, layer_name=\"hex_data\", config=config)\nm\n</pre> m = leafmap.Map(center=[37.7621, -122.4143], zoom=12) in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_data.csv\" config = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_config.json\" m.add_csv(in_csv, layer_name=\"hex_data\", config=config) m <p>Save the map configuration as a JSON file.</p> In\u00a0[7]: Copied! <pre>m.save_config(\"cache/config.json\")\n</pre> m.save_config(\"cache/config.json\") <p>Save the map to an interactive html.</p> In\u00a0[8]: Copied! <pre>m.to_html(outfile=\"../html/kepler_hex.html\")\n</pre> m.to_html(outfile=\"../html/kepler_hex.html\") <p>Add a GeoJSON to the map.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1)\nlines = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(lines, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1) lines = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(lines, layer_name=\"Cable lines\") m In\u00a0[10]: Copied! <pre>m.to_html(\"../html/kepler_lines.html\")\n</pre> m.to_html(\"../html/kepler_lines.html\") <p>Add a GeoJSON with US state boundaries to the map.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map(center=[50, -110], zoom=2)\npolygons = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\"\nm.add_geojson(polygons, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[50, -110], zoom=2) polygons = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\" m.add_geojson(polygons, layer_name=\"Countries\") m In\u00a0[12]: Copied! <pre>m.to_html(\"../html/kepler_states.html\")\n</pre> m.to_html(\"../html/kepler_states.html\") <p>Add a shapefile to the map.</p> In\u00a0[13]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, \"Countries\")\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, \"Countries\") m In\u00a0[14]: Copied! <pre>m.to_html(\"../html/kepler_countries.html\")\n</pre> m.to_html(\"../html/kepler_countries.html\") <p>Add a GeoPandas GeoDataFrame to the map.</p> In\u00a0[15]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[16]: Copied! <pre>gdf = gpd.read_file(\n    \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.geojson\"\n)\n</pre> gdf = gpd.read_file(     \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.geojson\" ) In\u00a0[17]: Copied! <pre>gdf\n</pre> gdf Out[17]: name sov_a3 latitude longitude pop_max geometry 0 Bombo UGA 0.58330 32.53330 75000 POINT (32.53330 0.58330) 1 Fort Portal UGA 0.67100 30.27500 42670 POINT (30.27500 0.67100) 2 Potenza ITA 40.64200 15.79900 69060 POINT (15.79900 40.64200) 3 Campobasso ITA 41.56300 14.65600 50762 POINT (14.65600 41.56300) 4 Aosta ITA 45.73700 7.31500 34062 POINT (7.31500 45.73700) ... ... ... ... ... ... ... 1244 Rio de Janeiro BRA -22.92502 -43.22502 11748000 POINT (-43.22502 -22.92502) 1245 Sao Paulo BRA -23.55868 -46.62502 18845000 POINT (-46.62502 -23.55868) 1246 Sydney AUS -33.92001 151.18518 4630000 POINT (151.18518 -33.92001) 1247 Singapore SGP 1.29303 103.85582 5183700 POINT (103.85582 1.29303) 1248 Hong Kong CHN 22.30498 114.18501 7206000 POINT (114.18501 22.30498) <p>1249 rows \u00d7 6 columns</p> In\u00a0[18]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1)\nm.add_gdf(gdf, \"World cities\")\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1) m.add_gdf(gdf, \"World cities\") m In\u00a0[19]: Copied! <pre>m.to_html(\"../html/kepler_cities.html\")\n</pre> m.to_html(\"../html/kepler_cities.html\")"},{"location":"notebooks/27_basemap_gallery/","title":"27 basemap gallery","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap.leafmap as leafmap\n</pre> import leafmap.leafmap as leafmap <p>Select 100 basemaps</p> In\u00a0[3]: Copied! <pre>layers = list(leafmap.basemaps.keys())[17:117]\n# layers\n</pre> layers = list(leafmap.basemaps.keys())[17:117] # layers <p>Print out the labels</p> In\u00a0[4]: Copied! <pre>print(layers[:10])\n</pre> print(layers[:10]) <pre>['USGS NAIP Imagery NDVI', 'USGS Hydrography', 'USGS 3DEP Elevation', 'ESA Worldcover 2020', 'ESA Worldcover 2020 S2 FCC', 'ESA Worldcover 2020 S2 TCC', 'ESA Worldcover 2021', 'ESA Worldcover 2021 S2 FCC', 'ESA Worldcover 2021 S2 TCC', 'BaseMapDE.Color']\n</pre> <p>Create linked maps of 100 basemaps</p> In\u00a0[5]: Copied! <pre>leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers)\n</pre> leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers)"},{"location":"notebooks/28_publish_map/","title":"28 publish map","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap <p>To follow this tutorial, you will need to sign up for an account with https://datapane.com, then install and authenticate the <code>datapane</code> Python package. More information can be found here.</p> <ul> <li><code>pip install datapane</code></li> <li><code>datapane login</code></li> <li><code>datapane ping</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Create an elevation map of North America.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"USGS 3DEP Elevation\")\ncolors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nvmin = 0\nvmax = 4000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"USGS 3DEP Elevation\") colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] vmin = 0 vmax = 4000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m <p>Publish the map to datapane.com</p> In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"Elevation Map of North America\")\n</pre> m.publish(name=\"Elevation Map of North America\") <p>Create a land use and land cover map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"NLCD 2016 CONUS Land Cover\")\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"NLCD 2016 CONUS Land Cover\") m.add_legend(builtin_legend=\"NLCD\") m <p>Publish the map to datapane.com.</p> In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"National Land Cover Database (NLCD) 2016\")\n</pre> m.publish(name=\"National Land Cover Database (NLCD) 2016\") <p>Create a world population heat map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m = leafmap.Map() in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) In\u00a0[\u00a0]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nvmin = 0\nvmax = 10000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm\n</pre> colors = [\"blue\", \"lime\", \"red\"] vmin = 0 vmax = 10000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m <p>Publish the map to datapane.com.</p> In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"World Population Heat Map\")\n</pre> m.publish(name=\"World Population Heat Map\")"},{"location":"notebooks/29_pydeck/","title":"29 pydeck","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap.deck as leafmap\n</pre> import leafmap.deck as leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=3)\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=3) m Out[3]: <p>Add basemap.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m Out[4]: <p>Add vector data to the map. It supports any GeoPandas supported format, such as GeoJSON, shapefile, KML.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nfilename = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\"\n)\nm.add_vector(filename, random_color_column=\"STATEFP\")\nm\n</pre> m = leafmap.Map() filename = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\" ) m.add_vector(filename, random_color_column=\"STATEFP\") m Out[5]: <p>Add a GeoPandas GeoDataFrame to the map.</p> In\u00a0[6]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[7]: Copied! <pre>url = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_counties.geojson\"\n)\ngdf = gpd.read_file(url)\n</pre> url = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_counties.geojson\" ) gdf = gpd.read_file(url) In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, random_color_column=\"STATEFP\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, random_color_column=\"STATEFP\") m Out[8]: <p>Create a 3D view of the map. Press Ctrl and hold down the left mouse button to rotate the 3D view.</p> In\u00a0[9]: Copied! <pre>initial_view_state = {\n    \"latitude\": 40,\n    \"longitude\": -100,\n    \"zoom\": 3,\n    \"pitch\": 45,\n    \"bearing\": 10,\n}\nm = leafmap.Map(initial_view_state=initial_view_state)\nfilename = (\n    \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\"\n)\nm.add_vector(\n    filename,\n    random_color_column=\"STATEFP\",\n    extruded=True,\n    get_elevation=\"ALAND\",\n    elevation_scale=0.000001,\n)\nm\n</pre> initial_view_state = {     \"latitude\": 40,     \"longitude\": -100,     \"zoom\": 3,     \"pitch\": 45,     \"bearing\": 10, } m = leafmap.Map(initial_view_state=initial_view_state) filename = (     \"https://github.com/giswqs/streamlit-geospatial/raw/master/data/us_states.geojson\" ) m.add_vector(     filename,     random_color_column=\"STATEFP\",     extruded=True,     get_elevation=\"ALAND\",     elevation_scale=0.000001, ) m Out[9]: <p></p> In\u00a0[10]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=3)\nDATA_URL = \"https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson\"\ngdf = gpd.read_file(DATA_URL)\n\nm.add_vector(\n    gdf,\n    layer_type=\"ColumnLayer\",\n    get_position=[\"LONGITUDE\", \"LATITUDE\"],\n    get_elevation=\"FUNDING_NUMERIC\",\n    get_fill_color=[256, 256, 0, 140],\n    elevation_scale=0.01,\n    radius=10000,\n    pickable=True,\n    auto_highlight=True,\n)\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=3) DATA_URL = \"https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson\" gdf = gpd.read_file(DATA_URL)  m.add_vector(     gdf,     layer_type=\"ColumnLayer\",     get_position=[\"LONGITUDE\", \"LATITUDE\"],     get_elevation=\"FUNDING_NUMERIC\",     get_fill_color=[256, 256, 0, 140],     elevation_scale=0.01,     radius=10000,     pickable=True,     auto_highlight=True, ) m Out[10]: In\u00a0[11]: Copied! <pre>import pydeck as pdk\n\nm = leafmap.Map(center=(40, -100), zoom=3)\n\nDATA_URL = \"https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson\"\ndf = gpd.read_file(DATA_URL)\n\ncolumn_layer = pdk.Layer(\n    \"ColumnLayer\",\n    data=df,\n    get_position=[\"LONGITUDE\", \"LATITUDE\"],\n    get_elevation=\"FUNDING_NUMERIC\",\n    get_fill_color=[256, 256, 0, 140],\n    elevation_scale=0.01,\n    radius=10000,\n    pickable=True,\n    auto_highlight=True,\n)\n\nm.add_layer(column_layer)\nm\n</pre> import pydeck as pdk  m = leafmap.Map(center=(40, -100), zoom=3)  DATA_URL = \"https://data.source.coop/cboettig/conservation-policy/Inflation_Reduction_Act_Projects.geojson\" df = gpd.read_file(DATA_URL)  column_layer = pdk.Layer(     \"ColumnLayer\",     data=df,     get_position=[\"LONGITUDE\", \"LATITUDE\"],     get_elevation=\"FUNDING_NUMERIC\",     get_fill_color=[256, 256, 0, 140],     elevation_scale=0.01,     radius=10000,     pickable=True,     auto_highlight=True, )  m.add_layer(column_layer) m Out[11]:"},{"location":"notebooks/30_census_data/","title":"30 census data","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Get the Census data WMS tiles as a dictionary. More info can be found at https://tigerweb.geo.census.gov/tigerwebmain/TIGERweb_wms.html</p> In\u00a0[3]: Copied! <pre>census_data_dict = leafmap.get_census_dict()\n</pre> census_data_dict = leafmap.get_census_dict() <p>Print out the list of US Census WMS.</p> In\u00a0[4]: Copied! <pre>for key in census_data_dict:\n    print(key)\n</pre> for key in census_data_dict:     print(key) <pre>Current\nACS 2021\nACS 2019\nACS 2018\nACS 2017\nACS 2016\nACS 2015\nACS 2014\nACS 2013\nACS 2012\nECON 2012\nCensus 2020\nCensus 2010\nPhysical Features\nDecennial Census 2020\nDecennial Census 2010\nDecennial Census 2000\nDecennial Physical Features\n</pre> <p>Get the list of layers for a WMS.</p> In\u00a0[5]: Copied! <pre>census_data_dict[\"Census 2020\"][\"layers\"]\n</pre> census_data_dict[\"Census 2020\"][\"layers\"] Out[5]: <pre>['Alaska_Native_Regional_Corporations10465',\n 'Alaska_Native_Regional_Corporations_Labels60868',\n 'Alaska_Native_Village_Statistical_Areas34178',\n 'Alaska_Native_Village_Statistical_Areas_Labels14319',\n 'American_Indian_Joint-Use_Areas11842',\n 'American_Indian_Joint-Use_Areas_Labels32943',\n 'Census_Block_Groups59805',\n 'Census_Block_Groups_Labels32376',\n 'Census_Blocks1978',\n 'Census_Blocks_Labels63431',\n 'Census_Designated_Places65166',\n 'Census_Designated_Places_Labels61459',\n 'Census_Divisions8578',\n 'Census_Divisions_Labels29679',\n 'Census_Regions16659',\n 'Census_Regions_Labels31526',\n 'Census_Tracts7651',\n 'Census_Tracts_Labels33558',\n 'Combined_New_England_City_and_Town_Areas35117',\n 'Combined_New_England_City_and_Town_Areas_Labels20328',\n 'Combined_Statistical_Areas61231',\n 'Combined_Statistical_Areas_Labels52090',\n 'Consolidated_Cities65047',\n 'Consolidated_Cities_Labels30018',\n 'Counties',\n 'Counties_Labels19364',\n 'County_Subdivisions63689',\n 'County_Subdivisions_Labels25452',\n 'Elementary_School_Districts36200',\n 'Elementary_School_Districts_Labels21637',\n 'Estates',\n 'Estates_Labels15809',\n 'Federal_American_Indian_Reservations63680',\n 'Federal_American_Indian_Reservations_Labels65437',\n 'Hawaiian_Home_Lands45702',\n 'Hawaiian_Home_Lands_Labels15115',\n 'Incorporated_Places1469',\n 'Incorporated_Places_Labels58904',\n 'Metropolitan_Divisions40847',\n 'Metropolitan_Divisions_Labels25946',\n 'Metropolitan_New_England_City_and_Town_Areas62616',\n 'Metropolitan_New_England_City_and_Town_Areas_Labels59733',\n 'Metropolitan_Statistical_Areas62762',\n 'Metropolitan_Statistical_Areas_Labels6295',\n 'Micropolitan_New_England_City_and_Town_Areas31587',\n 'Micropolitan_New_England_City_and_Town_Areas_Labels33942',\n 'Micropolitan_Statistical_Areas31521',\n 'Micropolitan_Statistical_Areas_Labels772',\n 'New_England_City_and_Town_Area_Divisions60153',\n 'New_England_City_and_Town_Area__Divisions_Labels46148',\n 'Off-Reservation_Trust_Lands54343',\n 'Off-Reservation_Trust_Lands_Labels18066',\n 'Oklahoma_Tribal_Statistical_Areas50120',\n 'Oklahoma_Tribal_Statistical_Areas_Labels48357',\n 'Secondary_School_Districts43718',\n 'Secondary_School_Districts_Labels36427',\n 'State_American_Indian_Reservations3874',\n 'State_American_Indian_Reservations_Labels35471',\n 'State_Designated_Tribal_Statistical_Areas1347',\n 'State_Designated_Tribal_Statistical_Areas_Labels45558',\n 'States',\n 'States_Labels49388',\n 'Subbarrios',\n 'Subbarrios_Labels47498',\n 'Tribal_Block_Groups26640',\n 'Tribal_Block_Groups_Labels32973',\n 'Tribal_Census_Tracts2987',\n 'Tribal_Census_Tracts_Labels1374',\n 'Tribal_Designated_Statistical_Areas45836',\n 'Tribal_Designated_Statistical_Areas_Labels6465',\n 'Tribal_Subdivisions42483',\n 'Tribal_Subdivisions_Labels35078',\n 'Unified_School_Districts15496',\n 'Unified_School_Districts_Labels28837',\n 'Urban_Growth_Areas59666',\n 'Urban_Growth_Areas_Labels47199',\n 'Voting_Districts56637',\n 'Voting_Districts_Labels20888',\n 'Zip_Code_Tabulation_Areas4692',\n 'Zip_Code_Tabulation_Areas_Labels47657',\n '_018_State_Legislative_Districts_-_Lower20349',\n '_018_State_Legislative_Districts_-_Lower_Labels7384',\n '_018_State_Legislative_Districts_-_Upper25708',\n '_018_State_Legislative_Districts_-_Upper_Labels34849',\n '_16th_Congressional_Districts4189',\n '_16th_Congressional_Districts_Labels3128']</pre> <p>Create an interactive map and add Census data layer to it. You might need to zoom in to see the data layer</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_census_data(wms=\"Census 2020\", layer=\"States\")\nm.add_census_data(wms=\"Census 2020\", layer=\"States_Labels49388\")\nm\n</pre> m = leafmap.Map() m.add_census_data(wms=\"Census 2020\", layer=\"States\") m.add_census_data(wms=\"Census 2020\", layer=\"States_Labels49388\") m Out[6]: <p>Alternatively, you can use the toolbar to load Census data interactively without coding.</p> <p></p>"},{"location":"notebooks/31_search_basemaps/","title":"31 search basemaps","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Search xyz tiles from xyzservices.</p> In\u00a0[3]: Copied! <pre>leafmap.search_xyz_services(keyword=\"esri\")\n</pre> leafmap.search_xyz_services(keyword=\"esri\") Out[3]: <pre>['xyz.Esri.WorldStreetMap',\n 'xyz.Esri.DeLorme',\n 'xyz.Esri.WorldTopoMap',\n 'xyz.Esri.WorldImagery',\n 'xyz.Esri.WorldTerrain',\n 'xyz.Esri.WorldShadedRelief',\n 'xyz.Esri.WorldPhysical',\n 'xyz.Esri.OceanBasemap',\n 'xyz.Esri.NatGeoWorldMap',\n 'xyz.Esri.WorldGrayCanvas',\n 'xyz.Esri.ArcticImagery',\n 'xyz.Esri.ArcticOceanBase',\n 'xyz.Esri.ArcticOceanReference',\n 'xyz.Esri.AntarcticImagery',\n 'xyz.Esri.AntarcticBasemap']</pre> <p>Add an xyz tile to the map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_xyz_service(\"xyz.Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_xyz_service(\"xyz.Esri.NatGeoWorldMap\") m Out[4]: <p>Search xyz tiles from Quick Map Services.</p> In\u00a0[5]: Copied! <pre>leafmap.search_qms(keyword=\"google\")\n</pre> leafmap.search_qms(keyword=\"google\") Out[5]: <pre>['qms.basemap.at',\n 'qms.basemap.at Orthofoto',\n 'qms.EOX::Maps - Sentinel-2 cloudless',\n 'qms.Geoland Basemap',\n 'qms.Geoland Basemap Gel\u00e4nde',\n 'qms.Geoland Basemap Grau',\n 'qms.Geoland Basemap High DPI',\n 'qms.Geoland Basemap Oberfl\u00e4che',\n 'qms.Geoland Basemap Orthofoto',\n 'qms.Geoland Basemap Overlay']</pre> <p>Add xyz tile to the map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_xyz_service(\"qms.Google Satellite Hybrid\")\nm\n</pre> m = leafmap.Map() m.add_xyz_service(\"qms.Google Satellite Hybrid\") m Out[6]: <p>Search basemaps interactively without coding.</p> <p></p>"},{"location":"notebooks/32_local_tile/","title":"32 local tile","text":"<p>Using local raster datasets or remote Cloud Optimized GeoTIFFs (COG) with leafmap</p> <p>Uncomment the following line to install leafmap and localtileserver if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install localtileserver\n</pre> # !pip install localtileserver In\u00a0[3]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Specify input raster datasets</p> In\u00a0[4]: Copied! <pre>dem = \"dem.tif\"\nlandsat = \"landsat.tif\"\n</pre> dem = \"dem.tif\" landsat = \"landsat.tif\" <p>Download samples raster datasets.</p> In\u00a0[5]: Copied! <pre>dem_url = (\n    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n)\nleafmap.download_file(dem_url, dem, unzip=False)\n</pre> dem_url = (     \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" ) leafmap.download_file(dem_url, dem, unzip=False) <pre>dem.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[5]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif'</pre> In\u00a0[6]: Copied! <pre>landsat_url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cog.tif\"\nleafmap.download_file(landsat_url, landsat, unzip=False)\n</pre> landsat_url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cog.tif\" leafmap.download_file(landsat_url, landsat, unzip=False) <pre>landsat.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[6]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif'</pre> <p>Create an interactive map.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add local raster datasets to the map. The available palettes can be found at https://jiffyclub.github.io/palettable/</p> In\u00a0[8]: Copied! <pre>m.add_raster(landsat, indexes=[4, 3, 2], layer_name=\"Landsat\")\n</pre> m.add_raster(landsat, indexes=[4, 3, 2], layer_name=\"Landsat\") In\u00a0[9]: Copied! <pre>m.add_raster(dem, colormap=\"viridis\", layer_name=\"DEM\")\n</pre> m.add_raster(dem, colormap=\"viridis\", layer_name=\"DEM\") In\u00a0[10]: Copied! <pre>m\n</pre> m Out[10]: <p>Add a remote Cloud Optimized GeoTIFF(COG) to the map.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() In\u00a0[12]: Copied! <pre>url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n</pre> url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" In\u00a0[13]: Copied! <pre>m.add_cog_layer(url, name=\"Maxar\")\n</pre> m.add_cog_layer(url, name=\"Maxar\") In\u00a0[14]: Copied! <pre>m\n</pre> m Out[14]: <p></p>"},{"location":"notebooks/33_image_overlay/","title":"33 image overlay","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import os\nfrom leafmap import leafmap\n</pre> import os from leafmap import leafmap <p>Using local files</p> <p>Download the sample png from https://i.imgur.com/06Q1fSz.png to your <code>Downloads</code> folder.</p> In\u00a0[3]: Copied! <pre>filepath = \"weather.png\"\nurl = \"https://open.gishub.org/data/images/weather.png\"\nif not os.path.exists(filepath):\n    leafmap.download_file(url, filepath)\n</pre> filepath = \"weather.png\" url = \"https://open.gishub.org/data/images/weather.png\" if not os.path.exists(filepath):     leafmap.download_file(url, filepath) <pre>Downloading...\nFrom: https://open.gishub.org/data/images/weather.png\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/weather.png\n</pre> <pre>\r  0%|          | 0.00/489k [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 489k/489k [00:00&lt;00:00, 26.0MB/s]</pre> <pre>\n</pre> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=(25, -115), zoom=4)\n\nimage = leafmap.ImageOverlay(url=filepath, bounds=((13, -130), (32, -100)))\n\nm.add_layer(image)\nm\n</pre> m = leafmap.Map(center=(25, -115), zoom=4)  image = leafmap.ImageOverlay(url=filepath, bounds=((13, -130), (32, -100)))  m.add_layer(image) m <p>Using remote files</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=(25, -115), zoom=4)\n\nimage = leafmap.ImageOverlay(url=url, bounds=((13, -130), (32, -100)))\n\nm.add_layer(image)\nm\n</pre> m = leafmap.Map(center=(25, -115), zoom=4)  image = leafmap.ImageOverlay(url=url, bounds=((13, -130), (32, -100)))  m.add_layer(image) m <p>Update image url</p> In\u00a0[6]: Copied! <pre># image.url = \"https://i.imgur.com/J9qCf4E.png\"\n</pre> # image.url = \"https://i.imgur.com/J9qCf4E.png\""},{"location":"notebooks/34_add_points_from_xy/","title":"34 add points from xy","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\nimport pandas as pd\n</pre> import leafmap import pandas as pd In\u00a0[3]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>Using a CSV file containing xy coordinates</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\ndata = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\nm.add_points_from_xy(data, x=\"longitude\", y=\"latitude\")\nm\n</pre> m = leafmap.Map() data = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" m.add_points_from_xy(data, x=\"longitude\", y=\"latitude\") m Out[4]: <p>Using a Pandas DataFrame containing xy coordinates.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\ndata = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\ndf = pd.read_csv(data)\nm.add_points_from_xy(df, x=\"longitude\", y=\"latitude\")\nm\n</pre> m = leafmap.Map() data = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" df = pd.read_csv(data) m.add_points_from_xy(df, x=\"longitude\", y=\"latitude\") m Out[5]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/35_circle_markers/","title":"35 circle markers","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>For a list of options for circle markers, see https://ipyleaflet.readthedocs.io/en/latest/api_reference/circle_marker.html</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\ndata = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\nm.add_circle_markers_from_xy(\n    data, x=\"longitude\", y=\"latitude\", radius=10, color=\"blue\", fill_color=\"black\"\n)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) data = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" m.add_circle_markers_from_xy(     data, x=\"longitude\", y=\"latitude\", radius=10, color=\"blue\", fill_color=\"black\" ) m Out[3]:"},{"location":"notebooks/36_add_labels/","title":"36 add labels","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Update the package if needed.</p> In\u00a0[3]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>data = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\"\n</pre> data = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\" In\u00a0[5]: Copied! <pre>Map = leafmap.Map(center=[40, -100], zoom=4, add_google_map=False, layers_control=True)\n</pre> Map = leafmap.Map(center=[40, -100], zoom=4, add_google_map=False, layers_control=True) <p>Labeling data.</p> In\u00a0[6]: Copied! <pre>Map.add_labels(\n    data,\n    \"id\",\n    font_size=\"12pt\",\n    font_color=\"blue\",\n    font_family=\"arial\",\n    font_weight=\"bold\",\n)\nMap\n</pre> Map.add_labels(     data,     \"id\",     font_size=\"12pt\",     font_color=\"blue\",     font_family=\"arial\",     font_weight=\"bold\", ) Map Out[6]: <p>Remove labels</p> In\u00a0[7]: Copied! <pre>Map.remove_labels()\n</pre> Map.remove_labels() <pre>The folium plotting backend does not support removing labels.\n</pre> <p></p>"},{"location":"notebooks/37_planetary_computer/","title":"37 planetary computer","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add a STAC item via an HTTP URL</p> In\u00a0[3]: Copied! <pre>url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n</pre> url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" In\u00a0[4]: Copied! <pre>leafmap.stac_assets(url)\n</pre> leafmap.stac_assets(url) Out[4]: <pre>['pan', 'B1', 'B2', 'B3', 'B4']</pre> In\u00a0[5]: Copied! <pre>leafmap.stac_bounds(url)\n</pre> leafmap.stac_bounds(url) Out[5]: <pre>[-111.6453245, 60.59892389999882, -110.1583693, 61.30928879999903]</pre> In\u00a0[6]: Copied! <pre>leafmap.stac_center(url)\n</pre> leafmap.stac_center(url) Out[6]: <pre>(-110.90184690000001, 60.95410634999892)</pre> In\u00a0[7]: Copied! <pre># leafmap.stac_info(url)\n</pre> # leafmap.stac_info(url) In\u00a0[8]: Copied! <pre># leafmap.stac_stats(url)\n</pre> # leafmap.stac_stats(url) In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"])\nm\n</pre> m = leafmap.Map() m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"]) m Out[9]: <p>Add a Microsoft Planetry Computer STAC item. The titiler endpoint can set in one of the ways below:</p> <pre><code>os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\"\ntitiler_endpoint=\"pc\"\ntitiler_endpoint=\"planetary-computer\"\n</code></pre> In\u00a0[10]: Copied! <pre># import os\n# os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\"\n</pre> # import os # os.environ[\"TITILER_ENDPOINT\"] = \"planetary-computer\" In\u00a0[11]: Copied! <pre>collection = \"landsat-8-c2-l2\"\n</pre> collection = \"landsat-8-c2-l2\" In\u00a0[12]: Copied! <pre>item = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> item = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[13]: Copied! <pre>leafmap.stac_assets(collection=collection, item=item, titiler_endpoint=\"pc\")\n</pre> leafmap.stac_assets(collection=collection, item=item, titiler_endpoint=\"pc\") Out[13]: <pre>['SR_B1',\n 'SR_B2',\n 'SR_B3',\n 'SR_B4',\n 'SR_B5',\n 'SR_B6',\n 'SR_B7',\n 'ST_QA',\n 'ST_B10',\n 'ST_DRAD',\n 'ST_EMIS',\n 'ST_EMSD',\n 'ST_TRAD',\n 'ST_URAD',\n 'QA_PIXEL',\n 'ST_ATRAN',\n 'ST_CDIST',\n 'QA_RADSAT',\n 'SR_QA_AEROSOL']</pre> In\u00a0[14]: Copied! <pre>leafmap.stac_bounds(collection=collection, item=item)\n</pre> leafmap.stac_bounds(collection=collection, item=item) Out[14]: <pre>[-124.98085491310867,\n 46.35352512466258,\n -121.78788697796408,\n 48.51466487533742]</pre> In\u00a0[15]: Copied! <pre>leafmap.stac_info(collection=collection, item=item, assets=\"SR_B7\")\n</pre> leafmap.stac_info(collection=collection, item=item, assets=\"SR_B7\") Out[15]: <pre>{'SR_B7': {'bounds': [-124.9808633132731,\n   46.35352340750138,\n   -121.78787875260963,\n   48.52103509752985],\n  'minzoom': 7,\n  'maxzoom': 12,\n  'band_metadata': [['b1', {}]],\n  'band_descriptions': [['b1', '']],\n  'dtype': 'uint16',\n  'nodata_type': 'Nodata',\n  'colorinterp': ['gray'],\n  'width': 7861,\n  'height': 7971,\n  'count': 1,\n  'driver': 'GTiff',\n  'nodata_value': 0.0,\n  'overviews': [2, 4, 8, 16, 32, 64]}}</pre> In\u00a0[16]: Copied! <pre>leafmap.stac_stats(collection=collection, item=item, assets=\"SR_B7\")\n</pre> leafmap.stac_stats(collection=collection, item=item, assets=\"SR_B7\") Out[16]: <pre>{'SR_B7_b1': {'min': 6912.0,\n  'max': 32069.0,\n  'mean': 8275.555009181073,\n  'count': 673124.0,\n  'sum': 5570474690.0,\n  'std': 1156.664685686523,\n  'median': 8046.0,\n  'majority': 7295.0,\n  'minority': 6912.0,\n  'unique': 8681.0,\n  'histogram': [[587083.0,\n    79039.0,\n    4498.0,\n    1328.0,\n    914.0,\n    222.0,\n    37.0,\n    2.0,\n    0.0,\n    1.0],\n   [6912.0,\n    9427.7,\n    11943.4,\n    14459.099999999999,\n    16974.8,\n    19490.5,\n    22006.199999999997,\n    24521.899999999998,\n    27037.6,\n    29553.3,\n    32069.0]],\n  'valid_percent': 65.08,\n  'masked_pixels': 361116.0,\n  'valid_pixels': 673124.0,\n  'percentile_2': 7278.0,\n  'percentile_98': 11233.0}}</pre> <p>Color infrared composite.</p> In\u00a0[17]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    assets=[\"SR_B5\", \"SR_B4\", \"SR_B3\"],\n    name=\"Color infrared\",\n)\nm\n</pre> m = leafmap.Map() m.add_stac_layer(     collection=collection,     item=item,     assets=[\"SR_B5\", \"SR_B4\", \"SR_B3\"],     name=\"Color infrared\", ) m Out[17]: <p>False color composite.</p> In\u00a0[18]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(\n    collection=collection, item=item, assets=\"SR_B7,SR_B5,SR_B4\", name=\"False color\"\n)\nm\n</pre> m = leafmap.Map() m.add_stac_layer(     collection=collection, item=item, assets=\"SR_B7,SR_B5,SR_B4\", name=\"False color\" ) m Out[18]: <p>Calculate NDVI.</p> In\u00a0[19]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n    rescale=\"-1,1\",\n    name=\"NDVI\",\n)\nm\n</pre> m = leafmap.Map() m.add_stac_layer(     collection=collection,     item=item,     expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",     rescale=\"-1,1\",     name=\"NDVI\", ) m Out[19]: <p>Calculate NDVI and add a colormap. See available colormaps at https://planetarycomputer.microsoft.com/docs/reference/data/</p> In\u00a0[20]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(\n    collection=collection, item=item, assets=\"SR_B5,SR_B4,SR_B3\", name=\"Color infrared\"\n)\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",\n    rescale=\"-1,1\",\n    colormap_name=\"greens\",\n    name=\"NDVI Green\",\n)\nm\n</pre> m = leafmap.Map() m.add_stac_layer(     collection=collection, item=item, assets=\"SR_B5,SR_B4,SR_B3\", name=\"Color infrared\" ) m.add_stac_layer(     collection=collection,     item=item,     expression=\"(SR_B5-SR_B4)/(SR_B5+SR_B4)\",     rescale=\"-1,1\",     colormap_name=\"greens\",     name=\"NDVI Green\", ) m Out[20]:"},{"location":"notebooks/38_plotly/","title":"38 plotly","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap.plotlymap as leafmap\n</pre> import leafmap.plotlymap as leafmap <p>If you run into an error saying \"FigureWidget - 'mapbox._derived' Value Error\" (source), uncomment the following line and run it.</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.fix_widget_error()\n</pre> # leafmap.fix_widget_error() <p>Create an interactive map using default settings.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Change default setting when creating a map.</p> <p>Can be one of string from \"open-street-map\", \"carto-positron\", \"carto-darkmatter\", \"stamen-terrain\", \"stamen-toner\" or \"stamen-watercolor\" .</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=3, basemap=\"stamen-terrain\", height=500)\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=3, basemap=\"stamen-terrain\", height=500) m <p>Set map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(basemap=\"stamen-watercolor\")\nm.set_center(lat=20, lon=0, zoom=2)\nm\n</pre> m = leafmap.Map(basemap=\"stamen-watercolor\") m.set_center(lat=20, lon=0, zoom=2) m <p>Print out available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.basemaps.keys()\n</pre> # leafmap.basemaps.keys() <p>Add a basemap.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m <p>Add XYZ tile layer.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\ntile_url = \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\"\nm.add_tile_layer(tile_url, name=\"Google Satellite\", attribution=\"Google\", opacity=1.0)\nm\n</pre> m = leafmap.Map() tile_url = \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\" m.add_tile_layer(tile_url, name=\"Google Satellite\", attribution=\"Google\", opacity=1.0) m <p>Add a mapbox tile layer. You will need a mapbox token. The map style can be Can be \"basic\", \"streets\", \"outdoors\", \"light\", \"dark\", \"satellite\", or \"satellite-streets\".</p> In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre># os.environ[\"MAPBOX_TOKEN\"] = \"your-mapbox-token\"\n</pre> # os.environ[\"MAPBOX_TOKEN\"] = \"your-mapbox-token\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_mapbox_layer(style=\"streets\")\nm\n</pre> m = leafmap.Map() m.add_mapbox_layer(style=\"streets\") m <p>Remove the modebar in the upper-right corner.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(basemap=\"stamen-toner\")\nm\n</pre> m = leafmap.Map(basemap=\"stamen-toner\") m In\u00a0[\u00a0]: Copied! <pre>m.clear_controls()\n</pre> m.clear_controls() <p>Add more buttons to the modebar.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(basemap=\"carto-positron\")\ncontrols = [\n    \"drawline\",\n    \"drawopenpath\",\n    \"drawclosedpath\",\n    \"drawcircle\",\n    \"drawrect\",\n    \"eraseshape\",\n]\nm.add_controls(controls)\nm\n</pre> m = leafmap.Map(basemap=\"carto-positron\") controls = [     \"drawline\",     \"drawopenpath\",     \"drawclosedpath\",     \"drawcircle\",     \"drawrect\",     \"eraseshape\", ] m.add_controls(controls) m <p>Add Cloud Optimized GeoTIFF.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" m.add_cog_layer(url, name=\"Fire (pre-event)\") m <p>Add a STAC item via HTTP URL.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m <p>Add a STAC item from Microsoft Planetary Computer.</p> In\u00a0[\u00a0]: Copied! <pre>collection = \"landsat-8-c2-l2\"\nitem = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> collection = \"landsat-8-c2-l2\" item = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    bands=[\"SR_B7\", \"SR_B5\", \"SR_B4\"],\n    titiler_endpoint=\"pc\",\n)\nm\n</pre> m = leafmap.Map() m.add_stac_layer(     collection=collection,     item=item,     bands=[\"SR_B7\", \"SR_B5\", \"SR_B4\"],     titiler_endpoint=\"pc\", ) m <p>Add a heat map.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\"\n</pre> url = \"https://raw.githubusercontent.com/plotly/datasets/master/earthquakes-23k.csv\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(basemap=\"stamen-terrain\")\nm.add_heatmap(\n    url, latitude=\"Latitude\", longitude=\"Longitude\", z=\"Magnitude\", name=\"Earthquake\"\n)\nm\n</pre> m = leafmap.Map(basemap=\"stamen-terrain\") m.add_heatmap(     url, latitude=\"Latitude\", longitude=\"Longitude\", z=\"Magnitude\", name=\"Earthquake\" ) m <p>Add a choropleth map.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n</pre> url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(basemap=\"stamen-terrain\")\nm.add_choropleth_map(url, name=\"Pop\", z=\"POP_EST\", colorscale=\"Viridis\")\nm\n</pre> m = leafmap.Map(basemap=\"stamen-terrain\") m.add_choropleth_map(url, name=\"Pop\", z=\"POP_EST\", colorscale=\"Viridis\") m"},{"location":"notebooks/39_inspector_tool/","title":"39 inspector tool","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add Cloud Optimized GeoTIFF (COG) from Planetary Computer.</p> In\u00a0[4]: Copied! <pre>collection = \"landsat-8-c2-l2\"\nitem = \"LC08_L2SP_047027_20201204_02_T1\"\n</pre> collection = \"landsat-8-c2-l2\" item = \"LC08_L2SP_047027_20201204_02_T1\" In\u00a0[5]: Copied! <pre>m.add_stac_layer(\n    collection=collection,\n    item=item,\n    assets=\"SR_B7,SR_B5,SR_B4\",\n    name=\"Landsat Band-754\",\n)\n</pre> m.add_stac_layer(     collection=collection,     item=item,     assets=\"SR_B7,SR_B5,SR_B4\",     name=\"Landsat Band-754\", ) In\u00a0[6]: Copied! <pre>m.add_stac_layer(\n    collection=collection,\n    item=item,\n    assets=\"SR_B5,SR_B4,SR_B3\",\n    name=\"Landsat Band-543\",\n)\n</pre> m.add_stac_layer(     collection=collection,     item=item,     assets=\"SR_B5,SR_B4,SR_B3\",     name=\"Landsat Band-543\", ) In\u00a0[7]: Copied! <pre>m\n</pre> m Out[7]: <p></p>"},{"location":"notebooks/40_plotly_gui/","title":"40 plotly gui","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap.plotlymap as leafmap\n</pre> import leafmap.plotlymap as leafmap <p>Note: For best experience, please use Jupyter notebook. The toolbar GUI is not working very well with JupyterLab at the moment.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() In\u00a0[\u00a0]: Copied! <pre>m.add_basemap(\"Esri.WorldTopoMap\")\n</pre> m.add_basemap(\"Esri.WorldTopoMap\") In\u00a0[\u00a0]: Copied! <pre>m.add_heatmap_demo()\n</pre> m.add_heatmap_demo() In\u00a0[\u00a0]: Copied! <pre>m.add_scatter_plot_demo()\n</pre> m.add_scatter_plot_demo() In\u00a0[\u00a0]: Copied! <pre>m.show()\n</pre> m.show() <p></p>"},{"location":"notebooks/41_raster_gui/","title":"41 raster gui","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[3]: <p></p>"},{"location":"notebooks/42_create_cog/","title":"42 create cog","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Provide a dataset path or URL.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" <p>Validate COG.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_validate(url)\n</pre> leafmap.cog_validate(url) In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_validate(url, verbose=True)\n</pre> leafmap.cog_validate(url, verbose=True) <p>Convert the image to tiled COG.</p> In\u00a0[\u00a0]: Copied! <pre>out_cog = \"cog.tif\"\nleafmap.image_to_cog(url, out_cog)\n</pre> out_cog = \"cog.tif\" leafmap.image_to_cog(url, out_cog) <p>Validate COG.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_validate(out_cog)\n</pre> leafmap.cog_validate(out_cog) In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_validate(out_cog, verbose=True)\n</pre> leafmap.cog_validate(out_cog, verbose=True) <p>Add COG to map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(out_cog, palette=\"terrain\", layer_name=\"Local COG\")\nm.add_cog_layer(url, palette=\"gist_earth\", name=\"Remote COG\")\nm\n</pre> m = leafmap.Map() m.add_raster(out_cog, palette=\"terrain\", layer_name=\"Local COG\") m.add_cog_layer(url, palette=\"gist_earth\", name=\"Remote COG\") m"},{"location":"notebooks/43_search_control/","title":"43 search control","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add a search control to the map. See the Nominatim Usage Policy.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(draw_control=False)\nurl = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\nm.add_search_control(url)\nm\n</pre> m = leafmap.Map(draw_control=False) url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\" m.add_search_control(url) m <pre>The folium plotting backend does not support this function.\n</pre> Out[3]: <p>Search for features in GeoJSON files or any GeoPandas supported vector data.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(draw_control=False, layers_control=True)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url,\n    layer_name=\"Countries\",\n    fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"],\n    info_mode=None,\n)\nm\n</pre> m = leafmap.Map(draw_control=False, layers_control=True) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url,     layer_name=\"Countries\",     fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"],     info_mode=None, ) m Out[4]: <p></p>"},{"location":"notebooks/44_attribute_table/","title":"44 attribute table","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add vector data to the map and use the GUI to open attribute table.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url,\n    layer_name=\"Countries\",\n    fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"],\n    info_mode=False,\n)\n\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=False)\n\nm\n</pre> m = leafmap.Map()  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url,     layer_name=\"Countries\",     fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"],     info_mode=False, )  in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=False)  m Out[3]: <p></p>"},{"location":"notebooks/45_create_vector/","title":"45 create vector","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map and use the drawing tool to draw shapes on the map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[3]: <p>Save the draw features as GeoJSON, Shapefile, or GeoPackage.</p> In\u00a0[4]: Copied! <pre>m.save_draw_features(\"data.geojson\")\n</pre> m.save_draw_features(\"data.geojson\") <pre>The folium plotting backend does not support this function.\n</pre> <p></p>"},{"location":"notebooks/46_edit_vector/","title":"46 edit vector","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=(37.712615, -122.386665), zoom=12)\nm.add_basemap(\"HYBRID\")\nm\n</pre> m = leafmap.Map(center=(37.712615, -122.386665), zoom=12) m.add_basemap(\"HYBRID\") m <pre>Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\n</pre> <p>Add existing vector data to the map.</p> In\u00a0[4]: Copied! <pre>url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/training_samples.geojson\"\nm.edit_vector(url)\n</pre> url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/training_samples.geojson\" m.edit_vector(url) <p>Edit the existing vector data using the drawing tools and save the resulting vector data as GeoJSON, Shapefile, or GeoPackage.</p> In\u00a0[5]: Copied! <pre>m.save_draw_features(\"data.geojson\")\n</pre> m.save_draw_features(\"data.geojson\")"},{"location":"notebooks/47_numpy_to_cog/","title":"47 numpy to cog","text":"<p>Create a fresh conda env to run this example if needed.</p> <pre><code>conda create -n cog python=3.9\nconda install mamba -c conda-forge\nmamba install leafmap rio-cogeo -c conda-forge\n</code></pre> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install rio-cogeo\n</pre> # !pip install rio-cogeo In\u00a0[3]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cog.tif\"\nin_cog = \"cog.tif\"\nout_cog = \"ndvi.tif\"\n</pre> url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cog.tif\" in_cog = \"cog.tif\" out_cog = \"ndvi.tif\" <p>Download a sample dataset.</p> In\u00a0[5]: Copied! <pre>leafmap.download_from_url(url, in_cog)\n</pre> leafmap.download_from_url(url, in_cog) <pre>Downloading https://github.com/opengeos/leafmap/raw/master/examples/data/cog.tif ...\n</pre> <pre>Data downloaded to: /home/runner/work/leafmap/leafmap/docs/notebooks/cog.tif\n</pre> <p>Convert image to numpy array.</p> In\u00a0[6]: Copied! <pre>arr = leafmap.image_to_numpy(in_cog)\n</pre> arr = leafmap.image_to_numpy(in_cog) In\u00a0[7]: Copied! <pre>arr.shape\n</pre> arr.shape Out[7]: <pre>(4, 206, 343)</pre> <p>Computer NDVI.</p> In\u00a0[8]: Copied! <pre>ndvi = (arr[3] - arr[0]) / (arr[3] + arr[0])\n</pre> ndvi = (arr[3] - arr[0]) / (arr[3] + arr[0]) In\u00a0[9]: Copied! <pre>ndvi.shape\n</pre> ndvi.shape Out[9]: <pre>(206, 343)</pre> <p>Convert numpy array to COG.</p> In\u00a0[10]: Copied! <pre>leafmap.numpy_to_cog(ndvi, out_cog, profile=in_cog)\n</pre> leafmap.numpy_to_cog(ndvi, out_cog, profile=in_cog) In\u00a0[11]: Copied! <pre>m = leafmap.Map()\nm.add_raster(in_cog, band=[4, 1, 2], layer_name=\"Color infrared\")\nm.add_raster(out_cog, palette=\"Greens\", layer_name=\"NDVI\")\nm\n</pre> m = leafmap.Map() m.add_raster(in_cog, band=[4, 1, 2], layer_name=\"Color infrared\") m.add_raster(out_cog, palette=\"Greens\", layer_name=\"NDVI\") m Out[11]: <p></p>"},{"location":"notebooks/48_lidar/","title":"48 lidar","text":"<p>Visualizing LiDAR data in 3D with only one line of code</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install leafmap[lidar] open3d\n</pre> # !pip install leafmap[lidar] open3d In\u00a0[3]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Download a sample LiDAR dataset from Google Drive. The zip file is 52.1 MB and the uncompressed LAS file is 109 MB.</p> In\u00a0[4]: Copied! <pre>url = \"https://open.gishub.org/data/lidar/madison.zip\"\nfilename = \"madison.las\"\n</pre> url = \"https://open.gishub.org/data/lidar/madison.zip\" filename = \"madison.las\" In\u00a0[5]: Copied! <pre>leafmap.download_file(url, \"madison.zip\", unzip=True)\n</pre> leafmap.download_file(url, \"madison.zip\", unzip=True) <pre>Downloading...\nFrom: https://open.gishub.org/data/lidar/madison.zip\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/madison.zip\n</pre> <pre>\r  0%|          | 0.00/54.7M [00:00&lt;?, ?B/s]</pre> <pre>\r 41%|\u2588\u2588\u2588\u2588      | 22.5M/54.7M [00:00&lt;00:00, 224MB/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 54.7M/54.7M [00:00&lt;00:00, 281MB/s]</pre> <pre>\n</pre> <pre>Extracting files...\n</pre> Out[5]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/madison.zip'</pre> <p>Read the LiDAR data</p> In\u00a0[6]: Copied! <pre>las = leafmap.read_lidar(filename)\n</pre> las = leafmap.read_lidar(filename) <p>The LAS header.</p> In\u00a0[7]: Copied! <pre>las.header\n</pre> las.header Out[7]: <pre>&lt;LasHeader(1.3, &lt;PointFormat(1, 0 bytes of extra dims)&gt;)&gt;</pre> <p>The number of points.</p> In\u00a0[8]: Copied! <pre>las.header.point_count\n</pre> las.header.point_count Out[8]: <pre>4068294</pre> <p>The list of features.</p> In\u00a0[9]: Copied! <pre>list(las.point_format.dimension_names)\n</pre> list(las.point_format.dimension_names) Out[9]: <pre>['X',\n 'Y',\n 'Z',\n 'intensity',\n 'return_number',\n 'number_of_returns',\n 'scan_direction_flag',\n 'edge_of_flight_line',\n 'classification',\n 'synthetic',\n 'key_point',\n 'withheld',\n 'scan_angle_rank',\n 'user_data',\n 'point_source_id',\n 'gps_time']</pre> <p>Inspect data.</p> In\u00a0[10]: Copied! <pre>las.X\n</pre> las.X Out[10]: <pre>array([5324343, 5324296, 5323993, ..., 5784049, 5784359, 5784667],\n      dtype=int32)</pre> In\u00a0[11]: Copied! <pre>las.Y\n</pre> las.Y Out[11]: <pre>array([8035264, 8035347, 8035296, ..., 7550110, 7550066, 7550026],\n      dtype=int32)</pre> In\u00a0[12]: Copied! <pre>las.Z\n</pre> las.Z Out[12]: <pre>array([36696, 34835, 34826, ..., 36839, 36858, 36842], dtype=int32)</pre> In\u00a0[13]: Copied! <pre>las.intensity\n</pre> las.intensity Out[13]: <pre>array([ 9, 41, 24, ..., 87, 80, 95], dtype=uint16)</pre> <p>Visualize LiDAR data using the pyvista backend.</p> In\u00a0[14]: Copied! <pre>leafmap.view_lidar(filename, cmap=\"terrain\", backend=\"pyvista\")\n</pre> leafmap.view_lidar(filename, cmap=\"terrain\", backend=\"pyvista\") <p></p> <p>Visualize LiDAR data using the ipygany backend.</p> In\u00a0[15]: Copied! <pre>leafmap.view_lidar(filename, backend=\"ipygany\", background=\"white\")\n</pre> leafmap.view_lidar(filename, backend=\"ipygany\", background=\"white\") <p></p> <p>Visualize LiDAR data using the panel backend.</p> In\u00a0[16]: Copied! <pre>leafmap.view_lidar(filename, cmap=\"terrain\", backend=\"panel\", background=\"white\")\n</pre> leafmap.view_lidar(filename, cmap=\"terrain\", backend=\"panel\", background=\"white\") <p></p> <p>Visualize LiDAR data using the open3d backend.</p> In\u00a0[17]: Copied! <pre>leafmap.view_lidar(filename, backend=\"open3d\")\n</pre> leafmap.view_lidar(filename, backend=\"open3d\") <p></p>"},{"location":"notebooks/49_split_control/","title":"49 split control","text":"<p>Creating a split-panel map</p> <p>This notebook demonstrates how to add a split-panel map with leafmap anf folium. It also supports streamlit. Note that the ipyleaflet SplitControl does not support streamlit.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import folium\nimport rioxarray\nimport xarray as xr\nimport leafmap.foliumap as leafmap\n</pre> import folium import rioxarray import xarray as xr import leafmap.foliumap as leafmap <p>The split-panel map requires two layers: <code>left_layer</code> and <code>right_layer</code>. The layer instance can be a string representing a basemap, or an HTTP URL to a Cloud Optimized GeoTIFF (COG), or a folium TileLayer instance.</p> <p>Using basemaps</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(height=500)\nm.split_map(left_layer=\"TERRAIN\", right_layer=\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map(height=500) m.split_map(left_layer=\"TERRAIN\", right_layer=\"OpenTopoMap\") m Out[3]: <p>Show available basemaps.</p> In\u00a0[4]: Copied! <pre># leafmap.basemaps.keys()\n</pre> # leafmap.basemaps.keys() <p>Using COG</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(height=600, center=[39.4948, -108.5492], zoom=12)\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm.split_map(url, url2)\nm\n</pre> m = leafmap.Map(height=600, center=[39.4948, -108.5492], zoom=12) url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m.split_map(url, url2) m Out[5]: <p>Using folium TileLayer</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\n\nurl1 = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2001_Land_Cover_L48/wms?\"\nurl2 = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\n\nleft_layer = folium.WmsTileLayer(\n    url=url1,\n    layers=\"NLCD_2001_Land_Cover_L48\",\n    name=\"NLCD 2001\",\n    attr=\"MRLC\",\n    fmt=\"image/png\",\n    transparent=True,\n)\nright_layer = folium.WmsTileLayer(\n    url=url2,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019\",\n    attr=\"MRLC\",\n    fmt=\"image/png\",\n    transparent=True,\n)\n\nm.split_map(left_layer, right_layer)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4)  url1 = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2001_Land_Cover_L48/wms?\" url2 = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"  left_layer = folium.WmsTileLayer(     url=url1,     layers=\"NLCD_2001_Land_Cover_L48\",     name=\"NLCD 2001\",     attr=\"MRLC\",     fmt=\"image/png\",     transparent=True, ) right_layer = folium.WmsTileLayer(     url=url2,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019\",     attr=\"MRLC\",     fmt=\"image/png\",     transparent=True, )  m.split_map(left_layer, right_layer) m Out[6]: <p>Using xarrays</p> <p>Download a sample dataset.</p> In\u00a0[7]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\ndem = leafmap.download_file(url, \"srtm90.tif\")\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" dem = leafmap.download_file(url, \"srtm90.tif\") <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/srtm90.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/srtm90.tif\n</pre> <pre>\r  0%|          | 0.00/16.6M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16.6M/16.6M [00:00&lt;00:00, 239MB/s]</pre> <pre>\n</pre> <p>Use rioxarray to read the raster as a xarray DataArray and then classify the DEM into 2 elevation classes.</p> In\u00a0[8]: Copied! <pre>dem_ds = rioxarray.open_rasterio(dem)\ndem_class = xr.where(dem_ds &lt; 2000, 0, 1)\n</pre> dem_ds = rioxarray.open_rasterio(dem) dem_class = xr.where(dem_ds &lt; 2000, 0, 1) <p>Visualize the DEM and the elevation class image as a split map.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map(center=[37.6, -119], zoom=9)\nm.split_map(\n    dem_ds,\n    dem_class,\n    left_args={\"layer_name\": \"DEM\", \"colormap\": \"terrain\"},\n    right_args={\"layer_name\": \"Classified DEM\", \"colormap\": \"coolwarm\"},\n)\nm\n</pre> m = leafmap.Map(center=[37.6, -119], zoom=9) m.split_map(     dem_ds,     dem_class,     left_args={\"layer_name\": \"DEM\", \"colormap\": \"terrain\"},     right_args={\"layer_name\": \"Classified DEM\", \"colormap\": \"coolwarm\"}, ) m Out[9]:"},{"location":"notebooks/50_marker_cluster/","title":"50 marker cluster","text":"<p>Creating a marker cluster with custom icons</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) <p>Use sample datasets.</p> In\u00a0[\u00a0]: Copied! <pre>cities = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\nregions = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_regions.geojson\"\n</pre> cities = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" regions = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_regions.geojson\" <p>Add a GeoJSON to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_geojson(regions, layer_name=\"US Regions\")\n</pre> m.add_geojson(regions, layer_name=\"US Regions\") <p>Add a marker cluster to the map. The input can either be a string (representing file path or HTTP URL to a csv file) or a Pandas DataFrame.</p> <p>The list of available icon names can be found at https://fontawesome.com/v4/icons.</p> <p>Please note that the <code>spin</code> parameter only supports the ipyleaflet backend. The folium backend does not support this.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_points_from_xy(\n    cities,\n    x=\"longitude\",\n    y=\"latitude\",\n    color_column=\"region\",\n    icon_names=[\"gear\", \"map\", \"leaf\", \"globe\"],\n    spin=True,\n    add_legend=True,\n)\n</pre> m.add_points_from_xy(     cities,     x=\"longitude\",     y=\"latitude\",     color_column=\"region\",     icon_names=[\"gear\", \"map\", \"leaf\", \"globe\"],     spin=True,     add_legend=True, ) <p>Display the map.</p> In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m <p></p>"},{"location":"notebooks/51_clip_image/","title":"51 clip image","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install rasterio fiona\n</pre> # !pip install rasterio fiona In\u00a0[3]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Download a sample raster dataset.</p> In\u00a0[4]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\ndem = \"dem.tif\"\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" dem = \"dem.tif\" In\u00a0[5]: Copied! <pre>leafmap.download_file(url, dem, overwrite=True)\n</pre> leafmap.download_file(url, dem, overwrite=True) <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/srtm90.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif\n</pre> <pre>\r  0%|          | 0.00/16.6M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16.6M/16.6M [00:00&lt;00:00, 228MB/s]</pre> <pre>\n</pre> Out[5]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif'</pre> <p>Create an interactive map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_raster(dem, palette=\"terrain\", layer_name=\"DEM\")\nm\n</pre> m = leafmap.Map() m.add_raster(dem, palette=\"terrain\", layer_name=\"DEM\") m Out[6]: <p>Define a mask to extract the image. The mask can be a string representing a file path to a vector dataset (e.g., geojson, shp), or a list of coordinates (e.g., <code>[[lon,lat], [lon,lat]]</code>), or a dictionary representing a feature (e.g., m.user_roi).</p> <p>For example, the mask can be a filepath to a vector dataset.</p> In\u00a0[7]: Copied! <pre># mask = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/mask.geojson'\n</pre> # mask = 'https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/mask.geojson' <p>Or you can draw a polygon on the map, then use <code>m.user_roi</code> as the mask.</p> In\u00a0[8]: Copied! <pre># mask = m.user_roi\n</pre> # mask = m.user_roi <p>Or specify a list of coordinates <code>[lon, lat]</code> as the mask.</p> In\u00a0[9]: Copied! <pre>mask = [\n    [-119.679565, 37.256566],\n    [-119.679565, 38.061067],\n    [-118.24585, 38.061067],\n    [-118.24585, 37.256566],\n    [-119.679565, 37.256566],\n]\n</pre> mask = [     [-119.679565, 37.256566],     [-119.679565, 38.061067],     [-118.24585, 38.061067],     [-118.24585, 37.256566],     [-119.679565, 37.256566], ] <p>Specify the output filename.</p> In\u00a0[10]: Copied! <pre>output = \"clip.tif\"\n</pre> output = \"clip.tif\" <p>Clip image by mask.</p> In\u00a0[11]: Copied! <pre>try:\n    leafmap.clip_image(dem, mask, output)\nexcept Exception as e:\n    print(e)\n</pre> try:     leafmap.clip_image(dem, mask, output) except Exception as e:     print(e) <pre>Reading input: /home/runner/work/leafmap/leafmap/docs/notebooks/clip.tif\n</pre> <pre>\n</pre> <pre>Adding overviews...\n</pre> <pre>Updating dataset tags...\n</pre> <pre>Writing output to: /home/runner/work/leafmap/leafmap/docs/notebooks/clip.tif\n</pre> <p>Add the clipped image to the map.</p> In\u00a0[12]: Copied! <pre>try:\n    m.add_raster(output, palette=\"gist_earth\", layer_name=\"Clip Image\")\nexcept Exception as e:\n    print(e)\n</pre> try:     m.add_raster(output, palette=\"gist_earth\", layer_name=\"Clip Image\") except Exception as e:     print(e)"},{"location":"notebooks/52_netcdf/","title":"52 netcdf","text":"<p>Visualizing NetCDF data</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install xarray rioxarray netcdf4 localtileserver\n</pre> # !pip install xarray rioxarray netcdf4 localtileserver In\u00a0[3]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Download a sample NetCDF dataset.</p> In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/wind_global.nc\"\nfilename = \"wind_global.nc\"\n</pre> url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/wind_global.nc\" filename = \"wind_global.nc\" In\u00a0[5]: Copied! <pre>leafmap.download_file(url, output=filename)\n</pre> leafmap.download_file(url, output=filename) <pre>Downloading...\nFrom: https://github.com/opengeos/leafmap/raw/master/examples/data/wind_global.nc\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/wind_global.nc\n</pre> <pre>\r  0%|          | 0.00/1.05M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.05M/1.05M [00:00&lt;00:00, 38.5MB/s]</pre> <pre>\n</pre> Out[5]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/wind_global.nc'</pre> <p>Read the NetCDF dataset.</p> In\u00a0[6]: Copied! <pre>data = leafmap.read_netcdf(filename)\ndata\n</pre> data = leafmap.read_netcdf(filename) data Out[6]: <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (lat: 181, lon: 360)\nCoordinates:\n  * lat      (lat) float64 1kB 90.0 89.0 88.0 87.0 ... -87.0 -88.0 -89.0 -90.0\n  * lon      (lon) float64 3kB 0.0 1.0 2.0 3.0 4.0 ... 356.0 357.0 358.0 359.0\nData variables:\n    u_wind   (lat, lon) float64 521kB ...\n    v_wind   (lat, lon) float64 521kB ...\nAttributes:\n    centerName:      US National Weather Service - NCEP(WMC)\n    disciplineName:  Meteorological products\n    refTime:         2016-04-30T06:00:00.000Z</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lat: 181</li><li>lon: 360</li></ul></li><li>Coordinates: (2)<ul><li>lat(lat)float6490.0 89.0 88.0 ... -89.0 -90.0<pre>array([ 90.,  89.,  88.,  87.,  86.,  85.,  84.,  83.,  82.,  81.,  80.,  79.,\n        78.,  77.,  76.,  75.,  74.,  73.,  72.,  71.,  70.,  69.,  68.,  67.,\n        66.,  65.,  64.,  63.,  62.,  61.,  60.,  59.,  58.,  57.,  56.,  55.,\n        54.,  53.,  52.,  51.,  50.,  49.,  48.,  47.,  46.,  45.,  44.,  43.,\n        42.,  41.,  40.,  39.,  38.,  37.,  36.,  35.,  34.,  33.,  32.,  31.,\n        30.,  29.,  28.,  27.,  26.,  25.,  24.,  23.,  22.,  21.,  20.,  19.,\n        18.,  17.,  16.,  15.,  14.,  13.,  12.,  11.,  10.,   9.,   8.,   7.,\n         6.,   5.,   4.,   3.,   2.,   1.,   0.,  -1.,  -2.,  -3.,  -4.,  -5.,\n        -6.,  -7.,  -8.,  -9., -10., -11., -12., -13., -14., -15., -16., -17.,\n       -18., -19., -20., -21., -22., -23., -24., -25., -26., -27., -28., -29.,\n       -30., -31., -32., -33., -34., -35., -36., -37., -38., -39., -40., -41.,\n       -42., -43., -44., -45., -46., -47., -48., -49., -50., -51., -52., -53.,\n       -54., -55., -56., -57., -58., -59., -60., -61., -62., -63., -64., -65.,\n       -66., -67., -68., -69., -70., -71., -72., -73., -74., -75., -76., -77.,\n       -78., -79., -80., -81., -82., -83., -84., -85., -86., -87., -88., -89.,\n       -90.])</pre></li><li>lon(lon)float640.0 1.0 2.0 ... 357.0 358.0 359.0<pre>array([  0.,   1.,   2., ..., 357., 358., 359.])</pre></li></ul></li><li>Data variables: (2)<ul><li>u_wind(lat, lon)float64...<pre>[65160 values with dtype=float64]</pre></li><li>v_wind(lat, lon)float64...<pre>[65160 values with dtype=float64]</pre></li></ul></li><li>Indexes: (2)<ul><li>latPandasIndex<pre>PandasIndex(Index([ 90.0,  89.0,  88.0,  87.0,  86.0,  85.0,  84.0,  83.0,  82.0,  81.0,\n       ...\n       -81.0, -82.0, -83.0, -84.0, -85.0, -86.0, -87.0, -88.0, -89.0, -90.0],\n      dtype='float64', name='lat', length=181))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([  0.0,   1.0,   2.0,   3.0,   4.0,   5.0,   6.0,   7.0,   8.0,   9.0,\n       ...\n       350.0, 351.0, 352.0, 353.0, 354.0, 355.0, 356.0, 357.0, 358.0, 359.0],\n      dtype='float64', name='lon', length=360))</pre></li></ul></li><li>Attributes: (3)centerName :US National Weather Service - NCEP(WMC)disciplineName :Meteorological productsrefTime :2016-04-30T06:00:00.000Z</li></ul> <p>Convert the NetCDF dataset to GeoTIFF. Note that the longitude range of the NetCDF dataset is <code>[0, 360]</code>. We need to convert it to <code>[-180, 180]</code> by setting <code>shift_lon=True</code> so that it can be displayed on the map.</p> In\u00a0[7]: Copied! <pre>tif = \"wind_global.tif\"\nleafmap.netcdf_to_tif(filename, tif, variables=[\"u_wind\", \"v_wind\"], shift_lon=True)\n</pre> tif = \"wind_global.tif\" leafmap.netcdf_to_tif(filename, tif, variables=[\"u_wind\", \"v_wind\"], shift_lon=True) Out[7]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/wind_global.tif'</pre> <p>Add the GeoTIFF to the map. We can also overlay the country boundary on the map.</p> In\u00a0[8]: Copied! <pre>geojson = (\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.geojson\"\n)\n</pre> geojson = (     \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.geojson\" ) In\u00a0[9]: Copied! <pre>m = leafmap.Map(layers_control=True)\nm.add_raster(tif, indexes=[1], palette=\"coolwarm\", layer_name=\"u_wind\")\nm.add_geojson(geojson, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(layers_control=True) m.add_raster(tif, indexes=[1], palette=\"coolwarm\", layer_name=\"u_wind\") m.add_geojson(geojson, layer_name=\"Countries\") m <p>You can also use the <code>add_netcdf()</code> function to add the NetCDF dataset to the map without having to convert it to GeoTIFF explicitly.</p> In\u00a0[10]: Copied! <pre>m = leafmap.Map(layers_control=True)\nm.add_netcdf(\n    filename,\n    variables=[\"v_wind\"],\n    palette=\"coolwarm\",\n    shift_lon=True,\n    layer_name=\"v_wind\",\n    indexes=[1],\n)\nm.add_geojson(geojson, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(layers_control=True) m.add_netcdf(     filename,     variables=[\"v_wind\"],     palette=\"coolwarm\",     shift_lon=True,     layer_name=\"v_wind\",     indexes=[1], ) m.add_geojson(geojson, layer_name=\"Countries\") m <p>Visualizing wind velocity.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map(layers_control=True)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_velocity(\n    filename,\n    zonal_speed=\"u_wind\",\n    meridional_speed=\"v_wind\",\n    color_scale=[\n        \"rgb(0,0,150)\",\n        \"rgb(0,150,0)\",\n        \"rgb(255,255,0)\",\n        \"rgb(255,165,0)\",\n        \"rgb(150,0,0)\",\n    ],\n)\nm\n</pre> m = leafmap.Map(layers_control=True) m.add_basemap(\"CartoDB.DarkMatter\") m.add_velocity(     filename,     zonal_speed=\"u_wind\",     meridional_speed=\"v_wind\",     color_scale=[         \"rgb(0,0,150)\",         \"rgb(0,150,0)\",         \"rgb(255,255,0)\",         \"rgb(255,165,0)\",         \"rgb(150,0,0)\",     ], ) m <p></p>"},{"location":"notebooks/53_choropleth/","title":"53 choropleth","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre>data = leafmap.examples.datasets.countries_geojson\n</pre> data = leafmap.examples.datasets.countries_geojson <p>Available classification schemes:</p> <ul> <li>BoxPlot</li> <li>EqualInterval</li> <li>FisherJenks</li> <li>FisherJenksSampled</li> <li>HeadTailBreaks</li> <li>JenksCaspall</li> <li>JenksCaspallForced</li> <li>JenksCaspallSampled</li> <li>MaxP</li> <li>MaximumBreaks</li> <li>NaturalBreaks</li> <li>Quantiles</li> <li>Percentiles</li> <li>StdMean</li> <li>UserDefined</li> </ul> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_data(\n    data, column=\"POP_EST\", scheme=\"Quantiles\", cmap=\"Blues\", legend_title=\"Population\"\n)\nm\n</pre> m = leafmap.Map() m.add_data(     data, column=\"POP_EST\", scheme=\"Quantiles\", cmap=\"Blues\", legend_title=\"Population\" ) m Out[4]: In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nm.add_data(\n    data,\n    column=\"POP_EST\",\n    scheme=\"EqualInterval\",\n    cmap=\"Blues\",\n    legend_title=\"Population\",\n)\nm\n</pre> m = leafmap.Map() m.add_data(     data,     column=\"POP_EST\",     scheme=\"EqualInterval\",     cmap=\"Blues\",     legend_title=\"Population\", ) m Out[5]: In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_data(\n    data,\n    column=\"POP_EST\",\n    scheme=\"FisherJenks\",\n    cmap=\"Blues\",\n    legend_title=\"Population\",\n)\nm\n</pre> m = leafmap.Map() m.add_data(     data,     column=\"POP_EST\",     scheme=\"FisherJenks\",     cmap=\"Blues\",     legend_title=\"Population\", ) m Out[6]: In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_data(\n    data,\n    column=\"POP_EST\",\n    scheme=\"JenksCaspall\",\n    cmap=\"Blues\",\n    legend_title=\"Population\",\n)\nm\n</pre> m = leafmap.Map() m.add_data(     data,     column=\"POP_EST\",     scheme=\"JenksCaspall\",     cmap=\"Blues\",     legend_title=\"Population\", ) m Out[7]:"},{"location":"notebooks/54_plot_raster/","title":"54 plot raster","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Download a sample dataset.</p> In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" In\u00a0[4]: Copied! <pre>image = \"srtm90.tif\"\nif not os.path.exists(image):\n    leafmap.download_file(url, image)\n</pre> image = \"srtm90.tif\" if not os.path.exists(image):     leafmap.download_file(url, image) <p>Plot the raster image in 2D.</p> In\u00a0[5]: Copied! <pre>leafmap.plot_raster(image, cmap=\"terrain\", figsize=(15, 10))\n</pre> leafmap.plot_raster(image, cmap=\"terrain\", figsize=(15, 10)) <p></p> <p>Plot the raster image in 3D.</p> In\u00a0[6]: Copied! <pre>leafmap.plot_raster_3d(\"srtm90.tif\", factor=2, cmap=\"terrain\", background=\"gray\")\n</pre> leafmap.plot_raster_3d(\"srtm90.tif\", factor=2, cmap=\"terrain\", background=\"gray\") <p></p>"},{"location":"notebooks/55_lidar/","title":"55 lidar","text":"<p>LiDAR data analysis and visualization with whitebox and leafmap</p> <p>Create a new conda env to install required packages:</p> <pre>conda create -n geo python\nconda activate geo\nconda install -c conda-forge mamba\nmamba install -c conda-forge pygis\npip install laspy[lazrs]\n</pre> <p>Uncomment the following line to install packages in Google Colab.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install laspy[lazrs]\n</pre> # !pip install laspy[lazrs] In\u00a0[3]: Copied! <pre>import os\nimport leafmap\nimport whitebox\n</pre> import os import leafmap import whitebox In\u00a0[4]: Copied! <pre>wbt = whitebox.WhiteboxTools()\nwbt.set_working_dir(os.getcwd())\nwbt.set_verbose_mode(False)\n</pre> wbt = whitebox.WhiteboxTools() wbt.set_working_dir(os.getcwd()) wbt.set_verbose_mode(False) <pre>Downloading WhiteboxTools pre-compiled binary for first time use ...\n</pre> <pre>Downloading WhiteboxTools binary from https://www.whiteboxgeo.com/WBT_Linux/WhiteboxTools_linux_amd64.zip\nDecompressing WhiteboxTools_linux_amd64.zip ...\n</pre> <pre>WhiteboxTools package directory: /home/runner/miniconda3/envs/test/lib/python3.11/site-packages/whitebox\nDownloading testdata ...\n</pre> Out[4]: <pre>0</pre> In\u00a0[5]: Copied! <pre>url = \"https://open.gishub.org/data/lidar/madison.zip\"\nfilename = \"madison.las\"\n</pre> url = \"https://open.gishub.org/data/lidar/madison.zip\" filename = \"madison.las\" In\u00a0[6]: Copied! <pre>leafmap.download_file(url, \"madison.zip\", unzip=True)\n</pre> leafmap.download_file(url, \"madison.zip\", unzip=True) <pre>madison.zip already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[6]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/madison.zip'</pre> In\u00a0[7]: Copied! <pre>laz = leafmap.read_lidar(filename)\n</pre> laz = leafmap.read_lidar(filename) In\u00a0[8]: Copied! <pre>laz\n</pre> laz Out[8]: <pre>&lt;LasData(1.3, point fmt: &lt;PointFormat(1, 0 bytes of extra dims)&gt;, 4068294 points, 2 vlrs)&gt;</pre> In\u00a0[9]: Copied! <pre>str(laz.header.version)\n</pre> str(laz.header.version) Out[9]: <pre>'1.3'</pre> In\u00a0[10]: Copied! <pre>las = leafmap.convert_lidar(laz, file_version=\"1.4\")\n</pre> las = leafmap.convert_lidar(laz, file_version=\"1.4\") In\u00a0[11]: Copied! <pre>str(las.header.version)\n</pre> str(las.header.version) Out[11]: <pre>'1.4'</pre> In\u00a0[12]: Copied! <pre>leafmap.write_lidar(las, \"madison.las\")\n</pre> leafmap.write_lidar(las, \"madison.las\") In\u00a0[13]: Copied! <pre>wbt.lidar_histogram(\"madison.las\", \"histogram.html\")\n</pre> wbt.lidar_histogram(\"madison.las\", \"histogram.html\") Out[13]: <pre>0</pre> In\u00a0[14]: Copied! <pre>leafmap.view_lidar(\"madison.las\")\n</pre> leafmap.view_lidar(\"madison.las\") In\u00a0[15]: Copied! <pre>wbt.lidar_elevation_slice(\"madison.las\", \"madison_rm.las\", minz=0, maxz=450)\n</pre> wbt.lidar_elevation_slice(\"madison.las\", \"madison_rm.las\", minz=0, maxz=450) Out[15]: <pre>0</pre> In\u00a0[16]: Copied! <pre>leafmap.view_lidar(\"madison_rm.las\", cmap=\"terrain\")\n</pre> leafmap.view_lidar(\"madison_rm.las\", cmap=\"terrain\") In\u00a0[17]: Copied! <pre>wbt.lidar_digital_surface_model(\n    \"madison_rm.las\", \"dsm.tif\", resolution=1.0, minz=0, maxz=450\n)\n</pre> wbt.lidar_digital_surface_model(     \"madison_rm.las\", \"dsm.tif\", resolution=1.0, minz=0, maxz=450 ) Out[17]: <pre>0</pre> In\u00a0[18]: Copied! <pre>leafmap.add_crs(\"dsm.tif\", epsg=2255)\n</pre> leafmap.add_crs(\"dsm.tif\", epsg=2255) In\u00a0[19]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"dsm.tif\", palette=\"terrain\", layer_name=\"DSM\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"dsm.tif\", palette=\"terrain\", layer_name=\"DSM\") m Out[19]: In\u00a0[20]: Copied! <pre>wbt.remove_off_terrain_objects(\"dsm.tif\", \"dem.tif\", filter=25, slope=15.0)\n</pre> wbt.remove_off_terrain_objects(\"dsm.tif\", \"dem.tif\", filter=25, slope=15.0) Out[20]: <pre>0</pre> In\u00a0[21]: Copied! <pre>m.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"DEM\")\nm\n</pre> m.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"DEM\") m Out[21]: In\u00a0[22]: Copied! <pre>chm = wbt.subtract(\"dsm.tif\", \"dem.tif\", \"chm.tif\")\n</pre> chm = wbt.subtract(\"dsm.tif\", \"dem.tif\", \"chm.tif\") In\u00a0[23]: Copied! <pre>m.add_raster(\"chm.tif\", palette=\"gist_earth\", layer_name=\"CHM\")\nm\n</pre> m.add_raster(\"chm.tif\", palette=\"gist_earth\", layer_name=\"CHM\") m Out[23]:"},{"location":"notebooks/55_lidar/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/55_lidar/#set-up-whitebox","title":"Set up whitebox\u00b6","text":""},{"location":"notebooks/55_lidar/#download-sample-data","title":"Download sample data\u00b6","text":""},{"location":"notebooks/55_lidar/#read-laslaz-data","title":"Read LAS/LAZ data\u00b6","text":""},{"location":"notebooks/55_lidar/#upgrade-file-version","title":"Upgrade file version\u00b6","text":""},{"location":"notebooks/55_lidar/#write-las-data","title":"Write LAS data\u00b6","text":""},{"location":"notebooks/55_lidar/#histogram-analysis","title":"Histogram analysis\u00b6","text":""},{"location":"notebooks/55_lidar/#visualize-lidar-data","title":"Visualize LiDAR data\u00b6","text":""},{"location":"notebooks/55_lidar/#remove-outliers","title":"Remove outliers\u00b6","text":""},{"location":"notebooks/55_lidar/#visualize-lidar-data-after-removing-outliers","title":"Visualize LiDAR data after removing outliers\u00b6","text":""},{"location":"notebooks/55_lidar/#create-dsm","title":"Create DSM\u00b6","text":""},{"location":"notebooks/55_lidar/#visualize-dsm","title":"Visualize DSM\u00b6","text":""},{"location":"notebooks/55_lidar/#create-dem","title":"Create DEM\u00b6","text":""},{"location":"notebooks/55_lidar/#visualize-dem","title":"Visualize DEM\u00b6","text":""},{"location":"notebooks/55_lidar/#create-chm","title":"Create CHM\u00b6","text":""},{"location":"notebooks/56_download_ned/","title":"56 download ned","text":"<p>Downloading 10-m National Elevation Dataset (NED) with only one line of code</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install geopandas rasterio\n</pre> # !pip install geopandas rasterio In\u00a0[3]: Copied! <pre>import os\nimport leafmap\nimport shutil\nimport sys\n</pre> import os import leafmap import shutil import sys In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m Out[4]: In\u00a0[5]: Copied! <pre>region = m.user_roi_bounds()\nif region is None:\n    region = [-115.9689, 35.9758, -115.3619, 36.4721]\nprint(region)\n</pre> region = m.user_roi_bounds() if region is None:     region = [-115.9689, 35.9758, -115.3619, 36.4721] print(region) <pre>The folium plotting backend does not support this function.\n[-115.9689, 35.9758, -115.3619, 36.4721]\n</pre> In\u00a0[6]: Copied! <pre>leafmap.download_ned(region, return_url=True)\n</pre> leafmap.download_ned(region, return_url=True) In\u00a0[7]: Copied! <pre>out_dir = \"data\"\nos.makedirs(out_dir, exist_ok=True)\n</pre> out_dir = \"data\" os.makedirs(out_dir, exist_ok=True) In\u00a0[8]: Copied! <pre>if \"google.colab\" in sys.modules:\n    leafmap.download_ned(region, out_dir)\n</pre> if \"google.colab\" in sys.modules:     leafmap.download_ned(region, out_dir) In\u00a0[9]: Copied! <pre>if \"google.colab\" in sys.modules:\n    mosaic = \"mosaic.tif\"\n    leafmap.mosaic(images=out_dir, output=mosaic)\n</pre> if \"google.colab\" in sys.modules:     mosaic = \"mosaic.tif\"     leafmap.mosaic(images=out_dir, output=mosaic) In\u00a0[10]: Copied! <pre>if \"google.colab\" in sys.modules and (m.user_roi is not None):\n    image = \"dem.tif\"\n    leafmap.clip_image(mosaic, mask=m.user_roi, output=image)\n</pre> if \"google.colab\" in sys.modules and (m.user_roi is not None):     image = \"dem.tif\"     leafmap.clip_image(mosaic, mask=m.user_roi, output=image) In\u00a0[11]: Copied! <pre>out_dir = \"/content/drive/MyDrive/Data\"\nif os.path.exists(out_dir) and os.path.exists(image):\n    shutil.copyfile(image, os.path.join(out_dir, image))\n</pre> out_dir = \"/content/drive/MyDrive/Data\" if os.path.exists(out_dir) and os.path.exists(image):     shutil.copyfile(image, os.path.join(out_dir, image))"},{"location":"notebooks/57_national_map/","title":"57 national map","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>TNM = leafmap.The_national_map_USGS()\n</pre> TNM = leafmap.The_national_map_USGS() In\u00a0[\u00a0]: Copied! <pre>TNM.datasets\n</pre> TNM.datasets In\u00a0[\u00a0]: Copied! <pre>TNM.prodFormats\n</pre> TNM.prodFormats In\u00a0[\u00a0]: Copied! <pre>TNM.find_details().keys(), TNM.find_details()[\"total\"]\n</pre> TNM.find_details().keys(), TNM.find_details()[\"total\"] In\u00a0[\u00a0]: Copied! <pre>TNM.find_details()[\"items\"][0]\n</pre> TNM.find_details()[\"items\"][0] In\u00a0[\u00a0]: Copied! <pre>params = {\n    \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n    \"polyCode\": \"01010002\",\n    \"polyType\": \"huc8\",\n}\n\nTNM.find_details(**params)[\"total\"]\n</pre> params = {     \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",     \"polyCode\": \"01010002\",     \"polyType\": \"huc8\", }  TNM.find_details(**params)[\"total\"] In\u00a0[\u00a0]: Copied! <pre>params = {\n    \"prodFormats\": \"LAS,LAZ\",\n    \"datasets\": \"Lidar Point Cloud (LPC)\",\n    \"polygon\": [\n        (-104.94262695312236, 41.52867510196275),\n        (-102.83325195312291, 40.45065268246805),\n        (-104.94262695312236, 40.45065268246805),\n        (-104.94262695312236, 41.52867510196275),\n    ],\n}\n\nTNM.find_details(**params)[\"total\"]\n</pre> params = {     \"prodFormats\": \"LAS,LAZ\",     \"datasets\": \"Lidar Point Cloud (LPC)\",     \"polygon\": [         (-104.94262695312236, 41.52867510196275),         (-102.83325195312291, 40.45065268246805),         (-104.94262695312236, 40.45065268246805),         (-104.94262695312236, 41.52867510196275),     ], }  TNM.find_details(**params)[\"total\"] <p>Available parameters</p> In\u00a0[\u00a0]: Copied! <pre>help(TNM.find_details)\n</pre> help(TNM.find_details) In\u00a0[\u00a0]: Copied! <pre>len(TNM.find_details()[\"items\"])\n</pre> len(TNM.find_details()[\"items\"]) In\u00a0[\u00a0]: Copied! <pre>len(TNM.find_details(max=1000000)[\"items\"])\n</pre> len(TNM.find_details(max=1000000)[\"items\"]) <p>Use offset to retrieve more batches.</p> In\u00a0[\u00a0]: Copied! <pre>params = {\n    \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n    \"polyCode\": \"01010002\",\n    \"polyType\": \"huc8\",\n    \"max\": 2,\n}\n\nTNM.find_details(**params, offset=0)[\"items\"][0] == TNM.find_details(\n    **params, offset=1\n)[\"items\"][0]\n</pre> params = {     \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",     \"polyCode\": \"01010002\",     \"polyType\": \"huc8\",     \"max\": 2, }  TNM.find_details(**params, offset=0)[\"items\"][0] == TNM.find_details(     **params, offset=1 )[\"items\"][0] In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m In\u00a0[\u00a0]: Copied! <pre>region = m.user_roi_bounds()\nif region is None:\n    region = [-115.9689, 35.9758, -115.3619, 36.4721]\n</pre> region = m.user_roi_bounds() if region is None:     region = [-115.9689, 35.9758, -115.3619, 36.4721] In\u00a0[\u00a0]: Copied! <pre>TNM.find_details(q=\"LAZ\", bbox=region)[\"total\"]\n</pre> TNM.find_details(q=\"LAZ\", bbox=region)[\"total\"] In\u00a0[\u00a0]: Copied! <pre>bool(TNM.find_details(start=\"01-01-2010\", q=\"NED\", bbox=region))\n</pre> bool(TNM.find_details(start=\"01-01-2010\", q=\"NED\", bbox=region)) In\u00a0[\u00a0]: Copied! <pre>bool(TNM.find_details(start=\"2021-12-01\", end=\"2020-01-01\", q=\"NED\", bbox=region))\n</pre> bool(TNM.find_details(start=\"2021-12-01\", end=\"2020-01-01\", q=\"NED\", bbox=region)) In\u00a0[\u00a0]: Copied! <pre>bool(TNM.find_details(start=\"2021-12-01\", end=\"2022-01-01\", q=\"NED\", bbox=region))\n</pre> bool(TNM.find_details(start=\"2021-12-01\", end=\"2022-01-01\", q=\"NED\", bbox=region)) In\u00a0[\u00a0]: Copied! <pre>bool(\n    TNM.find_details(\n        start=\"2020-12-01\",\n        end=\"2022-01-01\",\n        q=\"NED\",\n        dateType=\"dateCreated\",\n        bbox=region,\n    )\n)\n</pre> bool(     TNM.find_details(         start=\"2020-12-01\",         end=\"2022-01-01\",         q=\"NED\",         dateType=\"dateCreated\",         bbox=region,     ) ) In\u00a0[\u00a0]: Copied! <pre>help(TNM.download_tiles)\n</pre> help(TNM.download_tiles) In\u00a0[\u00a0]: Copied! <pre>params = {\n    \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n    \"polyCode\": \"01010002\",\n    \"polyType\": \"huc8\",\n    \"max\": 0,\n}\n\nTNM.download_tiles(API=params)\n</pre> params = {     \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",     \"polyCode\": \"01010002\",     \"polyType\": \"huc8\",     \"max\": 0, }  TNM.download_tiles(API=params) <p>It can also be accessed without invoking the class.</p> In\u00a0[\u00a0]: Copied! <pre>params = {\n    \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n    \"polyCode\": \"01010002\",\n    \"polyType\": \"huc8\",\n    \"max\": 0,\n}\n\nleafmap.download_tnm(API=params)\n</pre> params = {     \"q\": \"National Elevation Dataset (NED) 1/3 arc-second\",     \"polyCode\": \"01010002\",     \"polyType\": \"huc8\",     \"max\": 0, }  leafmap.download_tnm(API=params) In\u00a0[\u00a0]: Copied! <pre>region = [-115.9689, 35.9758, -115.3619, 36.4721]\n\nleafmap.download_ned(region=region, return_url=True) == leafmap.download_tnm(\n    region=region, return_url=True, API={\"q\": \"NED\"}\n)\n</pre> region = [-115.9689, 35.9758, -115.3619, 36.4721]  leafmap.download_ned(region=region, return_url=True) == leafmap.download_tnm(     region=region, return_url=True, API={\"q\": \"NED\"} ) In\u00a0[\u00a0]: Copied! <pre>TNM.find_tiles(API=params)\n</pre> TNM.find_tiles(API=params) In\u00a0[\u00a0]: Copied! <pre>TNM.datasets_full[0]\n</pre> TNM.datasets_full[0] In\u00a0[\u00a0]: Copied! <pre>help(TNM)\n</pre> help(TNM)"},{"location":"notebooks/57_national_map/#downloading-various-shapes-from-the-national-map","title":"Downloading various shapes from the National Map\u00b6","text":"<p>The national map (TNM) is a catalog of topological datasources maintained by the USGS.</p> <ul> <li>It contains a wide range of dataformats (such as GeoTiff, LAZ, ...) and datasets.</li> <li>It provides an endpoint that can be used to search for published datasets and files.</li> <li>This API supports a wide range of searchable parameters (bounding box, polygon, dates, keyword, ...)</li> <li>It returns detailed information regarding the properties of datasets, file,</li> <li>as well as various download links (file, thumbnail, xml descriptions, ...).</li> </ul> <p>We've created a thin wrapper to expose this treasure trove.</p> <ul> <li>For more details about TNM, see https://apps.nationalmap.gov/tnmaccess/#/</li> <li>The same data is also downloable using https://apps.nationalmap.gov/downloader/</li> </ul>"},{"location":"notebooks/57_national_map/#usage","title":"Usage\u00b6","text":"<p>A class groups the functionalities together.</p>"},{"location":"notebooks/57_national_map/#datasets","title":"Datasets\u00b6","text":""},{"location":"notebooks/57_national_map/#formats","title":"Formats\u00b6","text":"<p>Note that any format (f.e. 'All') is specific to one or more datasets.</p>"},{"location":"notebooks/57_national_map/#looking-for-files","title":"Looking for files\u00b6","text":""},{"location":"notebooks/57_national_map/#a-detail","title":"A detail\u00b6","text":""},{"location":"notebooks/57_national_map/#using-parameters","title":"Using parameters\u00b6","text":""},{"location":"notebooks/57_national_map/#max-items","title":"Max items\u00b6","text":"<p>Defaults to about 50. You only retrieve about 1000 items in one call.</p>"},{"location":"notebooks/57_national_map/#select-a-region-from-leafmap","title":"Select a region from leafmap\u00b6","text":""},{"location":"notebooks/57_national_map/#error-handling","title":"Error handling\u00b6","text":""},{"location":"notebooks/57_national_map/#downloading-files","title":"Downloading files\u00b6","text":""},{"location":"notebooks/57_national_map/#list-of-files","title":"List of files\u00b6","text":""},{"location":"notebooks/57_national_map/#dataset-metadata","title":"Dataset metadata\u00b6","text":""},{"location":"notebooks/57_national_map/#read-the-docs","title":"Read the docs\u00b6","text":""},{"location":"notebooks/58_bokeh/","title":"58 bokeh","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[2]: Copied! <pre># !pip install bokeh jupyter_bokeh\n</pre> # !pip install bokeh jupyter_bokeh In\u00a0[3]: Copied! <pre>import leafmap.bokehmap as leafmap\n</pre> import leafmap.bokehmap as leafmap <p>Create an interactive map</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Loading BokehJS ... Out[4]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af1ed8a10&gt;</pre> <p>Specify center and zoom level</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4, height=400)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4, height=400) m Out[5]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af1e77150&gt;</pre> <p>Add basemaps</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m Out[6]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af1c135d0&gt;</pre> In\u00a0[7]: Copied! <pre># print(leafmap.basemaps.keys())\n</pre> # print(leafmap.basemaps.keys()) <p>Add COG</p> In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm.add_cog_layer(url)\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m.add_cog_layer(url) m Out[8]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af1dd4b10&gt;</pre> <p>Add STAC</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m Out[9]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af1c76cd0&gt;</pre> <p>Add local raster datasets</p> In\u00a0[10]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\nleafmap.download_file(url, \"dem.tif\")\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" leafmap.download_file(url, \"dem.tif\") <pre>dem.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[10]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif'</pre> In\u00a0[11]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"dem.tif\", colormap=\"terrain\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"dem.tif\", colormap=\"terrain\") m Out[11]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af13a5dd0&gt;</pre> <p>Add points</p> In\u00a0[12]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/leafmap/blob/master/examples/data/us_cities.geojson\"\nm.add_geojson(url, size=10, color=\"blue\", alpha=0.7)\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/leafmap/blob/master/examples/data/us_cities.geojson\" m.add_geojson(url, size=10, color=\"blue\", alpha=0.7) m <pre>BokehDeprecationWarning: 'circle() method with size value' was deprecated in Bokeh 3.4.0 and will be removed, use 'scatter(size=...) instead' instead.\n</pre> Out[12]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0ae8574990&gt;</pre> <p>Add lines</p> In\u00a0[13]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"CartoDB.DarkMatter\")\nurl = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\nm.add_vector(url, line_color=\"color\", line_width=2)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"CartoDB.DarkMatter\") url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" m.add_vector(url, line_color=\"color\", line_width=2) m Out[13]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0af138ff50&gt;</pre> <p>Add polygons</p> In\u00a0[14]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/leafmap/blob/master/examples/data/countries.geojson\"\nm.add_vector(url, fill_alpha=0.5, fill_color=\"lightblue\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/leafmap/blob/master/examples/data/countries.geojson\" m.add_vector(url, fill_alpha=0.5, fill_color=\"lightblue\") m Out[14]: <pre>&lt;leafmap.bokehmap.Map at 0x7f0ae21ca150&gt;</pre>"},{"location":"notebooks/59_create_legend/","title":"59 create legend","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Create a built-in draggable legend. Specify the <code>output</code> parameter to save the legend as an HTML file.</p> In\u00a0[3]: Copied! <pre>leafmap.create_legend(\n    title=\"NLCD Land Cover Type\",\n    builtin_legend=\"NLCD\",\n    draggable=True,\n    output=\"NLCD_legend.html\",\n)\n</pre> leafmap.create_legend(     title=\"NLCD Land Cover Type\",     builtin_legend=\"NLCD\",     draggable=True,     output=\"NLCD_legend.html\", ) <p>Create a built-in non-draggable legend. If the <code>output</code> parameter is not specified, the legend will be returned as an HTML string.</p> In\u00a0[4]: Copied! <pre>html = leafmap.create_legend(\n    title=\"NLCD Land Cover Type\",\n    builtin_legend=\"NLCD\",\n    draggable=False,\n    position=\"bottomright\",\n)\n</pre> html = leafmap.create_legend(     title=\"NLCD Land Cover Type\",     builtin_legend=\"NLCD\",     draggable=False,     position=\"bottomright\", ) In\u00a0[5]: Copied! <pre>widget = leafmap.show_html(html)\nwidget\n</pre> widget = leafmap.show_html(html) widget In\u00a0[6]: Copied! <pre>try:\n    widget.close()\nexcept:\n    pass\n</pre> try:     widget.close() except:     pass <p>Create a custom legend.</p> In\u00a0[7]: Copied! <pre>legend_dict = {\n    \"10 Trees\": \"006400\",\n    \"20 Shrubland\": \"ffbb22\",\n    \"30 Grassland\": \"ffff4c\",\n    \"40 Cropland\": \"f096ff\",\n    \"50 Built-up\": \"fa0000\",\n    \"60 Barren / sparse vegetation\": \"b4b4b4\",\n    \"70 Snow and ice\": \"f0f0f0\",\n    \"80 Open water\": \"0064c8\",\n    \"90 Herbaceous wetland\": \"0096a0\",\n    \"95 Mangroves\": \"00cf75\",\n    \"100 Moss and lichen\": \"fae6a0\",\n}\n</pre> legend_dict = {     \"10 Trees\": \"006400\",     \"20 Shrubland\": \"ffbb22\",     \"30 Grassland\": \"ffff4c\",     \"40 Cropland\": \"f096ff\",     \"50 Built-up\": \"fa0000\",     \"60 Barren / sparse vegetation\": \"b4b4b4\",     \"70 Snow and ice\": \"f0f0f0\",     \"80 Open water\": \"0064c8\",     \"90 Herbaceous wetland\": \"0096a0\",     \"95 Mangroves\": \"00cf75\",     \"100 Moss and lichen\": \"fae6a0\", } In\u00a0[8]: Copied! <pre>leafmap.create_legend(\n    title=\"ESA Land Cover Type\",\n    legend_dict=legend_dict,\n    draggable=False,\n    output=\"ESA_legend.html\",\n)\n</pre> leafmap.create_legend(     title=\"ESA Land Cover Type\",     legend_dict=legend_dict,     draggable=False,     output=\"ESA_legend.html\", ) <p>Customize the legend by specifying the <code>style</code> parameter.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"ESA WorldCover 2021\")\n\nstyle = {\n    \"position\": \"fixed\",\n    \"z-index\": \"9999\",\n    \"border\": \"2px solid grey\",\n    \"background-color\": \"rgba(255, 255, 255, 0.8)\",\n    \"border-radius\": \"10px\",\n    \"padding\": \"5px\",\n    \"font-size\": \"14px\",\n    \"bottom\": \"20px\",\n    \"right\": \"5px\",\n}\n\nm.add_legend(\n    title=\"ESA Land Cover Type\", legend_dict=legend_dict, draggable=False, style=style\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"ESA WorldCover 2021\")  style = {     \"position\": \"fixed\",     \"z-index\": \"9999\",     \"border\": \"2px solid grey\",     \"background-color\": \"rgba(255, 255, 255, 0.8)\",     \"border-radius\": \"10px\",     \"padding\": \"5px\",     \"font-size\": \"14px\",     \"bottom\": \"20px\",     \"right\": \"5px\", }  m.add_legend(     title=\"ESA Land Cover Type\", legend_dict=legend_dict, draggable=False, style=style ) m Out[9]: <p>Add a legend to the map.</p> In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"ESA WorldCover 2021\")\nm.add_legend(title=\"ESA Land Cover Type\", builtin_legend=\"ESA_WorldCover\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"ESA WorldCover 2021\") m.add_legend(title=\"ESA Land Cover Type\", builtin_legend=\"ESA_WorldCover\") m Out[10]: <p>Add legends to a split-view map. Make sure the <code>draggable</code> parameter is set to <code>False</code>.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map(\n    center=[40, -100],\n    zoom=4,\n    draw_control=False,\n    measure_control=False,\n    scale_control=False,\n)\nm.split_map(left_layer=\"ESA WorldCover 2021\", right_layer=\"NLCD 2019 CONUS Land Cover\")\nm.add_legend(\n    title=\"ESA Land Cover Type\",\n    builtin_legend=\"ESA_WorldCover\",\n    draggable=False,\n    position=\"bottomleft\",\n    style={\"bottom\": \"5px\"},\n)\nm.add_legend(\n    title=\"NLCD Land Cover Type\",\n    builtin_legend=\"NLCD\",\n    draggable=False,\n    position=\"bottomright\",\n)\nm\n</pre> m = leafmap.Map(     center=[40, -100],     zoom=4,     draw_control=False,     measure_control=False,     scale_control=False, ) m.split_map(left_layer=\"ESA WorldCover 2021\", right_layer=\"NLCD 2019 CONUS Land Cover\") m.add_legend(     title=\"ESA Land Cover Type\",     builtin_legend=\"ESA_WorldCover\",     draggable=False,     position=\"bottomleft\",     style={\"bottom\": \"5px\"}, ) m.add_legend(     title=\"NLCD Land Cover Type\",     builtin_legend=\"NLCD\",     draggable=False,     position=\"bottomright\", ) m Out[11]:"},{"location":"notebooks/60_add_widget/","title":"60 add widget","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add text.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\ntext = \"Hello World\"\nm.add_text(text, position=\"bottomright\")\nm\n</pre> m = leafmap.Map() text = \"Hello World\" m.add_text(text, position=\"bottomright\") m Out[3]: <p>Customize text style.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\ntext = \"Hello World\"\n\nparams = {\n    \"fontsize\": 30,\n    \"fontcolor\": \"blue\",\n    \"bold\": True,\n    \"padding\": \"10px\",\n    \"background\": True,\n    \"bg_color\": \"white\",\n    \"border_radius\": \"5px\",\n    \"position\": \"bottomright\",\n}\n\nm.add_text(text, **params)\nm\n</pre> m = leafmap.Map() text = \"Hello World\"  params = {     \"fontsize\": 30,     \"fontcolor\": \"blue\",     \"bold\": True,     \"padding\": \"10px\",     \"background\": True,     \"bg_color\": \"white\",     \"border_radius\": \"5px\",     \"position\": \"bottomright\", }  m.add_text(text, **params) m Out[4]: In\u00a0[5]: Copied! <pre>m = leafmap.Map(measure_control=False, scale_control=False)\nleft = \"ESA WorldCover 2021 S2 FCC\"\nright = \"ESA WorldCover 2021 S2 TCC\"\nm.split_map(left_layer=left, right_layer=right)\nm.add_text(left, position=\"bottomleft\")\nm.add_text(right, position=\"bottomright\")\nm\n</pre> m = leafmap.Map(measure_control=False, scale_control=False) left = \"ESA WorldCover 2021 S2 FCC\" right = \"ESA WorldCover 2021 S2 TCC\" m.split_map(left_layer=left, right_layer=right) m.add_text(left, position=\"bottomleft\") m.add_text(right, position=\"bottomright\") m Out[5]: <p>Add image.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nimage = \"https://i.imgur.com/LmTETPX.png\"\nm.add_image(image, position=\"bottomright\")\nm\n</pre> m = leafmap.Map() image = \"https://i.imgur.com/LmTETPX.png\" m.add_image(image, position=\"bottomright\") m Out[6]: <p>Add HTML.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nhtml = \"\"\"\n&lt;h2&gt;Jupyter Logo&lt;/h2&gt;\n&lt;img src=\"https://i.imgur.com/LmTETPX.png\"&gt;\n\"\"\"\nm.add_html(html, position=\"bottomright\")\nm\n</pre> m = leafmap.Map() html = \"\"\" Jupyter Logo  \"\"\" m.add_html(html, position=\"bottomright\") m Out[7]: <p>Add widget.</p> In\u00a0[8]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n</pre> import numpy as np import matplotlib.pyplot as plt In\u00a0[9]: Copied! <pre># Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots(figsize=(4, 3))\nax.plot(t, s)\n\nax.set(\n    xlabel=\"time (s)\", ylabel=\"voltage (mV)\", title=\"About as simple as it gets, folks\"\n)\nax.grid()\n</pre> # Data for plotting t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2 * np.pi * t)  fig, ax = plt.subplots(figsize=(4, 3)) ax.plot(t, s)  ax.set(     xlabel=\"time (s)\", ylabel=\"voltage (mV)\", title=\"About as simple as it gets, folks\" ) ax.grid() In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nm.add_widget(fig, position=\"bottomright\")\nm\n</pre> m = leafmap.Map() m.add_widget(fig, position=\"bottomright\") m Out[10]:"},{"location":"notebooks/61_vector_to_gif/","title":"61 vector to gif","text":"<p>Creating animated GIF from vector data</p> <p>Inspired by Johannes Uhl's shapefile2gif, I created a <code>vector_to_gif()</code> function in leafmap that makes it much easier to create animated GIF from vector data with only one line of code. The sample dataset used in this notebook is a subset of the dataset retrieved from the shapefile2gif repo. Credits to Johannes Uhl. For more information about the datasets, check out the references below:</p> <ul> <li>Uhl, Johannes H; Leyk, Stefan (2022), \"MTBF-33: A multi-temporal building footprint dataset for 33 counties in the United States (1900\u20132015)\", Data in Brief, 43, 108369. DOI: 10.1016/j.dib.2022.108369</li> <li>Uhl, Johannes H; Leyk, Stefan (2022), \u201cMTBF-33: A multi-temporal building footprint dataset for 33 U.S. counties at annual resolution (1900-2015)\u201d, Mendeley Data, V2. DOI: 10.17632/w33vbvjtdy.2</li> </ul> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre># A subset of the dataset retrieved from https://github.com/johannesuhl/shapefile2gif\ndata = \"https://open.gishub.org/data/us/boulder_buildings.zip\"\n</pre> # A subset of the dataset retrieved from https://github.com/johannesuhl/shapefile2gif data = \"https://open.gishub.org/data/us/boulder_buildings.zip\" In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[39.9898, -105.2532], zoom=14)\nm.add_vector(data, layer_name=\"Buildings\")\nm\n</pre> m = leafmap.Map(center=[39.9898, -105.2532], zoom=14) m.add_vector(data, layer_name=\"Buildings\") m Out[4]: In\u00a0[5]: Copied! <pre>out_gif = \"buildings.gif\"\ncolname = \"year_built\"\ntitle = \"Building Evolution in Boulder, Colorado, USA (1950-2015)\"\n</pre> out_gif = \"buildings.gif\" colname = \"year_built\" title = \"Building Evolution in Boulder, Colorado, USA (1950-2015)\" In\u00a0[6]: Copied! <pre>leafmap.vector_to_gif(\n    data,\n    out_gif,\n    colname,\n    vmin=1950,\n    vmax=2015,\n    step=10,\n    facecolor=\"black\",\n    figsize=(10, 8),\n    title=title,\n    xy=(\"1%\", \"1%\"),\n    fontsize=20,\n    progress_bar_color=\"blue\",\n    progress_bar_height=10,\n    dpi=300,\n    fps=10,\n    mp4=False,\n    verbose=True,\n)\n</pre> leafmap.vector_to_gif(     data,     out_gif,     colname,     vmin=1950,     vmax=2015,     step=10,     facecolor=\"black\",     figsize=(10, 8),     title=title,     xy=(\"1%\", \"1%\"),     fontsize=20,     progress_bar_color=\"blue\",     progress_bar_height=10,     dpi=300,     fps=10,     mp4=False,     verbose=True, ) <pre>Processing 1/8: 1950...\n</pre> <pre>Processing 2/8: 1960...\n</pre> <pre>Processing 3/8: 1970...\n</pre> <pre>Processing 4/8: 1980...\n</pre> <pre>Processing 5/8: 1990...\n</pre> <pre>Processing 6/8: 2000...\n</pre> <pre>Processing 7/8: 2010...\n</pre> <pre>Processing 8/8: 2020...\n</pre> <pre>Done. The GIF is saved to buildings.gif.\n</pre> <p></p>"},{"location":"notebooks/62_folium_colorbar/","title":"62 folium colorbar","text":"<p>Adding colorbars to a folium map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Unlike the ipyleaflet plotting backend, folium does not support adding matplotlib colormap directly. One workaround is to save the maplotlib colormap as an image, then add the image to the map. Let's first create a colormap.</p> <p>Create a colormap using specified parameters.</p> In\u00a0[2]: Copied! <pre>params = {\n    \"width\": 4.0,\n    \"height\": 0.3,\n    \"vmin\": 0,\n    \"vmax\": 6000,\n    \"cmap\": \"terrain\",\n    \"label\": \"Elevation (m)\",\n    \"orientation\": \"horizontal\",\n    \"transparent\": False,\n}\n</pre> params = {     \"width\": 4.0,     \"height\": 0.3,     \"vmin\": 0,     \"vmax\": 6000,     \"cmap\": \"terrain\",     \"label\": \"Elevation (m)\",     \"orientation\": \"horizontal\",     \"transparent\": False, } <p>Save the colormap as an image.</p> In\u00a0[3]: Copied! <pre>leafmap.save_colorbar(\"colorbar.png\", **params)\n</pre> leafmap.save_colorbar(\"colorbar.png\", **params) Out[3]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/colorbar.png'</pre> <p>You can also create use the <code>m.add_colormap()</code> method to add a colormap. Under the hood, it generate a colormap as an image, then add it to the map. You need to specified the position of the colormap using a tuple (x, y), which represents the percentage [0-100] from the lower-left corner. If the map size changes, you might need to change the colormap position as well.</p> <p>Add a horizontal colormap to the map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(position=(55, 5), **params)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(position=(55, 5), **params) m Out[4]: <p>Make the colormap background transparent.</p> In\u00a0[5]: Copied! <pre>params[\"transparent\"] = True\n</pre> params[\"transparent\"] = True In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(position=(55, 5), **params)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(position=(55, 5), **params) m Out[6]: <p>Change the orientation to vertical.</p> In\u00a0[7]: Copied! <pre>params = {\n    \"width\": 0.3,\n    \"height\": 4,\n    \"vmin\": 0,\n    \"vmax\": 6000,\n    \"cmap\": \"terrain\",\n    \"label\": \"Elevation (m)\",\n    \"orientation\": \"vertical\",\n    \"transparent\": False,\n}\n</pre> params = {     \"width\": 0.3,     \"height\": 4,     \"vmin\": 0,     \"vmax\": 6000,     \"cmap\": \"terrain\",     \"label\": \"Elevation (m)\",     \"orientation\": \"vertical\",     \"transparent\": False, } In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(position=(85, 5), **params)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(position=(85, 5), **params) m Out[8]: <p>To make the colormap position fixed at four corners (i.e., <code>bottomright</code>, <code>bottomleft</code>, <code>topright</code>, <code>topleft</code>), you need to make the image available through an HTTP URL (e.g., imgur). Local file paths are not supported. Use <code>m.add_image()</code> to add the colormap image to the map.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nimage = \"https://i.imgur.com/SpmE7Cs.png\"\nm.add_image(image, position=\"bottomright\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") image = \"https://i.imgur.com/SpmE7Cs.png\" m.add_image(image, position=\"bottomright\") m Out[9]: <p></p>"},{"location":"notebooks/63_arcgis/","title":"63 arcgis","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Add basemap.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"TERRAIN\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"TERRAIN\") m <pre>Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\n</pre> Out[3]: <p>Add COG layer.</p> In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n</pre> url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" In\u00a0[5]: Copied! <pre>m.add_cog_layer(url, name=\"COG\")\n</pre> m.add_cog_layer(url, name=\"COG\") <p>Add STAC layer.</p> In\u00a0[6]: Copied! <pre>url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n</pre> url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" In\u00a0[7]: Copied! <pre>m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"STAC\")\n</pre> m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"STAC\") <p></p>"},{"location":"notebooks/64_stac_search/","title":"64 stac search","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre>url = \"https://earth-search.aws.element84.com/v1/\"\ncollection = \"sentinel-2-l2a\"\ntime_range = \"2020-12-01/2020-12-31\"\nbbox = [-122.2751, 47.5469, -121.9613, 47.7458]\n</pre> url = \"https://earth-search.aws.element84.com/v1/\" collection = \"sentinel-2-l2a\" time_range = \"2020-12-01/2020-12-31\" bbox = [-122.2751, 47.5469, -121.9613, 47.7458] In\u00a0[4]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n    sortby=[{\"field\": \"properties.eo:cloud_cover\", \"direction\": \"asc\"}],\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     query={\"eo:cloud_cover\": {\"lt\": 10}},     sortby=[{\"field\": \"properties.eo:cloud_cover\", \"direction\": \"asc\"}], ) search Out[4]: <pre>&lt;pystac_client.item_search.ItemSearch at 0x7f9bd2bb43d0&gt;</pre> In\u00a0[5]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_collection=True,\n)\n# search\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_collection=True, ) # search In\u00a0[6]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_gdf=True,\n)\nsearch.head()\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_gdf=True, ) search.head() Out[6]: geometry created platform constellation instruments eo:cloud_cover proj:epsg mgrs:utm_zone mgrs:latitude_band mgrs:grid_square ... s2:datastrip_id s2:granule_id s2:reflectance_conversion_factor datetime s2:sequence earthsearch:s3_path earthsearch:payload_id earthsearch:boa_offset_applied processing:software updated 0 POLYGON ((-123.00025 47.85369, -121.53274 47.8... 2022-11-06T15:26:41.911Z sentinel-2b sentinel-2 [msi] 64.642105 32610 10 T ET ... S2B_OPER_MSI_L2A_DS_EPAE_20201231T212743_S2020... S2B_OPER_MSI_L2A_TL_EPAE_20201231T212743_A0199... 1.034125 2020-12-31T19:21:21.475000Z 0 s3://sentinel-cogs/sentinel-s2-l2a-cogs/10/T/E... roda-sentinel2/workflow-sentinel2-to-stac/6658... False {'sentinel2-to-stac': '0.1.0'} 2022-11-06T15:26:41.911Z 1 POLYGON ((-123.00025 47.85369, -123.00025 46.8... 2023-08-18T22:50:02.992Z sentinel-2b sentinel-2 [msi] 83.644599 32610 10 T ET ... S2B_OPER_MSI_L2A_DS_S2RP_20230304T134741_S2020... S2B_OPER_MSI_L2A_TL_S2RP_20230304T134741_A0199... 1.034125 2020-12-31T19:21:21.474000Z 1 s3://sentinel-cogs/sentinel-s2-l2a-cogs/10/T/E... roda-sentinel2/workflow-sentinel2-to-stac/81d2... True {'sentinel2-to-stac': '0.1.1'} 2023-08-18T22:50:02.992Z 2 POLYGON ((-122.78713 47.85350, -123.00025 47.2... 2023-08-20T03:19:26.086Z sentinel-2b sentinel-2 [msi] 21.615067 32610 10 T ET ... S2B_OPER_MSI_L2A_DS_S2RP_20230304T070956_S2020... S2B_OPER_MSI_L2A_TL_S2RP_20230304T070956_A0199... 1.033888 2020-12-28T19:11:24.522000Z 1 s3://sentinel-cogs/sentinel-s2-l2a-cogs/10/T/E... roda-sentinel2/workflow-sentinel2-to-stac/818b... True {'sentinel2-to-stac': '0.1.1'} 2023-08-20T03:19:26.086Z 3 POLYGON ((-122.79462 47.85351, -121.53274 47.8... 2022-11-06T15:29:35.737Z sentinel-2b sentinel-2 [msi] 22.943574 32610 10 T ET ... S2B_OPER_MSI_L2A_DS_EPAE_20201228T211944_S2020... S2B_OPER_MSI_L2A_TL_EPAE_20201228T211944_A0199... 1.033888 2020-12-28T19:11:24.522000Z 0 s3://sentinel-cogs/sentinel-s2-l2a-cogs/10/T/E... roda-sentinel2/workflow-sentinel2-to-stac/e6b4... False {'sentinel2-to-stac': '0.1.0'} 2022-11-06T15:29:35.737Z 4 POLYGON ((-123.00025 47.85369, -123.00025 46.8... 2023-07-18T07:29:04.662Z sentinel-2a sentinel-2 [msi] 98.842812 32610 10 T ET ... S2A_OPER_MSI_L2A_DS_S2RP_20230305T133645_S2020... S2A_OPER_MSI_L2A_TL_S2RP_20230305T133645_A0287... 1.033680 2020-12-26T19:21:22.739000Z 1 s3://sentinel-cogs/sentinel-s2-l2a-cogs/10/T/E... roda-sentinel2/workflow-sentinel2-to-stac/8387... True {'sentinel2-to-stac': '0.1.1'} 2023-07-18T07:29:04.662Z <p>5 rows \u00d7 42 columns</p> In\u00a0[7]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_assets=True,\n)\n# search\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_assets=True, ) # search In\u00a0[8]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_info=True,\n)\n# search\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_info=True, ) # search In\u00a0[9]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_links=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_links=True, ) search Out[9]: <pre>['https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201231_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201231_1_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201228_1_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201228_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_10TET_20201226_1_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_10TET_20201226_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_10TET_20201223_1_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_10TET_20201223_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201221_1_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10TET_20201221_0_L2A']</pre> <p>Search and visualize open geospatial dataset interactively</p> In\u00a0[10]: Copied! <pre>leafmap.show_youtube_video(\"https://youtu.be/7OEraGYOWiU\")\n</pre> leafmap.show_youtube_video(\"https://youtu.be/7OEraGYOWiU\") Out[10]: In\u00a0[11]: Copied! <pre>m = leafmap.Map(center=[37.7517, -122.4433], zoom=8)\nm\n</pre> m = leafmap.Map(center=[37.7517, -122.4433], zoom=8) m Out[11]: <p>The search results can be accessed using one of the following methods:</p> In\u00a0[12]: Copied! <pre># m.stac_gdf  # The GeoDataFrame of the STAC search results\n</pre> # m.stac_gdf  # The GeoDataFrame of the STAC search results In\u00a0[13]: Copied! <pre># m.stac_dict  # The STAC search results as a dictionary\n</pre> # m.stac_dict  # The STAC search results as a dictionary In\u00a0[14]: Copied! <pre># m.stac_item  # The selected STAC item of the search result\n</pre> # m.stac_item  # The selected STAC item of the search result"},{"location":"notebooks/65_sagemaker/","title":"65 sagemaker","text":"In\u00a0[1]: Copied! <pre># %pip install --find-links=https://girder.github.io/large_image_wheels --no-cache GDAL\n</pre> # %pip install --find-links=https://girder.github.io/large_image_wheels --no-cache GDAL In\u00a0[2]: Copied! <pre># pip install leafmap localtileserver matplotlib==3.6.3 folium==0.13.0\n</pre> # pip install leafmap localtileserver matplotlib==3.6.3 folium==0.13.0 <p>Restart the kernel after installing the packages.</p> In\u00a0[3]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Download a sample raster dataset.</p> In\u00a0[4]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\nleafmap.download_file(url, \"dem.tif\")\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" leafmap.download_file(url, \"dem.tif\") <pre>dem.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[4]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/dem.tif'</pre> <p>Create an interactive map.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"Local Raster\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"Local Raster\") m Out[5]: <p>Create a split-view map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.split_map(\n    left_layer=\"dem.tif\", right_layer=\"dem.tif\", right_args={\"palette\": \"terrain\"}\n)\nm\n</pre> m = leafmap.Map() m.split_map(     left_layer=\"dem.tif\", right_layer=\"dem.tif\", right_args={\"palette\": \"terrain\"} ) m Out[6]: In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nm.add_cog_layer(url, name=\"COG\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" m.add_cog_layer(url, name=\"COG\") m Out[7]: In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm.split_map(left_layer=url, right_layer=url2)\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m.split_map(left_layer=url, right_layer=url2) m Out[8]: In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\")\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\") m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m Out[9]:"},{"location":"notebooks/65_sagemaker/#install-packages","title":"Install packages\u00b6","text":"<p>Uncomment the following code blocks to install GDAL, leafmap, and localtileserver on SageMaker Studio Lab.</p>"},{"location":"notebooks/65_sagemaker/#import-libraries","title":"Import libraries\u00b6","text":"<p>ipyleaflet currently does not work on SageMAker Studio Lab. See this issue. We can use the folium plotting backend instead.</p>"},{"location":"notebooks/65_sagemaker/#visualize-local-raster-data","title":"Visualize local raster data\u00b6","text":""},{"location":"notebooks/65_sagemaker/#visualize-cloud-optimized-geotiff-cog","title":"Visualize Cloud Optimized GeoTIFF (COG)\u00b6","text":""},{"location":"notebooks/65_sagemaker/#visualize-spatiotemporal-asset-catalog-stac-items","title":"Visualize SpatioTemporal Asset Catalog (STAC) Items\u00b6","text":""},{"location":"notebooks/66_gradio/","title":"66 gradio","text":"<p>Developing interactive web apps with gradio and leafmap</p> <p>Gradio: https://gradio.app</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[2]: Copied! <pre>import gradio as gr\nimport leafmap.foliumap as leafmap\n\n\ndef split(left, right):\n    m = leafmap.Map()\n    m.split_map(left_layer=left, right_layer=right)\n    return m.to_gradio()\n\n\nleft_url = (\n    \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n)\nright_url = (\n    \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n)\nleft_input = gr.Textbox(value=left_url, label=\"Left Layer URL\")\nright_input = gr.Textbox(value=right_url, label=\"Right Layer URL\")\n\ndemo = gr.Interface(split, [left_input, right_input], \"html\")\n# demo.launch()\n</pre> import gradio as gr import leafmap.foliumap as leafmap   def split(left, right):     m = leafmap.Map()     m.split_map(left_layer=left, right_layer=right)     return m.to_gradio()   left_url = (     \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" ) right_url = (     \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" ) left_input = gr.Textbox(value=left_url, label=\"Left Layer URL\") right_input = gr.Textbox(value=right_url, label=\"Right Layer URL\")  demo = gr.Interface(split, [left_input, right_input], \"html\") # demo.launch() <p></p> In\u00a0[3]: Copied! <pre>import gradio as gr\nimport leafmap.plotlymap as leafmap\n\n\ndef viz_cog(url):\n    m = leafmap.Map()\n    m.add_cog_layer(url)\n    return m\n\n\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n\ndemo = gr.Interface(\n    fn=viz_cog,\n    inputs=gr.Text(value=url, label=\"Enter a COG URL\"),\n    outputs=gr.Plot(),\n)\n# demo.launch()\n</pre> import gradio as gr import leafmap.plotlymap as leafmap   def viz_cog(url):     m = leafmap.Map()     m.add_cog_layer(url)     return m   url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"  demo = gr.Interface(     fn=viz_cog,     inputs=gr.Text(value=url, label=\"Enter a COG URL\"),     outputs=gr.Plot(), ) # demo.launch() <p></p>"},{"location":"notebooks/66_gradio/#folium-backend","title":"Folium backend\u00b6","text":""},{"location":"notebooks/66_gradio/#plotly-backend","title":"Plotly backend\u00b6","text":""},{"location":"notebooks/67_maxar_open_data/","title":"67 maxar open data","text":"<p>Visualizing Maxar Open Data with Leafmap</p> <p>The Maxar Open Data Program provides pre- and post-event high-resolution satellite imagery in support of emergency planning, risk assessment, monitoring of staging areas and emergency response, damage assessment, and recovery. Check out the links below for more information.</p> <ul> <li>Maxar Open Data Program</li> <li>Maxar Open Data on AWS</li> <li>Maxar Open Data on STAC Index</li> <li>Maxar Open Data on STAC Browser</li> </ul> <p>The Maxar Open Data STAC catalog URL is: https://maxar-opendata.s3.amazonaws.com/events/catalog.json</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U leafmap\n</pre> # !pip install -U leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Retrieve all collections from the Maxar Open Data STAC catalog. Each collection represents a single event.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.maxar_collections()\n</pre> leafmap.maxar_collections() <p>Retrieve all collections for a specific event:</p> In\u00a0[\u00a0]: Copied! <pre>collections = leafmap.maxar_child_collections(\"Kahramanmaras-turkey-earthquake-23\")\nprint(f\"The number of collections: {len(collections)}\")\n</pre> collections = leafmap.maxar_child_collections(\"Kahramanmaras-turkey-earthquake-23\") print(f\"The number of collections: {len(collections)}\") In\u00a0[\u00a0]: Copied! <pre>collections[:5]\n</pre> collections[:5] <p>Retrieve all items (tiles) for a specific collection and generate the footprints:</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.maxar_items(\n    collection_id=\"Kahramanmaras-turkey-earthquake-23\",\n    child_id=\"1050050044DE7E00\",\n    return_gdf=True,\n    assets=[\"visual\"],\n)\ngdf.head()\n</pre> gdf = leafmap.maxar_items(     collection_id=\"Kahramanmaras-turkey-earthquake-23\",     child_id=\"1050050044DE7E00\",     return_gdf=True,     assets=[\"visual\"], ) gdf.head() <p>Add the footprints to the map:</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Footprints\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Footprints\") m <p>Retrieve the COG URLs for all tiles in a collection:</p> In\u00a0[\u00a0]: Copied! <pre>images = gdf[\"visual\"].tolist()\nimages[:5]\n</pre> images = gdf[\"visual\"].tolist() images[:5] <p>Create a mosaic json file for the collection. You need to install <code>cogeo-mosaic</code> first using <code>pip install cogeo-mosaic</code>. Creating a mosaic json file might take a few minutes. Please be patient.</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.create_mosaicjson(images, output='1050050044DE7E00.json')\n</pre> # leafmap.create_mosaicjson(images, output='1050050044DE7E00.json') <p>Make the mosaic json file available on the web, then you can add the mosaic to the map:</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://geospatial.glitch.me/1050050044DE7E00.json\"\nm.add_stac_layer(url, name=\"Mosaic\")\nm.add_gdf(gdf, layer_name=\"Footprints\")\nm\n</pre> m = leafmap.Map() url = \"https://geospatial.glitch.me/1050050044DE7E00.json\" m.add_stac_layer(url, name=\"Mosaic\") m.add_gdf(gdf, layer_name=\"Footprints\") m <p>Retrieve the footprint of all tiles for a specific event. This might take 15+ minutes. Please be patient.</p> In\u00a0[\u00a0]: Copied! <pre># gdf = leafmap.maxar_all_items(\n#     collection_id='Kahramanmaras-turkey-earthquake-23',\n#     return_gdf=True,\n#     verbose=True\n#     )\n# gdf.to_file('maxar_footprints.geojson', driver='GeoJSON')\n# gdf\n</pre> # gdf = leafmap.maxar_all_items( #     collection_id='Kahramanmaras-turkey-earthquake-23', #     return_gdf=True, #     verbose=True #     ) # gdf.to_file('maxar_footprints.geojson', driver='GeoJSON') # gdf <p>Add the footprints to the map:</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[36.844461, 37.386475], zoom=8)\n# m.add_gdf(gdf, layer_name=\"Footprints\")\nurl = \"https://cdn.glitch.global/cc5b7737-d8d0-4b07-bf2f-867b9009e986/maxar_footprints.geojson?v=1676583955698\"\nm.add_geojson(url, layer_name=\"Footprints\")\nm\n</pre> m = leafmap.Map(center=[36.844461, 37.386475], zoom=8) # m.add_gdf(gdf, layer_name=\"Footprints\") url = \"https://cdn.glitch.global/cc5b7737-d8d0-4b07-bf2f-867b9009e986/maxar_footprints.geojson?v=1676583955698\" m.add_geojson(url, layer_name=\"Footprints\") m"},{"location":"notebooks/68_openaerialmap/","title":"68 openaerialmap","text":"<p>Searching and visualizing OpenAerialMap imagery interactively</p> <p>OpenAerialMap (OAM) provides openly licensed satellite and unmanned aerial vehicle (UAV) imagery. Currently, it has over 12,400+ images around the globe. This notebook demonstrates how to search and visualize OAM imagery interactively. You can download images automatically with one line of code.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Search OAM images by a bounding box and a date range. The results can be returned as a GeoDataFrame or a list of image metadata.</p> In\u00a0[2]: Copied! <pre>bbox = [-79.6344, -0.9063, -77.3383, 1.0436]\nstart_date = \"2016-04-01\"\nend_date = \"2016-04-30\"\ngdf = leafmap.oam_search(\n    bbox=bbox, start_date=start_date, end_date=end_date, return_gdf=True\n)\nprint(f\"Found {len(gdf)} images\")\n</pre> bbox = [-79.6344, -0.9063, -77.3383, 1.0436] start_date = \"2016-04-01\" end_date = \"2016-04-30\" gdf = leafmap.oam_search(     bbox=bbox, start_date=start_date, end_date=end_date, return_gdf=True ) print(f\"Found {len(gdf)} images\") <pre>Found 55 images\n</pre> In\u00a0[3]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[3]: geometry _id uuid __v title gsd file_size acquisition_start acquisition_end platform provider contact sensor thumbnail tms wmts uploaded_at meta_uri bbox 0 POLYGON ((-78.10058 0.03903, -78.10058 0.22225... 59e62b7e3d6412ef72209701 http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... 0 Planet Labs PlanetScope Ecuador Earthquake 3 3144604 2016-04-20T00:00:00.000Z 2016-04-20T23:30:00.000Z satellite Planet Labs Erika Reinhardt,erika@planet.com PlanetScope http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... http://tiles.openaerialmap.org/571e5c7fcd0663b... http://tiles.openaerialmap.org/571e5c7fcd0663b... 2016-04-25T00:00:00.000Z http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... [-78.10058445823623, 0.03902710389879522, -77.... 1 POLYGON ((-78.20509 -0.11029, -78.20509 0.0732... 59e62b7e3d6412ef7220970b http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... 0 Planet Labs PlanetScope Ecuador Earthquake 3 3831430 2016-04-20T00:00:00.000Z 2016-04-20T23:30:00.000Z satellite Planet Labs Erika Reinhardt,erika@planet.com PlanetScope http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... http://tiles.openaerialmap.org/571e5c7fcd0663b... http://tiles.openaerialmap.org/571e5c7fcd0663b... 2016-04-25T00:00:00.000Z http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... [-78.20508551319601, -0.11029022565691535, -78... 2 POLYGON ((-78.15366 -0.03562, -78.15366 0.1479... 59e62b7d3d6412ef7220968d http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... 0 Planet Labs PlanetScope Ecuador Earthquake 3 3812140 2016-04-20T00:00:00.000Z 2016-04-20T23:30:00.000Z satellite Planet Labs Erika Reinhardt,erika@planet.com PlanetScope http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... http://tiles.openaerialmap.org/571e5c7fcd0663b... http://tiles.openaerialmap.org/571e5c7fcd0663b... 2016-04-25T00:00:00.000Z http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... [-78.15365598124903, -0.03562021446422918, -77... 3 POLYGON ((-78.58833 -0.65642, -78.58833 -0.472... 59e62b7e3d6412ef722096dc http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... 0 Planet Labs PlanetScope Ecuador Earthquake 3 3248739 2016-04-20T00:00:00.000Z 2016-04-20T23:30:00.000Z satellite Planet Labs Erika Reinhardt,erika@planet.com PlanetScope http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... http://tiles.openaerialmap.org/571e5c7fcd0663b... http://tiles.openaerialmap.org/571e5c7fcd0663b... 2016-04-25T00:00:00.000Z http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... [-78.58833199002822, -0.6564207526726079, -78.... 4 POLYGON ((-78.69573 -0.81214, -78.69573 -0.628... 59e62b7d3d6412ef722096a0 http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... 0 Planet Labs PlanetScope Ecuador Earthquake 3 2777837 2016-04-20T00:00:00.000Z 2016-04-20T23:30:00.000Z satellite Planet Labs Erika Reinhardt,erika@planet.com PlanetScope http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... http://tiles.openaerialmap.org/571e5c7fcd0663b... http://tiles.openaerialmap.org/571e5c7fcd0663b... 2016-04-25T00:00:00.000Z http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0... [-78.69572836359227, -0.8121394423861734, -78.... <p>The tile URLs are stored in the <code>tms</code> column of the GeoDataFrame.</p> In\u00a0[4]: Copied! <pre>tiles = gdf[\"tms\"].tolist()\ntiles[:5]\n</pre> tiles = gdf[\"tms\"].tolist() tiles[:5] Out[4]: <pre>['http://tiles.openaerialmap.org/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb43/{z}/{x}/{y}.png',\n 'http://tiles.openaerialmap.org/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb46/{z}/{x}/{y}.png',\n 'http://tiles.openaerialmap.org/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb29/{z}/{x}/{y}.png',\n 'http://tiles.openaerialmap.org/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb3b/{z}/{x}/{y}.png',\n 'http://tiles.openaerialmap.org/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb2d/{z}/{x}/{y}.png']</pre> <p>The image sources (downloadable URLs) are stored in the <code>uuid</code> column of the GeoDataFrame.</p> In\u00a0[5]: Copied! <pre>images = gdf[\"uuid\"].tolist()\nimages[:5]\n</pre> images = gdf[\"uuid\"].tolist() images[:5] Out[5]: <pre>['http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb43.tif',\n 'http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb46.tif',\n 'http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb29.tif',\n 'http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb3b.tif',\n 'http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb2d.tif']</pre> <p>Download all images using the <code>download_files()</code> function.</p> In\u00a0[6]: Copied! <pre>leafmap.download_files(images[:2])\n</pre> leafmap.download_files(images[:2]) <pre>Downloading...\nFrom: http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb43.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/571e60322b67227a79b4fb43.tif\n</pre> <pre>\r  0%|          | 0.00/3.14M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3.14M/3.14M [00:00&lt;00:00, 73.2MB/s]</pre> <pre>\nDownloading...\nFrom: http://oin-hotosm.s3.amazonaws.com/571e5c7fcd0663bb003c31f9/0/571e60322b67227a79b4fb46.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/571e60322b67227a79b4fb46.tif\n</pre> <pre>\r  0%|          | 0.00/3.83M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3.83M/3.83M [00:00&lt;00:00, 70.6MB/s]</pre> <pre>\n</pre> <p>Add the image footprints to the map.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Footprints\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Footprints\") m Out[7]: <p>Search OAM imagery within the current map extent or user drawn ROI.</p> In\u00a0[8]: Copied! <pre>m = leafmap.Map(center=[4.7955, -75.6899], zoom=15)\nm.add_basemap(\"SATELLITE\", show=False)\n\nbbox = [-75.7138, 4.7826, -75.6659, 4.808332]\nm.oam_search(bbox=bbox)\n\nm\n</pre> m = leafmap.Map(center=[4.7955, -75.6899], zoom=15) m.add_basemap(\"SATELLITE\", show=False)  bbox = [-75.7138, 4.7826, -75.6659, 4.808332] m.oam_search(bbox=bbox)  m <pre>Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\nFound 8 images. \nShowing the first 5.\n</pre> Out[8]: <p>Search OAM imagery interactively using the interactive GUI.</p> In\u00a0[9]: Copied! <pre>m = leafmap.Map(center=[4.7955, -75.6899], zoom=15)\nm\n</pre> m = leafmap.Map(center=[4.7955, -75.6899], zoom=15) m Out[9]: <p></p>"},{"location":"notebooks/69_turkey_earthquake/","title":"69 turkey earthquake","text":"<p>Visualizing Maxar Open Data for the 2023 Turkey-Syria Earthquake</p> <p>The Maxar Open Data Program provides pre- and post-event high-resolution satellite imagery in support of emergency planning, risk assessment, monitoring of staging areas and emergency response, damage assessment, and recovery. Check out the links below for more information.</p> <ul> <li>Maxar Open Data Program</li> <li>Maxar Open Data on AWS</li> <li>Maxar Open Data on STAC Index</li> <li>Maxar Open Data on STAC Browser</li> <li>Maxar Open Data in CSV, GeoJSON, and MosaicJSON formats</li> </ul> <p>This notebook shows how to visualize and download the Maxar Open Data for the 2023 Turkey Earthquake using leafmap.</p> <p>First, install libraries and import modules.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U leafmap geopandas\n</pre> # !pip install -U leafmap geopandas In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport geopandas as gpd\n</pre> import leafmap import geopandas as gpd <p>Retrieve all collections from the Maxar Open Data STAC catalog. Each collection represents a single event.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.maxar_collections()\n</pre> leafmap.maxar_collections() <p>The collection ID for the 2023 Turkey Earthquake is <code>Kahramanmaras-turkey-earthquake-23</code>. We can get the footprints (geojson, tsv) of the event from the Maxar Open Data GitHub repo:</p> In\u00a0[\u00a0]: Copied! <pre>collection = \"Kahramanmaras-turkey-earthquake-23\"\nurl = leafmap.maxar_collection_url(collection, dtype=\"geojson\")\nurl\n</pre> collection = \"Kahramanmaras-turkey-earthquake-23\" url = leafmap.maxar_collection_url(collection, dtype=\"geojson\") url <p>Let's find out how many images are available for the event:</p> In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(url)\nprint(f\"Total number of images: {len(gdf)}\")\ngdf.head()\n</pre> gdf = gpd.read_file(url) print(f\"Total number of images: {len(gdf)}\") gdf.head() <p>Visualize the footprints of the images on the map:</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Footprints\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Footprints\") m <p>The earthquake started on February 6, 2023. We can use the <code>start_date</code> and <code>end_date</code> parameters to filter the images by date. Set <code>end_date</code> to <code>2023-02-06</code> to get all images captured before the earthquake:</p> In\u00a0[\u00a0]: Copied! <pre>pre_gdf = leafmap.maxar_search(collection, end_date=\"2023-02-06\")\nprint(f\"Total number of pre-event images: {len(pre_gdf)}\")\npre_gdf.head()\n</pre> pre_gdf = leafmap.maxar_search(collection, end_date=\"2023-02-06\") print(f\"Total number of pre-event images: {len(pre_gdf)}\") pre_gdf.head() <p>Set the <code>start_date</code> to <code>2023-02-06</code> to get all images captured after the earthquake:</p> In\u00a0[\u00a0]: Copied! <pre>post_gdf = leafmap.maxar_search(collection, start_date=\"2023-02-06\")\nprint(f\"Total number of post-event images: {len(post_gdf)}\")\npost_gdf.head()\n</pre> post_gdf = leafmap.maxar_search(collection, start_date=\"2023-02-06\") print(f\"Total number of post-event images: {len(post_gdf)}\") post_gdf.head() <p>Visualize the pre-event and post-event image footprints on the map. The red footprints represent the pre-event images and the blue footprints represent the post-event images:</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\npre_style = {\"color\": \"red\", \"fillColor\": \"red\", \"opacity\": 1, \"fillOpacity\": 0.5}\nm.add_gdf(pre_gdf, layer_name=\"Pre-event\", style=pre_style, info_mode=\"on_click\")\nm.add_gdf(post_gdf, layer_name=\"Post-event\", info_mode=\"on_click\")\nm\n</pre> m = leafmap.Map() pre_style = {\"color\": \"red\", \"fillColor\": \"red\", \"opacity\": 1, \"fillOpacity\": 0.5} m.add_gdf(pre_gdf, layer_name=\"Pre-event\", style=pre_style, info_mode=\"on_click\") m.add_gdf(post_gdf, layer_name=\"Post-event\", info_mode=\"on_click\") m <p>Use the draw tools to select a region of interest (ROI) and get the bounding box coordinates:</p> In\u00a0[\u00a0]: Copied! <pre>bbox = m.user_roi_bounds()\nif bbox is None:\n    bbox = [36.8715, 37.5497, 36.9814, 37.6019]\n</pre> bbox = m.user_roi_bounds() if bbox is None:     bbox = [36.8715, 37.5497, 36.9814, 37.6019] <p>Search the Maxar Open Data catalog for images within the ROI before the earthquake:</p> In\u00a0[\u00a0]: Copied! <pre>pre_event = leafmap.maxar_search(collection, bbox=bbox, end_date=\"2023-02-06\")\npre_event.head()\n</pre> pre_event = leafmap.maxar_search(collection, bbox=bbox, end_date=\"2023-02-06\") pre_event.head() <p>Search the Maxar Open Data catalog for images within the ROI after the earthquake:</p> In\u00a0[\u00a0]: Copied! <pre>post_event = leafmap.maxar_search(collection, bbox=bbox, start_date=\"2023-02-06\")\npost_event.head()\n</pre> post_event = leafmap.maxar_search(collection, bbox=bbox, start_date=\"2023-02-06\") post_event.head() <p>Get the catalog id of the pre-event tile, which contain several images. Each of the image has a unique <code>quadkey</code>:</p> In\u00a0[\u00a0]: Copied! <pre>pre_tile = pre_event[\"catalog_id\"].values[0]\npre_tile\n</pre> pre_tile = pre_event[\"catalog_id\"].values[0] pre_tile <p>Get the catalog id of the post-event tile, which contain several images. Each of the image has a unique <code>quadkey</code>:</p> In\u00a0[\u00a0]: Copied! <pre>post_tile = post_event[\"catalog_id\"].values[0]\npost_tile\n</pre> post_tile = post_event[\"catalog_id\"].values[0] post_tile <p>Get the MosaicJSON for the pre-event tile:</p> In\u00a0[\u00a0]: Copied! <pre>pre_stac = leafmap.maxar_tile_url(collection, pre_tile, dtype=\"json\")\npre_stac\n</pre> pre_stac = leafmap.maxar_tile_url(collection, pre_tile, dtype=\"json\") pre_stac <p>Get the MosaicJSON for the post-event tile:</p> In\u00a0[\u00a0]: Copied! <pre>post_stac = leafmap.maxar_tile_url(collection, post_tile, dtype=\"json\")\npost_stac\n</pre> post_stac = leafmap.maxar_tile_url(collection, post_tile, dtype=\"json\") post_stac <p>Create a split map to compare the pre-event and post-event images. Note the the ipyleaflet split map has some bugs (source), so we will use the folium plotting backend instead.</p> In\u00a0[\u00a0]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.split_map(\n    left_layer=pre_stac,\n    right_layer=post_stac,\n    left_label=\"Pre-event\",\n    right_label=\"Post-event\",\n)\nm.set_center(36.9265, 37.5762, 16)\nm\n</pre> m = leafmap.Map() m.split_map(     left_layer=pre_stac,     right_layer=post_stac,     left_label=\"Pre-event\",     right_label=\"Post-event\", ) m.set_center(36.9265, 37.5762, 16) m <p>Get download links for the pre-event and post-event images:</p> In\u00a0[\u00a0]: Copied! <pre>pre_images = pre_event[\"visual\"].tolist()\npost_images = post_event[\"visual\"].tolist()\n</pre> pre_images = pre_event[\"visual\"].tolist() post_images = post_event[\"visual\"].tolist() <p>Download the pre-event and post-event images:</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.maxar_download(pre_images)\n</pre> leafmap.maxar_download(pre_images) In\u00a0[\u00a0]: Copied! <pre># leafmap.maxar_download(post_images)\n</pre> # leafmap.maxar_download(post_images)"},{"location":"notebooks/70_zonal_stats/","title":"70 zonal stats","text":"<p>Calculating zonal statistics - summarizing geospatial raster datasets based on vector geometries</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre># %pip install -U rasterstats geopandas\n</pre> # %pip install -U rasterstats geopandas In\u00a0[3]: Copied! <pre>import leafmap\nimport geopandas as gpd\n</pre> import leafmap import geopandas as gpd In\u00a0[4]: Copied! <pre>dsm = \"https://open.gishub.org/data/elevation/dsm.tif\"\nhag = \"https://open.gishub.org/data/elevation/hag.tif\"\nbuildings = \"https://open.gishub.org/data/elevation/buildings.geojson\"\n</pre> dsm = \"https://open.gishub.org/data/elevation/dsm.tif\" hag = \"https://open.gishub.org/data/elevation/hag.tif\" buildings = \"https://open.gishub.org/data/elevation/buildings.geojson\" In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nm.add_cog_layer(dsm, name=\"DSM\", palette=\"terrain\")\nm.add_cog_layer(hag, name=\"Height Above Ground\", palette=\"magma\")\nm.add_geojson(buildings, layer_name=\"Buildings\")\nm\n</pre> m = leafmap.Map() m.add_cog_layer(dsm, name=\"DSM\", palette=\"terrain\") m.add_cog_layer(hag, name=\"Height Above Ground\", palette=\"magma\") m.add_geojson(buildings, layer_name=\"Buildings\") m Out[5]: In\u00a0[6]: Copied! <pre>gdf = gpd.read_file(buildings)\nlen(gdf)\n</pre> gdf = gpd.read_file(buildings) len(gdf) Out[6]: <pre>84</pre> In\u00a0[7]: Copied! <pre>gdf.head()\n</pre> gdf.head() Out[7]: HEIGHT SQMETERS geometry 0 17.530001 3525.113281 MULTIPOLYGON (((-77.05121 38.81215, -77.05132 ... 1 6.620000 51.499035 MULTIPOLYGON (((-77.05339 38.80930, -77.05341 ... 2 5.970000 233.687225 MULTIPOLYGON (((-77.05272 38.81064, -77.05282 ... 3 7.190000 320.350342 MULTIPOLYGON (((-77.05211 38.81024, -77.05213 ... 4 6.340000 85.387062 MULTIPOLYGON (((-77.05285 38.81006, -77.05303 ... <p>The <code>leafmap.zonal_stats()</code> function wraps the <code>rasterstats.zonal_stats()</code> function and performs reprojection if necessary.</p> <p>By default, the zonal_stats function will return the following statistics:</p> <ul> <li><p>min</p> </li> <li><p>max</p> </li> <li><p>mean</p> </li> <li><p>count</p> </li> <li><p>Optionally, these statistics are also available.</p> </li> <li><p>sum</p> </li> <li><p>std</p> </li> <li><p>median</p> </li> <li><p>majority</p> </li> <li><p>minority</p> </li> <li><p>unique</p> </li> <li><p>range</p> </li> <li><p>nodata</p> </li> </ul> In\u00a0[8]: Copied! <pre>stats = leafmap.zonal_stats(gdf, hag, stats=[\"min\", \"max\", \"mean\", \"count\"])\nlen(stats)\n</pre> stats = leafmap.zonal_stats(gdf, hag, stats=[\"min\", \"max\", \"mean\", \"count\"]) len(stats) Out[8]: <pre>84</pre> In\u00a0[9]: Copied! <pre>stats[:5]\n</pre> stats[:5] Out[9]: <pre>[{'min': 10.539999961853027,\n  'max': 24.950000762939453,\n  'mean': 19.82754578143535,\n  'count': 843},\n {'min': 6.880000114440918,\n  'max': 10.819999694824219,\n  'mean': 8.442221747504341,\n  'count': 18},\n {'min': 6.079999923706055,\n  'max': 19.959999084472656,\n  'mean': 9.612962510850695,\n  'count': 54},\n {'min': 7.300000190734863,\n  'max': 18.920000076293945,\n  'mean': 11.190888129340278,\n  'count': 90},\n {'min': 5.929999828338623,\n  'max': 18.399999618530273,\n  'mean': 12.659524100167411,\n  'count': 21}]</pre> In\u00a0[10]: Copied! <pre>stats_geojson = leafmap.zonal_stats(gdf, hag, stats=[\"mean\", \"count\"], geojson_out=True)\nlen(stats_geojson)\n</pre> stats_geojson = leafmap.zonal_stats(gdf, hag, stats=[\"mean\", \"count\"], geojson_out=True) len(stats_geojson) Out[10]: <pre>84</pre> In\u00a0[11]: Copied! <pre>stats_geojson[0]\n</pre> stats_geojson[0] Out[11]: <pre>{'id': '0',\n 'type': 'Feature',\n 'properties': {'HEIGHT': 17.530000686645508,\n  'SQMETERS': 3525.11328125,\n  'mean': 19.82754578143535,\n  'count': 843},\n 'geometry': {'type': 'MultiPolygon',\n  'coordinates': [(((321904.9249656575, 4297929.359149771),\n     (321894.1639320927, 4297864.087817658),\n     (321872.0912812228, 4297867.69244786),\n     (321879.23566416965, 4297911.170307515),\n     (321851.01798099, 4297915.801282184),\n     (321845.1891851835, 4297880.621811273),\n     (321824.5034280424, 4297884.084395529),\n     (321831.04482289474, 4297923.911486235),\n     (321828.3629885514, 4297924.415869579),\n     (321831.17563400406, 4297941.341652784),\n     (321904.9249656575, 4297929.359149771)),)]},\n 'bbox': (321824.5034280424,\n  4297864.087817658,\n  321904.9249656575,\n  4297941.341652784)}</pre> In\u00a0[12]: Copied! <pre>stats_gdf = leafmap.zonal_stats(gdf, hag, stats=[\"mean\", \"count\"], gdf_out=True)\nlen(stats_gdf)\n</pre> stats_gdf = leafmap.zonal_stats(gdf, hag, stats=[\"mean\", \"count\"], gdf_out=True) len(stats_gdf) Out[12]: <pre>84</pre> In\u00a0[13]: Copied! <pre>stats_gdf.head()\n</pre> stats_gdf.head() Out[13]: geometry HEIGHT SQMETERS mean count 0 MULTIPOLYGON (((-77.05121 38.81215, -77.05132 ... 17.530001 3525.113281 19.827546 843 1 MULTIPOLYGON (((-77.05339 38.80930, -77.05341 ... 6.620000 51.499035 8.442222 18 2 MULTIPOLYGON (((-77.05272 38.81064, -77.05282 ... 5.970000 233.687225 9.612963 54 3 MULTIPOLYGON (((-77.05211 38.81024, -77.05213 ... 7.190000 320.350342 11.190888 90 4 MULTIPOLYGON (((-77.05285 38.81006, -77.05303 ... 6.340000 85.387062 12.659524 21 In\u00a0[14]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(stats_gdf, layer_name=\"Zonal Stats\")\nm\n</pre> m = leafmap.Map() m.add_gdf(stats_gdf, layer_name=\"Zonal Stats\") m Out[14]:"},{"location":"notebooks/71_aws_s3/","title":"71 aws s3","text":"<p>Loading geospatial datasets from an AWS S3 bucket</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[\u00a0]: Copied! <pre># %pip install -U boto3\n</pre> # %pip install -U boto3 <p>To Be able to run this notebook you'll need to have AWS credential available as environment variables. Uncomment the following lines to set the environment variables.</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\"\n# os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\"\n</pre> # import os # os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\" # os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\" In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>In this example, we will use datasets from the Maxar Open Data Program on AWS.</p> In\u00a0[\u00a0]: Copied! <pre>BUCKET = \"maxar-opendata\"\nFOLDER = \"events/Kahramanmaras-turkey-earthquake-23/\"\n</pre> BUCKET = \"maxar-opendata\" FOLDER = \"events/Kahramanmaras-turkey-earthquake-23/\" <p>List all the datasets in the bucket. Specify a file extension to filter the results if needed.</p> In\u00a0[\u00a0]: Copied! <pre>items = leafmap.s3_list_objects(BUCKET, FOLDER, ext=\".tif\")\nitems[:10]\n</pre> items = leafmap.s3_list_objects(BUCKET, FOLDER, ext=\".tif\") items[:10] <p>Visualize raster datasets from the bucket.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_cog_layer(items[2], name=\"Maxar\")\nm\n</pre> m = leafmap.Map() m.add_cog_layer(items[2], name=\"Maxar\") m <p>Download a raster dataset from the bucket.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.s3_download_file(items[0], outfile=\"maxar.tif\")\n</pre> leafmap.s3_download_file(items[0], outfile=\"maxar.tif\") <p>Download a list of raster datasets from the bucket.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.s3_download_files(items[:2], outdir=\"maxar\")\n</pre> leafmap.s3_download_files(items[:2], outdir=\"maxar\")"},{"location":"notebooks/72_timelapse/","title":"72 timelapse","text":"<p>Creating timelapse animations from satellite imagery timeseries</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[\u00a0]: Copied! <pre># %pip install rasterio\n</pre> # %pip install rasterio In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>url = \"https://open.gishub.org/data/landsat/peru.zip\"\nleafmap.download_file(url)\n</pre> url = \"https://open.gishub.org/data/landsat/peru.zip\" leafmap.download_file(url) <p>The downloaded zip file contains 38 Landsat images covering the area. They have been unzipped and saved to the <code>peru</code> folder. All GeoTIFF files under the <code>peru</code> folder will be used to create the timelapse animation.</p> In\u00a0[\u00a0]: Copied! <pre>images = \"peru/*.tif\"\n</pre> images = \"peru/*.tif\" <p>Each imagery contains four bands, including SWIR1, NIR, Red, and Green. First, let's create a Landsat timelapse using the <code>SWIR1/NIR/Red</code> bands.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.create_timelapse(\n    images,\n    out_gif=\"landsat.gif\",\n    bands=[0, 1, 2],\n    fps=10,\n    progress_bar_color=\"blue\",\n    add_text=True,\n    text_xy=(\"3%\", \"3%\"),\n    text_sequence=1984,\n    font_size=20,\n    font_color=\"black\",\n    mp4=False,\n    reduce_size=False,\n)\n</pre> leafmap.create_timelapse(     images,     out_gif=\"landsat.gif\",     bands=[0, 1, 2],     fps=10,     progress_bar_color=\"blue\",     add_text=True,     text_xy=(\"3%\", \"3%\"),     text_sequence=1984,     font_size=20,     font_color=\"black\",     mp4=False,     reduce_size=False, ) In\u00a0[\u00a0]: Copied! <pre>leafmap.show_image(\"landsat.gif\")\n</pre> leafmap.show_image(\"landsat.gif\") <p></p> <p>Creating another Landsat timelapse using the <code>NIR/Red/Green</code> bands.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.create_timelapse(\n    images,\n    out_gif=\"landsat2.gif\",\n    bands=[1, 2, 3],\n    fps=10,\n    progress_bar_color=\"blue\",\n    add_text=True,\n    text_xy=(\"3%\", \"3%\"),\n    text_sequence=1984,\n    font_size=20,\n    font_color=\"black\",\n)\n</pre> leafmap.create_timelapse(     images,     out_gif=\"landsat2.gif\",     bands=[1, 2, 3],     fps=10,     progress_bar_color=\"blue\",     add_text=True,     text_xy=(\"3%\", \"3%\"),     text_sequence=1984,     font_size=20,     font_color=\"black\", ) In\u00a0[\u00a0]: Copied! <pre>leafmap.show_image(\"landsat2.gif\")\n</pre> leafmap.show_image(\"landsat2.gif\") <p></p> <p>You can also create a timelapse using Cloud Optimized GeoTIFF (COG) files hosted on the web. The following example uses some COG files hosted on GitHub.</p> In\u00a0[\u00a0]: Copied! <pre>years = [str(year) for year in range(1985, 2021, 5)]\nyears\n</pre> years = [str(year) for year in range(1985, 2021, 5)] years In\u00a0[\u00a0]: Copied! <pre>images = [f\"https://open.gishub.org/data/landsat/{year}.tif\" for year in years]\nimages\n</pre> images = [f\"https://open.gishub.org/data/landsat/{year}.tif\" for year in years] images <p>If the original image size (shape) is too large, you can use the <code>size</code> parameter (rows, cols) to resize the image. The following example resizes the image to (300, 550).</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.create_timelapse(\n    images,\n    out_gif=\"landsat3.gif\",\n    bands=[0, 1, 2],\n    size=(300, 550),\n    fps=3,\n    progress_bar_color=\"blue\",\n    add_text=True,\n    text_xy=(\"3%\", \"3%\"),\n    text_sequence=years,\n    font_size=20,\n    font_color=\"black\",\n)\n</pre> leafmap.create_timelapse(     images,     out_gif=\"landsat3.gif\",     bands=[0, 1, 2],     size=(300, 550),     fps=3,     progress_bar_color=\"blue\",     add_text=True,     text_xy=(\"3%\", \"3%\"),     text_sequence=years,     font_size=20,     font_color=\"black\", ) In\u00a0[\u00a0]: Copied! <pre>leafmap.show_image(\"landsat3.gif\")\n</pre> leafmap.show_image(\"landsat3.gif\") <p></p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://open.gishub.org/data/naip/naip.zip\"\nleafmap.download_file(url)\n</pre> url = \"https://open.gishub.org/data/naip/naip.zip\" leafmap.download_file(url) <p>The downloaded zip file contains 10 NAIP images covering the area. All GeoTIFF files under the <code>naip</code> folder will be used to create the timelapse animation.</p> In\u00a0[\u00a0]: Copied! <pre>images = \"naip/*.tif\"\n</pre> images = \"naip/*.tif\" <p>The images cover the area from 2009 to 2020 annually except 2011 and 2013. Each image contains four bands, including Red, Green, Blue, and NIR.</p> In\u00a0[\u00a0]: Copied! <pre>text_sequence = [str(year) for year in range(2009, 2021)]\ntext_sequence.remove(\"2011\")\ntext_sequence.remove(\"2013\")\ntext_sequence\n</pre> text_sequence = [str(year) for year in range(2009, 2021)] text_sequence.remove(\"2011\") text_sequence.remove(\"2013\") text_sequence <p>Creating a timelapse using the <code>Red/Green/Blue</code> bands.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.create_timelapse(\n    images,\n    out_gif=\"naip.gif\",\n    bands=[0, 1, 2],\n    fps=3,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    add_text=True,\n    text_xy=(\"4%\", \"4%\"),\n    text_sequence=text_sequence,\n    font_size=30,\n    font_color=\"white\",\n)\n</pre> leafmap.create_timelapse(     images,     out_gif=\"naip.gif\",     bands=[0, 1, 2],     fps=3,     add_progress_bar=True,     progress_bar_color=\"blue\",     add_text=True,     text_xy=(\"4%\", \"4%\"),     text_sequence=text_sequence,     font_size=30,     font_color=\"white\", ) In\u00a0[\u00a0]: Copied! <pre>leafmap.show_image(\"naip.gif\")\n</pre> leafmap.show_image(\"naip.gif\") <p></p> <p>Creating a timelapse using the <code>NIR/Red/Green</code> bands.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.create_timelapse(\n    images,\n    out_gif=\"naip2.gif\",\n    bands=[3, 0, 1],\n    fps=3,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    add_text=True,\n    text_xy=(\"4%\", \"4%\"),\n    text_sequence=text_sequence,\n    font_size=30,\n    font_color=\"white\",\n)\n</pre> leafmap.create_timelapse(     images,     out_gif=\"naip2.gif\",     bands=[3, 0, 1],     fps=3,     add_progress_bar=True,     progress_bar_color=\"blue\",     add_text=True,     text_xy=(\"4%\", \"4%\"),     text_sequence=text_sequence,     font_size=30,     font_color=\"white\", ) In\u00a0[\u00a0]: Copied! <pre>leafmap.show_image(\"naip2.gif\")\n</pre> leafmap.show_image(\"naip2.gif\") <p></p>"},{"location":"notebooks/72_timelapse/#landsat-timelapse","title":"Landsat Timelapse\u00b6","text":"<p>Download Landsat imagery covering Pucallpa, Peru from 1984 to 2022.</p>"},{"location":"notebooks/72_timelapse/#naip-timelapse","title":"NAIP Timelapse\u00b6","text":"<p>Download NAIP imagery covering Valley Spring, North Dakota from 2009 to 2020.</p>"},{"location":"notebooks/73_custom_stac/","title":"73 custom stac","text":"<p>Searching Geospatial Data Interactively with Custom STAC API Endpoints</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>import os\nfrom leafmap import leafmap\n</pre> import os from leafmap import leafmap <p>Provide custom STAC API endpoints as a dictionary in the format of <code>{\"name\": \"url\"}</code>. The name will show up in the dropdown menu, while the url is the STAC API endpoint that will be used to search for items.</p> In\u00a0[3]: Copied! <pre>catalogs = {\n    \"Element84 Earth Search\": \"https://earth-search.aws.element84.com/v1\",\n    \"Microsoft Planetary Computer\": \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n}\n</pre> catalogs = {     \"Element84 Earth Search\": \"https://earth-search.aws.element84.com/v1\",     \"Microsoft Planetary Computer\": \"https://planetarycomputer.microsoft.com/api/stac/v1\", } <p>Create an interactive map and click on the catalog button as shown below to open the catalog panel. Be sure to specify the <code>catalog_source</code> parameter during the map creation.</p> <p></p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4, catalog_source=catalogs)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4, catalog_source=catalogs) m <p>Alternatively, you can also use the <code>Map.set_catalog_source</code> method to specify the custom API endpoints.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.set_catalog_source(catalogs)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.set_catalog_source(catalogs) m <p>Another way to specify STAC API endpoints is to set the environment variable <code>STAC_CATALOGS</code> to a dictionary in the format of <code>{\"name\": \"url\"}</code>.</p> In\u00a0[6]: Copied! <pre>os.environ[\"STAC_CATALOGS\"] = str(catalogs)\n</pre> os.environ[\"STAC_CATALOGS\"] = str(catalogs) <p>Then, you can create an interactive map as usual and click on the catalog button to open the catalog panel.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>The STAC GUI can also be open directly by calling the <code>stac_gui()</code> function.</p> In\u00a0[8]: Copied! <pre>from leafmap.toolbar import stac_gui\n</pre> from leafmap.toolbar import stac_gui In\u00a0[9]: Copied! <pre>stac_gui(m)\n</pre> stac_gui(m) <p>Once the catalog panel is open, you can search for items from the custom STAC API endpoints. Simply draw a bounding box on the map or zoom to a location of interest. Click on the Collections button to retrieve the collections from the custom STAC API endpoints. Next, select a collection from the dropdown menu. Then, click on the Items button to retrieve the items from the selected collection. Finally, click on the Display button to add the selected item to the map.</p> <p></p> In\u00a0[10]: Copied! <pre># m.stac_gdf  # The GeoDataFrame of the STAC search results\n</pre> # m.stac_gdf  # The GeoDataFrame of the STAC search results In\u00a0[11]: Copied! <pre># m.stac_dict  # The STAC search results as a dictionary\n</pre> # m.stac_dict  # The STAC search results as a dictionary In\u00a0[12]: Copied! <pre># m.stac_item  # The selected STAC item of the search result\n</pre> # m.stac_item  # The selected STAC item of the search result"},{"location":"notebooks/74_map_tiles_to_geotiff/","title":"74 map tiles to geotiff","text":"<p>Downloading maps tiles and converting them to a GeoTIFF file</p> <p>Disclaimer: The <code>leafmap.map_tiles_to_geotiff()</code> function is adapted from the tms2geotiff repo. Credit goes to the GitHub user @gumblex.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Use the drawing tools to draw a rectangle on the map.</p> In\u00a0[4]: Copied! <pre>if m.user_roi is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-122.5216, 37.733, -122.3661, 37.8095]\n</pre> if m.user_roi is not None:     bbox = m.user_roi_bounds() else:     bbox = [-122.5216, 37.733, -122.3661, 37.8095] <p>Download map tiles and create a GeoTIFF file. First, let's try Esri world imagery basemap.</p> In\u00a0[5]: Copied! <pre>leafmap.map_tiles_to_geotiff(\"satellite.tif\", bbox, zoom=13, source=\"Esri.WorldImagery\")\n</pre> leafmap.map_tiles_to_geotiff(\"satellite.tif\", bbox, zoom=13, source=\"Esri.WorldImagery\") <pre>Downloaded image 1/15\nDownloaded image 2/15\nDownloaded image 3/15\nDownloaded image 4/15\nDownloaded image 5/15\nDownloaded image 6/15\nDownloaded image 7/15\nDownloaded image 8/15\nDownloaded image 9/15\nDownloaded image 10/15\nDownloaded image 11/15\nDownloaded image 12/15\nDownloaded image 13/15\nDownloaded image 14/15\nDownloaded image 15/15\nSaving GeoTIFF. Please wait...\n</pre> <pre>Image saved to satellite.tif\n</pre> <p></p> In\u00a0[6]: Copied! <pre>leafmap.map_tiles_to_geotiff(\"topo.tif\", bbox, zoom=13, source=\"OpenTopoMap\")\n</pre> leafmap.map_tiles_to_geotiff(\"topo.tif\", bbox, zoom=13, source=\"OpenTopoMap\") <pre>Downloaded image 1/15\nDownloaded image 2/15\nDownloaded image 3/15\nDownloaded image 4/15\nDownloaded image 5/15\nDownloaded image 6/15\nDownloaded image 7/15\n</pre> <pre>Downloaded image 8/15\nDownloaded image 9/15\nDownloaded image 10/15\nDownloaded image 11/15\nDownloaded image 12/15\nDownloaded image 13/15\nDownloaded image 14/15\nDownloaded image 15/15\nSaving GeoTIFF. Please wait...\n</pre> <pre>Image saved to topo.tif\n</pre> <p></p>"},{"location":"notebooks/75_segment_anything/","title":"75 segment anything","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install leafmap\n</pre> # %pip install leafmap In\u00a0[\u00a0]: Copied! <pre># %pip install segment-geospatial localtileserver\n</pre> # %pip install segment-geospatial localtileserver In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nfrom samgeo import SamGeo, tms_to_geotiff, get_basemaps\n</pre> import os import leafmap from samgeo import SamGeo, tms_to_geotiff, get_basemaps In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[29.676840, -95.369222], zoom=19)\nm.add_basemap(\"SATELLITE\")\nm\n</pre> m = leafmap.Map(center=[29.676840, -95.369222], zoom=19) m.add_basemap(\"SATELLITE\") m <p>Pan and zoom the map to select the area of interest. Use the draw tools to draw a polygon or rectangle on the map</p> In\u00a0[\u00a0]: Copied! <pre>if m.user_roi_bounds() is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-95.3704, 29.6762, -95.368, 29.6775]\n</pre> if m.user_roi_bounds() is not None:     bbox = m.user_roi_bounds() else:     bbox = [-95.3704, 29.6762, -95.368, 29.6775] In\u00a0[\u00a0]: Copied! <pre>image = \"satellite.tif\"\n</pre> image = \"satellite.tif\" <p>Besides the <code>satellite</code> basemap, you can use any of the following basemaps returned by the <code>get_basemaps()</code> function:</p> In\u00a0[\u00a0]: Copied! <pre># get_basemaps().keys()\n</pre> # get_basemaps().keys() <p>Specify the basemap as the source.</p> In\u00a0[\u00a0]: Copied! <pre>tms_to_geotiff(output=image, bbox=bbox, zoom=20, source=\"Satellite\", overwrite=True)\n</pre> tms_to_geotiff(output=image, bbox=bbox, zoom=20, source=\"Satellite\", overwrite=True) <p>You can also use your own image. Uncomment and run the following cell to use your own image.</p> In\u00a0[\u00a0]: Copied! <pre># image = '/path/to/your/own/image.tif'\n</pre> # image = '/path/to/your/own/image.tif' <p>Display the downloaded image on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.layers[-1].visible = False  # turn off the basemap\nm.add_raster(image, layer_name=\"Image\")\nm\n</pre> m.layers[-1].visible = False  # turn off the basemap m.add_raster(image, layer_name=\"Image\") m <p></p> In\u00a0[\u00a0]: Copied! <pre>sam = SamGeo(\n    model_type=\"vit_h\",\n    checkpoint=\"sam_vit_h_4b8939.pth\",\n    sam_kwargs=None,\n)\n</pre> sam = SamGeo(     model_type=\"vit_h\",     checkpoint=\"sam_vit_h_4b8939.pth\",     sam_kwargs=None, ) In\u00a0[\u00a0]: Copied! <pre>mask = \"segment.tif\"\nsam.generate(\n    image, mask, batch=True, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255\n)\n</pre> mask = \"segment.tif\" sam.generate(     image, mask, batch=True, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255 ) In\u00a0[\u00a0]: Copied! <pre>vector = \"segment.gpkg\"\nsam.tiff_to_gpkg(mask, vector, simplify_tolerance=None)\n</pre> vector = \"segment.gpkg\" sam.tiff_to_gpkg(mask, vector, simplify_tolerance=None) <p>You can also save the segmentation results as any vector data format supported by GeoPandas.</p> In\u00a0[\u00a0]: Copied! <pre>shapefile = \"segment.shp\"\nsam.tiff_to_vector(mask, shapefile)\n</pre> shapefile = \"segment.shp\" sam.tiff_to_vector(mask, shapefile) In\u00a0[\u00a0]: Copied! <pre>style = {\n    \"color\": \"#3388ff\",\n    \"weight\": 2,\n    \"fillColor\": \"#7c4185\",\n    \"fillOpacity\": 0.5,\n}\nm.add_vector(vector, layer_name=\"Vector\", style=style)\nm\n</pre> style = {     \"color\": \"#3388ff\",     \"weight\": 2,     \"fillColor\": \"#7c4185\",     \"fillOpacity\": 0.5, } m.add_vector(vector, layer_name=\"Vector\", style=style) m <p></p>"},{"location":"notebooks/75_segment_anything/#segment-anything-model-for-geospatial-data","title":"Segment Anything Model for Geospatial Data\u00b6","text":"<p>This notebook shows how to use segment satellite imagery using the Segment Anything Model (SAM) with a few lines of code.</p> <p>Make sure you use GPU runtime for this notebook. For Google Colab, go to <code>Runtime</code> -&gt; <code>Change runtime type</code> and select <code>GPU</code> as the hardware accelerator.</p>"},{"location":"notebooks/75_segment_anything/#install-dependencies","title":"Install dependencies\u00b6","text":"<p>Uncomment and run the following cell to install the required dependencies.</p>"},{"location":"notebooks/75_segment_anything/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/75_segment_anything/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"notebooks/75_segment_anything/#download-map-tiles","title":"Download map tiles\u00b6","text":"<p>Download maps tiles and mosaic them into a single GeoTIFF file</p>"},{"location":"notebooks/75_segment_anything/#initialize-sam-class","title":"Initialize SAM class\u00b6","text":""},{"location":"notebooks/75_segment_anything/#segment-the-image","title":"Segment the image\u00b6","text":"<p>Set <code>batch=True</code> to segment the image in batches. This is useful for large images that cannot fit in memory.</p>"},{"location":"notebooks/75_segment_anything/#polygonize-the-raster-data","title":"Polygonize the raster data\u00b6","text":"<p>Save the segmentation results as a GeoPackage file.</p>"},{"location":"notebooks/75_segment_anything/#visualize-the-results","title":"Visualize the results\u00b6","text":""},{"location":"notebooks/76_image_comparison/","title":"76 image comparison","text":"<p>Comparing images with an interactive slider</p> <p>Uncomment the following line to install leafmap if needed.</p> <p>Note that the <code>image_comparison</code> will only work with Jupyter Notebook or JupyterLab. It seems not working with Visual Studio Code.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[3]: Copied! <pre>img1 = \"https://open.gishub.org/data/images/berkeley.jpg\"\nimg2 = \"https://open.gishub.org/data/images/berkeley_sam.jpg\"\n</pre> img1 = \"https://open.gishub.org/data/images/berkeley.jpg\" img2 = \"https://open.gishub.org/data/images/berkeley_sam.jpg\" <p>The labels might not show up the first time. Try running the code block again to show the labels.</p> In\u00a0[4]: Copied! <pre>leafmap.image_comparison(\n    img1,\n    img2,\n    label1=\"Satellite Image\",\n    label2=\"Image Segmentation\",\n    starting_position=50,\n    out_html=\"image_comparison.html\",\n)\n</pre> leafmap.image_comparison(     img1,     img2,     label1=\"Satellite Image\",     label2=\"Image Segmentation\",     starting_position=50,     out_html=\"image_comparison.html\", ) <p></p>"},{"location":"notebooks/77_split_raster/","title":"77 split raster","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Create an interactive map and add a raster layer to it.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://open.gishub.org/data/raster/cog.tif\"\nm.add_cog_layer(url, name=\"COG\")\nm\n</pre> m = leafmap.Map() url = \"https://open.gishub.org/data/raster/cog.tif\" m.add_cog_layer(url, name=\"COG\") m <p>Split the raster layer into multiple tiles.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_raster(url, out_dir=\"tiles\", tile_size=(100, 100), overlap=0)\n</pre> leafmap.split_raster(url, out_dir=\"tiles\", tile_size=(100, 100), overlap=0) <p>Show the tiles.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.find_files(\"tiles\", ext=\".tif\")\n</pre> leafmap.find_files(\"tiles\", ext=\".tif\") <p>Merge the tiles into a single raster dataset.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.merge_rasters(\"tiles\", output=\"merged.tif\", input_pattern=\"*.tif\")\n</pre> leafmap.merge_rasters(\"tiles\", output=\"merged.tif\", input_pattern=\"*.tif\")"},{"location":"notebooks/78_read_raster/","title":"78 read raster","text":"<p>Interactive Extraction and Visualization of AWS Open Geospatial Data</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Set custom STAC endpoints.</p> In\u00a0[3]: Copied! <pre>catalogs = {\n    \"Element84 Earth Search\": \"https://earth-search.aws.element84.com/v1\",\n    \"Microsoft Planetary Computer\": \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n}\n</pre> catalogs = {     \"Element84 Earth Search\": \"https://earth-search.aws.element84.com/v1\",     \"Microsoft Planetary Computer\": \"https://planetarycomputer.microsoft.com/api/stac/v1\", } <p>Display the STAC search GUI. Pan and zoom to the area of interest and use the drawing tools to draw a bounding box or polygon. Select a STAC catalog and click the Collections button to retrieve the collections, then click on the Items button to retrieve the items within the bounding box or polygon. Select an item from the dropdown list and click the Display button to display the item on the map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[37.7452, -122.4108], zoom=12, catalog_source=catalogs)\nm.add(\"stac\")\nm\n</pre> m = leafmap.Map(center=[37.7452, -122.4108], zoom=12, catalog_source=catalogs) m.add(\"stac\") m <p>Display the information of the selected item.</p> In\u00a0[5]: Copied! <pre># m.stac_item\n</pre> # m.stac_item <p>Alternatively, you can search the STAC catalog programmatically by providing a bounding box, time range, and other filters. The example below use the Earth Search STAC endpoint by Element 84 for searching for AWS Open Data.</p> In\u00a0[6]: Copied! <pre>url = \"https://earth-search.aws.element84.com/v1/\"\ncollection = \"sentinel-2-l2a\"\ntime_range = \"2023-04-01/2023-07-31\"\nbbox = [-122.491, 37.7208, -122.411, 37.7786]\n</pre> url = \"https://earth-search.aws.element84.com/v1/\" collection = \"sentinel-2-l2a\" time_range = \"2023-04-01/2023-07-31\" bbox = [-122.491, 37.7208, -122.411, 37.7786] <p>Search the STAC catalog and return the results as an ItemCollection.</p> In\u00a0[7]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=5,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n    get_collection=True,\n)\n# search\n</pre> search = leafmap.stac_search(     url=url,     max_items=5,     collections=[collection],     bbox=bbox,     datetime=time_range,     query={\"eo:cloud_cover\": {\"lt\": 10}},     get_collection=True, ) # search <p>Search the STAC catalog and return the results as a dictionary of assets.</p> In\u00a0[8]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=5,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n    get_assets=True,\n)\n# search\n</pre> search = leafmap.stac_search(     url=url,     max_items=5,     collections=[collection],     bbox=bbox,     datetime=time_range,     query={\"eo:cloud_cover\": {\"lt\": 10}},     get_assets=True, ) # search <p>Get the first item in the collection.</p> In\u00a0[9]: Copied! <pre>name, item = next(iter(search.items()))\nname\n</pre> name, item = next(iter(search.items())) name Out[9]: <pre>'S2A_10SEG_20230618_0_L2A'</pre> <p>Retrieve the item's assets, which are links to the actual data files.</p> In\u00a0[10]: Copied! <pre>item\n</pre> item Out[10]: <pre>{'aot': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/AOT.tif',\n 'blue': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B02.tif',\n 'coastal': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B01.tif',\n 'granule_metadata': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/granule_metadata.xml',\n 'green': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B03.tif',\n 'nir': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B08.tif',\n 'nir08': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B8A.tif',\n 'nir09': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B09.tif',\n 'red': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B04.tif',\n 'rededge1': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B05.tif',\n 'rededge2': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B06.tif',\n 'rededge3': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B07.tif',\n 'scl': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/SCL.tif',\n 'swir16': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B11.tif',\n 'swir22': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B12.tif',\n 'thumbnail': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/thumbnail.jpg',\n 'tileinfo_metadata': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/tileinfo_metadata.json',\n 'visual': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/TCI.tif',\n 'wvp': 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/WVP.tif',\n 'aot-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/AOT.jp2',\n 'blue-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B02.jp2',\n 'coastal-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B01.jp2',\n 'green-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B03.jp2',\n 'nir-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B08.jp2',\n 'nir08-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B8A.jp2',\n 'nir09-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B09.jp2',\n 'red-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B04.jp2',\n 'rededge1-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B05.jp2',\n 'rededge2-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B06.jp2',\n 'rededge3-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B07.jp2',\n 'scl-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/SCL.jp2',\n 'swir16-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B11.jp2',\n 'swir22-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/B12.jp2',\n 'visual-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/TCI.jp2',\n 'wvp-jp2': 's3://sentinel-s2-l2a/tiles/10/S/EG/2023/6/18/0/WVP.jp2'}</pre> <p>Retrieve the STAT item's URLs.</p> In\u00a0[11]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=5,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n    get_links=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=5,     collections=[collection],     bbox=bbox,     datetime=time_range,     query={\"eo:cloud_cover\": {\"lt\": 10}},     get_links=True, ) search Out[11]: <pre>['https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_10SEG_20230618_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10SEG_20230424_0_L2A',\n 'https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2B_10SEG_20230414_0_L2A']</pre> <p>Check the band names of the selected item.</p> In\u00a0[12]: Copied! <pre>url = search[0]\nbands = leafmap.stac_bands(url)\nbands[:10]\n</pre> url = search[0] bands = leafmap.stac_bands(url) bands[:10] Out[12]: <pre>['aot',\n 'blue',\n 'coastal',\n 'green',\n 'nir',\n 'nir08',\n 'nir09',\n 'red',\n 'rededge1',\n 'rededge2']</pre> <p>Display the selected item on the map.</p> In\u00a0[13]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(url, bands=[\"nir\", \"red\", \"green\"], name=\"Sentinel-2\")\nm\n</pre> m = leafmap.Map() m.add_stac_layer(url, bands=[\"nir\", \"red\", \"green\"], name=\"Sentinel-2\") m <p>Use the drawing tools to draw a small bounding box on the image.</p> In\u00a0[14]: Copied! <pre>if m.user_roi is not None:\n    roi = m.user_roi_bounds()\nelse:\n    roi = [-122.5315, 37.6882, -122.3523, 37.8166]\n</pre> if m.user_roi is not None:     roi = m.user_roi_bounds() else:     roi = [-122.5315, 37.6882, -122.3523, 37.8166] <p>Specify the bands to use.</p> In\u00a0[15]: Copied! <pre>bands = [\"nir\", \"red\", \"green\"]\n</pre> bands = [\"nir\", \"red\", \"green\"] <p>Display the COG URL.</p> In\u00a0[16]: Copied! <pre>item[\"nir\"]\n</pre> item[\"nir\"] Out[16]: <pre>'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/10/S/EG/2023/6/S2A_10SEG_20230618_0_L2A/B08.tif'</pre> <p>Extract one single band within the bounding box as an a numpy array.</p> In\u00a0[17]: Copied! <pre>array = leafmap.read_raster(item[\"nir\"], window=roi, coord_crs=\"epsg:4326\")\n</pre> array = leafmap.read_raster(item[\"nir\"], window=roi, coord_crs=\"epsg:4326\") <p>Check the shape of the array.</p> In\u00a0[18]: Copied! <pre>array.shape\n</pre> array.shape Out[18]: <pre>(1, 1434, 1570)</pre> <p>Extract multiple bands within the bounding box as an a numpy array.</p> In\u00a0[19]: Copied! <pre>sources = [item[\"nir\"], item[\"red\"], item[\"green\"]]\narray = leafmap.read_rasters(sources, window=roi, coord_crs=\"epsg:4326\")\n</pre> sources = [item[\"nir\"], item[\"red\"], item[\"green\"]] array = leafmap.read_rasters(sources, window=roi, coord_crs=\"epsg:4326\") <p>Check the shape of the array.</p> In\u00a0[20]: Copied! <pre>array.shape\n</pre> array.shape Out[20]: <pre>(3, 1434, 1570)</pre> <p>Convert the numpy array to a Cloud Optimized GeoTIFF (COG).</p> In\u00a0[21]: Copied! <pre>leafmap.numpy_to_cog(\n    array, \"s2.tif\", bounds=roi, profile=item[\"nir\"], coord_crs=\"epsg:4326\"\n)\n</pre> leafmap.numpy_to_cog(     array, \"s2.tif\", bounds=roi, profile=item[\"nir\"], coord_crs=\"epsg:4326\" ) <p>Display the image on the map.</p> In\u00a0[22]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"s2.tif\", band=[1, 2, 3], vmin=0, vmax=4000, layer_name=\"Subset\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"s2.tif\", band=[1, 2, 3], vmin=0, vmax=4000, layer_name=\"Subset\") m"},{"location":"notebooks/79_timeseries/","title":"79 timeseries","text":"<p>Visualizing time series images interactively with a time slider</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Download sample data here.</p> In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/landsat/timeseries.zip\"\nleafmap.download_file(url)\n</pre> url = \"https://open.gishub.org/data/landsat/timeseries.zip\" leafmap.download_file(url) <pre>Downloading...\nFrom: https://open.gishub.org/data/landsat/timeseries.zip\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/timeseries.zip\n</pre> <pre>\r  0%|          | 0.00/27.4M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 27.4M/27.4M [00:00&lt;00:00, 276MB/s]</pre> <pre>\n</pre> <pre>Extracting files...\n</pre> Out[3]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/timeseries.zip'</pre> <p>Visualize time series images interactively with a time slider. You can pass a list of file paths or a string representing a directory to the <code>add_time_slider</code> function.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nimages = \"landsat\"\nm.add_time_slider(\n    images,\n    time_interval=0.5,\n    position=\"bottomright\",\n    band=[1, 2, 3],\n    zoom_to_layer=True,\n)\nm\n</pre> m = leafmap.Map() images = \"landsat\" m.add_time_slider(     images,     time_interval=0.5,     position=\"bottomright\",     band=[1, 2, 3],     zoom_to_layer=True, ) m <p></p>"},{"location":"notebooks/80_solar/","title":"80 solar","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Set Google API key. Get one from https://developers.google.com/maps/documentation/solar/get-api-key</p> <p>You also need to enable the Google Solar API at https://console.cloud.google.com/google/maps-apis/api-list</p> In\u00a0[\u00a0]: Copied! <pre>os.environ[\"GOOGLE_API_KEY\"] = \"YOUR-API-KEY\"\n</pre> os.environ[\"GOOGLE_API_KEY\"] = \"YOUR-API-KEY\" <p>Set download directory.</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.expanduser(\"~/Downloads\")\n</pre> out_dir = os.path.expanduser(\"~/Downloads\") <p>Download Solar data from Google's Solar API.</p> In\u00a0[\u00a0]: Copied! <pre>lat = 50.97579908646006\nlon = 11.023334842349778\nradiusMeters = 50\nview = \"FULL_LAYERS\"\nrequiredQuality = \"HIGH\"\npixelSizeMeters = 0.1\n</pre> lat = 50.97579908646006 lon = 11.023334842349778 radiusMeters = 50 view = \"FULL_LAYERS\" requiredQuality = \"HIGH\" pixelSizeMeters = 0.1 In\u00a0[\u00a0]: Copied! <pre>files = leafmap.get_solar_data(\n    lat, lon, radiusMeters, view, requiredQuality, pixelSizeMeters, out_dir=out_dir\n)\nfiles\n</pre> files = leafmap.get_solar_data(     lat, lon, radiusMeters, view, requiredQuality, pixelSizeMeters, out_dir=out_dir ) files <p>Create an interactive map and add the Solar data.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(files[\"rgb\"], layer_name=\"RGB\")\nm.add_raster(files[\"mask\"], layer_name=\"Mask\")\nm.add_raster(files[\"dsm\"], colormap=\"terrain\", layer_name=\"DSM\", visible=False)\nm.add_raster(files[\"annualFlux\"], colormap=\"plasma\", layer_name=\"annualFlux\")\nm.add_raster(\n    files[\"monthlyFlux\"],\n    colormap=\"plasma\",\n    band=[7],\n    layer_name=\"monthlyFlux\",\n    visible=False,\n)\n\nm.add_colormap(cmap=\"terrain\", vmin=190, vmax=250, label=\"Elevation (m)\")\nm.add_colormap(cmap=\"plasma\", vmin=500, vmax=1000, label=\"Annual flux (kWh/kW/year)\")\nm\n</pre> m = leafmap.Map() m.add_raster(files[\"rgb\"], layer_name=\"RGB\") m.add_raster(files[\"mask\"], layer_name=\"Mask\") m.add_raster(files[\"dsm\"], colormap=\"terrain\", layer_name=\"DSM\", visible=False) m.add_raster(files[\"annualFlux\"], colormap=\"plasma\", layer_name=\"annualFlux\") m.add_raster(     files[\"monthlyFlux\"],     colormap=\"plasma\",     band=[7],     layer_name=\"monthlyFlux\",     visible=False, )  m.add_colormap(cmap=\"terrain\", vmin=190, vmax=250, label=\"Elevation (m)\") m.add_colormap(cmap=\"plasma\", vmin=500, vmax=1000, label=\"Annual flux (kWh/kW/year)\") m <p></p>"},{"location":"notebooks/81_buildings/","title":"81 buildings","text":"<p>Downloading Microsoft and Google Building Footprints</p> <p>This notebook demonstrates how to download Microsoft and Google Building Footprints and merge them into a single vector file.</p> <ul> <li>Microsoft Global Building Footprints: https://github.com/microsoft/GlobalMLBuildingFootprints</li> <li>Google Open Buildings: https://sites.research.google/open-buildings</li> </ul> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap geopandas\n</pre> # %pip install -U leafmap geopandas In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Specify the country name.</p> In\u00a0[\u00a0]: Copied! <pre>country = \"Libya\"\n</pre> country = \"Libya\" <p>Specify the number of files to download. Set to <code>None</code> to download all files.</p> In\u00a0[\u00a0]: Copied! <pre>head = 2\n</pre> head = 2 <p>Download the Microsoft building footprints.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.download_ms_buildings(\n    country, out_dir=\"buildings\", merge_output=f\"{country}_ms.shp\", head=head\n)\n</pre> leafmap.download_ms_buildings(     country, out_dir=\"buildings\", merge_output=f\"{country}_ms.shp\", head=head ) <p>Display the Microsoft building footprints.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"SATELLITE\")\nm.add_vector(f\"{country}_ms.shp\", layer_name=\"MS Buildings\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"SATELLITE\") m.add_vector(f\"{country}_ms.shp\", layer_name=\"MS Buildings\") m <p>Download the Google building footprints.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.download_google_buildings(\n    country,\n    out_dir=\"buildings\",\n    merge_output=f\"{country}_google.shp\",\n    head=head,\n    overwrite=True,\n)\n</pre> leafmap.download_google_buildings(     country,     out_dir=\"buildings\",     merge_output=f\"{country}_google.shp\",     head=head,     overwrite=True, ) <p>Display the Google building footprints.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://sites.research.google/open-buildings/tiles.geojson\"\n</pre> url = \"https://sites.research.google/open-buildings/tiles.geojson\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"SATELLITE\")\nm.add_geojson(url, layer_name=\"Google Building Coverage\")\nm.add_vector(f\"{country}_google.shp\", layer_name=\"Google Buildings\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"SATELLITE\") m.add_geojson(url, layer_name=\"Google Building Coverage\") m.add_vector(f\"{country}_google.shp\", layer_name=\"Google Buildings\") m"},{"location":"notebooks/82_pmtiles/","title":"82 pmtiles","text":"<p>Visualizing PMTiles with leafmap</p> <p>PMTiles is a single-file archive format for tiled data. A PMTiles archive can be hosted on a commodity storage platform such as S3, and enables low-cost, zero-maintenance map applications that are \"serverless\" - free of a custom tile backend or third party provider.</p> <p>The PMTiles functionality for leafmap is based on the folium-pmtiles package. Credits to Jt Miclat.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap pmtiles\n</pre> # %pip install -U leafmap pmtiles In\u00a0[2]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['earth', 'natural', 'land', 'water', 'physical_line', 'buildings', 'physical_point', 'places', 'roads', 'transit', 'pois', 'boundaries', 'mask']\nbounds: [11.154026, 43.7270125, 11.3289395, 43.8325455]\n</pre> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"landuse\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"steelblue\"},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"black\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url, name=\"PMTiles\", style=style, overlay=True, show=True, zoom_to_layer=True\n)\nm\n</pre> m = leafmap.Map()  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"landuse\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"steelblue\"},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"black\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url, name=\"PMTiles\", style=style, overlay=True, show=True, zoom_to_layer=True ) m Out[4]: <p>You can also visualize Overture data. Inspired by overture-maps.</p> In\u00a0[5]: Copied! <pre>url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['admins', 'buildings', 'places', 'roads']\nbounds: [3.295898, 50.746884, 7.245483, 53.5762]\n</pre> In\u00a0[6]: Copied! <pre>m = leafmap.Map(height=\"800px\")\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"admins\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"admins\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},\n        },\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"places\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"places\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"#FB8072\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url, name=\"PMTiles\", style=style, overlay=True, show=True, zoom_to_layer=True\n)\n\nlegend_dict = {\n    \"admins\": \"BDD3C7\",\n    \"buildings\": \"FFFFB3\",\n    \"places\": \"BEBADA\",\n    \"roads\": \"FB8072\",\n}\n\nm.add_legend(legend_dict=legend_dict)\nm\n</pre> m = leafmap.Map(height=\"800px\") m.add_basemap(\"CartoDB.DarkMatter\")  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"admins\",             \"source\": \"example_source\",             \"source-layer\": \"admins\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},         },         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},         },         {             \"id\": \"places\",             \"source\": \"example_source\",             \"source-layer\": \"places\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"#FB8072\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url, name=\"PMTiles\", style=style, overlay=True, show=True, zoom_to_layer=True )  legend_dict = {     \"admins\": \"BDD3C7\",     \"buildings\": \"FFFFB3\",     \"places\": \"BEBADA\",     \"roads\": \"FB8072\", }  m.add_legend(legend_dict=legend_dict) m Out[6]: In\u00a0[7]: Copied! <pre>url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['building_footprints']\nbounds: [-160.221701, -55.9756776, 166.709685, 74.7731168]\n</pre> In\u00a0[8]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=2, height=\"800px\")\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_basemap(\"Esri.WorldImagery\", show=False)\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"building_footprints\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url, name=\"Buildings\", style=style, overlay=True, show=True, zoom_to_layer=False\n)\n\nhtml = \"Source: &lt;a href='https://beta.source.coop/repositories/vida/google-microsoft-open-buildings/description' target='_blank'&gt;source.coop&lt;/a&gt;\"\nm.add_html(html, position=\"bottomright\")\n\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=2, height=\"800px\") m.add_basemap(\"CartoDB.DarkMatter\") m.add_basemap(\"Esri.WorldImagery\", show=False)  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"building_footprints\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url, name=\"Buildings\", style=style, overlay=True, show=True, zoom_to_layer=False )  html = \"Source: source.coop\" m.add_html(html, position=\"bottomright\")  m <pre>Basemap can only be one of the following: OpenStreetMap, ROADMAP, SATELLITE, TERRAIN, HYBRID, FWS NWI Wetlands, FWS NWI Wetlands Raster, NLCD 2021 CONUS Land Cover, NLCD 2019 CONUS Land Cover, NLCD 2016 CONUS Land Cover, NLCD 2013 CONUS Land Cover, NLCD 2011 CONUS Land Cover, NLCD 2008 CONUS Land Cover, NLCD 2006 CONUS Land Cover, NLCD 2004 CONUS Land Cover, NLCD 2001 CONUS Land Cover, USGS NAIP Imagery, USGS NAIP Imagery False Color, USGS NAIP Imagery NDVI, USGS Hydrography, USGS 3DEP Elevation, ESA WorldCover 2020, ESA WorldCover 2020 S2 FCC, ESA WorldCover 2020 S2 TCC, ESA WorldCover 2021, ESA WorldCover 2021 S2 FCC, ESA WorldCover 2021 S2 TCC, BaseMapDE.Color, BaseMapDE.Grey, BasemapAT.basemap, BasemapAT.grau, BasemapAT.highdpi, BasemapAT.orthofoto, BasemapAT.overlay, BasemapAT.surface, BasemapAT.terrain, CartoDB.DarkMatter, CartoDB.DarkMatterNoLabels, CartoDB.DarkMatterOnlyLabels, CartoDB.Positron, CartoDB.PositronNoLabels, CartoDB.PositronOnlyLabels, CartoDB.Voyager, CartoDB.VoyagerLabelsUnder, CartoDB.VoyagerNoLabels, CartoDB.VoyagerOnlyLabels, CyclOSM, Esri.AntarcticBasemap, Esri.AntarcticImagery, Esri.ArcticImagery, Esri.ArcticOceanBase, Esri.ArcticOceanReference, Esri.DeLorme, Esri.NatGeoWorldMap, Esri.OceanBasemap, Esri.WorldGrayCanvas, Esri.WorldPhysical, Esri.WorldShadedRelief, Esri.WorldTerrain, FreeMapSK, Gaode.Normal, Gaode.Satellite, HikeBike.HikeBike, HikeBike.HillShading, JusticeMap.americanIndian, JusticeMap.asian, JusticeMap.black, JusticeMap.hispanic, JusticeMap.income, JusticeMap.multi, JusticeMap.nonWhite, JusticeMap.plurality, JusticeMap.white, MtbMap, NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief, NASAGIBS.BlueMarble3031, NASAGIBS.BlueMarble3413, NASAGIBS.BlueMarbleBathymetry3031, NASAGIBS.BlueMarbleBathymetry3413, NASAGIBS.MEaSUREsIceVelocity3031, NASAGIBS.MEaSUREsIceVelocity3413, NASAGIBS.ModisAquaBands721CR, NASAGIBS.ModisAquaTrueColorCR, NASAGIBS.ModisTerraAOD, NASAGIBS.ModisTerraBands367CR, NASAGIBS.ModisTerraBands721CR, NASAGIBS.ModisTerraChlorophyll, NASAGIBS.ModisTerraLSTDay, NASAGIBS.ModisTerraSnowCover, NASAGIBS.ModisTerraTrueColorCR, NASAGIBS.ViirsEarthAtNight2012, NASAGIBS.ViirsTrueColorCR, OPNVKarte, OneMapSG.Default, OneMapSG.Grey, OneMapSG.LandLot, OneMapSG.Night, OneMapSG.Original, OpenAIP, OpenFireMap, OpenRailwayMap, OpenSeaMap, OpenSnowMap.pistes, OpenStreetMap.BZH, OpenStreetMap.BlackAndWhite, OpenStreetMap.CH, OpenStreetMap.DE, OpenStreetMap.HOT, OpenStreetMap.Mapnik, OpenTopoMap, SafeCast, Stadia.AlidadeSatellite, Stadia.AlidadeSmooth, Stadia.AlidadeSmoothDark, Stadia.OSMBright, Stadia.Outdoors, Stadia.StamenTerrain, Stadia.StamenTerrainBackground, Stadia.StamenTerrainLabels, Stadia.StamenTerrainLines, Stadia.StamenToner, Stadia.StamenTonerBackground, Stadia.StamenTonerLabels, Stadia.StamenTonerLines, Stadia.StamenTonerLite, Stadia.StamenWatercolor, Strava.All, Strava.Ride, Strava.Run, Strava.Water, Strava.Winter, SwissFederalGeoportal.JourneyThroughTime, SwissFederalGeoportal.NationalMapColor, SwissFederalGeoportal.NationalMapGrey, SwissFederalGeoportal.SWISSIMAGE, TopPlusOpen.Color, TopPlusOpen.Grey, USGS.USImagery, USGS.USImageryTopo, USGS.USTopo, WaymarkedTrails.cycling, WaymarkedTrails.hiking, WaymarkedTrails.mtb, WaymarkedTrails.riding, WaymarkedTrails.skating, WaymarkedTrails.slopes, nlmaps.grijs, nlmaps.luchtfoto, nlmaps.pastel, nlmaps.standaard, nlmaps.water, Planet_2016q1, Planet_2016q2, Planet_2016q3, Planet_2016q4, Planet_2017q1, Planet_2017q2, Planet_2017q3, Planet_2017q4, Planet_2018q1, Planet_2018q2, Planet_2018q3, Planet_2018q4, Planet_2019q1, Planet_2019q2, Planet_2019q3, Planet_2019q4, Planet_2020q1, Planet_2020q2, Planet_2020q3, Planet_2020q4, Planet_2021q1, Planet_2021q2, Planet_2021q3, Planet_2021q4, Planet_2022q1, Planet_2022q2, Planet_2022q3, Planet_2022q4, Planet_2023q1, Planet_2023q2, Planet_2023q3, Planet_2023q4, Planet_2024q1, Planet_2016_01, Planet_2016_02, Planet_2016_03, Planet_2016_04, Planet_2016_05, Planet_2016_06, Planet_2016_07, Planet_2016_08, Planet_2016_09, Planet_2016_10, Planet_2016_11, Planet_2016_12, Planet_2017_01, Planet_2017_02, Planet_2017_03, Planet_2017_04, Planet_2017_05, Planet_2017_06, Planet_2017_07, Planet_2017_08, Planet_2017_09, Planet_2017_10, Planet_2017_11, Planet_2017_12, Planet_2018_01, Planet_2018_02, Planet_2018_03, Planet_2018_04, Planet_2018_05, Planet_2018_06, Planet_2018_07, Planet_2018_08, Planet_2018_09, Planet_2018_10, Planet_2018_11, Planet_2018_12, Planet_2019_01, Planet_2019_02, Planet_2019_03, Planet_2019_04, Planet_2019_05, Planet_2019_06, Planet_2019_07, Planet_2019_08, Planet_2019_09, Planet_2019_10, Planet_2019_11, Planet_2019_12, Planet_2020_01, Planet_2020_02, Planet_2020_03, Planet_2020_04, Planet_2020_05, Planet_2020_06, Planet_2020_07, Planet_2020_08, Planet_2020_09, Planet_2020_10, Planet_2020_11, Planet_2020_12, Planet_2021_01, Planet_2021_02, Planet_2021_03, Planet_2021_04, Planet_2021_05, Planet_2021_06, Planet_2021_07, Planet_2021_08, Planet_2021_09, Planet_2021_10, Planet_2021_11, Planet_2021_12, Planet_2022_01, Planet_2022_02, Planet_2022_03, Planet_2022_04, Planet_2022_05, Planet_2022_06, Planet_2022_07, Planet_2022_08, Planet_2022_09, Planet_2022_10, Planet_2022_11, Planet_2022_12, Planet_2023_01, Planet_2023_02, Planet_2023_03, Planet_2023_04, Planet_2023_05, Planet_2023_06, Planet_2023_07, Planet_2023_08, Planet_2023_09, Planet_2023_10, Planet_2023_11, Planet_2023_12, Planet_2024_01, Planet_2024_02, Planet_2024_03, Planet_2024_04, Planet_2024_05\n</pre> Out[8]: In\u00a0[9]: Copied! <pre>m.save(\"buildings.html\")\n</pre> m.save(\"buildings.html\") In\u00a0[10]: Copied! <pre>url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\"\nleafmap.download_file(url, \"buildings.geojson\")\n</pre> url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\" leafmap.download_file(url, \"buildings.geojson\") <pre>Downloading...\nFrom: https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/buildings.geojson\n</pre> <pre>\r  0%|          | 0.00/2.77M [00:00&lt;?, ?B/s]</pre> <pre>\r12.8MB [00:00, 166MB/s]                    </pre> <pre>\n</pre> Out[10]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/buildings.geojson'</pre> <p>Convert vector to PMTiles.</p> In\u00a0[11]: Copied! <pre>pmtiles = \"buildings.pmtiles\"\nleafmap.geojson_to_pmtiles(\n    \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True\n)\n</pre> pmtiles = \"buildings.pmtiles\" leafmap.geojson_to_pmtiles(     \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True ) <pre>Error: tippecanoe is not installed.\nYou can install it using conda with the following command:\nconda install -c conda-forge tippecanoe\n</pre> <p>Start a HTTP Sever</p> In\u00a0[12]: Copied! <pre>leafmap.start_server(port=8000)\n</pre> leafmap.start_server(port=8000) In\u00a0[13]: Copied! <pre>url = f\"http://127.0.0.1:8000/{pmtiles}\"\n# leafmap.pmtiles_metadata(url)\n</pre> url = f\"http://127.0.0.1:8000/{pmtiles}\" # leafmap.pmtiles_metadata(url) <p>Display the PMTiles on the map.</p> In\u00a0[14]: Copied! <pre>m = leafmap.Map()\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(url, name=\"Buildings\", show=True, zoom_to_layer=True, style=style)\nm\n</pre> m = leafmap.Map()  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(url, name=\"Buildings\", show=True, zoom_to_layer=True, style=style) m <pre>HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /buildings.pmtiles (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x7ff41b9af590&gt;: Failed to establish a new connection: [Errno 111] Connection refused'))\n</pre> Out[14]:"},{"location":"notebooks/82_pmtiles/#remote-pmtiles","title":"Remote PMTiles\u00b6","text":""},{"location":"notebooks/82_pmtiles/#protomaps-sample-data","title":"Protomaps sample data\u00b6","text":""},{"location":"notebooks/82_pmtiles/#overture-data","title":"Overture data\u00b6","text":""},{"location":"notebooks/82_pmtiles/#source-cooperative","title":"Source Cooperative\u00b6","text":"<p>Google-Microsoft Open Buildings - combined by VIDA</p>"},{"location":"notebooks/82_pmtiles/#local-pmtiles","title":"Local PMTiles\u00b6","text":"<p>tippecanoe is required to convert vector data to pmtiles. Install it with <code>conda install -c conda-forge tippecanoe</code>.</p> <p>Download building footprints of Derna, Libya.</p>"},{"location":"notebooks/83_vector_viz/","title":"83 vector viz","text":"<p>Visualizing large vector datasets with lonboard</p> <p>This notebook demonstrates how to visualize large vector datasets with lonboard. Please note that lonboard does not support Visual Studio Code's interactive notebook yet. You will need to run this notebook in Jupyter Notebook or JupyterLab.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap lonboard\n</pre> # %pip install -U leafmap lonboard In\u00a0[2]: Copied! <pre>import leafmap.deckgl as leafmap\nimport geopandas as gpd\nimport ipywidgets as widgets\n</pre> import leafmap.deckgl as leafmap import geopandas as gpd import ipywidgets as widgets <p>Download sample datasets.</p> In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/duckdb/nyc_data.zip\"\nleafmap.download_file(url, unzip=True)\n</pre> url = \"https://open.gishub.org/data/duckdb/nyc_data.zip\" leafmap.download_file(url, unzip=True) <pre>Downloading...\nFrom: https://open.gishub.org/data/duckdb/nyc_data.zip\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/nyc_data.zip\n</pre> <pre>\r  0%|          | 0.00/8.73M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8.73M/8.73M [00:00&lt;00:00, 171MB/s]</pre> <pre>Extracting files...\n</pre> <pre>\n</pre> Out[3]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/nyc_data.zip'</pre> <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1.2)\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1.2) m <p>Add GeoDataFrame.</p> In\u00a0[5]: Copied! <pre>streets = gpd.read_file(\"nyc_streets.shp\")\nm.add_gdf(streets, zoom_to_layer=True, pickable=True, get_width=5)\n</pre> streets = gpd.read_file(\"nyc_streets.shp\") m.add_gdf(streets, zoom_to_layer=True, pickable=True, get_width=5) <p>Add any vector format supported by GeoPandas.</p> In\u00a0[6]: Copied! <pre>m.add_vector(\"nyc_subway_stations.shp\", get_radius=10, get_fill_color=[255, 0, 0, 180])\n</pre> m.add_vector(\"nyc_subway_stations.shp\", get_radius=10, get_fill_color=[255, 0, 0, 180]) <p>Change layer properties.</p> In\u00a0[7]: Copied! <pre>layer = m.layers[-1]\nlayer.get_fill_color = [0, 0, 255, 255]\n</pre> layer = m.layers[-1] layer.get_fill_color = [0, 0, 255, 255] <p>Interactive widgets.</p> In\u00a0[8]: Copied! <pre>color = widgets.ColorPicker(value=\"red\", description=\"Color\")\nwidth = widgets.IntSlider(min=1, max=100, value=10, description=\"Radius\")\nhbox = widgets.HBox([color, width])\n</pre> color = widgets.ColorPicker(value=\"red\", description=\"Color\") width = widgets.IntSlider(min=1, max=100, value=10, description=\"Radius\") hbox = widgets.HBox([color, width]) In\u00a0[9]: Copied! <pre>widgets.dlink((color, \"value\"), (layer, \"get_fill_color\"))\nwidgets.dlink((width, \"value\"), (layer, \"get_radius\"))\n</pre> widgets.dlink((color, \"value\"), (layer, \"get_fill_color\")) widgets.dlink((width, \"value\"), (layer, \"get_radius\")) Out[9]: <pre>&lt;traitlets.traitlets.directional_link at 0x7f858131f410&gt;</pre> In\u00a0[10]: Copied! <pre>hbox\n</pre> hbox In\u00a0[11]: Copied! <pre>m\n</pre> m"},{"location":"notebooks/84_read_parquet/","title":"84 read parquet","text":"<p>Reading GeoParquet files and visualizing vector data interactively</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap lonboard==0.3.0\n</pre> # %pip install -U leafmap lonboard==0.3.0 In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>Visualizing point data.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://open.gishub.org/data/duckdb/cities.parquet\"\n</pre> url = \"https://open.gishub.org/data/duckdb/cities.parquet\" <p>Read GeoParquet and return a GeoPandas GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.read_parquet(url, return_type=\"gdf\", src_crs=\"EPSG:4326\")\ngdf.head()\n</pre> gdf = leafmap.read_parquet(url, return_type=\"gdf\", src_crs=\"EPSG:4326\") gdf.head() <p>View the GeoDataFrame interactively using folium.</p> In\u00a0[\u00a0]: Copied! <pre>gdf.explore()\n</pre> gdf.explore() <p>Visualize the GeoDataFrame using lonboard.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.view_vector(gdf, get_radius=20000, get_fill_color=\"blue\")\n</pre> leafmap.view_vector(gdf, get_radius=20000, get_fill_color=\"blue\") <p>Visualizing polygon data.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://data.source.coop/giswqs/nwi/wetlands/DC_Wetlands.parquet\"\n</pre> url = \"https://data.source.coop/giswqs/nwi/wetlands/DC_Wetlands.parquet\" In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.read_parquet(\n    url, return_type=\"gdf\", src_crs=\"EPSG:5070\", dst_crs=\"EPSG:4326\"\n)\ngdf.head()\n</pre> gdf = leafmap.read_parquet(     url, return_type=\"gdf\", src_crs=\"EPSG:5070\", dst_crs=\"EPSG:4326\" ) gdf.head() In\u00a0[\u00a0]: Copied! <pre>gdf.explore()\n</pre> gdf.explore() In\u00a0[\u00a0]: Copied! <pre>leafmap.view_vector(gdf, get_fill_color=[0, 0, 255, 128])\n</pre> leafmap.view_vector(gdf, get_fill_color=[0, 0, 255, 128]) <p></p> <p>Alternatively, you can specify a color map to visualize the data.</p> In\u00a0[\u00a0]: Copied! <pre>color_map = {\n    \"Freshwater Forested/Shrub Wetland\": (0, 136, 55),\n    \"Freshwater Emergent Wetland\": (127, 195, 28),\n    \"Freshwater Pond\": (104, 140, 192),\n    \"Estuarine and Marine Wetland\": (102, 194, 165),\n    \"Riverine\": (1, 144, 191),\n    \"Lake\": (19, 0, 124),\n    \"Estuarine and Marine Deepwater\": (0, 124, 136),\n    \"Other\": (178, 134, 86),\n}\n</pre> color_map = {     \"Freshwater Forested/Shrub Wetland\": (0, 136, 55),     \"Freshwater Emergent Wetland\": (127, 195, 28),     \"Freshwater Pond\": (104, 140, 192),     \"Estuarine and Marine Wetland\": (102, 194, 165),     \"Riverine\": (1, 144, 191),     \"Lake\": (19, 0, 124),     \"Estuarine and Marine Deepwater\": (0, 124, 136),     \"Other\": (178, 134, 86), } In\u00a0[\u00a0]: Copied! <pre>leafmap.view_vector(gdf, color_column=\"WETLAND_TYPE\", color_map=color_map, opacity=0.5)\n</pre> leafmap.view_vector(gdf, color_column=\"WETLAND_TYPE\", color_map=color_map, opacity=0.5) <p></p> <p>Display a legend for the data.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.Legend(title=\"Wetland Type\", legend_dict=color_map)\n</pre> leafmap.Legend(title=\"Wetland Type\", legend_dict=color_map) <p></p>"},{"location":"notebooks/85_gedi/","title":"85 gedi","text":"<p>How to search and download GEDI L4A dataset interactively</p> <p>This notebook shows how to search and download the GEDI L4A dataset using leafmap. The source code is adapted from the gedi_tutorials repository but has been greatly simplified. Credit goes to ORNL DAAC and Rupesh Shrestha.</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U \"leafmap[vector]\"\n</pre> # %pip install -U \"leafmap[vector]\" In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map(height=600)\nm\n</pre> m = leafmap.Map(height=600) m <p>Use the draw tool to draw a rectangle on the map. If no rectangle is drawn, the default bounding box will be used.</p> In\u00a0[4]: Copied! <pre>if m.user_roi is not None:\n    roi = m.user_roi_bounds()\nelse:\n    roi = [-73.9872, -33.7683, -34.7299, 5.2444]\n</pre> if m.user_roi is not None:     roi = m.user_roi_bounds() else:     roi = [-73.9872, -33.7683, -34.7299, 5.2444] <p>Specify the start and end date.</p> In\u00a0[5]: Copied! <pre>start_date = \"2020-07-01\"\nend_date = \"2020-07-31\"\n</pre> start_date = \"2020-07-01\" end_date = \"2020-07-31\" <p>Search and download GEDI L4A dataset.</p> In\u00a0[6]: Copied! <pre>gdf = leafmap.gedi_search(roi, start_date, end_date, add_roi=False, sort_filesize=True)\ngdf.head()\n</pre> gdf = leafmap.gedi_search(roi, start_date, end_date, add_roi=False, sort_filesize=True) gdf.head() Out[6]: id title time_start time_end granule_size granule_url granule_poly 53 G2613724953-ORNL_CLOUD GEDI_L4A_AGB_Density_V2_1.GEDI04_A_20201881134... 2020-07-06T12:43:14.000Z 2020-07-06T12:46:58.000Z 47.861555 https://data.ornldaac.earthdata.nasa.gov/prote... MULTIPOLYGON (((-44.97207 2.55617, -42.81717 -... 158 G2613715991-ORNL_CLOUD GEDI_L4A_AGB_Density_V2_1.GEDI04_A_20202000651... 2020-07-18T08:01:01.000Z 2020-07-18T08:04:33.000Z 54.162131 https://data.ornldaac.earthdata.nasa.gov/prote... MULTIPOLYGON (((-42.53334 -0.01093, -40.37672 ... 154 G2613746001-ORNL_CLOUD GEDI_L4A_AGB_Density_V2_1.GEDI04_A_20201992001... 2020-07-17T20:19:34.000Z 2020-07-17T20:24:35.000Z 55.751903 https://data.ornldaac.earthdata.nasa.gov/prote... MULTIPOLYGON (((-56.59662 -15.01064, -54.30646... 86 G2613716275-ORNL_CLOUD GEDI_L4A_AGB_Density_V2_1.GEDI04_A_20201921001... 2020-07-10T11:10:20.000Z 2020-07-10T11:14:01.000Z 57.355977 https://data.ornldaac.earthdata.nasa.gov/prote... MULTIPOLYGON (((-43.26376 0.03918, -41.10744 -... 192 G2613743057-ORNL_CLOUD GEDI_L4A_AGB_Density_V2_1.GEDI04_A_20202040516... 2020-07-22T06:26:07.000Z 2020-07-22T06:29:35.000Z 60.549672 https://data.ornldaac.earthdata.nasa.gov/prote... MULTIPOLYGON (((-42.25131 0.03698, -40.09134 -... <p>Visualize the GEDI L4A dataset footprints.</p> In\u00a0[7]: Copied! <pre>m.add_gdf(gdf, layer_name=\"GEDI footprints\")\nm\n</pre> m.add_gdf(gdf, layer_name=\"GEDI footprints\") m <p>Download the GEDI L4A dataset from NASA EarthData website. You need to register an account first if you don't have one. Create an account at https://urs.earthdata.nasa.gov. Then return to this notebook and uncomment the following code cell to set your username and password.</p> In\u00a0[8]: Copied! <pre># import os\n# os.environ[\"EARTHDATA_USERNAME\"] = \"your_username\"\n# os.environ[\"EARTHDATA_PASSWORD\"] = \"your_password\"\n</pre> # import os # os.environ[\"EARTHDATA_USERNAME\"] = \"your_username\" # os.environ[\"EARTHDATA_PASSWORD\"] = \"your_password\" In\u00a0[9]: Copied! <pre>leafmap.gedi_download_files(gdf.head(), outdir=\"data\")\n</pre> leafmap.gedi_download_files(gdf.head(), outdir=\"data\") <pre>Downloading file 1 of 5...\n</pre> <pre>Downloading file 2 of 5...\n</pre> <pre>Downloading file 3 of 5...\n</pre> <pre>Downloading file 4 of 5...\n</pre> <pre>Downloading file 5 of 5...\n</pre> <p>Read the downloaded GEDI L4A dataset as a GeoDataFrame.</p> In\u00a0[10]: Copied! <pre>try:\n    gdf = leafmap.h5_to_gdf(\n        \"data/*.h5\", dataset=\"BEAM0110\", columns=[\"agbd\"], nodata=-9999\n    )\nexcept:\n    # Download the sample data if the above code fails\n    gdf = leafmap.geojson_to_gdf(\n        \"https://github.com/opengeos/data/releases/download/v1.0.0/gedi_sample.geojson\"\n    )\ngdf.head()\n</pre> try:     gdf = leafmap.h5_to_gdf(         \"data/*.h5\", dataset=\"BEAM0110\", columns=[\"agbd\"], nodata=-9999     ) except:     # Download the sample data if the above code fails     gdf = leafmap.geojson_to_gdf(         \"https://github.com/opengeos/data/releases/download/v1.0.0/gedi_sample.geojson\"     ) gdf.head() Out[10]: agbd lat_lowestmode lon_lowestmode category color geometry 0 0.294734 -6.611691 -38.467288 1 #f7fcf5 POINT (-38.46729 -6.61169) 1 0.698346 -6.614202 -38.465479 1 #f7fcf5 POINT (-38.46548 -6.61420) 2 0.377637 -6.704764 -38.400342 1 #f7fcf5 POINT (-38.40034 -6.70476) 3 0.655570 -6.705182 -38.400042 1 #f7fcf5 POINT (-38.40004 -6.70518) 4 6.617977 -6.708118 -38.397930 3 #74c476 POINT (-38.39793 -6.70812) <p>We can subset the GeoDataFrame by a bounding box. First, create an interactive map and add the bounding box to the map.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map(height=620)\nroi = [-38.8641, -6.8664, -37.2107, -6.359]\nbbox = leafmap.bbox_to_gdf(roi)\nm.add_gdf(bbox, layer_name=\"ROI\", zoom_to_layer=True, info_mode=None)\nm\n</pre> m = leafmap.Map(height=620) roi = [-38.8641, -6.8664, -37.2107, -6.359] bbox = leafmap.bbox_to_gdf(roi) m.add_gdf(bbox, layer_name=\"ROI\", zoom_to_layer=True, info_mode=None) m <p>Use the bounding box to subset the GeoDataFrame.</p> In\u00a0[12]: Copied! <pre>subset = leafmap.filter_bounds(gdf, roi, within=True)\n</pre> subset = leafmap.filter_bounds(gdf, roi, within=True) <p>Add the subsetted GeoDataFrame to the map. Note that this is only for visualizing a small subset of the data. If you want to work with the entire dataset, you can skip this step.</p> In\u00a0[13]: Copied! <pre>m.add_data(subset, column=\"agbd\", cmap=\"Greens\", marker_radius=5)\n</pre> m.add_data(subset, column=\"agbd\", cmap=\"Greens\", marker_radius=5) <p>Visualize the GEDI L4A Aboveground Biomass Density (AGBD) data with lonboard.</p> In\u00a0[14]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[15]: Copied! <pre>leafmap.view_vector(\n    gdf, color_column=\"agbd\", color_map=\"Greens\", color_k=10, get_radius=25\n)\n</pre> leafmap.view_vector(     gdf, color_column=\"agbd\", color_map=\"Greens\", color_k=10, get_radius=25 )"},{"location":"notebooks/86_add_markers/","title":"86 add markers","text":"<p>Adding markers to the map</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U \"leafmap[vector]\"\n</pre> # %pip install -U \"leafmap[vector]\" In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap <p>Create an interactive map.</p> In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Add a simple marker to the map.</p> In\u00a0[4]: Copied! <pre>m.add_markers(markers=[40, -100], shape=\"marker\")\n</pre> m.add_markers(markers=[40, -100], shape=\"marker\") <p>Add circle markers to the map.</p> In\u00a0[5]: Copied! <pre>m.add_markers(markers=[[40, -100], [35, -110]], shape=\"circle\")\n</pre> m.add_markers(markers=[[40, -100], [35, -110]], shape=\"circle\") <p>Customize circle markers.</p> In\u00a0[6]: Copied! <pre>m.add_markers(\n    markers=[[40, -100], [35, -110]],\n    shape=\"circle\",\n    radius=20,\n    color=\"red\",\n    fill_color=\"#3388ff\",\n    fill_opacity=0.5,\n)\n</pre> m.add_markers(     markers=[[40, -100], [35, -110]],     shape=\"circle\",     radius=20,     color=\"red\",     fill_color=\"#3388ff\",     fill_opacity=0.5, ) <p></p> <p>Add country polygons to the map.</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\ncountries = \"https://open.gishub.org/data/world/countries.geojson\"\nm.add_geojson(countries, layer_name=\"Countries\", info_mode=None)\nm\n</pre> m = leafmap.Map() countries = \"https://open.gishub.org/data/world/countries.geojson\" m.add_geojson(countries, layer_name=\"Countries\", info_mode=None) m <p>Add circle markers with popups to the map.</p> In\u00a0[8]: Copied! <pre>url = \"https://open.gishub.org/data/world/world_cities.geojson\"\nm.add_data(url, column=\"population\", cmap=\"Blues\", marker_radius=5, layer_name=\"Cities\")\n</pre> url = \"https://open.gishub.org/data/world/world_cities.geojson\" m.add_data(url, column=\"population\", cmap=\"Blues\", marker_radius=5, layer_name=\"Cities\") <p></p>"},{"location":"notebooks/87_actinia/","title":"87 actinia","text":"<p>Cloud-based geoprocessing with Actinia</p> In\u00a0[\u00a0]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap <p>The cloud based geoprocessing platform actinia is able to ingest and analyse large volumes of geodata in the cloud.</p> <p>For the following actinia example we use the actinia-python-client (source code) to establish the connection to an actinia instance. First install the actinia-python-client (for latest version, see actinia-python-client releases).</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>%pip install actinia_python_client\n</pre> %pip install actinia_python_client <p>The results of actinia ephemeral processing are available via object storage as GeoTIFF/COG or GeoPackage files.</p> <p>Add a helper function for \"pretty printing\" of actinia results:</p> In\u00a0[\u00a0]: Copied! <pre>from json import dumps as json_dumps\n\n\ndef print_dict(input_dict, text=None):\n    if text:\n        print(text)\n    if \"region\" in input_dict:\n        input_dict[\"region\"] = input_dict[\"region\"].__dict__\n    print(json_dumps(input_dict, sort_keys=True, indent=4))\n\n\ndef print_dict_keys(input_dict, text=None):\n    if text:\n        print(text)\n    print(\", \".join(input_dict.keys()))\n</pre> from json import dumps as json_dumps   def print_dict(input_dict, text=None):     if text:         print(text)     if \"region\" in input_dict:         input_dict[\"region\"] = input_dict[\"region\"].__dict__     print(json_dumps(input_dict, sort_keys=True, indent=4))   def print_dict_keys(input_dict, text=None):     if text:         print(text)     print(\", \".join(input_dict.keys())) <p>Connect to the default actinia server which is defined in the actinia-python-client, currently https://actinia.mundialis.de.</p> In\u00a0[\u00a0]: Copied! <pre># connect to the actinia server\nfrom actinia import Actinia\n\n# connect to default actinia server (https://actinia.mundialis.de)\nactinia_mundialis = Actinia()\n\n# retrieve metadata about actinia server and related software versions\nversion = actinia_mundialis.get_version()\nprint_dict(version, \"Version is:\")\n</pre> # connect to the actinia server from actinia import Actinia  # connect to default actinia server (https://actinia.mundialis.de) actinia_mundialis = Actinia()  # retrieve metadata about actinia server and related software versions version = actinia_mundialis.get_version() print_dict(version, \"Version is:\") <p>Set the authentication settings of the actinia demo user to gain access to the actinia server functionality.</p> In\u00a0[\u00a0]: Copied! <pre>actinia_user = \"demouser\"\nactinia_password = \"gu3st!pa55w0rd\"\n\n# we use the default actinia server\nactinia_mundialis.set_authentication(actinia_user, actinia_password)\nprint(\"Connected to actinia server.\")\n</pre> actinia_user = \"demouser\" actinia_password = \"gu3st!pa55w0rd\"  # we use the default actinia server actinia_mundialis.set_authentication(actinia_user, actinia_password) print(\"Connected to actinia server.\") <p>Obtain the list of locations and retrieve the metadata of a selected location.</p> In\u00a0[\u00a0]: Copied! <pre># obtain the list of projects (called \"locations\") which are accessible to current user\nlocations = actinia_mundialis.get_locations()\nprint_dict_keys(locations, \"Locations: \")\n</pre> # obtain the list of projects (called \"locations\") which are accessible to current user locations = actinia_mundialis.get_locations() print_dict_keys(locations, \"Locations: \") <p>Retrieve the metadata of a selected location (this shows the respective projection information, spatial extent, resolution, etc.) to get an idea how the output looks like.</p> In\u00a0[\u00a0]: Copied! <pre>print_dict(actinia_mundialis.locations[\"nc_spm_08\"].get_info(), \"Location info:\")\n</pre> print_dict(actinia_mundialis.locations[\"nc_spm_08\"].get_info(), \"Location info:\") <p>At this point the connection to the selected actinia server is properly established.</p> <p>Reading the online data resource into the actinia server</p> <p>Next we demonstrate the data processing of a raster map available online in actinia, here a sample DEM GeoTIFF file.</p> In\u00a0[\u00a0]: Copied! <pre># define raster elevation map name\nraster_layer_name = \"srtm90\"\n\n# cache file locally\nout_dir = os.getcwd()\ndem_file = os.path.join(out_dir, f\"{raster_layer_name}.tif\")\n\n# dem_url = (\n#    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n# )\ndem_url = f\"https://github.com/giswqs/data/raw/main/raster/{raster_layer_name}.tif\"\n\n# leafmap.download_file(dem_url, dem_file, unzip=False, overwrite=True)\n</pre> # define raster elevation map name raster_layer_name = \"srtm90\"  # cache file locally out_dir = os.getcwd() dem_file = os.path.join(out_dir, f\"{raster_layer_name}.tif\")  # dem_url = ( #    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" # ) dem_url = f\"https://github.com/giswqs/data/raw/main/raster/{raster_layer_name}.tif\"  # leafmap.download_file(dem_url, dem_file, unzip=False, overwrite=True) <p>Prepare actinia location and mapset, i.e. generate a subproject for data processing.</p> In\u00a0[\u00a0]: Copied! <pre># request list of all locations\nlocations = actinia_mundialis.get_locations()\nprint([loc for loc in locations])\n</pre> # request list of all locations locations = actinia_mundialis.get_locations() print([loc for loc in locations]) In\u00a0[\u00a0]: Copied! <pre># remove leftover location from previous run\n# actinia_mundialis.locations[\"latlong_wgs84\"].delete()\n#\n# remove leftover mapset from previous run\nlocations[\"latlong_wgs84\"].delete_mapset(\"elevation\")\n</pre> # remove leftover location from previous run # actinia_mundialis.locations[\"latlong_wgs84\"].delete() # # remove leftover mapset from previous run locations[\"latlong_wgs84\"].delete_mapset(\"elevation\") In\u00a0[\u00a0]: Copied! <pre># Create a new location for the data processing in actinia\nnew_location = actinia_mundialis.create_location(\"latlong_wgs84\", 4326)\nprint(new_location.name)\nprint(new_location.region)\nprint([loc for loc in actinia_mundialis.locations])\n\n# request list of mapsets in selected location\nmapsets = actinia_mundialis.locations[\"latlong_wgs84\"].get_mapsets()\nprint_dict_keys(mapsets, \"Mapsets in latlong_wgs84:\")\n</pre> # Create a new location for the data processing in actinia new_location = actinia_mundialis.create_location(\"latlong_wgs84\", 4326) print(new_location.name) print(new_location.region) print([loc for loc in actinia_mundialis.locations])  # request list of mapsets in selected location mapsets = actinia_mundialis.locations[\"latlong_wgs84\"].get_mapsets() print_dict_keys(mapsets, \"Mapsets in latlong_wgs84:\") In\u00a0[\u00a0]: Copied! <pre># Create a new mapset for the data processing in actinia\nmapset_name = \"elevation\"\nlocations[\"latlong_wgs84\"].create_mapset(mapset_name)\n</pre> # Create a new mapset for the data processing in actinia mapset_name = \"elevation\" locations[\"latlong_wgs84\"].create_mapset(mapset_name) In\u00a0[\u00a0]: Copied! <pre>## Optional: Upload the sample DEM data set to actinia (indeed not needed since we use `vsicurl/` below\n##           to directly retrieve the online dataset).\n# locations[\"latlong_wgs84\"].mapsets[mapset_name].upload_raster(raster_layer_name, dem_file)\n# print_dict_keys(locations[\"latlong_wgs84\"].mapsets[mapset_name].raster_layers, \"Raster maps in new mapset:\")\n</pre> ## Optional: Upload the sample DEM data set to actinia (indeed not needed since we use `vsicurl/` below ##           to directly retrieve the online dataset). # locations[\"latlong_wgs84\"].mapsets[mapset_name].upload_raster(raster_layer_name, dem_file) # print_dict_keys(locations[\"latlong_wgs84\"].mapsets[mapset_name].raster_layers, \"Raster maps in new mapset:\") <p>Hillshading example</p> <p>Here an example for an ephemeral processing job: We download and import the remotely available GeoTIFF file. Then we use r.relief to generate a hillshading map and pre-define the resolution to 10 m. The computational region is set to the input elevation map. The resulting <code>hillshade.tif</code> raster map is then provided as a resource for download and visualization.</p> In\u00a0[\u00a0]: Copied! <pre>pc = {\n    \"list\": [\n        {\n            \"id\": \"importer_0\",\n            \"comment\": \"Import of remote data source (here: COG)\",\n            \"module\": \"r.import\",\n            \"inputs\": [\n                {\"param\": \"input\", \"value\": f\"/vsicurl/{dem_url}\"},\n                {\"param\": \"memory\", \"value\": \"2000\"},\n                {\"param\": \"extent\", \"value\": \"input\"},\n            ],\n            \"outputs\": [{\"param\": \"output\", \"value\": f\"{raster_layer_name}\"}],\n        },\n        {\n            \"id\": \"r.info_1\",\n            \"comment\": \"Print metadata of imported raster map\",\n            \"module\": \"r.info\",\n            \"inputs\": [{\"param\": \"map\", \"value\": f\"{raster_layer_name}\"}],\n        },\n        {\n            \"id\": \"computational_region_2\",\n            \"comment\": \"Set computational region to imported map, and print settings\",\n            \"module\": \"g.region\",\n            \"inputs\": [{\"param\": \"raster\", \"value\": f\"{raster_layer_name}\"}],\n            \"stdout\": {\"id\": \"region\", \"format\": \"kv\", \"delimiter\": \"=\"},\n            \"flags\": \"g\",\n        },\n        {\n            \"id\": \"create_hillshading_3\",\n            \"comment\": \"Compute hillshading map\",\n            \"module\": \"r.relief\",\n            \"inputs\": [{\"param\": \"input\", \"value\": f\"{raster_layer_name}\"}],\n            \"outputs\": [{\"param\": \"output\", \"value\": \"hillshade\"}],\n        },\n        {\n            \"id\": \"exporter_4\",\n            \"comment\": \"Export hillshading map to COG file\",\n            \"module\": \"exporter\",\n            \"outputs\": [\n                {\n                    \"export\": {\"type\": \"raster\", \"format\": \"COG\"},\n                    \"param\": \"map\",\n                    \"value\": \"hillshade\",\n                }\n            ],\n        },\n    ],\n    \"version\": \"1\",\n}\n\n\nprint(pc)\njob = actinia_mundialis.locations[\"latlong_wgs84\"].create_processing_export_job(\n    pc, \"hillshading\"\n)\njob.poll_until_finished()\n\nprint(job.status)\nprint(job.message)\nexported_raster = job.urls[\"resources\"][0]\nprint(exported_raster)\n</pre> pc = {     \"list\": [         {             \"id\": \"importer_0\",             \"comment\": \"Import of remote data source (here: COG)\",             \"module\": \"r.import\",             \"inputs\": [                 {\"param\": \"input\", \"value\": f\"/vsicurl/{dem_url}\"},                 {\"param\": \"memory\", \"value\": \"2000\"},                 {\"param\": \"extent\", \"value\": \"input\"},             ],             \"outputs\": [{\"param\": \"output\", \"value\": f\"{raster_layer_name}\"}],         },         {             \"id\": \"r.info_1\",             \"comment\": \"Print metadata of imported raster map\",             \"module\": \"r.info\",             \"inputs\": [{\"param\": \"map\", \"value\": f\"{raster_layer_name}\"}],         },         {             \"id\": \"computational_region_2\",             \"comment\": \"Set computational region to imported map, and print settings\",             \"module\": \"g.region\",             \"inputs\": [{\"param\": \"raster\", \"value\": f\"{raster_layer_name}\"}],             \"stdout\": {\"id\": \"region\", \"format\": \"kv\", \"delimiter\": \"=\"},             \"flags\": \"g\",         },         {             \"id\": \"create_hillshading_3\",             \"comment\": \"Compute hillshading map\",             \"module\": \"r.relief\",             \"inputs\": [{\"param\": \"input\", \"value\": f\"{raster_layer_name}\"}],             \"outputs\": [{\"param\": \"output\", \"value\": \"hillshade\"}],         },         {             \"id\": \"exporter_4\",             \"comment\": \"Export hillshading map to COG file\",             \"module\": \"exporter\",             \"outputs\": [                 {                     \"export\": {\"type\": \"raster\", \"format\": \"COG\"},                     \"param\": \"map\",                     \"value\": \"hillshade\",                 }             ],         },     ],     \"version\": \"1\", }   print(pc) job = actinia_mundialis.locations[\"latlong_wgs84\"].create_processing_export_job(     pc, \"hillshading\" ) job.poll_until_finished()  print(job.status) print(job.message) exported_raster = job.urls[\"resources\"][0] print(exported_raster) <p>It will take a moment, then the communication by actinia is shown: \"Status of hillshading job is accepted: Resource accepted\" continued by further communication messages.</p> <p>In case an error occurs, check the process log (use [x] with x being the step number in the process chain). Examples:</p> In\u00a0[\u00a0]: Copied! <pre># check step 0 (r.import)\nprint_dict(job.process_log[0])\n</pre> # check step 0 (r.import) print_dict(job.process_log[0]) In\u00a0[\u00a0]: Copied! <pre># check step 2 (g.region)\nprint_dict(job.process_log[2])\n</pre> # check step 2 (g.region) print_dict(job.process_log[2]) In\u00a0[\u00a0]: Copied! <pre># check step 3 (r.relief)\nprint_dict(job.process_log[3])\n</pre> # check step 3 (r.relief) print_dict(job.process_log[3]) <p>Inject <code>user:password@server</code> into <code>exported_raster</code> URL (i.e., the actinia resource).</p> In\u00a0[\u00a0]: Copied! <pre>url = exported_raster.replace(\"//\", f\"//{actinia_user}:{actinia_password}@\")\nprint(url)\n</pre> url = exported_raster.replace(\"//\", f\"//{actinia_user}:{actinia_password}@\") print(url) <p>Visualize the <code>hillshade</code> map in leafmap (colorbar inspired by this notebook):</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    cmap=\"terrain\",\n    label=\"Elevation\",\n    width=3,\n    height=0.3,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=4000,\n)\nm.add_cog_layer(\n    url,\n    name=\"SRTM90 hillshaded map\",\n    attribution='&lt;a href=\"https://e4ftl01.cr.usgs.gov/MEASURES/\"&gt;https://e4ftl01.cr.usgs.gov/MEASURES/&lt;/a&gt;',\n)\n# show map\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     cmap=\"terrain\",     label=\"Elevation\",     width=3,     height=0.3,     orientation=\"horizontal\",     vmin=0,     vmax=4000, ) m.add_cog_layer(     url,     name=\"SRTM90 hillshaded map\",     attribution='https://e4ftl01.cr.usgs.gov/MEASURES/', ) # show map m <p>Find further leafmap (styling) tools in the upper-right toolbox of leafmap.</p>"},{"location":"notebooks/87_actinia/#ephemeral-processing-with-actinia","title":"Ephemeral Processing with actinia\u00b6","text":"<p>Ephemeral processing is used to keep computed results, including user-generated data and temporary data, only for a limited period of time (e.g. 24 hours by default in the actinia demo server). This reduces cloud storage costs.</p> <p>In contrast, persistent processing refers to the persistent retention of data without a scheduled deletion time, even in the event of a power outage, resulting in corresponding storage costs. In the geo/EO context, persistent storage is used to provide, for example, basic cartography, i.e. elevation models, road networks, building footprints, etc.</p>"},{"location":"notebooks/88_nasa_earth_data/","title":"88 nasa earth data","text":"<p>Searching and downloading NASA Earth science data products</p> <p>Leafmap builds upon the earthaccess Python package to search and download NASA Earth science data products, making it easier visualize the footprints of the data products and download them interactively.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install leafmap earthaccess mapclassify\n</pre> # %pip install leafmap earthaccess mapclassify In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport pandas as pd\n</pre> import leafmap import pandas as pd <p>To download and access the data, you will need to create an Earthdata login. You can register for an account at urs.earthdata.nasa.gov.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.nasa_data_login()\n</pre> leafmap.nasa_data_login() <p>You can search data by short name, doi, concept id, etc. You can find the list of NASA Earth science data products from the NASA-Earth-Data repo. The example below shows how to show the metadata of the 9,000+ NASA Earth science data products.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\ndf = pd.read_csv(url, sep=\"\\t\")\ndf\n</pre> url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\" df = pd.read_csv(url, sep=\"\\t\") df <p>To search data, specify the short name, bounding box, date range, etc. To return the footprints of the data, set <code>return_gdf=True</code>.</p> In\u00a0[\u00a0]: Copied! <pre>results, gdf = leafmap.nasa_data_search(\n    short_name=\"GEDI_L4A_AGB_Density_V2_1_2056\",\n    cloud_hosted=True,\n    bounding_box=(-73.9872, -33.7683, -34.7299, 5.2444),\n    temporal=(\"2020-07-01\", \"2020-07-31\"),\n    count=-1,  # use -1 to return all datasets\n    return_gdf=True,\n)\n</pre> results, gdf = leafmap.nasa_data_search(     short_name=\"GEDI_L4A_AGB_Density_V2_1_2056\",     cloud_hosted=True,     bounding_box=(-73.9872, -33.7683, -34.7299, 5.2444),     temporal=(\"2020-07-01\", \"2020-07-31\"),     count=-1,  # use -1 to return all datasets     return_gdf=True, ) <p>Visualize the footprints of the data on an interactive map.</p> In\u00a0[\u00a0]: Copied! <pre>gdf.explore()\n</pre> gdf.explore() <p>Download the data to your local drive. Let's download the first 5 data products.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.nasa_data_download(results[:5], out_dir=\"data\")\n</pre> leafmap.nasa_data_download(results[:5], out_dir=\"data\") <p>Use the interactive GUI to search and download data.</p> In\u00a0[\u00a0]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add(\"nasa_earth_data\")\nm\n</pre> m = leafmap.Map() m.add(\"nasa_earth_data\") m <p></p> <p>To access the search results as a GeoDataFrame:</p> In\u00a0[\u00a0]: Copied! <pre># m._NASA_DATA_GDF\n</pre> # m._NASA_DATA_GDF <p>To download the data:</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.nasa_data_download(m._NASA_DATA_RESULTS, out_dir=\"data\")\n</pre> # leafmap.nasa_data_download(m._NASA_DATA_RESULTS, out_dir=\"data\")"},{"location":"notebooks/89_image_array_viz/","title":"89 image array viz","text":"<p>Visualizing in-memory raster datasets and image arrays</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[raster]\"\n</pre> # %pip install \"leafmap[raster]\" In\u00a0[2]: Copied! <pre>import leafmap\nimport rasterio\nimport rioxarray\nimport xarray as xr\n</pre> import leafmap import rasterio import rioxarray import xarray as xr <p>Download two sample raster datasets.</p> In\u00a0[3]: Copied! <pre>url1 = \"https://open.gishub.org/data/raster/landsat.tif\"\nurl2 = \"https://open.gishub.org/data/raster/srtm90.tif\"\nsatellite = leafmap.download_file(url1, \"landsat.tif\", overwrite=True)\ndem = leafmap.download_file(url2, \"srtm90.tif\")\n</pre> url1 = \"https://open.gishub.org/data/raster/landsat.tif\" url2 = \"https://open.gishub.org/data/raster/srtm90.tif\" satellite = leafmap.download_file(url1, \"landsat.tif\", overwrite=True) dem = leafmap.download_file(url2, \"srtm90.tif\") <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/landsat.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif\n</pre> <pre>\r  0%|          | 0.00/10.1M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10.1M/10.1M [00:00&lt;00:00, 184MB/s]</pre> <pre>srtm90.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> <pre>\n</pre> <p>The Landsat image contains 3 bands: nir, red, and green. Let's calculate NDVI using the nir and red bands.</p> In\u00a0[4]: Copied! <pre>dataset = rasterio.open(satellite)\nnir = dataset.read(4).astype(float)\nred = dataset.read(1).astype(float)\nndvi = (nir - red) / (nir + red)\n</pre> dataset = rasterio.open(satellite) nir = dataset.read(4).astype(float) red = dataset.read(1).astype(float) ndvi = (nir - red) / (nir + red) <p>Create an in-memory raster dataset from the NDVI array and use the projection and extent of the Landsat image.</p> In\u00a0[5]: Copied! <pre>ndvi_image = leafmap.array_to_image(ndvi, source=satellite)\n</pre> ndvi_image = leafmap.array_to_image(ndvi, source=satellite) <p>Visualize the Landsat image and the NDVI image on the same map.</p> In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nm.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\")\nm.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\")\nm\n</pre> m = leafmap.Map() m.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\") m.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\") m Out[6]: <p>You can also specify the image metadata (e.g., cellsize, crs, and transform) when creating the in-memory raster dataset.</p> <p>First, check the metadata of the origina image.</p> In\u00a0[7]: Copied! <pre>dataset.profile\n</pre> dataset.profile Out[7]: <pre>{'driver': 'GTiff', 'dtype': 'uint8', 'nodata': 0.0, 'width': 2127, 'height': 1564, 'count': 4, 'crs': CRS.from_epsg(3857), 'transform': Affine(180.0, 0.0, -13442580.0,\n       0.0, -180.0, 4670100.0), 'blockxsize': 512, 'blockysize': 512, 'tiled': True, 'compress': 'deflate', 'interleave': 'pixel'}</pre> <p>Check the crs of the original image.</p> In\u00a0[8]: Copied! <pre>dataset.crs\n</pre> dataset.crs Out[8]: <pre>CRS.from_epsg(3857)</pre> <p>Check the transform of the original image.</p> In\u00a0[9]: Copied! <pre>dataset.transform\n</pre> dataset.transform Out[9]: <pre>Affine(180.0, 0.0, -13442580.0,\n       0.0, -180.0, 4670100.0)</pre> <p>Create an in-memory raster dataset from the NDVI array and specify the cellsize, crs, and transform.</p> In\u00a0[10]: Copied! <pre>transform = (30.0, 0.0, -13651650.0, 0.0, -30.0, 4576290.0)\nndvi_image = leafmap.array_to_image(\n    ndvi, cellsize=30, crs=\"EPSG:3857\", transform=transform\n)\n</pre> transform = (30.0, 0.0, -13651650.0, 0.0, -30.0, 4576290.0) ndvi_image = leafmap.array_to_image(     ndvi, cellsize=30, crs=\"EPSG:3857\", transform=transform ) <p>Add the NDVI image to the map.</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map()\nm.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\")\nm.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\")\nm\n</pre> m = leafmap.Map() m.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\") m.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\") m Out[11]: <p>Use rioxarray to read raster datasets into xarray DataArrays.</p> In\u00a0[12]: Copied! <pre>ds = rioxarray.open_rasterio(dem)\nds\n</pre> ds = rioxarray.open_rasterio(dem) ds Out[12]: <pre>&lt;xarray.DataArray (band: 1, y: 2465, x: 4269)&gt; Size: 21MB\n[10523085 values with dtype=int16]\nCoordinates:\n  * band         (band) int64 8B 1\n  * x            (x) float64 34kB -120.8 -120.8 -120.8 ... -117.3 -117.3 -117.3\n  * y            (y) float64 20kB 38.63 38.63 38.62 38.62 ... 36.64 36.64 36.63\n    spatial_ref  int64 8B 0\nAttributes:\n    AREA_OR_POINT:       Area\n    OVR_RESAMPLING_ALG:  NEAREST\n    scale_factor:        1.0\n    add_offset:          0.0\n    long_name:           elevation</pre>xarray.DataArray<ul><li>band: 1</li><li>y: 2465</li><li>x: 4269</li></ul><ul><li>...<pre>[10523085 values with dtype=int16]</pre></li><li>Coordinates: (4)<ul><li>band(band)int641<pre>array([1])</pre></li><li>x(x)float64-120.8 -120.8 ... -117.3 -117.3<pre>array([-120.755523, -120.754715, -120.753906, ..., -117.306531, -117.305723,\n       -117.304914])</pre></li><li>y(y)float6438.63 38.63 38.62 ... 36.64 36.63<pre>array([38.626519, 38.625711, 38.624902, ..., 36.636032, 36.635224, 36.634415])</pre></li><li>spatial_ref()int640crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984grid_mapping_name :latitude_longitudespatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]GeoTransform :-120.75592734926073 0.0008084837557075694 0.0 38.6269234341147 0.0 -0.0008084837557075694<pre>array(0)</pre></li></ul></li><li>Indexes: (3)<ul><li>bandPandasIndex<pre>PandasIndex(Index([1], dtype='int64', name='band'))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([-120.75552310738287, -120.75471462362717, -120.75390613987146,\n       -120.75309765611574, -120.75228917236004, -120.75148068860433,\n       -120.75067220484863, -120.74986372109292, -120.74905523733722,\n        -120.7482467535815,\n       ...\n       -117.31219079182434, -117.31138230806863, -117.31057382431291,\n        -117.3097653405572,  -117.3089568568015,  -117.3081483730458,\n       -117.30733988929009, -117.30653140553439, -117.30572292177867,\n       -117.30491443802296],\n      dtype='float64', name='x', length=4269))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([ 38.62651919223685, 38.625710708481144,  38.62490222472543,\n        38.62409374096973,  38.62328525721402,  38.62247677345831,\n       38.621668289702605,  38.62085980594689,  38.62005132219119,\n        38.61924283843548,\n       ...\n        36.64169157197477, 36.640883088219056,  36.64007460446335,\n       36.639266120707646, 36.638457636951934,  36.63764915319623,\n       36.636840669440524,  36.63603218568481,  36.63522370192911,\n       36.634415218173395],\n      dtype='float64', name='y', length=2465))</pre></li></ul></li><li>Attributes: (5)AREA_OR_POINT :AreaOVR_RESAMPLING_ALG :NEARESTscale_factor :1.0add_offset :0.0long_name :elevation</li></ul> <p>Classify the DEM into 2 elevation classes.</p> In\u00a0[13]: Copied! <pre>array = ds.sel(band=1)\nmasked_array = xr.where(array &lt; 2000, 0, 1)\n</pre> array = ds.sel(band=1) masked_array = xr.where(array &lt; 2000, 0, 1) <p>Visualize the DEM and the elevation class image on the same map.</p> In\u00a0[14]: Copied! <pre>m = leafmap.Map()\nm.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\nm.add_raster(masked_array, colormap=\"coolwarm\", layer_name=\"Classified DEM\")\nm\n</pre> m = leafmap.Map() m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") m.add_raster(masked_array, colormap=\"coolwarm\", layer_name=\"Classified DEM\") m Out[14]: <p>Add a split map.</p> In\u00a0[15]: Copied! <pre>m = leafmap.Map(center=[37.6, -119], zoom=9)\nm.split_map(\n    dem,\n    masked_array,\n    left_args={\n        \"layer_name\": \"DEM\",\n        \"colormap\": \"terrain\",\n    },\n    right_args={\n        \"layer_name\": \"Classified DEM\",\n        \"colormap\": \"coolwarm\",\n    },\n)\nm\n</pre> m = leafmap.Map(center=[37.6, -119], zoom=9) m.split_map(     dem,     masked_array,     left_args={         \"layer_name\": \"DEM\",         \"colormap\": \"terrain\",     },     right_args={         \"layer_name\": \"Classified DEM\",         \"colormap\": \"coolwarm\",     }, ) m Out[15]:"},{"location":"notebooks/90_pixel_inspector/","title":"90 pixel inspector","text":"In\u00a0[1]: Copied! <pre># %pip install \"leafmap[raster]\"\n</pre> # %pip install \"leafmap[raster]\" In\u00a0[2]: Copied! <pre>import leafmap\nimport rasterio\nimport rioxarray\nimport xarray as xr\n</pre> import leafmap import rasterio import rioxarray import xarray as xr In\u00a0[3]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nm.add_cog_layer(url, name=\"Libya\")\nm.add(\"inspector\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" m.add_cog_layer(url, name=\"Libya\") m.add(\"inspector\") m Out[3]: In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"SPOT Image\")\nm.add(\"inspector\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"SPOT Image\") m.add(\"inspector\") m Out[4]: In\u00a0[5]: Copied! <pre>m = leafmap.Map()\ncollection = \"landsat-8-c2-l2\"\nitem = \"LC08_L2SP_047027_20201204_02_T1\"\nm.add_stac_layer(\n    collection=collection,\n    item=item,\n    assets=\"SR_B7,SR_B5,SR_B4\",\n    name=\"Landsat Band-754\",\n)\nm.add(\"inspector\")\nm\n</pre> m = leafmap.Map() collection = \"landsat-8-c2-l2\" item = \"LC08_L2SP_047027_20201204_02_T1\" m.add_stac_layer(     collection=collection,     item=item,     assets=\"SR_B7,SR_B5,SR_B4\",     name=\"Landsat Band-754\", ) m.add(\"inspector\") m Out[5]: In\u00a0[6]: Copied! <pre>url = \"https://open.gishub.org/data/raster/landsat.tif\"\nsatellite = leafmap.download_file(url, \"landsat.tif\", overwrite=True)\n</pre> url = \"https://open.gishub.org/data/raster/landsat.tif\" satellite = leafmap.download_file(url, \"landsat.tif\", overwrite=True) <pre>Downloading...\nFrom: https://open.gishub.org/data/raster/landsat.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif\n</pre> <pre>\r  0%|          | 0.00/10.1M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10.1M/10.1M [00:00&lt;00:00, 181MB/s]</pre> <pre>\n</pre> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\")\nm.add(\"inspector\")\nm\n</pre> m = leafmap.Map() m.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\") m.add(\"inspector\") m Out[7]: In\u00a0[8]: Copied! <pre>dataset = rasterio.open(satellite)\nnir = dataset.read(4).astype(float)\nred = dataset.read(1).astype(float)\nndvi = (nir - red) / (nir + red)\nndvi_image = leafmap.array_to_image(ndvi, source=satellite)\n</pre> dataset = rasterio.open(satellite) nir = dataset.read(4).astype(float) red = dataset.read(1).astype(float) ndvi = (nir - red) / (nir + red) ndvi_image = leafmap.array_to_image(ndvi, source=satellite) In\u00a0[9]: Copied! <pre>m = leafmap.Map()\nm.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\")\nm.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\")\nm.add(\"inspector\")\nm\n</pre> m = leafmap.Map() m.add_raster(satellite, indexes=[4, 1, 2], vmin=0, vmax=120, layer_name=\"Landsat 7\") m.add_raster(ndvi_image, colormap=\"Greens\", layer_name=\"NDVI\") m.add(\"inspector\") m Out[9]: In\u00a0[10]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\ndem = leafmap.download_file(url, \"srtm90.tif\")\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" dem = leafmap.download_file(url, \"srtm90.tif\") <pre>srtm90.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> In\u00a0[11]: Copied! <pre>ds = rioxarray.open_rasterio(dem)\nds\n</pre> ds = rioxarray.open_rasterio(dem) ds Out[11]: <pre>&lt;xarray.DataArray (band: 1, y: 2465, x: 4269)&gt; Size: 21MB\n[10523085 values with dtype=int16]\nCoordinates:\n  * band         (band) int64 8B 1\n  * x            (x) float64 34kB -120.8 -120.8 -120.8 ... -117.3 -117.3 -117.3\n  * y            (y) float64 20kB 38.63 38.63 38.62 38.62 ... 36.64 36.64 36.63\n    spatial_ref  int64 8B 0\nAttributes:\n    AREA_OR_POINT:       Area\n    OVR_RESAMPLING_ALG:  NEAREST\n    scale_factor:        1.0\n    add_offset:          0.0\n    long_name:           elevation</pre>xarray.DataArray<ul><li>band: 1</li><li>y: 2465</li><li>x: 4269</li></ul><ul><li>...<pre>[10523085 values with dtype=int16]</pre></li><li>Coordinates: (4)<ul><li>band(band)int641<pre>array([1])</pre></li><li>x(x)float64-120.8 -120.8 ... -117.3 -117.3<pre>array([-120.755523, -120.754715, -120.753906, ..., -117.306531, -117.305723,\n       -117.304914])</pre></li><li>y(y)float6438.63 38.63 38.62 ... 36.64 36.63<pre>array([38.626519, 38.625711, 38.624902, ..., 36.636032, 36.635224, 36.634415])</pre></li><li>spatial_ref()int640crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984grid_mapping_name :latitude_longitudespatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]GeoTransform :-120.75592734926073 0.0008084837557075694 0.0 38.6269234341147 0.0 -0.0008084837557075694<pre>array(0)</pre></li></ul></li><li>Indexes: (3)<ul><li>bandPandasIndex<pre>PandasIndex(Index([1], dtype='int64', name='band'))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([-120.75552310738287, -120.75471462362717, -120.75390613987146,\n       -120.75309765611574, -120.75228917236004, -120.75148068860433,\n       -120.75067220484863, -120.74986372109292, -120.74905523733722,\n        -120.7482467535815,\n       ...\n       -117.31219079182434, -117.31138230806863, -117.31057382431291,\n        -117.3097653405572,  -117.3089568568015,  -117.3081483730458,\n       -117.30733988929009, -117.30653140553439, -117.30572292177867,\n       -117.30491443802296],\n      dtype='float64', name='x', length=4269))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([ 38.62651919223685, 38.625710708481144,  38.62490222472543,\n        38.62409374096973,  38.62328525721402,  38.62247677345831,\n       38.621668289702605,  38.62085980594689,  38.62005132219119,\n        38.61924283843548,\n       ...\n        36.64169157197477, 36.640883088219056,  36.64007460446335,\n       36.639266120707646, 36.638457636951934,  36.63764915319623,\n       36.636840669440524,  36.63603218568481,  36.63522370192911,\n       36.634415218173395],\n      dtype='float64', name='y', length=2465))</pre></li></ul></li><li>Attributes: (5)AREA_OR_POINT :AreaOVR_RESAMPLING_ALG :NEARESTscale_factor :1.0add_offset :0.0long_name :elevation</li></ul> In\u00a0[12]: Copied! <pre>array = ds.sel(band=1)\nmasked_array = xr.where(array &lt; 2000, 0, 1)\n</pre> array = ds.sel(band=1) masked_array = xr.where(array &lt; 2000, 0, 1) In\u00a0[13]: Copied! <pre>m = leafmap.Map()\nm.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\nm.add_raster(masked_array, colormap=\"coolwarm\", layer_name=\"Classified DEM\")\nm\n</pre> m = leafmap.Map() m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") m.add_raster(masked_array, colormap=\"coolwarm\", layer_name=\"Classified DEM\") m Out[13]: In\u00a0[14]: Copied! <pre>m = leafmap.Map(center=[37.6, -119], zoom=9)\nm.split_map(\n    dem,\n    masked_array,\n    left_args={\n        \"layer_name\": \"DEM\",\n        \"colormap\": \"terrain\",\n    },\n    right_args={\n        \"layer_name\": \"Classified DEM\",\n        \"colormap\": \"coolwarm\",\n    },\n)\nm\n</pre> m = leafmap.Map(center=[37.6, -119], zoom=9) m.split_map(     dem,     masked_array,     left_args={         \"layer_name\": \"DEM\",         \"colormap\": \"terrain\",     },     right_args={         \"layer_name\": \"Classified DEM\",         \"colormap\": \"coolwarm\",     }, ) m Out[14]:"},{"location":"notebooks/90_pixel_inspector/#interactive-pixel-inspector","title":"Interactive pixel inspector\u00b6","text":"<p>The interactive pixel inspector can be used to explore the pixel values of an image. It supports Cloud Optimized GeoTIFF (COG), STAC, and other raster data formats, either stored locally or on the cloud. The COG and STAC functionalities are powered by the TiTiler, while the local file support is powered by localtileserver.</p>"},{"location":"notebooks/90_pixel_inspector/#cog","title":"COG\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#stac","title":"STAC\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#planetary-computer","title":"Planetary Computer\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#local-raster","title":"Local raster\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#in-memory-raster","title":"In-memory raster\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#numpy-array","title":"NumPy array\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#xarray-dataarray","title":"Xarray DataArray\u00b6","text":""},{"location":"notebooks/90_pixel_inspector/#split-map","title":"Split map\u00b6","text":""},{"location":"notebooks/91_raster_viz_gui/","title":"91 raster viz gui","text":"<p>Visualizing raster data interactively</p> <p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>from leafmap import leafmap\n</pre> from leafmap import leafmap In\u00a0[3]: Copied! <pre>filename = \"landsat.tif\"\nlandsat_url = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\"\n)\nleafmap.download_file(landsat_url, filename, overwrite=True)\n</pre> filename = \"landsat.tif\" landsat_url = (     \"https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\" ) leafmap.download_file(landsat_url, filename, overwrite=True) <pre>Downloading...\nFrom: https://github.com/opengeos/datasets/releases/download/raster/landsat.tif\nTo: /home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif\n</pre> <pre>\r  0%|          | 0.00/10.1M [00:00&lt;?, ?B/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10.1M/10.1M [00:00&lt;00:00, 169MB/s]</pre> <pre>\n</pre> Out[3]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/landsat.tif'</pre> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm.add_raster(filename, indexes=[3, 2, 1], vmin=0, vmax=100, layer_name=\"Landsat\")\nm.add(\"layer_manager\")\nm\n</pre> m = leafmap.Map() m.add_raster(filename, indexes=[3, 2, 1], vmin=0, vmax=100, layer_name=\"Landsat\") m.add(\"layer_manager\") m <p></p> In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nm.add_cog_layer(url, bands=[\"b1\", \"b2\", \"b3\"], name=\"Libya\")\nm.add(\"layer_manager\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" m.add_cog_layer(url, bands=[\"b1\", \"b2\", \"b3\"], name=\"Libya\") m.add(\"layer_manager\") m In\u00a0[6]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"SPOT\")\nm.add(\"layer_manager\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"SPOT\") m.add(\"layer_manager\") m <p></p>"},{"location":"notebooks/91_raster_viz_gui/#visualizing-local-raster-data","title":"Visualizing local raster data\u00b6","text":""},{"location":"notebooks/91_raster_viz_gui/#visualizing-cloud-optimized-geotiff-cog","title":"Visualizing Cloud Optimized GeoTIFF (COG)\u00b6","text":""},{"location":"notebooks/91_raster_viz_gui/#visualizing-spatiotemporal-asset-catalog-stac","title":"Visualizing SpatioTemporal Asset Catalog (STAC)\u00b6","text":""},{"location":"notebooks/92_maplibre/","title":"92 maplibre","text":"<p>Creating 3D maps with MapLibre</p> <p>The notebook demonstrates how to create 3D maps using the MapLibre Python package. The examples shown in this notebook are based on the MapLibre documentation. Credits to the original authors at eoda GmbH.</p> In\u00a0[1]: Copied! <pre># %pip install \"leafmap[maplibre]\"\n</pre> # %pip install \"leafmap[maplibre]\" In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3, pitch=0, bearing=0)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3, pitch=0, bearing=0) m <p></p> <p>To customize the basemap, you can specify the <code>style</code> parameter. It can be an URL or a string, such as <code>dark-matter</code>, <code>positron</code>, <code>voyager</code>, <code>demotiles</code>.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map(style=\"positron\")\nm\n</pre> m = leafmap.Map(style=\"positron\") m <p></p> <p>To create a map with a background color, use <code>style=\"background-&lt;COLOR&gt;\"</code>, such as <code>background-lightgray</code> and <code>background-green</code>.</p> In\u00a0[5]: Copied! <pre>m = leafmap.Map(style=\"background-lightgray\")\nm\n</pre> m = leafmap.Map(style=\"background-lightgray\") m <p></p> <p>Alternatively, you can provide a URL to a vector style.</p> In\u00a0[6]: Copied! <pre>style = \"https://demotiles.maplibre.org/style.json\"\nm = leafmap.Map(style=style)\nm\n</pre> style = \"https://demotiles.maplibre.org/style.json\" m = leafmap.Map(style=style) m <p></p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_control(\"geolocate\", position=\"top-left\")\nm\n</pre> m = leafmap.Map() m.add_control(\"geolocate\", position=\"top-left\") m <p></p> In\u00a0[8]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m In\u00a0[9]: Copied! <pre>m.add_basemap()\n</pre> m.add_basemap() In\u00a0[10]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m <p></p> In\u00a0[11]: Copied! <pre>m.add_basemap(\"Esri.WorldImagery\")\n</pre> m.add_basemap(\"Esri.WorldImagery\") In\u00a0[12]: Copied! <pre>m = leafmap.Map()\nurl = \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\"\nm.add_tile_layer(\n    url, name=\"OpenStreetMap\", attribution=\"OpenStreetMap\", opacity=1.0, visible=True\n)\nm\n</pre> m = leafmap.Map() url = \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\" m.add_tile_layer(     url, name=\"OpenStreetMap\", attribution=\"OpenStreetMap\", opacity=1.0, visible=True ) m <p></p> In\u00a0[13]: Copied! <pre>m = leafmap.Map(center=[-100, 40], zoom=3)\nm.add_basemap(\"Esri.WorldImagery\")\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2021_Land_Cover_L48/wms?bbox={bbox-epsg-3857}&amp;format=image/png&amp;service=WMS&amp;version=1.1.1&amp;request=GetMap&amp;srs=EPSG:3857&amp;transparent=true&amp;width=256&amp;height=256&amp;layers=NLCD_2021_Land_Cover_L48\"\nm.add_wms_layer(url, name=\"NLCD\", opacity=0.8)\nm\n</pre> m = leafmap.Map(center=[-100, 40], zoom=3) m.add_basemap(\"Esri.WorldImagery\") url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2021_Land_Cover_L48/wms?bbox={bbox-epsg-3857}&amp;format=image/png&amp;service=WMS&amp;version=1.1.1&amp;request=GetMap&amp;srs=EPSG:3857&amp;transparent=true&amp;width=256&amp;height=256&amp;layers=NLCD_2021_Land_Cover_L48\" m.add_wms_layer(url, name=\"NLCD\", opacity=0.8) m <p></p> In\u00a0[14]: Copied! <pre>m = leafmap.Map()\nurl = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\nm.add_cog_layer(url, name=\"COG\", attribution=\"Maxar\", fit_bounds=True)\nm\n</pre> m = leafmap.Map() url = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) m.add_cog_layer(url, name=\"COG\", attribution=\"Maxar\", fit_bounds=True) m <p></p> In\u00a0[15]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"SPOT\", vmin=0, vmax=150)\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B4\", \"B3\", \"B2\"], name=\"SPOT\", vmin=0, vmax=150) m <p></p> In\u00a0[16]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\"\nfilepath = \"srtm90.tif\"\nleafmap.download_file(url, filepath)\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\" filepath = \"srtm90.tif\" leafmap.download_file(url, filepath) <pre>srtm90.tif already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[16]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/srtm90.tif'</pre> In\u00a0[17]: Copied! <pre>m = leafmap.Map()\nm.add_raster(filepath, colormap=\"terrain\", name=\"DEM\")\nm\n</pre> m = leafmap.Map() m.add_raster(filepath, colormap=\"terrain\", name=\"DEM\") m <p></p> In\u00a0[18]: Copied! <pre>m = leafmap.Map(\n    center=[-123.13, 49.254], zoom=11, style=\"dark-matter\", pitch=45, bearing=0\n)\nurl = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/geojson/vancouver-blocks.json\"\npaint_line = {\n    \"line-color\": \"white\",\n    \"line-width\": 2,\n}\npaint_fill = {\n    \"fill-extrusion-color\": {\n        \"property\": \"valuePerSqm\",\n        \"stops\": [\n            [0, \"grey\"],\n            [1000, \"yellow\"],\n            [5000, \"orange\"],\n            [10000, \"darkred\"],\n            [50000, \"lightblue\"],\n        ],\n    },\n    \"fill-extrusion-height\": [\"*\", 10, [\"sqrt\", [\"get\", \"valuePerSqm\"]]],\n    \"fill-extrusion-opacity\": 0.9,\n}\nm.add_geojson(url, layer_type=\"line\", paint=paint_line, name=\"blocks-line\")\nm.add_geojson(url, layer_type=\"fill-extrusion\", paint=paint_fill, name=\"blocks-fill\")\nm\n</pre> m = leafmap.Map(     center=[-123.13, 49.254], zoom=11, style=\"dark-matter\", pitch=45, bearing=0 ) url = \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/geojson/vancouver-blocks.json\" paint_line = {     \"line-color\": \"white\",     \"line-width\": 2, } paint_fill = {     \"fill-extrusion-color\": {         \"property\": \"valuePerSqm\",         \"stops\": [             [0, \"grey\"],             [1000, \"yellow\"],             [5000, \"orange\"],             [10000, \"darkred\"],             [50000, \"lightblue\"],         ],     },     \"fill-extrusion-height\": [\"*\", 10, [\"sqrt\", [\"get\", \"valuePerSqm\"]]],     \"fill-extrusion-opacity\": 0.9, } m.add_geojson(url, layer_type=\"line\", paint=paint_line, name=\"blocks-line\") m.add_geojson(url, layer_type=\"fill-extrusion\", paint=paint_fill, name=\"blocks-fill\") m In\u00a0[19]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[20]: Copied! <pre>m = leafmap.Map(style=\"positron\")\n\ndata = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\"\nsource_args = {\n    \"cluster\": True,\n    \"cluster_radius\": 50,\n    \"cluster_min_points\": 2,\n    \"cluster_max_zoom\": 14,\n    \"cluster_properties\": {\n        \"maxMag\": [\"max\", [\"get\", \"mag\"]],\n        \"minMag\": [\"min\", [\"get\", \"mag\"]],\n    },\n}\n\nm.add_geojson(\n    data,\n    layer_type=\"circle\",\n    name=\"earthquake-circles\",\n    filter=[\"!\", [\"has\", \"point_count\"]],\n    paint={\"circle-color\": \"darkblue\"},\n    source_args=source_args,\n)\n\nm.add_geojson(\n    data,\n    layer_type=\"circle\",\n    name=\"earthquake-clusters\",\n    filter=[\"has\", \"point_count\"],\n    paint={\n        \"circle-color\": [\n            \"step\",\n            [\"get\", \"point_count\"],\n            \"#51bbd6\",\n            100,\n            \"#f1f075\",\n            750,\n            \"#f28cb1\",\n        ],\n        \"circle-radius\": [\"step\", [\"get\", \"point_count\"], 20, 100, 30, 750, 40],\n    },\n    source_args=source_args,\n)\n\nm.add_geojson(\n    data,\n    layer_type=\"symbol\",\n    name=\"earthquake-labels\",\n    filter=[\"has\", \"point_count\"],\n    layout={\n        \"text-field\": [\"get\", \"point_count_abbreviated\"],\n        \"text-size\": 12,\n    },\n    source_args=source_args,\n)\nm\n</pre> m = leafmap.Map(style=\"positron\")  data = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\" source_args = {     \"cluster\": True,     \"cluster_radius\": 50,     \"cluster_min_points\": 2,     \"cluster_max_zoom\": 14,     \"cluster_properties\": {         \"maxMag\": [\"max\", [\"get\", \"mag\"]],         \"minMag\": [\"min\", [\"get\", \"mag\"]],     }, }  m.add_geojson(     data,     layer_type=\"circle\",     name=\"earthquake-circles\",     filter=[\"!\", [\"has\", \"point_count\"]],     paint={\"circle-color\": \"darkblue\"},     source_args=source_args, )  m.add_geojson(     data,     layer_type=\"circle\",     name=\"earthquake-clusters\",     filter=[\"has\", \"point_count\"],     paint={         \"circle-color\": [             \"step\",             [\"get\", \"point_count\"],             \"#51bbd6\",             100,             \"#f1f075\",             750,             \"#f28cb1\",         ],         \"circle-radius\": [\"step\", [\"get\", \"point_count\"], 20, 100, 30, 750, 40],     },     source_args=source_args, )  m.add_geojson(     data,     layer_type=\"symbol\",     name=\"earthquake-labels\",     filter=[\"has\", \"point_count\"],     layout={         \"text-field\": [\"get\", \"point_count_abbreviated\"],         \"text-size\": 12,     },     source_args=source_args, ) m <p></p> In\u00a0[21]: Copied! <pre>from maplibre.controls import Marker, MarkerOptions, Popup, PopupOptions\nimport pandas as pd\n</pre> from maplibre.controls import Marker, MarkerOptions, Popup, PopupOptions import pandas as pd In\u00a0[22]: Copied! <pre>m = leafmap.Map(style=\"positron\")\n\nurl = \"https://github.com/visgl/deck.gl-data/raw/master/examples/line/airports.json\"\ndata = leafmap.pandas_to_geojson(\n    url, \"coordinates\", properties=[\"type\", \"name\", \"abbrev\"]\n)\n\nm.add_geojson(\n    data,\n    name=\"Airports\",\n    layer_type=\"circle\",\n    paint={\n        \"circle-color\": [\n            \"match\",\n            [\"get\", \"type\"],\n            \"mid\",\n            \"darkred\",\n            \"major\",\n            \"darkgreen\",\n            \"darkblue\",\n        ],\n        \"circle_radius\": 10,\n        \"circle-opacity\": 0.3,\n    },\n)\n\n\ndef get_color(airport_type: str) -&gt; str:\n    color = \"darkblue\"\n    if airport_type == \"mid\":\n        color = \"darkred\"\n    elif airport_type == \"major\":\n        color = \"darkgreen\"\n\n    return color\n\n\nairports_data = pd.read_json(url)\npopup_options = PopupOptions(close_button=False)\n\nfor _, r in airports_data.iterrows():\n    m.add_marker(\n        lng_lat=r[\"coordinates\"],\n        options=MarkerOptions(color=get_color(r[\"type\"])),\n        popup=Popup(\n            text=r[\"name\"],\n            options=popup_options,\n        ),\n    )\n\nm\n</pre> m = leafmap.Map(style=\"positron\")  url = \"https://github.com/visgl/deck.gl-data/raw/master/examples/line/airports.json\" data = leafmap.pandas_to_geojson(     url, \"coordinates\", properties=[\"type\", \"name\", \"abbrev\"] )  m.add_geojson(     data,     name=\"Airports\",     layer_type=\"circle\",     paint={         \"circle-color\": [             \"match\",             [\"get\", \"type\"],             \"mid\",             \"darkred\",             \"major\",             \"darkgreen\",             \"darkblue\",         ],         \"circle_radius\": 10,         \"circle-opacity\": 0.3,     }, )   def get_color(airport_type: str) -&gt; str:     color = \"darkblue\"     if airport_type == \"mid\":         color = \"darkred\"     elif airport_type == \"major\":         color = \"darkgreen\"      return color   airports_data = pd.read_json(url) popup_options = PopupOptions(close_button=False)  for _, r in airports_data.iterrows():     m.add_marker(         lng_lat=r[\"coordinates\"],         options=MarkerOptions(color=get_color(r[\"type\"])),         popup=Popup(             text=r[\"name\"],             options=popup_options,         ),     )  m <p></p> In\u00a0[23]: Copied! <pre>m = leafmap.Map(\n    center=(-87.61694, 41.86625), zoom=17, pitch=40, bearing=20, style=\"positron\"\n)\nm.add_basemap(\"OpenStreetMap.Mapnik\")\ndata = \"https://maplibre.org/maplibre-gl-js/docs/assets/indoor-3d-map.geojson\"\nm.add_geojson(\n    data,\n    layer_type=\"fill-extrusion\",\n    name=\"floorplan\",\n    paint={\n        \"fill-extrusion-color\": [\"get\", \"color\"],\n        \"fill-extrusion-height\": [\"get\", \"height\"],\n        \"fill-extrusion-base\": [\"get\", \"base_height\"],\n        \"fill-extrusion-opacity\": 0.5,\n    },\n)\nm\n</pre> m = leafmap.Map(     center=(-87.61694, 41.86625), zoom=17, pitch=40, bearing=20, style=\"positron\" ) m.add_basemap(\"OpenStreetMap.Mapnik\") data = \"https://maplibre.org/maplibre-gl-js/docs/assets/indoor-3d-map.geojson\" m.add_geojson(     data,     layer_type=\"fill-extrusion\",     name=\"floorplan\",     paint={         \"fill-extrusion-color\": [\"get\", \"color\"],         \"fill-extrusion-height\": [\"get\", \"height\"],         \"fill-extrusion-base\": [\"get\", \"base_height\"],         \"fill-extrusion-opacity\": 0.5,     }, ) m <p></p> In\u00a0[24]: Copied! <pre>import leafmap.maplibregl as leafmap\nfrom maplibre.basemaps import construct_basemap_style\nfrom maplibre import Layer, LayerType, Map, MapOptions\nfrom maplibre.sources import GeoJSONSource\n\n\nbg_layer = Layer(\n    type=LayerType.BACKGROUND,\n    id=\"background\",\n    source=None,\n    paint={\"background-color\": \"darkblue\", \"background-opacity\": 0.8},\n)\n\ncountries_source = GeoJSONSource(\n    data=\"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson\"\n)\n\nlines_layer = Layer(\n    type=LayerType.LINE,\n    source=\"countries\",\n    paint={\"line-color\": \"white\", \"line-width\": 1.5},\n)\n\npolygons_layer = Layer(\n    type=LayerType.FILL,\n    source=\"countries\",\n    paint={\"fill-color\": \"darkred\", \"fill-opacity\": 0.8},\n)\n\ncustom_basemap = construct_basemap_style(\n    layers=[bg_layer, polygons_layer, lines_layer],\n    sources={\"countries\": countries_source},\n)\n\n\nm = leafmap.Map(style=custom_basemap)\ndata = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\"\nm.add_geojson(\n    data,\n    layer_type=\"circle\",\n    name=\"earthquakes\",\n    paint={\"circle-color\": \"yellow\", \"circle-radius\": 5},\n)\nm.add_popup(\"earthquakes\", \"mag\")\nm\n</pre> import leafmap.maplibregl as leafmap from maplibre.basemaps import construct_basemap_style from maplibre import Layer, LayerType, Map, MapOptions from maplibre.sources import GeoJSONSource   bg_layer = Layer(     type=LayerType.BACKGROUND,     id=\"background\",     source=None,     paint={\"background-color\": \"darkblue\", \"background-opacity\": 0.8}, )  countries_source = GeoJSONSource(     data=\"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson\" )  lines_layer = Layer(     type=LayerType.LINE,     source=\"countries\",     paint={\"line-color\": \"white\", \"line-width\": 1.5}, )  polygons_layer = Layer(     type=LayerType.FILL,     source=\"countries\",     paint={\"fill-color\": \"darkred\", \"fill-opacity\": 0.8}, )  custom_basemap = construct_basemap_style(     layers=[bg_layer, polygons_layer, lines_layer],     sources={\"countries\": countries_source}, )   m = leafmap.Map(style=custom_basemap) data = \"https://docs.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson\" m.add_geojson(     data,     layer_type=\"circle\",     name=\"earthquakes\",     paint={\"circle-color\": \"yellow\", \"circle-radius\": 5}, ) m.add_popup(\"earthquakes\", \"mag\") m <p></p> In\u00a0[25]: Copied! <pre>import pandas as pd\nimport h3\n</pre> import pandas as pd import h3 In\u00a0[26]: Copied! <pre>RESOLUTION = 7\nCOLORS = (\n    \"lightblue\",\n    \"turquoise\",\n    \"lightgreen\",\n    \"yellow\",\n    \"orange\",\n    \"darkred\",\n)\n\nroad_safety = pd.read_csv(\n    \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv\"\n).dropna()\n\n\ndef create_h3_grid(res=RESOLUTION) -&gt; dict:\n    road_safety[\"h3\"] = road_safety.apply(\n        lambda x: h3.geo_to_h3(x[\"lat\"], x[\"lng\"], resolution=res), axis=1\n    )\n    df = road_safety.groupby(\"h3\").h3.agg(\"count\").to_frame(\"count\").reset_index()\n    df[\"hexagon\"] = df.apply(\n        lambda x: [h3.h3_to_geo_boundary(x[\"h3\"], geo_json=True)], axis=1\n    )\n    df[\"color\"] = pd.cut(\n        df[\"count\"],\n        bins=len(COLORS),\n        labels=COLORS,\n    )\n    return leafmap.pandas_to_geojson(\n        df, \"hexagon\", geometry_type=\"Polygon\", properties=[\"count\", \"color\"]\n    )\n\n\nm = leafmap.Map(\n    center=(-1.415727, 52.232395),\n    zoom=7,\n    pitch=40,\n    bearing=-27,\n)\ndata = create_h3_grid()\nm.add_geojson(\n    data,\n    layer_type=\"fill-extrusion\",\n    paint={\n        \"fill-extrusion-color\": [\"get\", \"color\"],\n        \"fill-extrusion-opacity\": 0.7,\n        \"fill-extrusion-height\": [\"*\", 100, [\"get\", \"count\"]],\n    },\n)\nm\n</pre> RESOLUTION = 7 COLORS = (     \"lightblue\",     \"turquoise\",     \"lightgreen\",     \"yellow\",     \"orange\",     \"darkred\", )  road_safety = pd.read_csv(     \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv\" ).dropna()   def create_h3_grid(res=RESOLUTION) -&gt; dict:     road_safety[\"h3\"] = road_safety.apply(         lambda x: h3.geo_to_h3(x[\"lat\"], x[\"lng\"], resolution=res), axis=1     )     df = road_safety.groupby(\"h3\").h3.agg(\"count\").to_frame(\"count\").reset_index()     df[\"hexagon\"] = df.apply(         lambda x: [h3.h3_to_geo_boundary(x[\"h3\"], geo_json=True)], axis=1     )     df[\"color\"] = pd.cut(         df[\"count\"],         bins=len(COLORS),         labels=COLORS,     )     return leafmap.pandas_to_geojson(         df, \"hexagon\", geometry_type=\"Polygon\", properties=[\"count\", \"color\"]     )   m = leafmap.Map(     center=(-1.415727, 52.232395),     zoom=7,     pitch=40,     bearing=-27, ) data = create_h3_grid() m.add_geojson(     data,     layer_type=\"fill-extrusion\",     paint={         \"fill-extrusion-color\": [\"get\", \"color\"],         \"fill-extrusion-opacity\": 0.7,         \"fill-extrusion-height\": [\"*\", 100, [\"get\", \"count\"]],     }, ) m <p></p> In\u00a0[27]: Copied! <pre>m = leafmap.Map(\n    style=\"positron\",\n    center=(-122.4, 37.74),\n    zoom=12,\n    pitch=40,\n)\ndeck_grid_layer = {\n    \"@@type\": \"GridLayer\",\n    \"id\": \"GridLayer\",\n    \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-bike-parking.json\",\n    \"extruded\": True,\n    \"getPosition\": \"@@=COORDINATES\",\n    \"getColorWeight\": \"@@=SPACES\",\n    \"getElevationWeight\": \"@@=SPACES\",\n    \"elevationScale\": 4,\n    \"cellSize\": 200,\n    \"pickable\": True,\n}\n\nm.add_deck_layers([deck_grid_layer], tooltip=\"Number of points: {{ count }}\")\nm\n</pre> m = leafmap.Map(     style=\"positron\",     center=(-122.4, 37.74),     zoom=12,     pitch=40, ) deck_grid_layer = {     \"@@type\": \"GridLayer\",     \"id\": \"GridLayer\",     \"data\": \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-bike-parking.json\",     \"extruded\": True,     \"getPosition\": \"@@=COORDINATES\",     \"getColorWeight\": \"@@=SPACES\",     \"getElevationWeight\": \"@@=SPACES\",     \"elevationScale\": 4,     \"cellSize\": 200,     \"pickable\": True, }  m.add_deck_layers([deck_grid_layer], tooltip=\"Number of points: {{ count }}\") m <p></p> In\u00a0[28]: Copied! <pre>import requests\n</pre> import requests In\u00a0[29]: Copied! <pre>data = requests.get(\n    \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson\"\n).json()\n</pre> data = requests.get(     \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson\" ).json() In\u00a0[30]: Copied! <pre>m = leafmap.Map(\n    style=\"positron\",\n    center=(0.45, 51.47),\n    zoom=4,\n    pitch=30,\n)\ndeck_geojson_layer = {\n    \"@@type\": \"GeoJsonLayer\",\n    \"id\": \"airports\",\n    \"data\": data,\n    \"filled\": True,\n    \"pointRadiusMinPixels\": 2,\n    \"pointRadiusScale\": 2000,\n    \"getPointRadius\": \"@@=11 - properties.scalerank\",\n    \"getFillColor\": [200, 0, 80, 180],\n    \"autoHighlight\": True,\n    \"pickable\": True,\n}\n\ndeck_arc_layer = {\n    \"@@type\": \"ArcLayer\",\n    \"id\": \"arcs\",\n    \"data\": [\n        feature\n        for feature in data[\"features\"]\n        if feature[\"properties\"][\"scalerank\"] &lt; 4\n    ],\n    \"getSourcePosition\": [-0.4531566, 51.4709959],  # London\n    \"getTargetPosition\": \"@@=geometry.coordinates\",\n    \"getSourceColor\": [0, 128, 200],\n    \"getTargetColor\": [200, 0, 80],\n    \"getWidth\": 2,\n    \"pickable\": True,\n}\n\nm.add_deck_layers(\n    [deck_geojson_layer, deck_arc_layer],\n    tooltip={\n        \"airports\": \"{{ &amp;properties.name }}\",\n        \"arcs\": \"gps_code: {{ properties.gps_code }}\",\n    },\n)\nm\n</pre> m = leafmap.Map(     style=\"positron\",     center=(0.45, 51.47),     zoom=4,     pitch=30, ) deck_geojson_layer = {     \"@@type\": \"GeoJsonLayer\",     \"id\": \"airports\",     \"data\": data,     \"filled\": True,     \"pointRadiusMinPixels\": 2,     \"pointRadiusScale\": 2000,     \"getPointRadius\": \"@@=11 - properties.scalerank\",     \"getFillColor\": [200, 0, 80, 180],     \"autoHighlight\": True,     \"pickable\": True, }  deck_arc_layer = {     \"@@type\": \"ArcLayer\",     \"id\": \"arcs\",     \"data\": [         feature         for feature in data[\"features\"]         if feature[\"properties\"][\"scalerank\"] &lt; 4     ],     \"getSourcePosition\": [-0.4531566, 51.4709959],  # London     \"getTargetPosition\": \"@@=geometry.coordinates\",     \"getSourceColor\": [0, 128, 200],     \"getTargetColor\": [200, 0, 80],     \"getWidth\": 2,     \"pickable\": True, }  m.add_deck_layers(     [deck_geojson_layer, deck_arc_layer],     tooltip={         \"airports\": \"{{ &amp;properties.name }}\",         \"arcs\": \"gps_code: {{ properties.gps_code }}\",     }, ) m <p></p>"},{"location":"notebooks/92_maplibre/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install leafmap if needed.</p>"},{"location":"notebooks/92_maplibre/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"notebooks/92_maplibre/#create-maps","title":"Create maps\u00b6","text":"<p>Create an interactive map by specifying map center [lon, lat], zoom level, pitch, and bearing.</p>"},{"location":"notebooks/92_maplibre/#add-controls","title":"Add controls\u00b6","text":"<p>The control to add to the map. Can be one of the following: <code>scale</code>, <code>fullscreen</code>, <code>geolocate</code>, <code>navigation</code>.</p>"},{"location":"notebooks/92_maplibre/#add-basemaps","title":"Add basemaps\u00b6","text":""},{"location":"notebooks/92_maplibre/#xyz-tile-layer","title":"XYZ tile layer\u00b6","text":""},{"location":"notebooks/92_maplibre/#wms-layer","title":"WMS layer\u00b6","text":""},{"location":"notebooks/92_maplibre/#cog-layer","title":"COG layer\u00b6","text":""},{"location":"notebooks/92_maplibre/#stac-layer","title":"STAC layer\u00b6","text":""},{"location":"notebooks/92_maplibre/#local-raster","title":"Local raster\u00b6","text":""},{"location":"notebooks/92_maplibre/#vancouver-property-value","title":"Vancouver Property Value\u00b6","text":""},{"location":"notebooks/92_maplibre/#earthquake-clusters","title":"Earthquake Clusters\u00b6","text":""},{"location":"notebooks/92_maplibre/#airport-markers","title":"Airport Markers\u00b6","text":""},{"location":"notebooks/92_maplibre/#3d-indoor-mapping","title":"3D Indoor Mapping\u00b6","text":""},{"location":"notebooks/92_maplibre/#custom-basemap","title":"Custom Basemap\u00b6","text":""},{"location":"notebooks/92_maplibre/#h3-grid-uk-road-safety","title":"H3 Grid UK Road Safety\u00b6","text":""},{"location":"notebooks/92_maplibre/#deckgl-layer","title":"Deck.GL Layer\u00b6","text":""},{"location":"notebooks/92_maplibre/#multiple-deckgl-layers","title":"Multiple Deck.GL Layers\u00b6","text":""},{"location":"notebooks/93_maplibre_pmtiles/","title":"93 maplibre pmtiles","text":"<p>Visualizing PMTiles with Leafmap and MapLibre</p> <p>PMTiles is a single-file archive format for tiled data. A PMTiles archive can be hosted on a commodity storage platform such as S3, and enables low-cost, zero-maintenance map applications that are \"serverless\" - free of a custom tile backend or third party provider.</p> In\u00a0[1]: Copied! <pre># %pip install -U \"leafmap[maplibre]\" pmtiles\n</pre> # %pip install -U \"leafmap[maplibre]\" pmtiles In\u00a0[2]: Copied! <pre>import leafmap.maplibregl as leafmap\n</pre> import leafmap.maplibregl as leafmap In\u00a0[3]: Copied! <pre>url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://open.gishub.org/data/pmtiles/protomaps_firenze.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['earth', 'natural', 'land', 'water', 'physical_line', 'buildings', 'physical_point', 'places', 'roads', 'transit', 'pois', 'boundaries', 'mask']\nbounds: [11.154026, 43.7270125, 11.3289395, 43.8325455]\n</pre> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"landuse\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"steelblue\"},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"black\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map()  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"landuse\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"steelblue\"},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"black\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m In\u00a0[5]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> <p>You can also visualize Overture data. Inspired by overture-maps.</p> In\u00a0[6]: Copied! <pre>url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://storage.googleapis.com/ahp-research/overture/pmtiles/overture.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['admins', 'buildings', 'places', 'roads']\nbounds: [3.295898, 50.746884, 7.245483, 53.5762]\n</pre> In\u00a0[7]: Copied! <pre>m = leafmap.Map(height=\"800px\")\nm.add_basemap(\"Esri.WorldImagery\")\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        # {\n        #     \"id\": \"admins\",\n        #     \"source\": \"example_source\",\n        #     \"source-layer\": \"admins\",\n        #     \"type\": \"fill\",\n        #     \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},\n        # },\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"places\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"places\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},\n        },\n        {\n            \"id\": \"roads\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"roads\",\n            \"type\": \"line\",\n            \"paint\": {\"line-color\": \"#FB8072\"},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map(height=\"800px\") m.add_basemap(\"Esri.WorldImagery\")  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         # {         #     \"id\": \"admins\",         #     \"source\": \"example_source\",         #     \"source-layer\": \"admins\",         #     \"type\": \"fill\",         #     \"paint\": {\"fill-color\": \"#BDD3C7\", \"fill-opacity\": 0.1},         # },         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#FFFFB3\", \"fill-opacity\": 0.5},         },         {             \"id\": \"places\",             \"source\": \"example_source\",             \"source-layer\": \"places\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#BEBADA\", \"fill-opacity\": 0.5},         },         {             \"id\": \"roads\",             \"source\": \"example_source\",             \"source-layer\": \"roads\",             \"type\": \"line\",             \"paint\": {\"line-color\": \"#FB8072\"},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m In\u00a0[8]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[9]: Copied! <pre>url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\"\nmetadata = leafmap.pmtiles_metadata(url)\nprint(f\"layer names: {metadata['layer_names']}\")\nprint(f\"bounds: {metadata['bounds']}\")\n</pre> url = \"https://data.source.coop/vida/google-microsoft-open-buildings/pmtiles/go_ms_building_footprints.pmtiles\" metadata = leafmap.pmtiles_metadata(url) print(f\"layer names: {metadata['layer_names']}\") print(f\"bounds: {metadata['bounds']}\") <pre>layer names: ['building_footprints']\nbounds: [-160.221701, -55.9756776, 166.709685, 74.7731168]\n</pre> In\u00a0[10]: Copied! <pre>m = leafmap.Map(center=[0, 20], zoom=2, height=\"800px\")\nm.add_basemap(\"Google Hybrid\", visible=False)\n\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"building_footprints\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=1.0,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map(center=[0, 20], zoom=2, height=\"800px\") m.add_basemap(\"Google Hybrid\", visible=False)  style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"building_footprints\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=1.0,     tooltip=True, ) m <pre>Basemap can only be one of the following:\n  OpenStreetMap\n  Esri.WorldStreetMap\n  Esri.WorldImagery\n  Esri.WorldTopoMap\n  FWS NWI Wetlands\n  FWS NWI Wetlands Raster\n  NLCD 2021 CONUS Land Cover\n  NLCD 2019 CONUS Land Cover\n  NLCD 2016 CONUS Land Cover\n  NLCD 2013 CONUS Land Cover\n  NLCD 2011 CONUS Land Cover\n  NLCD 2008 CONUS Land Cover\n  NLCD 2006 CONUS Land Cover\n  NLCD 2004 CONUS Land Cover\n  NLCD 2001 CONUS Land Cover\n  USGS NAIP Imagery\n  USGS NAIP Imagery False Color\n  USGS NAIP Imagery NDVI\n  USGS Hydrography\n  USGS 3DEP Elevation\n  ESA Worldcover 2020\n  ESA Worldcover 2020 S2 FCC\n  ESA Worldcover 2020 S2 TCC\n  ESA Worldcover 2021\n  ESA Worldcover 2021 S2 FCC\n  ESA Worldcover 2021 S2 TCC\n  BaseMapDE.Color\n  BaseMapDE.Grey\n  BasemapAT.basemap\n  BasemapAT.grau\n  BasemapAT.highdpi\n  BasemapAT.orthofoto\n  BasemapAT.overlay\n  BasemapAT.surface\n  BasemapAT.terrain\n  CartoDB.DarkMatter\n  CartoDB.DarkMatterNoLabels\n  CartoDB.DarkMatterOnlyLabels\n  CartoDB.Positron\n  CartoDB.PositronNoLabels\n  CartoDB.PositronOnlyLabels\n  CartoDB.Voyager\n  CartoDB.VoyagerLabelsUnder\n  CartoDB.VoyagerNoLabels\n  CartoDB.VoyagerOnlyLabels\n  CyclOSM\n  Esri.AntarcticBasemap\n  Esri.AntarcticImagery\n  Esri.ArcticImagery\n  Esri.ArcticOceanBase\n  Esri.ArcticOceanReference\n  Esri.DeLorme\n  Esri.NatGeoWorldMap\n  Esri.OceanBasemap\n  Esri.WorldGrayCanvas\n  Esri.WorldPhysical\n  Esri.WorldShadedRelief\n  Esri.WorldTerrain\n  FreeMapSK\n  Gaode.Normal\n  Gaode.Satellite\n  HikeBike.HikeBike\n  HikeBike.HillShading\n  JusticeMap.americanIndian\n  JusticeMap.asian\n  JusticeMap.black\n  JusticeMap.hispanic\n  JusticeMap.income\n  JusticeMap.multi\n  JusticeMap.nonWhite\n  JusticeMap.plurality\n  JusticeMap.white\n  MtbMap\n  NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief\n  NASAGIBS.BlueMarble3031\n  NASAGIBS.BlueMarble3413\n  NASAGIBS.BlueMarbleBathymetry3031\n  NASAGIBS.BlueMarbleBathymetry3413\n  NASAGIBS.MEaSUREsIceVelocity3031\n  NASAGIBS.MEaSUREsIceVelocity3413\n  NASAGIBS.ModisAquaBands721CR\n  NASAGIBS.ModisAquaTrueColorCR\n  NASAGIBS.ModisTerraAOD\n  NASAGIBS.ModisTerraBands367CR\n  NASAGIBS.ModisTerraBands721CR\n  NASAGIBS.ModisTerraChlorophyll\n  NASAGIBS.ModisTerraLSTDay\n  NASAGIBS.ModisTerraSnowCover\n  NASAGIBS.ModisTerraTrueColorCR\n  NASAGIBS.ViirsEarthAtNight2012\n  NASAGIBS.ViirsTrueColorCR\n  OPNVKarte\n  OneMapSG.Default\n  OneMapSG.Grey\n  OneMapSG.LandLot\n  OneMapSG.Night\n  OneMapSG.Original\n  OpenAIP\n  OpenFireMap\n  OpenRailwayMap\n  OpenSeaMap\n  OpenSnowMap.pistes\n  OpenStreetMap.BZH\n  OpenStreetMap.BlackAndWhite\n  OpenStreetMap.CH\n  OpenStreetMap.DE\n  OpenStreetMap.HOT\n  OpenStreetMap.Mapnik\n  OpenTopoMap\n  SafeCast\n  Stadia.AlidadeSatellite\n  Stadia.AlidadeSmooth\n  Stadia.AlidadeSmoothDark\n  Stadia.OSMBright\n  Stadia.Outdoors\n  Stadia.StamenTerrain\n  Stadia.StamenTerrainBackground\n  Stadia.StamenTerrainLabels\n  Stadia.StamenTerrainLines\n  Stadia.StamenToner\n  Stadia.StamenTonerBackground\n  Stadia.StamenTonerLabels\n  Stadia.StamenTonerLines\n  Stadia.StamenTonerLite\n  Stadia.StamenWatercolor\n  Strava.All\n  Strava.Ride\n  Strava.Run\n  Strava.Water\n  Strava.Winter\n  SwissFederalGeoportal.JourneyThroughTime\n  SwissFederalGeoportal.NationalMapColor\n  SwissFederalGeoportal.NationalMapGrey\n  SwissFederalGeoportal.SWISSIMAGE\n  TopPlusOpen.Color\n  TopPlusOpen.Grey\n  USGS.USImagery\n  USGS.USImageryTopo\n  USGS.USTopo\n  WaymarkedTrails.cycling\n  WaymarkedTrails.hiking\n  WaymarkedTrails.mtb\n  WaymarkedTrails.riding\n  WaymarkedTrails.skating\n  WaymarkedTrails.slopes\n  nlmaps.grijs\n  nlmaps.luchtfoto\n  nlmaps.pastel\n  nlmaps.standaard\n  nlmaps.water\n</pre> In\u00a0[11]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p> In\u00a0[12]: Copied! <pre>url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\"\nleafmap.download_file(url, \"buildings.geojson\")\n</pre> url = \"https://raw.githubusercontent.com/opengeos/open-data/main/datasets/libya/Derna_buildings.geojson\" leafmap.download_file(url, \"buildings.geojson\") <pre>buildings.geojson already exists. Skip downloading. Set overwrite=True to overwrite.\n</pre> Out[12]: <pre>'/home/runner/work/leafmap/leafmap/docs/notebooks/buildings.geojson'</pre> <p>Convert vector to PMTiles.</p> In\u00a0[13]: Copied! <pre>pmtiles = \"buildings.pmtiles\"\nleafmap.geojson_to_pmtiles(\n    \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True\n)\n</pre> pmtiles = \"buildings.pmtiles\" leafmap.geojson_to_pmtiles(     \"buildings.geojson\", pmtiles, layer_name=\"buildings\", overwrite=True, quiet=True ) <pre>Error: tippecanoe is not installed.\nYou can install it using conda with the following command:\nconda install -c conda-forge tippecanoe\n</pre> <p>Start a HTTP Sever</p> In\u00a0[14]: Copied! <pre>leafmap.start_server(port=8000)\n</pre> leafmap.start_server(port=8000) In\u00a0[15]: Copied! <pre>url = f\"http://127.0.0.1:8000/{pmtiles}\"\n# leafmap.pmtiles_metadata(url)\n</pre> url = f\"http://127.0.0.1:8000/{pmtiles}\" # leafmap.pmtiles_metadata(url) <p>Display the PMTiles on the map.</p> In\u00a0[16]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Google Hybrid\")\nstyle = {\n    \"version\": 8,\n    \"sources\": {\n        \"example_source\": {\n            \"type\": \"vector\",\n            \"url\": \"pmtiles://\" + url,\n            \"attribution\": \"PMTiles\",\n        }\n    },\n    \"layers\": [\n        {\n            \"id\": \"buildings\",\n            \"source\": \"example_source\",\n            \"source-layer\": \"buildings\",\n            \"type\": \"fill\",\n            \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},\n        },\n    ],\n}\n\n# style = leafmap.pmtiles_style(url)  # Use default style\n\nm.add_pmtiles(\n    url,\n    style=style,\n    visible=True,\n    opacity=0.8,\n    tooltip=True,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Google Hybrid\") style = {     \"version\": 8,     \"sources\": {         \"example_source\": {             \"type\": \"vector\",             \"url\": \"pmtiles://\" + url,             \"attribution\": \"PMTiles\",         }     },     \"layers\": [         {             \"id\": \"buildings\",             \"source\": \"example_source\",             \"source-layer\": \"buildings\",             \"type\": \"fill\",             \"paint\": {\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5},         },     ], }  # style = leafmap.pmtiles_style(url)  # Use default style  m.add_pmtiles(     url,     style=style,     visible=True,     opacity=0.8,     tooltip=True, ) m <pre>Basemap can only be one of the following:\n  OpenStreetMap\n  Esri.WorldStreetMap\n  Esri.WorldImagery\n  Esri.WorldTopoMap\n  FWS NWI Wetlands\n  FWS NWI Wetlands Raster\n  NLCD 2021 CONUS Land Cover\n  NLCD 2019 CONUS Land Cover\n  NLCD 2016 CONUS Land Cover\n  NLCD 2013 CONUS Land Cover\n  NLCD 2011 CONUS Land Cover\n  NLCD 2008 CONUS Land Cover\n  NLCD 2006 CONUS Land Cover\n  NLCD 2004 CONUS Land Cover\n  NLCD 2001 CONUS Land Cover\n  USGS NAIP Imagery\n  USGS NAIP Imagery False Color\n  USGS NAIP Imagery NDVI\n  USGS Hydrography\n  USGS 3DEP Elevation\n  ESA Worldcover 2020\n  ESA Worldcover 2020 S2 FCC\n  ESA Worldcover 2020 S2 TCC\n  ESA Worldcover 2021\n  ESA Worldcover 2021 S2 FCC\n  ESA Worldcover 2021 S2 TCC\n  BaseMapDE.Color\n  BaseMapDE.Grey\n  BasemapAT.basemap\n  BasemapAT.grau\n  BasemapAT.highdpi\n  BasemapAT.orthofoto\n  BasemapAT.overlay\n  BasemapAT.surface\n  BasemapAT.terrain\n  CartoDB.DarkMatter\n  CartoDB.DarkMatterNoLabels\n  CartoDB.DarkMatterOnlyLabels\n  CartoDB.Positron\n  CartoDB.PositronNoLabels\n  CartoDB.PositronOnlyLabels\n  CartoDB.Voyager\n  CartoDB.VoyagerLabelsUnder\n  CartoDB.VoyagerNoLabels\n  CartoDB.VoyagerOnlyLabels\n  CyclOSM\n  Esri.AntarcticBasemap\n  Esri.AntarcticImagery\n  Esri.ArcticImagery\n  Esri.ArcticOceanBase\n  Esri.ArcticOceanReference\n  Esri.DeLorme\n  Esri.NatGeoWorldMap\n  Esri.OceanBasemap\n  Esri.WorldGrayCanvas\n  Esri.WorldPhysical\n  Esri.WorldShadedRelief\n  Esri.WorldTerrain\n  FreeMapSK\n  Gaode.Normal\n  Gaode.Satellite\n  HikeBike.HikeBike\n  HikeBike.HillShading\n  JusticeMap.americanIndian\n  JusticeMap.asian\n  JusticeMap.black\n  JusticeMap.hispanic\n  JusticeMap.income\n  JusticeMap.multi\n  JusticeMap.nonWhite\n  JusticeMap.plurality\n  JusticeMap.white\n  MtbMap\n  NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief\n  NASAGIBS.BlueMarble3031\n  NASAGIBS.BlueMarble3413\n  NASAGIBS.BlueMarbleBathymetry3031\n  NASAGIBS.BlueMarbleBathymetry3413\n  NASAGIBS.MEaSUREsIceVelocity3031\n  NASAGIBS.MEaSUREsIceVelocity3413\n  NASAGIBS.ModisAquaBands721CR\n  NASAGIBS.ModisAquaTrueColorCR\n  NASAGIBS.ModisTerraAOD\n  NASAGIBS.ModisTerraBands367CR\n  NASAGIBS.ModisTerraBands721CR\n  NASAGIBS.ModisTerraChlorophyll\n  NASAGIBS.ModisTerraLSTDay\n  NASAGIBS.ModisTerraSnowCover\n  NASAGIBS.ModisTerraTrueColorCR\n  NASAGIBS.ViirsEarthAtNight2012\n  NASAGIBS.ViirsTrueColorCR\n  OPNVKarte\n  OneMapSG.Default\n  OneMapSG.Grey\n  OneMapSG.LandLot\n  OneMapSG.Night\n  OneMapSG.Original\n  OpenAIP\n  OpenFireMap\n  OpenRailwayMap\n  OpenSeaMap\n  OpenSnowMap.pistes\n  OpenStreetMap.BZH\n  OpenStreetMap.BlackAndWhite\n  OpenStreetMap.CH\n  OpenStreetMap.DE\n  OpenStreetMap.HOT\n  OpenStreetMap.Mapnik\n  OpenTopoMap\n  SafeCast\n  Stadia.AlidadeSatellite\n  Stadia.AlidadeSmooth\n  Stadia.AlidadeSmoothDark\n  Stadia.OSMBright\n  Stadia.Outdoors\n  Stadia.StamenTerrain\n  Stadia.StamenTerrainBackground\n  Stadia.StamenTerrainLabels\n  Stadia.StamenTerrainLines\n  Stadia.StamenToner\n  Stadia.StamenTonerBackground\n  Stadia.StamenTonerLabels\n  Stadia.StamenTonerLines\n  Stadia.StamenTonerLite\n  Stadia.StamenWatercolor\n  Strava.All\n  Strava.Ride\n  Strava.Run\n  Strava.Water\n  Strava.Winter\n  SwissFederalGeoportal.JourneyThroughTime\n  SwissFederalGeoportal.NationalMapColor\n  SwissFederalGeoportal.NationalMapGrey\n  SwissFederalGeoportal.SWISSIMAGE\n  TopPlusOpen.Color\n  TopPlusOpen.Grey\n  USGS.USImagery\n  USGS.USImageryTopo\n  USGS.USTopo\n  WaymarkedTrails.cycling\n  WaymarkedTrails.hiking\n  WaymarkedTrails.mtb\n  WaymarkedTrails.riding\n  WaymarkedTrails.skating\n  WaymarkedTrails.slopes\n  nlmaps.grijs\n  nlmaps.luchtfoto\n  nlmaps.pastel\n  nlmaps.standaard\n  nlmaps.water\nHTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /buildings.pmtiles (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x7f53cec1f210&gt;: Failed to establish a new connection: [Errno 111] Connection refused'))\n</pre> In\u00a0[17]: Copied! <pre>m.layer_interact()\n</pre> m.layer_interact() <p></p>"},{"location":"notebooks/93_maplibre_pmtiles/#remote-pmtiles","title":"Remote PMTiles\u00b6","text":""},{"location":"notebooks/93_maplibre_pmtiles/#protomaps-sample-data","title":"Protomaps sample data\u00b6","text":""},{"location":"notebooks/93_maplibre_pmtiles/#overture-data","title":"Overture data\u00b6","text":""},{"location":"notebooks/93_maplibre_pmtiles/#source-cooperative","title":"Source Cooperative\u00b6","text":"<p>Google-Microsoft Open Buildings - combined by VIDA</p>"},{"location":"notebooks/93_maplibre_pmtiles/#local-pmtiles","title":"Local PMTiles\u00b6","text":"<p>tippecanoe is required to convert vector data to pmtiles. Install it with <code>conda install -c conda-forge tippecanoe</code>.</p> <p>Download building footprints of Derna, Libya.</p>"},{"location":"notebooks/zz_notebook_template/","title":"Zz notebook template","text":"<p>Uncomment the following line to install leafmap if needed.</p> In\u00a0[1]: Copied! <pre># %pip install -U leafmap\n</pre> # %pip install -U leafmap In\u00a0[2]: Copied! <pre>import leafmap\n</pre> import leafmap <p>If you are using a recently implemented leafmap feature that has not yet been released to PyPI or conda-forge, you can uncomment the following line to install the development version from GitHub.</p> In\u00a0[3]: Copied! <pre># leafmap.update_package()\n</pre> # leafmap.update_package() <p>Create an interactive map.</p> In\u00a0[4]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[4]:"},{"location":"workshops/EarthCube_2023/","title":"EarthCube 2023","text":"<p>Interactive Geospatial Analysis and Data Visualization with Leafmap</p> <p>This notebook provides an introduction to interactive geospatial analysis and data visualization with leafmap. It is designed for the notebook demo at the EarthCube 2023.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install leafmap[raster] geopandas rasterstats\n</pre> # %pip install leafmap[raster] geopandas rasterstats In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nimport geopandas as gpd\n</pre> import os import leafmap import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4, height=\"600px\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4, height=\"600px\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_basemap(\"USGS 3DEP Elevation\")\nm.add_basemap(\"USGS Hydrography\")\nm.add_layer_manager()\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_basemap(\"USGS 3DEP Elevation\") m.add_basemap(\"USGS Hydrography\") m.add_layer_manager() m <p>Add NLCD land cover map and legend.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"HYBRID\")\nm.add_basemap(\"NLCD 2019 CONUS Land Cover\")\nm.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.add_basemap(\"HYBRID\") m.add_basemap(\"NLCD 2019 CONUS Land Cover\") m.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\") m <p>Add WMS layers.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"Esri.WorldImagery\")\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.add_basemap(\"Esri.WorldImagery\") url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\") m <p>Change basemaps interactively.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap_gui()\nm\n</pre> m = leafmap.Map() m.add_basemap_gui() m In\u00a0[\u00a0]: Copied! <pre>url = \"https://open.gishub.org/data/raster/srtm90.tif\"\n</pre> url = \"https://open.gishub.org/data/raster/srtm90.tif\" In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_stats(url)\n</pre> leafmap.cog_stats(url) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_cog_layer(url, name=\"Remote COG\", colormap_name=\"terrain\")\nm.add_colormap(vmin=0, vmax=4000, cmap=\"terrain\", label=\"Elevation (m)\")\nm.add_inspector_gui()\nm\n</pre> m = leafmap.Map() m.add_cog_layer(url, name=\"Remote COG\", colormap_name=\"terrain\") m.add_colormap(vmin=0, vmax=4000, cmap=\"terrain\", label=\"Elevation (m)\") m.add_inspector_gui() m <p>Download the COG file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.download_file(url, \"srtm90.tif\")\n</pre> leafmap.download_file(url, \"srtm90.tif\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"srtm90.tif\", colormap=\"terrain\", layer_name=\"Local COG\")\nm.add_colormap(vmin=0, vmax=4000, cmap=\"terrain\", label=\"Elevation (m)\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"srtm90.tif\", colormap=\"terrain\", layer_name=\"Local COG\") m.add_colormap(vmin=0, vmax=4000, cmap=\"terrain\", label=\"Elevation (m)\") m In\u00a0[\u00a0]: Copied! <pre>url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\n</pre> url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" In\u00a0[\u00a0]: Copied! <pre>leafmap.stac_bands(url)\n</pre> leafmap.stac_bands(url) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\")\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm.add_layer_manager()\nm\n</pre> m = leafmap.Map() m.add_stac_layer(url, bands=[\"pan\"], name=\"Panchromatic\") m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m.add_layer_manager() m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://open.gishub.org/data/world/continents.geojson\"\nm.add_geojson(url, layer_name=\"Continents\")\nm\n</pre> m = leafmap.Map() url = \"https://open.gishub.org/data/world/continents.geojson\" m.add_geojson(url, layer_name=\"Continents\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://open.gishub.org/data/world/countries.zip\"\nm.add_shp(url, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map() url = \"https://open.gishub.org/data/world/countries.zip\" m.add_shp(url, layer_name=\"Countries\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\nm.add_vector(url, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" m.add_vector(url, layer_name=\"Cable lines\") m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n\nm = leafmap.Map()\nm.add_basemap(\"CartoDB.DarkMatter\")\nurl = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\ncallback = lambda feat: {\"color\": feat[\"properties\"][\"color\"]}\nm.add_vector(url, layer_name=\"Cable lines\", style_callback=callback)\nm\n</pre> import leafmap  m = leafmap.Map() m.add_basemap(\"CartoDB.DarkMatter\") url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" callback = lambda feat: {\"color\": feat[\"properties\"][\"color\"]} m.add_vector(url, layer_name=\"Cable lines\", style_callback=callback) m In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/us_cities.csv\"\nleafmap.csv_to_df(url).head()\n</pre> url = \"https://github.com/opengeos/leafmap/raw/master/examples/data/us_cities.csv\" leafmap.csv_to_df(url).head() In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.add_points_from_xy(url, x=\"longitude\", y=\"latitude\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.add_points_from_xy(url, x=\"longitude\", y=\"latitude\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[36.1, -114.9], zoom=10)\nm.add_basemap(\"HYBRID\")\nm.split_map(\n    left_layer=\"NLCD 2001 CONUS Land Cover\",\n    right_layer=\"NLCD 2019 CONUS Land Cover\",\n    left_label=\"2001\",\n    right_label=\"2019\",\n)\nm.add_layer_control()\nm\n</pre> m = leafmap.Map(center=[36.1, -114.9], zoom=10) m.add_basemap(\"HYBRID\") m.split_map(     left_layer=\"NLCD 2001 CONUS Land Cover\",     right_layer=\"NLCD 2019 CONUS Land Cover\",     left_label=\"2001\",     right_label=\"2019\", ) m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nbefore = (\n    \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n)\nafter = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\nm.split_map(before, after, left_label=\"Before\", right_label=\"After\")\nm\n</pre> m = leafmap.Map() before = (     \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" ) after = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\" m.split_map(before, after, left_label=\"Before\", right_label=\"After\") m In\u00a0[\u00a0]: Copied! <pre>bbox = [-79.6344, -0.9063, -77.3383, 1.0436]\nstart_date = \"2016-04-01\"\nend_date = \"2016-04-30\"\ngdf = leafmap.oam_search(\n    bbox=bbox, start_date=start_date, end_date=end_date, return_gdf=True\n)\nprint(f\"Found {len(gdf)} images\")\n</pre> bbox = [-79.6344, -0.9063, -77.3383, 1.0436] start_date = \"2016-04-01\" end_date = \"2016-04-30\" gdf = leafmap.oam_search(     bbox=bbox, start_date=start_date, end_date=end_date, return_gdf=True ) print(f\"Found {len(gdf)} images\") In\u00a0[\u00a0]: Copied! <pre>gdf.head()\n</pre> gdf.head() <p>The tile URLs are stored in the <code>tms</code> column of the GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>tiles = gdf[\"tms\"].tolist()\ntiles[:5]\n</pre> tiles = gdf[\"tms\"].tolist() tiles[:5] <p>The image sources (downloadable URLs) are stored in the uuid column of the GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>images = gdf[\"uuid\"].tolist()\nimages[:5]\n</pre> images = gdf[\"uuid\"].tolist() images[:5] <p>Download all images using the download_files() function.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.download_files(images[:2])\n</pre> leafmap.download_files(images[:2]) <p>Add the image footprints to the map.</p> In\u00a0[\u00a0]: Copied! <pre>import leafmap\n\nm = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Footprints\")\nm.add_cog_layer(images[0], nodata=0, name=\"OpenAerialMap\")\n# m.add_tile_layer(tiles[0], attribution='OpenAerialMap', name='OpenAerialMap')\nm\n</pre> import leafmap  m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Footprints\") m.add_cog_layer(images[0], nodata=0, name=\"OpenAerialMap\") # m.add_tile_layer(tiles[0], attribution='OpenAerialMap', name='OpenAerialMap') m <p>Search OAM imagery interactively using the interactive GUI.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[4.7955, -75.6899], zoom=15)\nm.add_oam_gui()\nm\n</pre> m = leafmap.Map(center=[4.7955, -75.6899], zoom=15) m.add_oam_gui() m In\u00a0[\u00a0]: Copied! <pre>url = \"https://earth-search.aws.element84.com/v1/\"\ncollection = \"sentinel-2-l2a\"\ntime_range = \"2021-12-01/2021-12-31\"\nbbox = [-122.2751, 47.5469, -121.9613, 47.7458]\n</pre> url = \"https://earth-search.aws.element84.com/v1/\" collection = \"sentinel-2-l2a\" time_range = \"2021-12-01/2021-12-31\" bbox = [-122.2751, 47.5469, -121.9613, 47.7458] In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    query={\"eo:cloud_cover\": {\"lt\": 10}},\n    sortby=[{\"field\": \"properties.eo:cloud_cover\", \"direction\": \"asc\"}],\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     query={\"eo:cloud_cover\": {\"lt\": 10}},     sortby=[{\"field\": \"properties.eo:cloud_cover\", \"direction\": \"asc\"}], ) search In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_collection=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_collection=True, ) search In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_gdf=True,\n)\nsearch.head()\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_gdf=True, ) search.head() In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_assets=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_assets=True, ) search In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_info=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_info=True, ) search In\u00a0[\u00a0]: Copied! <pre>search = leafmap.stac_search(\n    url=url,\n    max_items=10,\n    collections=[collection],\n    bbox=bbox,\n    datetime=time_range,\n    get_links=True,\n)\nsearch\n</pre> search = leafmap.stac_search(     url=url,     max_items=10,     collections=[collection],     bbox=bbox,     datetime=time_range,     get_links=True, ) search In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[37.7517, -122.4433], zoom=8)\nm.add_stac_gui()\nm\n</pre> m = leafmap.Map(center=[37.7517, -122.4433], zoom=8) m.add_stac_gui() m In\u00a0[\u00a0]: Copied! <pre># m.stac_gdf\n</pre> # m.stac_gdf In\u00a0[\u00a0]: Copied! <pre># m.stac_dict\n</pre> # m.stac_dict In\u00a0[\u00a0]: Copied! <pre># m.stac_item\n</pre> # m.stac_item In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://open.gishub.org/data/raster/srtm90.tif\"\nm.add_cog_layer(url, name=\"Remote COG\")\nm\n</pre> m = leafmap.Map() url = \"https://open.gishub.org/data/raster/srtm90.tif\" m.add_cog_layer(url, name=\"Remote COG\") m In\u00a0[\u00a0]: Copied! <pre>leafmap.split_raster(url, out_dir=\"tiles\", tile_size=(1000, 1000), overlap=0)\n</pre> leafmap.split_raster(url, out_dir=\"tiles\", tile_size=(1000, 1000), overlap=0) In\u00a0[\u00a0]: Copied! <pre>tiles = leafmap.find_files(\"tiles\", ext=\".tif\")\ntiles\n</pre> tiles = leafmap.find_files(\"tiles\", ext=\".tif\") tiles In\u00a0[\u00a0]: Copied! <pre>for tile in tiles[:6]:\n    name = os.path.basename(tile).replace(\".tif\", \"\")\n    m.add_raster(\n        tile, cmap=\"terrain\", vmin=0, vmax=4000, layer_name=name, zoom_to_layer=False\n    )\n</pre> for tile in tiles[:6]:     name = os.path.basename(tile).replace(\".tif\", \"\")     m.add_raster(         tile, cmap=\"terrain\", vmin=0, vmax=4000, layer_name=name, zoom_to_layer=False     ) In\u00a0[\u00a0]: Copied! <pre>m.add_layer_manager()\nm\n</pre> m.add_layer_manager() m In\u00a0[\u00a0]: Copied! <pre>leafmap.merge_rasters(\"tiles\", output=\"merged.tif\", input_pattern=\"*.tif\")\n</pre> leafmap.merge_rasters(\"tiles\", output=\"merged.tif\", input_pattern=\"*.tif\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"merged.tif\", colormap=\"terrain\", layer_name=\"Merged raster\")\nm\n</pre> m = leafmap.Map() m.add_raster(\"merged.tif\", colormap=\"terrain\", layer_name=\"Merged raster\") m In\u00a0[\u00a0]: Copied! <pre>dsm = \"https://open.gishub.org/data/elevation/dsm.tif\"\nhag = \"https://open.gishub.org/data/elevation/hag.tif\"\nbuildings = \"https://open.gishub.org/data/elevation/buildings.geojson\"\n</pre> dsm = \"https://open.gishub.org/data/elevation/dsm.tif\" hag = \"https://open.gishub.org/data/elevation/hag.tif\" buildings = \"https://open.gishub.org/data/elevation/buildings.geojson\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_cog_layer(dsm, name=\"DSM\", palette=\"terrain\")\nm.add_cog_layer(hag, name=\"Height Above Ground\", palette=\"magma\")\nm.add_geojson(buildings, layer_name=\"Buildings\")\nm\n</pre> m = leafmap.Map() m.add_cog_layer(dsm, name=\"DSM\", palette=\"terrain\") m.add_cog_layer(hag, name=\"Height Above Ground\", palette=\"magma\") m.add_geojson(buildings, layer_name=\"Buildings\") m In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(buildings)\nlen(gdf)\n</pre> gdf = gpd.read_file(buildings) len(gdf) In\u00a0[\u00a0]: Copied! <pre>gdf.head()\n</pre> gdf.head() In\u00a0[\u00a0]: Copied! <pre>types = [\"min\", \"max\", \"mean\", \"std\", \"count\"]\ngdf = leafmap.zonal_stats(gdf, hag, stats=types, gdf_out=True)\ngdf\n</pre> types = [\"min\", \"max\", \"mean\", \"std\", \"count\"] gdf = leafmap.zonal_stats(gdf, hag, stats=types, gdf_out=True) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Zonal Stats\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Zonal Stats\") m"},{"location":"workshops/EarthCube_2023/#installation","title":"Installation\u00b6","text":"<p>Uncomment and run the following cell to install necessary packages for this notebook. Restart the kernel/runtime after installation.</p>"},{"location":"workshops/EarthCube_2023/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/EarthCube_2023/#create-interactive-maps","title":"Create interactive maps\u00b6","text":"<p>Specify the map center [lat, lon], zoom level, and height.</p>"},{"location":"workshops/EarthCube_2023/#add-basemaps","title":"Add basemaps\u00b6","text":"<p>Add OpenTopoMap, USGS 3DEP Elevation, and USGS Hydrography basemaps.</p>"},{"location":"workshops/EarthCube_2023/#visualize-raster-datasets","title":"Visualize raster datasets\u00b6","text":""},{"location":"workshops/EarthCube_2023/#cloud-optimized-geotiff","title":"Cloud Optimized GeoTIFF\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file that is optimized for serving on an HTTP file server, with an internal organization that enables more efficient workflows on a cloud environment. This is achieved by allowing clients to issue HTTP GET requests to ask for only the parts of a file that they need. For more information about COG, please visit https://www.cogeo.org.</p>"},{"location":"workshops/EarthCube_2023/#spatiotemporal-asset-catalog","title":"SpatioTemporal Asset Catalog\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information so that it can more easily be indexed and discovered. A SpatioTemporal Asset is any file that represents information about the earth captured in a certain space and time. STAC aims to enable that next generation of geospatial search engines, while also supporting web best practices so geospatial information is more easily surfaced in traditional search engines. More information about STAC can be found at the STAC website. The STAC Index website is a one-stop-shop for discovering STAC catalogs, collections, APIs, software and tools. In this example, we will use the STAC SPOT Orthoimages of Canada.</p>"},{"location":"workshops/EarthCube_2023/#visualize-vector-datasets","title":"Visualize vector datasets\u00b6","text":""},{"location":"workshops/EarthCube_2023/#geojson","title":"GeoJSON\u00b6","text":""},{"location":"workshops/EarthCube_2023/#shapefile","title":"Shapefile\u00b6","text":""},{"location":"workshops/EarthCube_2023/#other-vector-formats","title":"Other vector formats\u00b6","text":""},{"location":"workshops/EarthCube_2023/#vector-styling","title":"Vector styling\u00b6","text":""},{"location":"workshops/EarthCube_2023/#xy-coordinates","title":"XY coordinates\u00b6","text":""},{"location":"workshops/EarthCube_2023/#split-map","title":"Split Map\u00b6","text":""},{"location":"workshops/EarthCube_2023/#openaerialmap","title":"OpenAerialMap\u00b6","text":"<p>OpenAerialMap (OAM) provides openly licensed satellite and unmanned aerial vehicle (UAV) imagery. Currently, it has over 12,400+ images around the globe. You can search and visualize OAM imagery interactively. You can also download images automatically with one line of code.</p>"},{"location":"workshops/EarthCube_2023/#aws-open-data","title":"AWS Open Data\u00b6","text":"<p>The AWS Open Data Program hosts a lots of open and public datasets on AWS, including Landsat 8, Sentinel-2, NAIP, and many more. Check out https://github.com/opengeos#data-catalogs for a list of open and public datasets on AWS.</p>"},{"location":"workshops/EarthCube_2023/#split-raster-into-tiles","title":"Split raster into tiles\u00b6","text":""},{"location":"workshops/EarthCube_2023/#merge-tiles-into-a-single-raster","title":"Merge tiles into a single raster\u00b6","text":""},{"location":"workshops/EarthCube_2023/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"workshops/FOSS4G_2021/","title":"FOSS4G 2021","text":"<p>Using Leafmap for Geospatial Analysis and Data Visualization</p> <p>This notebook was developed for the leafmap workshop taking place on September 27, 2021 at the FOSS4G 2021 Conference.</p> <p>Author: Qiusheng Wu</p> <p>Launch this notebook to execute code interactively using:</p> <ul> <li>Google Colab: https://gishub.org/foss4g-colab</li> <li>Pangeo Binder JupyterLab: https://gishub.org/foss4g-binder</li> <li>Pangeo Binder Jupyter Notebook: https://gishub.org/foss4g-binder-nb</li> </ul> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport subprocess\nimport sys\n</pre> import os import subprocess import sys In\u00a0[\u00a0]: Copied! <pre>import warnings\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  warnings.filterwarnings(\"ignore\") <p>A function for installing Python packages.</p> In\u00a0[\u00a0]: Copied! <pre>def install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\n</pre> def install(package):     subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package]) <p>Install required Python packages in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>pkgs = [\n    \"leafmap\",\n    \"geopandas\",\n    \"keplergl\",\n    \"datapane\",\n    \"xarray_leaflet\",\n    \"osmnx\",\n    \"pygeos\",\n    \"imageio\",\n    \"tifffile\",\n]\nif \"google.colab\" in sys.modules:\n    for pkg in pkgs:\n        install(pkg)\n</pre> pkgs = [     \"leafmap\",     \"geopandas\",     \"keplergl\",     \"datapane\",     \"xarray_leaflet\",     \"osmnx\",     \"pygeos\",     \"imageio\",     \"tifffile\", ] if \"google.colab\" in sys.modules:     for pkg in pkgs:         install(pkg) In\u00a0[\u00a0]: Copied! <pre>try:\n    import leafmap\nexcept ImportError:\n    install(\"leafmap\")\n</pre> try:     import leafmap except ImportError:     install(\"leafmap\") In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=4)  # center=[lat, lon]\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=4)  # center=[lat, lon] m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(51.5, -0.15), zoom=17)\nm\n</pre> m = leafmap.Map(center=(51.5, -0.15), zoom=17) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(height=\"400px\", width=\"800px\")\nm\n</pre> m = leafmap.Map(height=\"400px\", width=\"800px\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    draw_control=False,\n    measure_control=False,\n    fullscreen_control=False,\n    attribution_control=False,\n)\nm\n</pre> m = leafmap.Map(     draw_control=False,     measure_control=False,     fullscreen_control=False,     attribution_control=False, ) m <p>Remove all controls from the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.clear_controls()\nm\n</pre> m = leafmap.Map() m.clear_controls() m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN\nm\n</pre> m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN m <p>Add a basemap using the <code>add_basemap()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m <p>Print out the list of available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>for basemap in leafmap.basemaps:\n    print(basemap[:5])\n</pre> for basemap in leafmap.basemaps:     print(basemap[:5]) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nnaip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True\n)\nm\n</pre> m = leafmap.Map() naip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\" m.add_wms_layer(     url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True ) m In\u00a0[\u00a0]: Copied! <pre>import xyzservices.providers as xyz\n</pre> import xyzservices.providers as xyz In\u00a0[\u00a0]: Copied! <pre>basemap = xyz.CartoDB.DarkMatter\nbasemap\n</pre> basemap = xyz.CartoDB.DarkMatter basemap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(basemap)\nm\n</pre> m = leafmap.Map() m.add_basemap(basemap) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>The URL to the vector tile.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=gCZXZglvRQa6sB2z7JzL1w\"\n</pre> url = \"https://tile.nextzen.org/tilezen/vector/v1/512/all/{z}/{x}/{y}.mvt?api_key=gCZXZglvRQa6sB2z7JzL1w\" <p>Attribution of the vector tile.</p> In\u00a0[\u00a0]: Copied! <pre>attribution = \"Nextzen\"\n</pre> attribution = \"Nextzen\" <p>One can customize the vector tile layer style if needed. More info can be found at https://ipyleaflet.readthedocs.io/en/latest/api_reference/vector_tile.html</p> In\u00a0[\u00a0]: Copied! <pre>vector_tile_layer_styles = {}\n</pre> vector_tile_layer_styles = {} <p>Add the vector tile layer to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_vector_tile_layer(url, attribution, vector_tile_layer_styles)\nm\n</pre> m.add_vector_tile_layer(url, attribution, vector_tile_layer_styles) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm.add_cog_layer(url2, name=\"Fire (post-event)\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"  m.add_cog_layer(url, name=\"Fire (pre-event)\") m.add_cog_layer(url2, name=\"Fire (post-event)\") m <p>Retrieve the bounding box coordinates of the COG file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_bounds(url)\n</pre> leafmap.cog_bounds(url) <p>Retrieve the centroid coordinates of the COG file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_center(url)\n</pre> leafmap.cog_center(url) <p>Retrieves the tile layer URL of the COG file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.cog_tile(url)\n</pre> leafmap.cog_tile(url) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m <p>Retrieve the bounding box coordinates of the STAC file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.stac_bounds(url)\n</pre> leafmap.stac_bounds(url) <p>Retrieve the centroid coordinates of the STAC file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.stac_center(url)\n</pre> leafmap.stac_center(url) <p>Retrieve the band names of the STAC file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.stac_bands(url)\n</pre> leafmap.stac_bands(url) <p>Retrieve the tile layer URL of the STAC file.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.stac_tile(url, bands=[\"B3\", \"B2\", \"B1\"])\n</pre> leafmap.stac_tile(url, bands=[\"B3\", \"B2\", \"B1\"]) <p>Download samples raster datasets</p> <p>More datasets can be downloaded from https://viewer.nationalmap.gov/basic/</p> In\u00a0[\u00a0]: Copied! <pre>landsat = \"landsat.tif\"\ndem = \"dem.tif\"\n</pre> landsat = \"landsat.tif\" dem = \"dem.tif\" <p>Download a small Landsat imagery.</p> In\u00a0[\u00a0]: Copied! <pre>landsat_url = (\n    \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\"\n)\nleafmap.download_file(landsat_url, \"landsat.tif\", unzip=False)\n</pre> landsat_url = (     \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\" ) leafmap.download_file(landsat_url, \"landsat.tif\", unzip=False) <p>Download a small DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>dem_url = (\n    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n)\nleafmap.download_file(dem_url, \"dem.tif\", unzip=False)\n</pre> dem_url = (     \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" ) leafmap.download_file(dem_url, \"dem.tif\", unzip=False) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add local raster datasets to the map</p> <p>More colormap can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\n</pre> m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\")\n</pre> m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\") In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m <p>List all available built-in legends.</p> In\u00a0[\u00a0]: Copied! <pre>legends = leafmap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = leafmap.builtin_legends for legend in legends:     print(legend) <p>Add a WMS layer and built-in legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\") m <p>Add U.S. National Wetlands Inventory (NWI). More info at https://www.fws.gov/wetlands.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"HYBRID\")\n\nurl1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\"\nm.add_wms_layer(\n    url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\"\n)\n\nurl2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\"\n)\n\nm.add_legend(builtin_legend=\"NWI\")\nm\n</pre> m = leafmap.Map(google_map=\"HYBRID\")  url1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\" m.add_wms_layer(     url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\" )  url2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\" m.add_wms_layer(     url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\" )  m.add_legend(builtin_legend=\"NWI\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nlabels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n# color can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]\n\nm.add_legend(title=\"Legend\", labels=labels, colors=colors)\nm\n</pre> m = leafmap.Map()  labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"] # color can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"] # colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]  m.add_legend(title=\"Legend\", labels=labels, colors=colors) m <p>Define a legend dictionary.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nm.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nm\n</pre> m = leafmap.Map()  url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, )  legend_dict = {     \"11 Open Water\": \"466b9f\",     \"12 Perennial Ice/Snow\": \"d1def8\",     \"21 Developed, Open Space\": \"dec5c5\",     \"22 Developed, Low Intensity\": \"d99282\",     \"23 Developed, Medium Intensity\": \"eb0000\",     \"24 Developed High Intensity\": \"ab0000\",     \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",     \"41 Deciduous Forest\": \"68ab5f\",     \"42 Evergreen Forest\": \"1c5f2c\",     \"43 Mixed Forest\": \"b5c58f\",     \"51 Dwarf Scrub\": \"af963c\",     \"52 Shrub/Scrub\": \"ccb879\",     \"71 Grassland/Herbaceous\": \"dfdfc2\",     \"72 Sedge/Herbaceous\": \"d1d182\",     \"73 Lichens\": \"a3cc51\",     \"74 Moss\": \"82ba9e\",     \"81 Pasture/Hay\": \"dcd939\",     \"82 Cultivated Crops\": \"ab6c28\",     \"90 Woody Wetlands\": \"b8d9eb\",     \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\", }  m.add_legend(legend_title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"USGS 3DEP Elevation\")\ncolors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nm.add_colorbar(colors=colors, vmin=0, vmax=4000)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"USGS 3DEP Elevation\") colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] m.add_colorbar(colors=colors, vmin=0, vmax=4000) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nurl = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url,\n    layers=\"3DEPElevation:Hillshade Elevation Tinted\",\n    name=\"USGS 3DEP Elevation\",\n    format=\"image/png\",\n    transparent=True,\n)\n\ncolors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nm.add_colorbar(colors=colors, vmin=0, vmax=4000, categorical=True, step=4)\nm\n</pre> m = leafmap.Map()  url = \"https://elevation.nationalmap.gov/arcgis/services/3DEPElevation/ImageServer/WMSServer?\" m.add_wms_layer(     url,     layers=\"3DEPElevation:Hillshade Elevation Tinted\",     name=\"USGS 3DEP Elevation\",     format=\"image/png\",     transparent=True, )  colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] m.add_colorbar(colors=colors, vmin=0, vmax=4000, categorical=True, step=4) m In\u00a0[\u00a0]: Copied! <pre>import leafmap.colormaps as cm\n</pre> import leafmap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>cm.palettes.dem\n</pre> cm.palettes.dem <p>Show the DEM palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.dem, axis_off=True)\n</pre> cm.plot_colormap(colors=cm.palettes.dem, axis_off=True) <p>Color palette for NDVI data.</p> In\u00a0[\u00a0]: Copied! <pre>cm.palettes.ndvi\n</pre> cm.palettes.ndvi <p>Show the NDVI palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.ndvi)\n</pre> cm.plot_colormap(colors=cm.palettes.ndvi) In\u00a0[\u00a0]: Copied! <pre>cm.get_palette(\"terrain\", n_class=8)\n</pre> cm.get_palette(\"terrain\", n_class=8) <p>Show the terrain palette with 8 classes.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8))\n</pre> cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8)) <p>Create a palette with custom colors, label, and font size.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12)\n</pre> cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12) <p>Create a discrete color palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12\n)\n</pre> cm.plot_colormap(     colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12 ) <p>Specify the width and height for the palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=1000, ) <p>Change the orentation of the colormap to be vertical.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=1000, ) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormaps(width=12, height=0.4)\n</pre> cm.plot_colormaps(width=12, height=0.4) In\u00a0[\u00a0]: Copied! <pre>in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\"\ndf = leafmap.csv_to_df(in_csv)\ndf\n</pre> in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\" df = leafmap.csv_to_df(in_csv) df <p>Create a point layer from a CSV file containing lat/long information.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\")\nm\n</pre> m = leafmap.Map() m.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\") m <p>Set the output directory.</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\nout_shp = os.path.join(out_dir, \"world_cities.shp\")\n</pre> out_dir = os.getcwd() out_shp = os.path.join(out_dir, \"world_cities.shp\") <p>Convert a CSV file containing lat/long information to a shapefile.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.csv_to_shp(in_csv, out_shp)\n</pre> leafmap.csv_to_shp(in_csv, out_shp) <p>Convert a CSV file containing lat/long information to a GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>out_geojson = os.path.join(out_dir, \"world_cities.geojson\")\nleafmap.csv_to_geojson(in_csv, out_geojson)\n</pre> out_geojson = os.path.join(out_dir, \"world_cities.geojson\") leafmap.csv_to_geojson(in_csv, out_geojson) <p>Convert a CSV file containing lat/long information to a GeoPandas GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.csv_to_gdf(in_csv)\ngdf\n</pre> gdf = leafmap.csv_to_gdf(in_csv) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\") m <p>Add a GeoJSON with random filled color to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m <p>Use the <code>style_callback</code> function for assigning a random color to each polygon.</p> In\u00a0[\u00a0]: Copied! <pre>import random\n\nm = leafmap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\n\ndef random_color(feature):\n    return {\n        \"color\": \"black\",\n        \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),\n    }\n\n\nm.add_geojson(url, layer_name=\"Countries\", style_callback=random_color)\nm\n</pre> import random  m = leafmap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"   def random_color(feature):     return {         \"color\": \"black\",         \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),     }   m.add_geojson(url, layer_name=\"Countries\", style_callback=random_color) m <p>Use custom <code>style</code> and <code>hover_style</code> functions.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\nhover_style = {\"fillOpacity\": 0.7}\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" style = {     \"stroke\": True,     \"color\": \"#0000ff\",     \"weight\": 2,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#0000ff\",     \"fillOpacity\": 0.1, } hover_style = {\"fillOpacity\": 0.7} m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, layer_name=\"Countries\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\nm\n</pre> m = leafmap.Map() in_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\" m.add_kml(in_kml, layer_name=\"US States KML\") m In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\ngdf = gpd.read_file(\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\n)\nm.add_gdf(gdf, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map() gdf = gpd.read_file(     \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" ) m.add_gdf(gdf, layer_name=\"Cable lines\") m <p>Read the GeoPandas sample dataset as a GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>path_to_data = gpd.datasets.get_path(\"nybb\")\ngdf = gpd.read_file(path_to_data)\ngdf\n</pre> path_to_data = gpd.datasets.get_path(\"nybb\") gdf = gpd.read_file(path_to_data) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"])\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"]) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Add a point layer programmatically.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\"\nm.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\")\nm\n</pre> m = leafmap.Map() url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\" m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_vector(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_vector(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\") m <p>Show OSM feature tags. https://wiki.openstreetmap.org/wiki/Map_features</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.osm_tags_list()\n</pre> # leafmap.osm_tags_list() In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\",\n    tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},\n    dist=1000,\n    layer_name=\"NYC buildings\",\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\",     tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},     dist=1000,     layer_name=\"NYC buildings\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nnorth, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965\nm.add_osm_from_bbox(\n    north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) north, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965 m.add_osm_from_bbox(     north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(46.7808, -96.0156),\n    tags={\"natural\": \"water\"},\n    dist=10000,\n    layer_name=\"Lakes\",\n)\nm\n</pre> m = leafmap.Map(     center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(46.7808, -96.0156),     tags={\"natural\": \"water\"},     dist=10000,     layer_name=\"Lakes\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(39.9170, 116.3908),\n    tags={\"building\": True, \"natural\": \"water\"},\n    dist=1000,\n    layer_name=\"Beijing\",\n)\nm\n</pre> m = leafmap.Map(     center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(39.9170, 116.3908),     tags={\"building\": True, \"natural\": \"water\"},     dist=1000,     layer_name=\"Beijing\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.set_center(-73.9854, 40.7500, 16)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.set_center(-73.9854, 40.7500, 16) m In\u00a0[\u00a0]: Copied! <pre>m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n</pre> m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\") <p>Create a GeoPandas GeoDataFrame from place.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"})\ngdf\n</pre> gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"}) gdf <p>Download a sample DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\"\n</pre> url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\" In\u00a0[\u00a0]: Copied! <pre>leafmap.download_file(url, \"dem.tif\")\n</pre> leafmap.download_file(url, \"dem.tif\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Display the toolbox using the default mode.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui()\n</pre> leafmap.whiteboxgui() <p>Display the toolbox using the collapsible tree mode. Note that the tree mode does not support Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui(tree=True)\n</pre> leafmap.whiteboxgui(tree=True) <p>Perform geospatial analysis using the whitebox package.</p> In\u00a0[\u00a0]: Copied! <pre>import whitebox\n</pre> import whitebox In\u00a0[\u00a0]: Copied! <pre>wbt = whitebox.WhiteboxTools()\nwbt.verbose = False\n</pre> wbt = whitebox.WhiteboxTools() wbt.verbose = False In\u00a0[\u00a0]: Copied! <pre>wbt.version()\n</pre> wbt.version() In\u00a0[\u00a0]: Copied! <pre>data_dir = os.getcwd()\nwbt.set_working_dir(data_dir)\n</pre> data_dir = os.getcwd() wbt.set_working_dir(data_dir) In\u00a0[\u00a0]: Copied! <pre>wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9)\nwbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")\nwbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\")\n</pre> wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9) wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\") wbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\") In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport imageio\n\n%matplotlib inline\n</pre> import matplotlib.pyplot as plt import imageio  %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>original = imageio.imread(os.path.join(data_dir, \"dem.tif\"))\nsmoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\"))\nbreached = imageio.imread(os.path.join(data_dir, \"breached.tif\"))\nflow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\"))\n</pre> original = imageio.imread(os.path.join(data_dir, \"dem.tif\")) smoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\")) breached = imageio.imread(os.path.join(data_dir, \"breached.tif\")) flow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\")) In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(16, 11))\n\nax1 = fig.add_subplot(2, 2, 1)\nax1.set_title(\"Original DEM\")\nplt.imshow(original)\n\nax2 = fig.add_subplot(2, 2, 2)\nax2.set_title(\"Smoothed DEM\")\nplt.imshow(smoothed)\n\nax3 = fig.add_subplot(2, 2, 3)\nax3.set_title(\"Breached DEM\")\nplt.imshow(breached)\n\nax4 = fig.add_subplot(2, 2, 4)\nax4.set_title(\"Flow Accumulation\")\nplt.imshow(flow_accum)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16, 11))  ax1 = fig.add_subplot(2, 2, 1) ax1.set_title(\"Original DEM\") plt.imshow(original)  ax2 = fig.add_subplot(2, 2, 2) ax2.set_title(\"Smoothed DEM\") plt.imshow(smoothed)  ax3 = fig.add_subplot(2, 2, 3) ax3.set_title(\"Breached DEM\") plt.imshow(breached)  ax4 = fig.add_subplot(2, 2, 4) ax4.set_title(\"Flow Accumulation\") plt.imshow(flow_accum)  plt.show() In\u00a0[\u00a0]: Copied! <pre>for basemap in leafmap.basemaps:\n    print(basemap)\n</pre> for basemap in leafmap.basemaps:     print(basemap) In\u00a0[\u00a0]: Copied! <pre>layers = list(leafmap.basemaps.keys())[17:117]\n</pre> layers = list(leafmap.basemaps.keys())[17:117] In\u00a0[\u00a0]: Copied! <pre>leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers)\n</pre> leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers) In\u00a0[\u00a0]: Copied! <pre>leafmap.basemaps.keys()\n</pre> leafmap.basemaps.keys() In\u00a0[\u00a0]: Copied! <pre>layers = [\"ROADMAP\", \"HYBRID\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"ROADMAP\", \"HYBRID\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) In\u00a0[\u00a0]: Copied! <pre>layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) <p>Create a 2 * 2 linked map to visualize land cover change. Specify the <code>center</code> and <code>zoom</code> parameters to change the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]]\nlabels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]]\nleafmap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    layers=layers,\n    labels=labels,\n    center=[36.1, -115.2],\n    zoom=9,\n)\n</pre> layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]] labels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]] leafmap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     layers=layers,     labels=labels,     center=[36.1, -115.2],     zoom=9, ) In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\")\n</pre> leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\") <p>Hide the zoom control from the map.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(\n    left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False\n)\n</pre> leafmap.split_map(     left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False ) <p>Add labels to the map and change the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(\n    left_layer=\"NLCD 2001 CONUS Land Cover\",\n    right_layer=\"NLCD 2019 CONUS Land Cover\",\n    left_label=\"2001\",\n    right_label=\"2019\",\n    label_position=\"bottom\",\n    center=[36.1, -114.9],\n    zoom=10,\n)\n</pre> leafmap.split_map(     left_layer=\"NLCD 2001 CONUS Land Cover\",     right_layer=\"NLCD 2019 CONUS Land Cover\",     left_label=\"2001\",     right_label=\"2019\",     label_position=\"bottom\",     center=[36.1, -114.9],     zoom=10, ) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(layers_control=True)\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> m = leafmap.Map(layers_control=True) in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m <p>Use the folium plotting backend.</p> In\u00a0[\u00a0]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m = leafmap.Map() in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) In\u00a0[\u00a0]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nm.add_colorbar(colors=colors, vmin=0, vmax=10000)\nm.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\")\nm\n</pre> colors = [\"blue\", \"lime\", \"red\"] m.add_colorbar(colors=colors, vmin=0, vmax=10000) m.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\") m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Esri.NatGeoWorldMap\") m <p>Specify the output HTML file name to save the map as a web page.</p> In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mymap.html\")\n</pre> m.to_html(\"mymap.html\") <p>If the output HTML file name is not provided, the function will return a string containing contain the source code of the HTML file.</p> In\u00a0[\u00a0]: Copied! <pre>html = m.to_html()\n</pre> html = m.to_html() In\u00a0[\u00a0]: Copied! <pre># print(html)\n</pre> # print(html) In\u00a0[\u00a0]: Copied! <pre>import datapane as dp\nimport leafmap.foliumap as leafmap\n</pre> import datapane as dp import leafmap.foliumap as leafmap In\u00a0[\u00a0]: Copied! <pre>os.environ.get(\"DP_TOKEN\")\n</pre> os.environ.get(\"DP_TOKEN\") In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"DP_TOKEN\") is None:\n    os.environ[\"DP_TOKEN\"] = \"your-api-key\"\n</pre> if os.environ.get(\"DP_TOKEN\") is None:     os.environ[\"DP_TOKEN\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>dp.login(token=os.environ[\"DP_TOKEN\"])\n</pre> dp.login(token=os.environ[\"DP_TOKEN\"]) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"USGS 3DEP Elevation\")\ncolors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nvmin = 0\nvmax = 4000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"USGS 3DEP Elevation\") colors = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] vmin = 0 vmax = 4000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"Elevation Map of North America\")\n</pre> m.publish(name=\"Elevation Map of North America\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"NLCD 2019 CONUS Land Cover\")\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"NLCD 2019 CONUS Land Cover\") m.add_legend(builtin_legend=\"NLCD\") m In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"National Land Cover Database (NLCD) 2019\")\n</pre> m.publish(name=\"National Land Cover Database (NLCD) 2019\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m = leafmap.Map() in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) In\u00a0[\u00a0]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nvmin = 0\nvmax = 10000\nm.add_colorbar(colors=colors, vmin=vmin, vmax=vmax)\nm\n</pre> colors = [\"blue\", \"lime\", \"red\"] vmin = 0 vmax = 10000 m.add_colorbar(colors=colors, vmin=vmin, vmax=vmax) m In\u00a0[\u00a0]: Copied! <pre>m.publish(name=\"World Population Heat Map\")\n</pre> m.publish(name=\"World Population Heat Map\") In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>biannual_tiles = leafmap.planet_biannual_tiles_tropical()\n</pre> biannual_tiles = leafmap.planet_biannual_tiles_tropical() In\u00a0[\u00a0]: Copied! <pre>for tile in biannual_tiles:\n    print(tile)\n</pre> for tile in biannual_tiles:     print(tile) In\u00a0[\u00a0]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles_tropical()\n</pre> monthly_tiles = leafmap.planet_monthly_tiles_tropical() In\u00a0[\u00a0]: Copied! <pre>for tile in monthly_tiles:\n    print(tile)\n</pre> for tile in monthly_tiles:     print(tile) <p>Add a Planet monthly mosaic by specifying year and month.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nlayer = monthly_tiles[\"Planet_2021-08\"]\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map() layer = monthly_tiles[\"Planet_2021-08\"] m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nlayer = biannual_tiles[\"Planet_2020-06_2020-08\"]\nm.add_layer(layer)\nm\n</pre> m = leafmap.Map() layer = biannual_tiles[\"Planet_2020-06_2020-08\"] m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>biannual_tiles = leafmap.planet_biannual_tiles_tropical()\n</pre> biannual_tiles = leafmap.planet_biannual_tiles_tropical() In\u00a0[\u00a0]: Copied! <pre>leafmap.ts_inspector(biannual_tiles, center=[8.5, -80], zoom=5)\n</pre> leafmap.ts_inspector(biannual_tiles, center=[8.5, -80], zoom=5) In\u00a0[\u00a0]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles_tropical()\n</pre> monthly_tiles = leafmap.planet_monthly_tiles_tropical() In\u00a0[\u00a0]: Copied! <pre>leafmap.ts_inspector(monthly_tiles, center=[8.5, -80], zoom=5)\n</pre> leafmap.ts_inspector(monthly_tiles, center=[8.5, -80], zoom=5) In\u00a0[\u00a0]: Copied! <pre>tiles = leafmap.planet_tiles_tropical()\n</pre> tiles = leafmap.planet_tiles_tropical() In\u00a0[\u00a0]: Copied! <pre>leafmap.ts_inspector(tiles, center=[8.5, -80], zoom=5)\n</pre> leafmap.ts_inspector(tiles, center=[8.5, -80], zoom=5) <p>Use the time slider to visualize Planet quarterly mosaic.</p> In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[8.5, -80], zoom=5)\nlayers_dict = leafmap.planet_monthly_tiles_tropical()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map(center=[8.5, -80], zoom=5) layers_dict = leafmap.planet_monthly_tiles_tropical() m.add_time_slider(layers_dict, time_interval=1) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[8.5, -80], zoom=5)\nlayers_dict = leafmap.planet_biannual_tiles_tropical()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map(center=[8.5, -80], zoom=5) layers_dict = leafmap.planet_biannual_tiles_tropical() m.add_time_slider(layers_dict, time_interval=1) m <p>Use the time slider to visualize basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.clear_layers()\nlayers_dict = leafmap.basemap_xyz_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map() m.clear_layers() layers_dict = leafmap.basemap_xyz_tiles() m.add_time_slider(layers_dict, time_interval=1) m In\u00a0[\u00a0]: Copied! <pre>try:\n    con = leafmap.connect_postgis(\n        database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True\n    )\nexcept:\n    pass\n</pre> try:     con = leafmap.connect_postgis(         database=\"nyc\", host=\"localhost\", user=None, password=None, use_env_var=True     ) except:     pass In\u00a0[\u00a0]: Copied! <pre>sql = \"SELECT * FROM nyc_neighborhoods\"\n</pre> sql = \"SELECT * FROM nyc_neighborhoods\" In\u00a0[\u00a0]: Copied! <pre>try:\n    gdf = leafmap.read_postgis(sql, con)\n    display(gdf)\nexcept:\n    pass\n</pre> try:     gdf = leafmap.read_postgis(sql, con)     display(gdf) except:     pass In\u00a0[\u00a0]: Copied! <pre>try:\n    m = leafmap.Map()\n    m.add_gdf_from_postgis(\n        sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]\n    )\n    display(m)\nexcept:\n    pass\n</pre> try:     m = leafmap.Map()     m.add_gdf_from_postgis(         sql, con, layer_name=\"NYC Neighborhoods\", fill_colors=[\"red\", \"green\", \"blue\"]     )     display(m) except:     pass <p></p> In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom ipywidgets import Output\nfrom ipyleaflet import WidgetControl\n</pre> import leafmap import numpy as np import matplotlib.pyplot as plt from ipywidgets import Output from ipyleaflet import WidgetControl In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(\n    xlabel=\"time (s)\", ylabel=\"voltage (mV)\", title=\"About as simple as it gets, folks\"\n)\nax.grid()\n\n# Create an output widget to host the plot\noutput_widget = Output()\n\n# Show the plot on the widget\nwith output_widget:\n    output_widget.clear_output()\n    plt.show()\n\n# Add the widget as a control to the map\noutput_control = WidgetControl(widget=output_widget, position=\"bottomright\")\nm.add_control(output_control)\n</pre> m = leafmap.Map()  # Data for plotting t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2 * np.pi * t)  fig, ax = plt.subplots() ax.plot(t, s)  ax.set(     xlabel=\"time (s)\", ylabel=\"voltage (mV)\", title=\"About as simple as it gets, folks\" ) ax.grid()  # Create an output widget to host the plot output_widget = Output()  # Show the plot on the widget with output_widget:     output_widget.clear_output()     plt.show()  # Add the widget as a control to the map output_control = WidgetControl(widget=output_widget, position=\"bottomright\") m.add_control(output_control) In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport ipywidgets as widgets\nfrom ipyleaflet import WidgetControl\n</pre> import leafmap import ipywidgets as widgets from ipyleaflet import WidgetControl In\u00a0[\u00a0]: Copied! <pre>widget_width = \"250px\"\npadding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n\ntoolbar_button = widgets.ToggleButton(\n    value=False,\n    tooltip=\"Toolbar\",\n    icon=\"gears\",\n    layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=padding),\n)\n\nclose_button = widgets.ToggleButton(\n    value=False,\n    tooltip=\"Close the tool\",\n    icon=\"times\",\n    button_style=\"primary\",\n    layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=padding),\n)\n</pre> widget_width = \"250px\" padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left  toolbar_button = widgets.ToggleButton(     value=False,     tooltip=\"Toolbar\",     icon=\"gears\",     layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=padding), )  close_button = widgets.ToggleButton(     value=False,     tooltip=\"Close the tool\",     icon=\"times\",     button_style=\"primary\",     layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=padding), ) In\u00a0[\u00a0]: Copied! <pre>toolbar = widgets.HBox([toolbar_button])\ntoolbar\n</pre> toolbar = widgets.HBox([toolbar_button]) toolbar In\u00a0[\u00a0]: Copied! <pre>def toolbar_click(change):\n    if change[\"new\"]:\n        toolbar.children = [toolbar_button, close_button]\n    else:\n        toolbar.children = [toolbar_button]\n\n\ntoolbar_button.observe(toolbar_click, \"value\")\n</pre> def toolbar_click(change):     if change[\"new\"]:         toolbar.children = [toolbar_button, close_button]     else:         toolbar.children = [toolbar_button]   toolbar_button.observe(toolbar_click, \"value\") In\u00a0[\u00a0]: Copied! <pre>def close_click(change):\n    if change[\"new\"]:\n        toolbar_button.close()\n        close_button.close()\n        toolbar.close()\n\n\nclose_button.observe(close_click, \"value\")\ntoolbar\n</pre> def close_click(change):     if change[\"new\"]:         toolbar_button.close()         close_button.close()         toolbar.close()   close_button.observe(close_click, \"value\") toolbar In\u00a0[\u00a0]: Copied! <pre>rows = 2\ncols = 2\ngrid = widgets.GridspecLayout(\n    rows, cols, grid_gap=\"0px\", layout=widgets.Layout(width=\"65px\")\n)\n</pre> rows = 2 cols = 2 grid = widgets.GridspecLayout(     rows, cols, grid_gap=\"0px\", layout=widgets.Layout(width=\"65px\") ) <p>icons: https://fontawesome.com/v4.7.0/icons/</p> In\u00a0[\u00a0]: Copied! <pre>icons = [\"folder-open\", \"map\", \"info\", \"question\"]\n\nfor i in range(rows):\n    for j in range(cols):\n        grid[i, j] = widgets.Button(\n            description=\"\",\n            button_style=\"primary\",\n            icon=icons[i * rows + j],\n            layout=widgets.Layout(width=\"28px\", padding=\"0px\"),\n        )\ngrid\n</pre> icons = [\"folder-open\", \"map\", \"info\", \"question\"]  for i in range(rows):     for j in range(cols):         grid[i, j] = widgets.Button(             description=\"\",             button_style=\"primary\",             icon=icons[i * rows + j],             layout=widgets.Layout(width=\"28px\", padding=\"0px\"),         ) grid In\u00a0[\u00a0]: Copied! <pre>toolbar = widgets.VBox([toolbar_button])\n</pre> toolbar = widgets.VBox([toolbar_button]) In\u00a0[\u00a0]: Copied! <pre>def toolbar_click(change):\n    if change[\"new\"]:\n        toolbar.children = [widgets.HBox([close_button, toolbar_button]), grid]\n    else:\n        toolbar.children = [toolbar_button]\n\n\ntoolbar_button.observe(toolbar_click, \"value\")\ntoolbar\n</pre> def toolbar_click(change):     if change[\"new\"]:         toolbar.children = [widgets.HBox([close_button, toolbar_button]), grid]     else:         toolbar.children = [toolbar_button]   toolbar_button.observe(toolbar_click, \"value\") toolbar In\u00a0[\u00a0]: Copied! <pre>toolbar_ctrl = WidgetControl(widget=toolbar, position=\"topright\")\n</pre> toolbar_ctrl = WidgetControl(widget=toolbar, position=\"topright\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_control(toolbar_ctrl)\nm\n</pre> m = leafmap.Map() m.add_control(toolbar_ctrl) m In\u00a0[\u00a0]: Copied! <pre>output = widgets.Output()\noutput_ctrl = WidgetControl(widget=output, position=\"bottomright\")\nm.add_control(output_ctrl)\n</pre> output = widgets.Output() output_ctrl = WidgetControl(widget=output, position=\"bottomright\") m.add_control(output_ctrl) In\u00a0[\u00a0]: Copied! <pre>def tool_click(b):\n    with output:\n        output.clear_output()\n        print(f\"You clicked the {b.icon} button\")\n</pre> def tool_click(b):     with output:         output.clear_output()         print(f\"You clicked the {b.icon} button\") In\u00a0[\u00a0]: Copied! <pre>for i in range(rows):\n    for j in range(cols):\n        tool = grid[i, j]\n        tool.on_click(tool_click)\n</pre> for i in range(rows):     for j in range(cols):         tool = grid[i, j]         tool.on_click(tool_click) <p></p>"},{"location":"workshops/FOSS4G_2021/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#workshop-description","title":"Workshop description\u00b6","text":"<p>Leafmap is a Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment. It is built upon a number of open-source packages, such as folium and ipyleaflet (for creating interactive maps), WhiteboxTools and whiteboxgui (for analyzing geospatial data), and ipywidgets (for designing interactive graphical user interface). The WhiteboxTools library currently contains 480+ tools for advanced geospatial analysis. Leafmap provides many convenient functions for loading and visualizing geospatial data with only one line of code. Users can also use the interactive user interface to load geospatial data without coding. Anyone with a web browser and Internet connection can use leafmap to perform geospatial analysis and data visualization in the cloud with minimal coding. The topics that will be covered in this workshop include:</p> <ol> <li>Creating interactive maps</li> <li>Changing basemaps</li> <li>Loading and visualizing vector/raster data</li> <li>Using Cloud Optimized GeoTIFF (COG) and SpatialTemporal Asset Catalog (STAC)</li> <li>Downloading OpenStreetMap data</li> <li>Loading data from a PostGIS database</li> <li>Creating custom legends and colorbars</li> <li>Creating split-panel maps and linked maps</li> <li>Visualizing Planet global monthly/quarterly mosaic</li> <li>Designing and publishing interactive web apps</li> <li>Performing geospatial analysis (e.g., hydrological analysis and LiDAR data analysis) using whiteboxgui.</li> </ol> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required. More information about leafmap can be found at https://leafmap.org</p>"},{"location":"workshops/FOSS4G_2021/#jupyter-keyboard-shortcuts","title":"Jupyter keyboard shortcuts\u00b6","text":"<ul> <li>Shift+Enter: run cell, select below</li> <li>Ctrl+Enter: : run selected cells</li> <li>Alt+Enter: run cell and insert below</li> <li>Tab: code completion or indent</li> <li>Shift+Tab: tooltip</li> <li>Ctrl+/: comment out code</li> </ul>"},{"location":"workshops/FOSS4G_2021/#set-up-environment","title":"Set up environment\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#required-python-packages","title":"Required Python packages:\u00b6","text":"<ul> <li>leafmap - A Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment</li> <li>geopandas - An open source project to make working with geospatial data in python easier.</li> <li>keplergl - A high-performance web-based application for visual exploration of large-scale geolocation data sets</li> <li>datapane - A Python library for building interactive reports in seconds</li> <li>xarray-leaflet - An xarray extension for tiled map plotting</li> </ul>"},{"location":"workshops/FOSS4G_2021/#required-api-keys","title":"Required API keys\u00b6","text":"<ul> <li>HERE Map API key</li> <li>datapane API key</li> <li>Planet API key</li> </ul>"},{"location":"workshops/FOSS4G_2021/#use-google-colab","title":"Use Google Colab\u00b6","text":"<p>Click the button below to open this notebook in Google Colab and execute code interactively.</p> <p> </p>"},{"location":"workshops/FOSS4G_2021/#use-pangeo-binder","title":"Use Pangeo Binder\u00b6","text":"<p>Click the buttons below to open this notebook in JupyterLab (first button) or Jupyter Notebook (second button) and execute code interactively.</p> <p> </p> <ul> <li>JupyterLab: https://gishub.org/foss4g-binder</li> <li>Jupyter Notebook: https://gishub.org/foss4g-binder-nb</li> </ul>"},{"location":"workshops/FOSS4G_2021/#use-minicondaanaconda","title":"Use Miniconda/Anaconda\u00b6","text":"<p>If you have Anaconda or Miniconda installed on your computer, you can install leafmap using the following commands. Leafmap has an optional dependency - geopandas, which can be challenging to install on some computers, especially Windows. It is highly recommended that you create a fresh conda environment to install geopandas and leafmap. Follow the commands below to set up a conda env and install geopandas, leafmap, datapane, keplergl, and xarray_leaflet.</p> <pre><code>conda create -n geo python=3.9\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap datapane keplergl xarray_leaflet -c conda-forge\nmamba install osmnx pygeos imageio tifffile -c conda-forge\njupyter lab\n</code></pre>"},{"location":"workshops/FOSS4G_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p><code>leafmap</code> has four plotting backends: folium, ipyleaflet, here-map, and kepler.gl. Note that the backends do not offer equal functionality. Some interactive functionality in <code>ipyleaflet</code> might not be available in other plotting backends. To use a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> <li><code>import leafmap.kepler as leafmap</code></li> </ul>"},{"location":"workshops/FOSS4G_2021/#use-ipyleaflet","title":"Use ipyleaflet\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#customize-the-default-map","title":"Customize the default map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#specify-map-center-and-zoom-level","title":"Specify map center and zoom level\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#change-map-size","title":"Change map size\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#set-control-visibility","title":"Set control visibility\u00b6","text":"<p>When creating a map, set the following controls to either <code>True</code> or <code>False</code> as appropriate.</p> <ul> <li>attribution_control</li> <li>draw_control</li> <li>fullscreen_control</li> <li>layers_control</li> <li>measure_control</li> <li>scale_control</li> <li>toolbar_control</li> </ul>"},{"location":"workshops/FOSS4G_2021/#change-basemaps","title":"Change basemaps\u00b6","text":"<p>Specify a Google basemap to use, can be one of [\"ROADMAP\", \"TERRAIN\", \"SATELLITE\", \"HYBRID\"].</p>"},{"location":"workshops/FOSS4G_2021/#add-tile-layers","title":"Add tile layers\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-xyz-tile-layer","title":"Add XYZ tile layer\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-wms-tile-layer","title":"Add WMS tile layer\u00b6","text":"<p>More WMS basemaps can be found at the following websites:</p> <ul> <li>USGS National Map: https://viewer.nationalmap.gov/services</li> <li>MRLC NLCD Land Cover data: https://www.mrlc.gov/data-services-page</li> <li>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</li> </ul>"},{"location":"workshops/FOSS4G_2021/#add-xyzservices-provider","title":"Add xyzservices provider\u00b6","text":"<p>Add a layer from xyzservices provider object.</p>"},{"location":"workshops/FOSS4G_2021/#add-vector-tile-layer","title":"Add vector tile layer\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-cogstac-layers","title":"Add COG/STAC layers\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> <li>https://www.digitalglobe.com/ecosystem/open-data</li> <li>https://earthexplorer.usgs.gov/</li> </ul> <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A list of COGs can be found here.</p>"},{"location":"workshops/FOSS4G_2021/#add-cog-layer","title":"Add COG layer\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-stac-layer","title":"Add STAC layer\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc. More information about STAC can be found at https://stacspec.org/</p> <p>Some publicly available SpatioTemporal Asset Catalog (STAC):</p> <ul> <li>https://stacindex.org</li> </ul> <p>For this demo, we will use STAC assets from https://stacindex.org/catalogs/spot-orthoimages-canada-2005#/?t=catalogs</p>"},{"location":"workshops/FOSS4G_2021/#add-local-raster-datasets","title":"Add local raster datasets\u00b6","text":"<p>The <code>add_raster</code> function relies on the <code>xarray_leaflet</code> package and is only available for the ipyleaflet plotting backend. Therefore, Google Colab is not supported. Note that <code>xarray_leaflet</code> does not work properly on Windows (source).</p>"},{"location":"workshops/FOSS4G_2021/#add-legend","title":"Add legend\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-built-in-legend","title":"Add built-in legend\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-custom-legend","title":"Add custom legend\u00b6","text":"<p>There are two ways you can add custom legends:</p> <ol> <li>Define legend labels and colors</li> <li>Define legend dictionary</li> </ol> <p>Define legend keys and colors</p>"},{"location":"workshops/FOSS4G_2021/#add-colorbar","title":"Add colorbar\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#continuous-color","title":"Continuous color\u00b6","text":"<p>Add a continuous colorbar with a custom palette to the map.</p>"},{"location":"workshops/FOSS4G_2021/#categorical-colorbar","title":"Categorical colorbar\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-colormap","title":"Add colormap\u00b6","text":"<p>The colormap functionality requires the ipyleaflet plotting backend. Folium is not supported.</p>"},{"location":"workshops/FOSS4G_2021/#common-colormaps","title":"Common colormaps\u00b6","text":"<p>Color palette for DEM data.</p>"},{"location":"workshops/FOSS4G_2021/#custom-colormaps","title":"Custom colormaps\u00b6","text":"<p>Specify the number of classes for a palette.</p>"},{"location":"workshops/FOSS4G_2021/#horizontal-colormap","title":"Horizontal colormap\u00b6","text":"<p>Add a horizontal colorbar to an interactive map.</p>"},{"location":"workshops/FOSS4G_2021/#vertical-colormap","title":"Vertical colormap\u00b6","text":"<p>Add a vertical colorbar to an interactive map.</p>"},{"location":"workshops/FOSS4G_2021/#list-of-available-colormaps","title":"List of available colormaps\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-vector-datasets","title":"Add vector datasets\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-csv","title":"Add CSV\u00b6","text":"<p>Read a CSV as a Pandas DataFrame.</p>"},{"location":"workshops/FOSS4G_2021/#add-geojson","title":"Add GeoJSON\u00b6","text":"<p>Add a GeoJSON to the map.</p>"},{"location":"workshops/FOSS4G_2021/#add-shapefile","title":"Add shapefile\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-kml","title":"Add KML\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-geodataframe","title":"Add GeoDataFrame\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-point-layer","title":"Add point layer\u00b6","text":"<p>Add a point layer using the interactive GUI.</p> <p></p>"},{"location":"workshops/FOSS4G_2021/#add-vector","title":"Add vector\u00b6","text":"<p>The <code>add_vector</code> function supports any vector data format supported by GeoPandas.</p>"},{"location":"workshops/FOSS4G_2021/#download-osm-data","title":"Download OSM data\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#osm-from-geocode","title":"OSM from geocode\u00b6","text":"<p>Add OSM data of place(s) by name or ID to the map. Note that the leafmap custom layer control does not support GeoJSON, we need to use the ipyleaflet built-in layer control.</p>"},{"location":"workshops/FOSS4G_2021/#osm-from-place","title":"OSM from place\u00b6","text":"<p>Add OSM entities within boundaries of geocodable place(s) to the map.</p>"},{"location":"workshops/FOSS4G_2021/#osm-from-address","title":"OSM from address\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#osm-from-bbox","title":"OSM from bbox\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#osm-from-point","title":"OSM from point\u00b6","text":"<p>Add OSM entities within some distance N, S, E, W of a point to the map.</p>"},{"location":"workshops/FOSS4G_2021/#osm-from-view","title":"OSM from view\u00b6","text":"<p>Add OSM entities within the current map view to the map.</p>"},{"location":"workshops/FOSS4G_2021/#use-whiteboxtools","title":"Use WhiteboxTools\u00b6","text":"<p>Use the built-in toolbox to perform geospatial analysis. For example, you can perform depression filling using the sample DEM dataset downloaded in the above step.</p> <p></p>"},{"location":"workshops/FOSS4G_2021/#create-basemap-gallery","title":"Create basemap gallery\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#create-linked-map","title":"Create linked map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#create-split-panel-map","title":"Create split-panel map\u00b6","text":"<p>Create a split-panel map by specifying the <code>left_layer</code> and <code>right_layer</code>, which can be chosen from the basemap names, or any custom XYZ tile layer.</p>"},{"location":"workshops/FOSS4G_2021/#create-heat-map","title":"Create heat map\u00b6","text":"<p>Specify the file path to the CSV. It can either be a file locally or on the Internet.</p>"},{"location":"workshops/FOSS4G_2021/#save-map-to-html","title":"Save map to HTML\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#publish-maps","title":"Publish maps\u00b6","text":"<p>To follow this tutorial, you will need to sign up for an account with https://datapane.com, then install and authenticate the <code>datapane</code> Python package. More information can be found here.</p> <ul> <li><code>pip install datapane</code></li> <li><code>datapane login</code></li> <li><code>datapane ping</code></li> </ul> <p></p> <p>If you encounter folium version errors, please uncomment the following line to update folium and restart the kernel.</p>"},{"location":"workshops/FOSS4G_2021/#elevation-map","title":"Elevation map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#land-cover-map","title":"Land cover map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#population-heat-map","title":"Population heat map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#use-planet-imagery","title":"Use planet imagery\u00b6","text":"<p>First, you need to sign up a Planet account and get an API key. See https://www.planet.com/nicfi &amp; https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p>"},{"location":"workshops/FOSS4G_2021/#use-timeseries-inspector","title":"Use timeseries inspector\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#use-time-slider","title":"Use time slider\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#use-postgis","title":"Use PostGIS\u00b6","text":"<p>Setting up the conda env:</p> <pre><code>conda create -n geo python=3.9\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap sqlalchemy psycopg2 -c conda-forge\n</code></pre> <p>Sample dataset:</p> <ul> <li>nyc_data.zip (Watch this video to load data into PostGIS)</li> </ul>"},{"location":"workshops/FOSS4G_2021/#connect-to-the-database","title":"Connect to the database\u00b6","text":"<p>You can directly pass in the user name and password to access the database. Alternative, you can define environment variables. The default environment variables for user and password are <code>SQL_USER</code> and <code>SQL_PASSWORD</code>, respectively.</p> <p>The <code>try...except...</code> statements are only used for building the documentation website (https://leafmap.org) because the PostGIS database is not available on GitHub. If you are running the notebook with Jupyter installed locally and PostGIS set up properly, you don't need these <code>try...except...</code> statements.</p>"},{"location":"workshops/FOSS4G_2021/#perform-sql-queries","title":"Perform SQL queries\u00b6","text":"<p>Create a GeoDataFrame from a sql query.</p>"},{"location":"workshops/FOSS4G_2021/#display-data-on-the-map","title":"Display data on the map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-widget-to-the-map","title":"Add widget to the map\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#develop-custom-widgets","title":"Develop custom widgets\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#create-a-toolbar-button","title":"Create a toolbar button\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-toolbar-event","title":"Add toolbar event\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-a-toolbar-grid","title":"Add a toolbar grid\u00b6","text":""},{"location":"workshops/FOSS4G_2021/#add-toolbar-to-leafmap","title":"Add toolbar to leafmap\u00b6","text":""},{"location":"workshops/ICRW_2023/","title":"ICRW 2023","text":"<p>An Introduction to Watershed Analysis with Leafmap and WhiteboxTools</p> <p>This notebook provides an introduction to watershed analysis with Leafmap and WhiteboxTools. It is designed for The Interagency Conference on Research in the Watersheds (ICRW) 2023 workshop - Working with Geospatial Hydrologic Data for Watershed Analyses in R and Python Using Web Services.</p> <ul> <li>Leafmap: https://leafmap.org</li> <li>WhiteboxTools: https://www.whiteboxgeo.com</li> <li>WhiteboxTools User Manual: https://www.whiteboxgeo.com/manual/wbt_book</li> </ul> In\u00a0[\u00a0]: Copied! <pre># %pip install leafmap[raster] geopandas\n</pre> # %pip install leafmap[raster] geopandas In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4, height=\"600px\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4, height=\"600px\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_basemap(\"USGS 3DEP Elevation\")\nm.add_basemap(\"USGS Hydrography\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_basemap(\"USGS 3DEP Elevation\") m.add_basemap(\"USGS Hydrography\") m <p>Add NLCD land cover map and legend.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"HYBRID\")\nm.add_basemap(\"NLCD 2019 CONUS Land Cover\")\nm.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.add_basemap(\"HYBRID\") m.add_basemap(\"NLCD 2019 CONUS Land Cover\") m.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\") m <p>Add WMS layers.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=4)\nm.add_basemap(\"Esri.WorldImagery\")\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\")\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=4) m.add_basemap(\"Esri.WorldImagery\") url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\", title=\"NLCD Land Cover Type\") m In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.get_nhd_basins(feature_ids=23763529, fsource=\"comid\", simplified=False)\n</pre> gdf = leafmap.get_nhd_basins(feature_ids=23763529, fsource=\"comid\", simplified=False) <p>Plot the watershed boundary on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Catchment\", info_mode=None)\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Catchment\", info_mode=None) m <p>Save the watershed boundary to a GeoJSON or shapefile.</p> In\u00a0[\u00a0]: Copied! <pre>gdf.to_file(\"basin.geojson\", driver=\"GeoJSON\")\n</pre> gdf.to_file(\"basin.geojson\", driver=\"GeoJSON\") In\u00a0[\u00a0]: Copied! <pre>gdf.to_file(\"basin.shp\")\n</pre> gdf.to_file(\"basin.shp\") In\u00a0[\u00a0]: Copied! <pre>leafmap.get_3dep_dem(\n    gdf, resolution=30, output=\"dem.tif\", dst_crs=\"EPSG:3857\", to_cog=True\n)\n</pre> leafmap.get_3dep_dem(     gdf, resolution=30, output=\"dem.tif\", dst_crs=\"EPSG:3857\", to_cog=True ) <p>Display the DEM on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"DEM\")\nm\n</pre> m.add_raster(\"dem.tif\", palette=\"terrain\", layer_name=\"DEM\") m In\u00a0[\u00a0]: Copied! <pre>metadata = leafmap.image_metadata(\"dem.tif\")\nmetadata\n</pre> metadata = leafmap.image_metadata(\"dem.tif\") metadata <p>Get a summary statistics of the DEM.</p> In\u00a0[\u00a0]: Copied! <pre>metadata[\"bands\"]\n</pre> metadata[\"bands\"] In\u00a0[\u00a0]: Copied! <pre>m.add_colormap(cmap=\"terrain\", vmin=\"60\", vmax=1500, label=\"Elevation (m)\")\nm\n</pre> m.add_colormap(cmap=\"terrain\", vmin=\"60\", vmax=1500, label=\"Elevation (m)\") m In\u00a0[\u00a0]: Copied! <pre>wbt = leafmap.WhiteboxTools()\n</pre> wbt = leafmap.WhiteboxTools() <p>Check the WhiteboxTools version.</p> In\u00a0[\u00a0]: Copied! <pre>wbt.version()\n</pre> wbt.version() <p>Display the WhiteboxTools interface.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui()\n</pre> leafmap.whiteboxgui() In\u00a0[\u00a0]: Copied! <pre>wbt.set_working_dir(os.getcwd())\nwbt.verbose = False\n</pre> wbt.set_working_dir(os.getcwd()) wbt.verbose = False In\u00a0[\u00a0]: Copied! <pre>wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9)\n</pre> wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9) <p>Display the smoothed DEM and watershed boundary on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_raster(\"smoothed.tif\", palette=\"terrain\", layer_name=\"Smoothed DEM\")\nm.add_geojson(\"basin.geojson\", layer_name=\"Watershed\", info_mode=None)\nm\n</pre> m = leafmap.Map() m.add_raster(\"smoothed.tif\", palette=\"terrain\", layer_name=\"Smoothed DEM\") m.add_geojson(\"basin.geojson\", layer_name=\"Watershed\", info_mode=None) m In\u00a0[\u00a0]: Copied! <pre>wbt.hillshade(\"smoothed.tif\", \"hillshade.tif\", azimuth=315, altitude=35)\n</pre> wbt.hillshade(\"smoothed.tif\", \"hillshade.tif\", azimuth=315, altitude=35) <p>Overlay the hillshade on the smoothed DEM with transparency.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"hillshade.tif\", layer_name=\"Hillshade\")\nm.layers[-1].opacity = 0.6\n</pre> m.add_raster(\"hillshade.tif\", layer_name=\"Hillshade\") m.layers[-1].opacity = 0.6 In\u00a0[\u00a0]: Copied! <pre>wbt.find_no_flow_cells(\"smoothed.tif\", \"noflow.tif\")\n</pre> wbt.find_no_flow_cells(\"smoothed.tif\", \"noflow.tif\") <p>Display the no-flow cells on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"noflow.tif\", layer_name=\"No Flow Cells\")\nm\n</pre> m.add_raster(\"noflow.tif\", layer_name=\"No Flow Cells\") m In\u00a0[\u00a0]: Copied! <pre>wbt.fill_depressions(\"smoothed.tif\", \"filled.tif\")\n</pre> wbt.fill_depressions(\"smoothed.tif\", \"filled.tif\") <p>Alternatively, you can use depression breaching to fill the depressions.</p> In\u00a0[\u00a0]: Copied! <pre>wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")\n</pre> wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\") In\u00a0[\u00a0]: Copied! <pre>wbt.find_no_flow_cells(\"breached.tif\", \"noflow2.tif\")\n</pre> wbt.find_no_flow_cells(\"breached.tif\", \"noflow2.tif\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"noflow2.tif\", layer_name=\"No Flow Cells after Breaching\")\nm\n</pre> m.add_raster(\"noflow2.tif\", layer_name=\"No Flow Cells after Breaching\") m In\u00a0[\u00a0]: Copied! <pre>wbt.d8_pointer(\"breached.tif\", \"flow_direction.tif\")\n</pre> wbt.d8_pointer(\"breached.tif\", \"flow_direction.tif\") In\u00a0[\u00a0]: Copied! <pre>wbt.d8_flow_accumulation(\"breached.tif\", \"flow_accum.tif\")\n</pre> wbt.d8_flow_accumulation(\"breached.tif\", \"flow_accum.tif\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"flow_accum.tif\", layer_name=\"Flow Accumulation\")\nm\n</pre> m.add_raster(\"flow_accum.tif\", layer_name=\"Flow Accumulation\") m In\u00a0[\u00a0]: Copied! <pre>wbt.extract_streams(\"flow_accum.tif\", \"streams.tif\", threshold=5000)\n</pre> wbt.extract_streams(\"flow_accum.tif\", \"streams.tif\", threshold=5000) In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"streams.tif\", layer_name=\"Streams\")\n</pre> m.add_raster(\"streams.tif\", layer_name=\"Streams\") In\u00a0[\u00a0]: Copied! <pre>wbt.distance_to_outlet(\n    \"flow_direction.tif\", streams=\"streams.tif\", output=\"distance_to_outlet.tif\"\n)\n</pre> wbt.distance_to_outlet(     \"flow_direction.tif\", streams=\"streams.tif\", output=\"distance_to_outlet.tif\" ) In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"distance_to_outlet.tif\", layer_name=\"Distance to Outlet\")\n</pre> m.add_raster(\"distance_to_outlet.tif\", layer_name=\"Distance to Outlet\") In\u00a0[\u00a0]: Copied! <pre>wbt.raster_streams_to_vector(\n    \"streams.tif\", d8_pntr=\"flow_direction.tif\", output=\"streams.shp\"\n)\n</pre> wbt.raster_streams_to_vector(     \"streams.tif\", d8_pntr=\"flow_direction.tif\", output=\"streams.shp\" ) <p>The raster_streams_to_vector tool has a bug. The output vector file is missing the coordinate system. Use leafmap.vector_set_crs() to set the coordinate system.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.vector_set_crs(source=\"streams.shp\", output=\"streams.shp\", crs=\"EPSG:3857\")\n</pre> leafmap.vector_set_crs(source=\"streams.shp\", output=\"streams.shp\", crs=\"EPSG:3857\") In\u00a0[\u00a0]: Copied! <pre>m.add_shp(\n    \"streams.shp\", layer_name=\"Streams Vector\", style={\"color\": \"#ff0000\", \"weight\": 3}\n)\nm\n</pre> m.add_shp(     \"streams.shp\", layer_name=\"Streams Vector\", style={\"color\": \"#ff0000\", \"weight\": 3} ) m In\u00a0[\u00a0]: Copied! <pre>wbt.basins(\"flow_direction.tif\", \"basins.tif\")\n</pre> wbt.basins(\"flow_direction.tif\", \"basins.tif\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"basins.tif\", layer_name=\"Basins\")\n</pre> m.add_raster(\"basins.tif\", layer_name=\"Basins\") In\u00a0[\u00a0]: Copied! <pre>wbt.longest_flowpath(\n    dem=\"breached.tif\", basins=\"basins.tif\", output=\"longest_flowpath.shp\"\n)\n</pre> wbt.longest_flowpath(     dem=\"breached.tif\", basins=\"basins.tif\", output=\"longest_flowpath.shp\" ) <p>Select only the longest flow path.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.select_largest(\n    \"longest_flowpath.shp\", column=\"LENGTH\", output=\"longest_flowpath.shp\"\n)\n</pre> leafmap.select_largest(     \"longest_flowpath.shp\", column=\"LENGTH\", output=\"longest_flowpath.shp\" ) In\u00a0[\u00a0]: Copied! <pre>m.add_shp(\n    \"longest_flowpath.shp\",\n    layer_name=\"Longest Flowpath\",\n    style={\"color\": \"#ff0000\", \"weight\": 3},\n)\nm\n</pre> m.add_shp(     \"longest_flowpath.shp\",     layer_name=\"Longest Flowpath\",     style={\"color\": \"#ff0000\", \"weight\": 3}, ) m In\u00a0[\u00a0]: Copied! <pre>if m.user_roi is not None:\n    m.save_draw_features(\"pour_point.shp\", crs=\"EPSG:3857\")\nelse:\n    coords = [-122.613559, 44.284383]\n    leafmap.coords_to_vector(coords, output=\"pour_point.shp\", crs=\"EPSG:3857\")\n</pre> if m.user_roi is not None:     m.save_draw_features(\"pour_point.shp\", crs=\"EPSG:3857\") else:     coords = [-122.613559, 44.284383]     leafmap.coords_to_vector(coords, output=\"pour_point.shp\", crs=\"EPSG:3857\") In\u00a0[\u00a0]: Copied! <pre>wbt.snap_pour_points(\n    \"pour_point.shp\", \"flow_accum.tif\", \"pour_point_snapped.shp\", snap_dist=300\n)\n</pre> wbt.snap_pour_points(     \"pour_point.shp\", \"flow_accum.tif\", \"pour_point_snapped.shp\", snap_dist=300 ) In\u00a0[\u00a0]: Copied! <pre>m.add_shp(\"pour_point_snapped.shp\", layer_name=\"Pour Point\")\n</pre> m.add_shp(\"pour_point_snapped.shp\", layer_name=\"Pour Point\") In\u00a0[\u00a0]: Copied! <pre>wbt.watershed(\"flow_direction.tif\", \"pour_point_snapped.shp\", \"watershed.tif\")\n</pre> wbt.watershed(\"flow_direction.tif\", \"pour_point_snapped.shp\", \"watershed.tif\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"watershed.tif\", layer_name=\"Watershed\")\nm\n</pre> m.add_raster(\"watershed.tif\", layer_name=\"Watershed\") m In\u00a0[\u00a0]: Copied! <pre>wbt.raster_to_vector_polygons(\"watershed.tif\", \"watershed.shp\")\n</pre> wbt.raster_to_vector_polygons(\"watershed.tif\", \"watershed.shp\") In\u00a0[\u00a0]: Copied! <pre>m.add_shp(\n    \"watershed.shp\",\n    layer_name=\"Watershed Vector\",\n    style={\"color\": \"#ffff00\", \"weight\": 3},\n)\n</pre> m.add_shp(     \"watershed.shp\",     layer_name=\"Watershed Vector\",     style={\"color\": \"#ffff00\", \"weight\": 3}, )"},{"location":"workshops/ICRW_2023/#installation","title":"Installation\u00b6","text":"<p>Uncomment and run the following cell to install necessary packages for this notebook, including leafmap, geopandas, localtileserver, rio-cogeo, pynhd, py3dep.</p>"},{"location":"workshops/ICRW_2023/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"workshops/ICRW_2023/#create-interactive-maps","title":"Create interactive maps\u00b6","text":"<p>Specify the map center, zoom level, and height.</p>"},{"location":"workshops/ICRW_2023/#add-basemaps","title":"Add basemaps\u00b6","text":"<p>Add OpenTopoMap, USGS 3DEP Elevation, and USGS Hydrography basemaps.</p>"},{"location":"workshops/ICRW_2023/#get-watershed-data","title":"Get watershed data\u00b6","text":"<p>Let's download watershed data for the Calapooia River basin in Oregon.</p>"},{"location":"workshops/ICRW_2023/#download-dem","title":"Download DEM\u00b6","text":"<p>Download a digital elevation model (DEM) for the watershed from the USGS 3DEP Elevation service. Convert the DEM to a Cloud Optimized GeoTIFF (COG).</p>"},{"location":"workshops/ICRW_2023/#get-dem-metadata","title":"Get DEM metadata\u00b6","text":""},{"location":"workshops/ICRW_2023/#add-colorbar","title":"Add colorbar\u00b6","text":""},{"location":"workshops/ICRW_2023/#initialize-whiteboxtools","title":"Initialize WhiteboxTools\u00b6","text":"<p>Initialize the WhiteboxTools class.</p>"},{"location":"workshops/ICRW_2023/#set-working-directory","title":"Set working directory\u00b6","text":""},{"location":"workshops/ICRW_2023/#smooth-dem","title":"Smooth DEM\u00b6","text":"<p>All WhiteboxTools functions will return 0 if they are successful, and 1 if they are not.</p>"},{"location":"workshops/ICRW_2023/#create-hillshade","title":"Create hillshade\u00b6","text":""},{"location":"workshops/ICRW_2023/#find-no-flow-cells","title":"Find no-flow cells\u00b6","text":"<p>Find cells with undefined flow, i.e. no valid flow direction, based on the D8 flow direction algorithm</p>"},{"location":"workshops/ICRW_2023/#fill-depressions","title":"Fill depressions\u00b6","text":""},{"location":"workshops/ICRW_2023/#delineate-flow-direction","title":"Delineate flow direction\u00b6","text":""},{"location":"workshops/ICRW_2023/#calculate-flow-accumulation","title":"Calculate flow accumulation\u00b6","text":""},{"location":"workshops/ICRW_2023/#extract-streams","title":"Extract streams\u00b6","text":""},{"location":"workshops/ICRW_2023/#calculate-distance-to-outlet","title":"Calculate distance to outlet\u00b6","text":""},{"location":"workshops/ICRW_2023/#vectorize-streams","title":"Vectorize streams\u00b6","text":""},{"location":"workshops/ICRW_2023/#delineate-basins","title":"Delineate basins\u00b6","text":""},{"location":"workshops/ICRW_2023/#delineate-the-longest-flow-path","title":"Delineate the longest flow path\u00b6","text":""},{"location":"workshops/ICRW_2023/#generate-a-pour-point","title":"Generate a pour point\u00b6","text":""},{"location":"workshops/ICRW_2023/#snap-pour-point-to-stream","title":"Snap pour point to stream\u00b6","text":""},{"location":"workshops/ICRW_2023/#delineate-watershed","title":"Delineate watershed\u00b6","text":""},{"location":"workshops/ICRW_2023/#convert-watershed-raster-to-vector","title":"Convert watershed raster to vector\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/","title":"SIGSPATIAL 2021","text":"<p>Interactive Mapping and Geospatial Analysis with Leafmap &amp; Jupyter</p> <p>This notebook was developed for the leafmap workshop taking place on November 2, 2021 at the The 3rd ACM SIGSPATIAL International Workshop on APIs and Libraries for Geospatial Data Science (SpatialAPI 2021).</p> <p>Author: Qiusheng Wu</p> <p>Launch this notebook to execute code interactively using:</p> <ul> <li>Google Colab: https://gishub.org/acm-colab</li> <li>Pangeo Binder JupyterLab: https://gishub.org/acm-binder</li> <li>Pangeo Binder Jupyter Notebook: https://gishub.org/acm-binder-nb</li> <li>Streamlit web app: https://streamlit.gishub.org</li> </ul> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport subprocess\nimport sys\n</pre> import os import subprocess import sys In\u00a0[\u00a0]: Copied! <pre>import warnings\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  warnings.filterwarnings(\"ignore\") <p>A function for installing Python packages.</p> In\u00a0[\u00a0]: Copied! <pre>def install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\n</pre> def install(package):     subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package]) <p>Install required Python packages in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>pkgs = [\n    \"leafmap\",\n    \"geopandas\",\n    \"keplergl\",\n    \"pydeck\",\n    \"xarray_leaflet\",\n    \"osmnx\",\n    \"pygeos\",\n    \"imageio\",\n    \"tifffile\",\n]\nif \"google.colab\" in sys.modules:\n    for pkg in pkgs:\n        install(pkg)\n</pre> pkgs = [     \"leafmap\",     \"geopandas\",     \"keplergl\",     \"pydeck\",     \"xarray_leaflet\",     \"osmnx\",     \"pygeos\",     \"imageio\",     \"tifffile\", ] if \"google.colab\" in sys.modules:     for pkg in pkgs:         install(pkg) In\u00a0[\u00a0]: Copied! <pre>try:\n    import leafmap\nexcept ImportError:\n    install(\"leafmap\")\n</pre> try:     import leafmap except ImportError:     install(\"leafmap\") In\u00a0[\u00a0]: Copied! <pre>import leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap  m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap.foliumap as leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap.foliumap as leafmap  m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap.kepler as leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap.kepler as leafmap  m = leafmap.Map() m <p>If you encounter an error saying <code>Error displaying widget: model not found</code> when trying to display the map, you can use <code>m.static_map()</code> as a workaround until this kepler.gl bug has been resolved.</p> In\u00a0[\u00a0]: Copied! <pre>m.static_map(width=1280, height=600)\n</pre> m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>import leafmap.deck as leafmap\n</pre> import leafmap.deck as leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=4)  # center=(lat, lon)\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=4)  # center=(lat, lon) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(51.5, -0.15), zoom=17)\nm\n</pre> m = leafmap.Map(center=(51.5, -0.15), zoom=17) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(height=\"400px\", width=\"800px\")\nm\n</pre> m = leafmap.Map(height=\"400px\", width=\"800px\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    draw_control=False,\n    measure_control=False,\n    fullscreen_control=False,\n    attribution_control=False,\n)\nm\n</pre> m = leafmap.Map(     draw_control=False,     measure_control=False,     fullscreen_control=False,     attribution_control=False, ) m <p>Remove all controls from the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.clear_controls()\nm\n</pre> m = leafmap.Map() m.clear_controls() m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN\nm\n</pre> m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN m <p>Add a basemap using the <code>add_basemap()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Esri.NatGeoWorldMap\") m <p>Print out the list of available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>for basemap in leafmap.basemaps:\n    print(basemap)\n</pre> for basemap in leafmap.basemaps:     print(basemap) <p></p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nnaip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True\n)\nm\n</pre> m = leafmap.Map() naip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\" m.add_wms_layer(     url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True ) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport xyzservices.providers as xyz\n</pre> import leafmap import xyzservices.providers as xyz In\u00a0[\u00a0]: Copied! <pre>basemap = xyz.OpenTopoMap\nbasemap\n</pre> basemap = xyz.OpenTopoMap basemap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(basemap)\nm\n</pre> m = leafmap.Map() m.add_basemap(basemap) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm.add_cog_layer(url2, name=\"Fire (post-event)\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"  m.add_cog_layer(url, name=\"Fire (pre-event)\") m.add_cog_layer(url2, name=\"Fire (post-event)\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Download samples raster datasets</p> <p>More datasets can be downloaded from https://viewer.nationalmap.gov/basic/</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\n\nlandsat = os.path.join(out_dir, \"landsat.tif\")\ndem = os.path.join(out_dir, \"dem.tif\")\n</pre> out_dir = os.getcwd()  landsat = os.path.join(out_dir, \"landsat.tif\") dem = os.path.join(out_dir, \"dem.tif\") <p>Download a small Landsat imagery.</p> In\u00a0[\u00a0]: Copied! <pre>landsat_url = (\n    \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\"\n)\nleafmap.download_file(landsat_url, \"landsat.tif\", unzip=False)\n</pre> landsat_url = (     \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\" ) leafmap.download_file(landsat_url, \"landsat.tif\", unzip=False) <p>Download a small DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>dem_url = (\n    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n)\nleafmap.download_file(dem_url, \"dem.tif\", unzip=False)\n</pre> dem_url = (     \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" ) leafmap.download_file(dem_url, \"dem.tif\", unzip=False) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add local raster datasets to the map</p> <p>More colormap can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\n</pre> m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\")\n</pre> m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\") In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>List all available built-in legends.</p> In\u00a0[\u00a0]: Copied! <pre>legends = leafmap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = leafmap.builtin_legends for legend in legends:     print(legend) <p>Add a WMS layer and built-in legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\") m <p>Add U.S. National Wetlands Inventory (NWI). More info at https://www.fws.gov/wetlands.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"HYBRID\")\n\nurl1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\"\nm.add_wms_layer(\n    url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\"\n)\n\nurl2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\"\n)\n\nm.add_legend(builtin_legend=\"NWI\")\nm\n</pre> m = leafmap.Map(google_map=\"HYBRID\")  url1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\" m.add_wms_layer(     url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\" )  url2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\" m.add_wms_layer(     url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\" )  m.add_legend(builtin_legend=\"NWI\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nlabels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n# color can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]\n\nm.add_legend(title=\"Legend\", labels=labels, colors=colors)\nm\n</pre> m = leafmap.Map()  labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"] # color can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"] # colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]  m.add_legend(title=\"Legend\", labels=labels, colors=colors) m <p>Define a legend dictionary.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nm.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nm\n</pre> m = leafmap.Map()  url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, )  legend_dict = {     \"11 Open Water\": \"466b9f\",     \"12 Perennial Ice/Snow\": \"d1def8\",     \"21 Developed, Open Space\": \"dec5c5\",     \"22 Developed, Low Intensity\": \"d99282\",     \"23 Developed, Medium Intensity\": \"eb0000\",     \"24 Developed High Intensity\": \"ab0000\",     \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",     \"41 Deciduous Forest\": \"68ab5f\",     \"42 Evergreen Forest\": \"1c5f2c\",     \"43 Mixed Forest\": \"b5c58f\",     \"51 Dwarf Scrub\": \"af963c\",     \"52 Shrub/Scrub\": \"ccb879\",     \"71 Grassland/Herbaceous\": \"dfdfc2\",     \"72 Sedge/Herbaceous\": \"d1d182\",     \"73 Lichens\": \"a3cc51\",     \"74 Moss\": \"82ba9e\",     \"81 Pasture/Hay\": \"dcd939\",     \"82 Cultivated Crops\": \"ab6c28\",     \"90 Woody Wetlands\": \"b8d9eb\",     \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\", }  m.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport leafmap.colormaps as cm\n</pre> import leafmap import leafmap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>cm.palettes.dem\n</pre> cm.palettes.dem <p>Show the DEM palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.dem, axis_off=True)\n</pre> cm.plot_colormap(colors=cm.palettes.dem, axis_off=True) <p>Color palette for NDVI data.</p> In\u00a0[\u00a0]: Copied! <pre>cm.palettes.ndvi\n</pre> cm.palettes.ndvi <p>Show the NDVI palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.ndvi)\n</pre> cm.plot_colormap(colors=cm.palettes.ndvi) In\u00a0[\u00a0]: Copied! <pre>cm.get_palette(\"terrain\", n_class=8)\n</pre> cm.get_palette(\"terrain\", n_class=8) <p>Show the terrain palette with 8 classes.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8))\n</pre> cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8)) <p>Create a palette with custom colors, label, and font size.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12)\n</pre> cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12) <p>Create a discrete color palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12\n)\n</pre> cm.plot_colormap(     colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12 ) <p>Specify the width and height for the palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=1000, ) <p>Change the orentation of the colormap to be vertical.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=1000, ) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormaps(width=12, height=0.4)\n</pre> cm.plot_colormaps(width=12, height=0.4) In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\"\ndf = leafmap.csv_to_df(in_csv)\ndf\n</pre> in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\" df = leafmap.csv_to_df(in_csv) df <p>Create a point layer from a CSV file containing lat/long information.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\")\nm\n</pre> m = leafmap.Map() m.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\") m <p>Set the output directory.</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\nout_shp = os.path.join(out_dir, \"world_cities.shp\")\n</pre> out_dir = os.getcwd() out_shp = os.path.join(out_dir, \"world_cities.shp\") <p>Convert a CSV file containing lat/long information to a shapefile.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.csv_to_shp(in_csv, out_shp)\n</pre> leafmap.csv_to_shp(in_csv, out_shp) <p>Convert a CSV file containing lat/long information to a GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>out_geojson = os.path.join(out_dir, \"world_cities.geojson\")\nleafmap.csv_to_geojson(in_csv, out_geojson)\n</pre> out_geojson = os.path.join(out_dir, \"world_cities.geojson\") leafmap.csv_to_geojson(in_csv, out_geojson) <p>Convert a CSV file containing lat/long information to a GeoPandas GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.csv_to_gdf(in_csv)\ngdf\n</pre> gdf = leafmap.csv_to_gdf(in_csv) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\") m <p>Add a GeoJSON with random filled color to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, layer_name=\"Countries\") m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\nm\n</pre> m = leafmap.Map() in_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\" m.add_kml(in_kml, layer_name=\"US States KML\") m In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\ngdf = gpd.read_file(\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\n)\nm.add_gdf(gdf, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map() gdf = gpd.read_file(     \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" ) m.add_gdf(gdf, layer_name=\"Cable lines\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Add a point layer programmatically.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\"\nm.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\")\nm\n</pre> m = leafmap.Map() url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\" m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_vector(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_vector(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\") m <p>Show OSM feature tags. https://wiki.openstreetmap.org/wiki/Map_features</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.osm_tags_list()\n</pre> # leafmap.osm_tags_list() In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\",\n    tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},\n    dist=1000,\n    layer_name=\"NYC buildings\",\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\",     tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},     dist=1000,     layer_name=\"NYC buildings\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nnorth, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965\nm.add_osm_from_bbox(\n    north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) north, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965 m.add_osm_from_bbox(     north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(46.7808, -96.0156),\n    tags={\"natural\": \"water\"},\n    dist=10000,\n    layer_name=\"Lakes\",\n)\nm\n</pre> m = leafmap.Map(     center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(46.7808, -96.0156),     tags={\"natural\": \"water\"},     dist=10000,     layer_name=\"Lakes\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(39.9170, 116.3908),\n    tags={\"building\": True, \"natural\": \"water\"},\n    dist=1000,\n    layer_name=\"Beijing\",\n)\nm\n</pre> m = leafmap.Map(     center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(39.9170, 116.3908),     tags={\"building\": True, \"natural\": \"water\"},     dist=1000,     layer_name=\"Beijing\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.set_center(-73.9854, 40.7500, 16)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.set_center(-73.9854, 40.7500, 16) m In\u00a0[\u00a0]: Copied! <pre>m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n</pre> m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\") <p>Create a GeoPandas GeoDataFrame from place.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"})\ngdf\n</pre> gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"}) gdf In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nimport urllib.request\n</pre> import os import leafmap import urllib.request <p>Download a sample DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\"\n</pre> url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\" In\u00a0[\u00a0]: Copied! <pre>urllib.request.urlretrieve(url, \"dem.tif\")\n</pre> urllib.request.urlretrieve(url, \"dem.tif\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Display the toolbox using the default mode.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui()\n</pre> leafmap.whiteboxgui() <p>Display the toolbox using the collapsible tree mode. Note that the tree mode does not support Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui(tree=True)\n</pre> leafmap.whiteboxgui(tree=True) <p>Perform geospatial analysis using the whitebox package.</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport whitebox\n</pre> import os import whitebox In\u00a0[\u00a0]: Copied! <pre>wbt = whitebox.WhiteboxTools()\nwbt.verbose = False\n</pre> wbt = whitebox.WhiteboxTools() wbt.verbose = False In\u00a0[\u00a0]: Copied! <pre>data_dir = os.getcwd()\nwbt.set_working_dir(data_dir)\n</pre> data_dir = os.getcwd() wbt.set_working_dir(data_dir) In\u00a0[\u00a0]: Copied! <pre>wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9)\nwbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")\nwbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\")\n</pre> wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9) wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\") wbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\") In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport imageio\n\n%matplotlib inline\n</pre> import matplotlib.pyplot as plt import imageio  %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>original = imageio.imread(os.path.join(data_dir, \"dem.tif\"))\nsmoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\"))\nbreached = imageio.imread(os.path.join(data_dir, \"breached.tif\"))\nflow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\"))\n</pre> original = imageio.imread(os.path.join(data_dir, \"dem.tif\")) smoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\")) breached = imageio.imread(os.path.join(data_dir, \"breached.tif\")) flow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\")) In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(16, 11))\n\nax1 = fig.add_subplot(2, 2, 1)\nax1.set_title(\"Original DEM\")\nplt.imshow(original)\n\nax2 = fig.add_subplot(2, 2, 2)\nax2.set_title(\"Smoothed DEM\")\nplt.imshow(smoothed)\n\nax3 = fig.add_subplot(2, 2, 3)\nax3.set_title(\"Breached DEM\")\nplt.imshow(breached)\n\nax4 = fig.add_subplot(2, 2, 4)\nax4.set_title(\"Flow Accumulation\")\nplt.imshow(flow_accum)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16, 11))  ax1 = fig.add_subplot(2, 2, 1) ax1.set_title(\"Original DEM\") plt.imshow(original)  ax2 = fig.add_subplot(2, 2, 2) ax2.set_title(\"Smoothed DEM\") plt.imshow(smoothed)  ax3 = fig.add_subplot(2, 2, 3) ax3.set_title(\"Breached DEM\") plt.imshow(breached)  ax4 = fig.add_subplot(2, 2, 4) ax4.set_title(\"Flow Accumulation\") plt.imshow(flow_accum)  plt.show() In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>leafmap.basemaps.keys()\n</pre> leafmap.basemaps.keys() In\u00a0[\u00a0]: Copied! <pre>layers = [\"ROADMAP\", \"HYBRID\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"ROADMAP\", \"HYBRID\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) In\u00a0[\u00a0]: Copied! <pre>layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) <p>Create a 2 * 2 linked map to visualize land cover change. Specify the <code>center</code> and <code>zoom</code> parameters to change the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]]\nlabels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]]\nleafmap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    layers=layers,\n    labels=labels,\n    center=[36.1, -115.2],\n    zoom=9,\n)\n</pre> layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]] labels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]] leafmap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     layers=layers,     labels=labels,     center=[36.1, -115.2],     zoom=9, ) In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\")\n</pre> leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\") <p>Hide the zoom control from the map.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(\n    left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False\n)\n</pre> leafmap.split_map(     left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False )"},{"location":"workshops/SIGSPATIAL_2021/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#workshop-description","title":"Workshop description\u00b6","text":"<p>Leafmap is a Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment. It is built upon a number of open-source packages, such as folium and ipyleaflet (for creating interactive maps), WhiteboxTools and whiteboxgui (for analyzing geospatial data), and ipywidgets (for designing interactive graphical user interface). The WhiteboxTools library currently contains 480+ tools for advanced geospatial analysis. Leafmap provides many convenient functions for loading and visualizing geospatial data with only one line of code. Users can also use the interactive user interface to load geospatial data without coding. Anyone with a web browser and Internet connection can use leafmap to perform geospatial analysis and data visualization in the cloud with minimal coding. The topics that will be covered in this workshop include:</p> <ol> <li>A brief introduction to leafmap and relevant web resources</li> <li>Creating interactive maps using multiple plotting backends</li> <li>Changing basemaps</li> <li>Loading and visualizing vector/raster data</li> <li>Using Cloud Optimized GeoTIFF (COG) and SpatialTemporal Asset Catalog (STAC)</li> <li>Downloading OpenStreetMap data</li> <li>Creating custom legends and colorbars</li> <li>Creating split-panel maps and linked maps</li> <li>Performing geospatial analysis using whiteboxgui.</li> <li>Discussion and Q&amp;A</li> </ol> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required. More information about leafmap can be found at https://leafmap.org.</p>"},{"location":"workshops/SIGSPATIAL_2021/#jupyter-keyboard-shortcuts","title":"Jupyter keyboard shortcuts\u00b6","text":"<ul> <li>Shift+Enter: run cell, select below</li> <li>Ctrl+Enter: : run selected cells</li> <li>Alt+Enter: run cell and insert below</li> <li>Tab: code completion or indent</li> <li>Shift+Tab: tooltip</li> <li>Ctrl+/: comment out code</li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#set-up-environment","title":"Set up environment\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#required-python-packages","title":"Required Python packages:\u00b6","text":"<ul> <li>leafmap - A Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment</li> <li>keplergl - A high-performance web-based application for visual exploration of large-scale geolocation data sets</li> <li>pydeck - High-scale spatial rendering in Python, powered by deck.gl.</li> <li>geopandas - An open source project to make working with geospatial data in python easier.</li> <li>xarray-leaflet - An xarray extension for tiled map plotting.</li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#use-google-colab","title":"Use Google Colab\u00b6","text":"<p>Click the button below to open this notebook in Google Colab and execute code interactively.</p> <p> </p>"},{"location":"workshops/SIGSPATIAL_2021/#use-pangeo-binder","title":"Use Pangeo Binder\u00b6","text":"<p>Click the buttons below to open this notebook in JupyterLab (first button) or Jupyter Notebook (second button) and execute code interactively.</p> <p> </p> <ul> <li>JupyterLab: https://gishub.org/acm-binder</li> <li>Jupyter Notebook: https://gishub.org/acm-binder-nb</li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#use-minicondaanaconda","title":"Use Miniconda/Anaconda\u00b6","text":"<p>If you have Anaconda or Miniconda installed on your computer, you can install leafmap using the following commands. Leafmap has an optional dependency - geopandas, which can be challenging to install on some computers, especially Windows. It is highly recommended that you create a fresh conda environment to install geopandas and leafmap. Follow the commands below to set up a conda env and install geopandas, leafmap, keplergl, and xarray_leaflet.</p> <pre><code>conda create -n geo python=3.8\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap keplergl pydeck xarray_leaflet -c conda-forge\nmamba install osmnx pygeos imageio tifffile -c conda-forge\njupyter lab\n</code></pre>"},{"location":"workshops/SIGSPATIAL_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p><code>Leafmap</code> has five plotting backends: folium, ipyleaflet, here-map, kepler.gl, and pydeck. Note that the backends do not offer equal functionality. Some interactive functionality in <code>ipyleaflet</code> might not be available in other plotting backends. To use a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> <li><code>import leafmap.kepler as leafmap</code></li> <li><code>import leafmap.deck as leafmap</code></li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#use-ipyleaflet","title":"Use ipyleaflet\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#use-folium","title":"Use folium\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#use-keplergl","title":"Use kepler.gl\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#use-pydeck","title":"Use pydeck\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#customize-the-default-map","title":"Customize the default map\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#specify-map-center-and-zoom-level","title":"Specify map center and zoom level\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#change-map-size","title":"Change map size\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#set-control-visibility","title":"Set control visibility\u00b6","text":"<p>When creating a map, set the following controls to either <code>True</code> or <code>False</code> as appropriate.</p> <ul> <li>attribution_control</li> <li>draw_control</li> <li>fullscreen_control</li> <li>layers_control</li> <li>measure_control</li> <li>scale_control</li> <li>toolbar_control</li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#change-basemaps","title":"Change basemaps\u00b6","text":"<p>Specify a Google basemap to use, can be one of [\"ROADMAP\", \"TERRAIN\", \"SATELLITE\", \"HYBRID\"].</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-wms-tile-layer","title":"Add WMS tile layer\u00b6","text":"<p>More WMS basemaps can be found at the following websites:</p> <ul> <li>USGS National Map: https://viewer.nationalmap.gov/services</li> <li>MRLC NLCD Land Cover data: https://www.mrlc.gov/data-services-page</li> <li>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</li> </ul>"},{"location":"workshops/SIGSPATIAL_2021/#add-xyzservices-provider","title":"Add xyzservices provider\u00b6","text":"<p>Add a layer from xyzservices provider object.</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-cogstac-layers","title":"Add COG/STAC layers\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> <li>https://www.digitalglobe.com/ecosystem/open-data</li> <li>https://earthexplorer.usgs.gov/</li> </ul> <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A list of COGs can be found here.</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-cog-layer","title":"Add COG layer\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-stac-layer","title":"Add STAC layer\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc. More information about STAC can be found at https://stacspec.org/</p> <p>Some publicly available SpatioTemporal Asset Catalog (STAC):</p> <ul> <li>https://stacindex.org</li> </ul> <p>For this demo, we will use STAC assets from https://stacindex.org/catalogs/spot-orthoimages-canada-2005#/?t=catalogs</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-local-raster-datasets","title":"Add local raster datasets\u00b6","text":"<p>The <code>add_raster</code> function relies on the <code>xarray_leaflet</code> package and is only available for the ipyleaflet plotting backend. Therefore, Google Colab is not supported. Note that <code>xarray_leaflet</code> does not work properly on Windows (source).</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-legend","title":"Add legend\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-built-in-legend","title":"Add built-in legend\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-custom-legend","title":"Add custom legend\u00b6","text":"<p>There are two ways you can add custom legends:</p> <ol> <li>Define legend labels and colors</li> <li>Define legend dictionary</li> </ol> <p>Define legend keys and colors</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-colormap","title":"Add colormap\u00b6","text":"<p>The colormap functionality requires the ipyleaflet plotting backend. Folium is not supported.</p>"},{"location":"workshops/SIGSPATIAL_2021/#common-colormaps","title":"Common colormaps\u00b6","text":"<p>Color palette for DEM data.</p>"},{"location":"workshops/SIGSPATIAL_2021/#custom-colormaps","title":"Custom colormaps\u00b6","text":"<p>Specify the number of classes for a palette.</p>"},{"location":"workshops/SIGSPATIAL_2021/#horizontal-colormap","title":"Horizontal colormap\u00b6","text":"<p>Add a horizontal colorbar to an interactive map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#vertical-colormap","title":"Vertical colormap\u00b6","text":"<p>Add a vertical colorbar to an interactive map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#list-of-available-colormaps","title":"List of available colormaps\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-vector-datasets","title":"Add vector datasets\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-csv","title":"Add CSV\u00b6","text":"<p>Read a CSV as a Pandas DataFrame.</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-geojson","title":"Add GeoJSON\u00b6","text":"<p>Add a GeoJSON to the map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#add-shapefile","title":"Add shapefile\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-kml","title":"Add KML\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-geodataframe","title":"Add GeoDataFrame\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#add-point-layer","title":"Add point layer\u00b6","text":"<p>Add a point layer using the interactive GUI.</p> <p></p>"},{"location":"workshops/SIGSPATIAL_2021/#add-vector","title":"Add vector\u00b6","text":"<p>The <code>add_vector</code> function supports any vector data format supported by GeoPandas.</p>"},{"location":"workshops/SIGSPATIAL_2021/#download-osm-data","title":"Download OSM data\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#osm-from-geocode","title":"OSM from geocode\u00b6","text":"<p>Add OSM data of place(s) by name or ID to the map. Note that the leafmap custom layer control does not support GeoJSON, we need to use the ipyleaflet built-in layer control.</p>"},{"location":"workshops/SIGSPATIAL_2021/#osm-from-place","title":"OSM from place\u00b6","text":"<p>Add OSM entities within boundaries of geocodable place(s) to the map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#osm-from-address","title":"OSM from address\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#osm-from-bbox","title":"OSM from bbox\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#osm-from-point","title":"OSM from point\u00b6","text":"<p>Add OSM entities within some distance N, S, E, W of a point to the map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#osm-from-view","title":"OSM from view\u00b6","text":"<p>Add OSM entities within the current map view to the map.</p>"},{"location":"workshops/SIGSPATIAL_2021/#use-whiteboxtools","title":"Use WhiteboxTools\u00b6","text":"<p>Use the built-in toolbox to perform geospatial analysis. For example, you can perform depression filling using the sample DEM dataset downloaded in the above step.</p> <p></p>"},{"location":"workshops/SIGSPATIAL_2021/#create-linked-map","title":"Create linked map\u00b6","text":""},{"location":"workshops/SIGSPATIAL_2021/#create-split-panel-map","title":"Create split-panel map\u00b6","text":"<p>Create a split-panel map by specifying the <code>left_layer</code> and <code>right_layer</code>, which can be chosen from the basemap names, or any custom XYZ tile layer.</p>"},{"location":"workshops/YouthMappers_2021/","title":"YouthMappers 2021","text":"<p>Interactive Mapping and Geospatial Analysis with Leafmap and Jupyter</p> <p>This notebook was developed for the 90-min leafmap workshop taking place on November 9, 2021. The workshop is hosted by YouthMappers.</p> <ul> <li>Author: Qiusheng Wu</li> <li>Slides: https://gishub.org/ym</li> <li>Streamlit web app: https://streamlit.gishub.org</li> </ul> <p>Launch this notebook to execute code interactively using:</p> <ul> <li>Google Colab: https://gishub.org/ym-colab</li> <li>Pangeo Binder JupyterLab: https://gishub.org/ym-binder</li> <li>Pangeo Binder Jupyter Notebook: https://gishub.org/ym-binder-nb</li> </ul> In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>import os\nimport subprocess\nimport sys\n</pre> import os import subprocess import sys In\u00a0[\u00a0]: Copied! <pre>import warnings\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  warnings.filterwarnings(\"ignore\") <p>A function for installing Python packages.</p> In\u00a0[\u00a0]: Copied! <pre>def install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\n</pre> def install(package):     subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package]) <p>Install required Python packages in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>pkgs = [\n    \"leafmap\",\n    \"geopandas\",\n    \"keplergl\",\n    \"pydeck\",\n    \"xarray_leaflet\",\n    \"osmnx\",\n    \"pygeos\",\n    \"imageio\",\n    \"tifffile\",\n]\nif \"google.colab\" in sys.modules:\n    for pkg in pkgs:\n        install(pkg)\n</pre> pkgs = [     \"leafmap\",     \"geopandas\",     \"keplergl\",     \"pydeck\",     \"xarray_leaflet\",     \"osmnx\",     \"pygeos\",     \"imageio\",     \"tifffile\", ] if \"google.colab\" in sys.modules:     for pkg in pkgs:         install(pkg) In\u00a0[\u00a0]: Copied! <pre>try:\n    import leafmap\nexcept ImportError:\n    install(\"leafmap\")\n</pre> try:     import leafmap except ImportError:     install(\"leafmap\") In\u00a0[\u00a0]: Copied! <pre>import leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap  m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap.foliumap as leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap.foliumap as leafmap  m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap.kepler as leafmap\n\nm = leafmap.Map()\nm\n</pre> import leafmap.kepler as leafmap  m = leafmap.Map() m <p>If you encounter an error saying <code>Error displaying widget: model not found</code> when trying to display the map, you can use <code>m.static_map()</code> as a workaround until this kepler.gl bug has been resolved.</p> In\u00a0[\u00a0]: Copied! <pre># m.static_map(width=1280, height=600)\n</pre> # m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>import leafmap.deck as leafmap\n</pre> import leafmap.deck as leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(40, -100), zoom=4)  # center=[lat, lon]\nm\n</pre> m = leafmap.Map(center=(40, -100), zoom=4)  # center=[lat, lon] m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=(51.5, -0.15), zoom=17)\nm\n</pre> m = leafmap.Map(center=(51.5, -0.15), zoom=17) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(height=\"400px\", width=\"800px\")\nm\n</pre> m = leafmap.Map(height=\"400px\", width=\"800px\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    draw_control=False,\n    measure_control=False,\n    fullscreen_control=False,\n    attribution_control=False,\n)\nm\n</pre> m = leafmap.Map(     draw_control=False,     measure_control=False,     fullscreen_control=False,     attribution_control=False, ) m <p>Remove all controls from the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.clear_controls()\nm\n</pre> m = leafmap.Map() m.clear_controls() m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN\nm\n</pre> m = leafmap.Map(google_map=\"TERRAIN\")  # HYBRID, ROADMAP, SATELLITE, TERRAIN m <p>Add a basemap using the <code>add_basemap()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Esri.NatGeoWorldMap\") m <p>Print out the list of available basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>for basemap in leafmap.basemaps:\n    print(basemap)\n</pre> for basemap in leafmap.basemaps:     print(basemap) <p></p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Satellite\",\n    attribution=\"Google\",\n)\nm\n</pre> m = leafmap.Map() m.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Satellite\",     attribution=\"Google\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nnaip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True\n)\nm\n</pre> m = leafmap.Map() naip_url = \"https://services.nationalmap.gov/arcgis/services/USGSNAIPImagery/ImageServer/WMSServer?\" m.add_wms_layer(     url=naip_url, layers=\"0\", name=\"NAIP Imagery\", format=\"image/png\", shown=True ) m In\u00a0[\u00a0]: Copied! <pre>import os\nimport xyzservices.providers as xyz\n</pre> import os import xyzservices.providers as xyz In\u00a0[\u00a0]: Copied! <pre>basemap = xyz.OpenTopoMap\nbasemap\n</pre> basemap = xyz.OpenTopoMap basemap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(basemap)\nm\n</pre> m = leafmap.Map() m.add_basemap(basemap) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\nurl2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"\n\nm.add_cog_layer(url, name=\"Fire (pre-event)\")\nm.add_cog_layer(url2, name=\"Fire (post-event)\")\nm\n</pre> m = leafmap.Map() url = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" url2 = \"https://github.com/opengeos/data/releases/download/raster/Libya-2023-09-13.tif\"  m.add_cog_layer(url, name=\"Fire (pre-event)\") m.add_cog_layer(url2, name=\"Fire (post-event)\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\"\nm.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\")\nm\n</pre> m = leafmap.Map() url = \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json\" m.add_stac_layer(url, bands=[\"B3\", \"B2\", \"B1\"], name=\"False color\") m In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap <p>Download samples raster datasets. More datasets can be downloaded from https://viewer.nationalmap.gov/basic/</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\n\nlandsat = os.path.join(out_dir, \"landsat.tif\")\ndem = os.path.join(out_dir, \"dem.tif\")\n</pre> out_dir = os.getcwd()  landsat = os.path.join(out_dir, \"landsat.tif\") dem = os.path.join(out_dir, \"dem.tif\") <p>Download a small Landsat imagery.</p> In\u00a0[\u00a0]: Copied! <pre>landsat_url = (\n    \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\"\n)\nleafmap.download_file(landsat_url, \"landsat.tif\", unzip=False)\n</pre> landsat_url = (     \"https://drive.google.com/file/d/1EV38RjNxdwEozjc9m0FcO3LFgAoAX1Uw/view?usp=sharing\" ) leafmap.download_file(landsat_url, \"landsat.tif\", unzip=False) <p>Download a small DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>dem_url = (\n    \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\"\n)\nleafmap.download_file(dem_url, \"dem.tif\", unzip=False)\n</pre> dem_url = (     \"https://drive.google.com/file/d/1vRkAWQYsLWCi6vcTMk8vLxoXMFbdMFn8/view?usp=sharing\" ) leafmap.download_file(dem_url, \"dem.tif\", unzip=False) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n</pre> m = leafmap.Map() <p>Add local raster datasets to the map</p> <p>More colormap can be found at https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\")\n</pre> m.add_raster(dem, colormap=\"terrain\", layer_name=\"DEM\") In\u00a0[\u00a0]: Copied! <pre>m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\")\n</pre> m.add_raster(landsat, bands=[5, 4, 3], layer_name=\"Landsat\") In\u00a0[\u00a0]: Copied! <pre>m\n</pre> m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap <p>List all available built-in legends.</p> In\u00a0[\u00a0]: Copied! <pre>legends = leafmap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = leafmap.builtin_legends for legend in legends:     print(legend) <p>Add a WMS layer and built-in legend to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\nm.add_legend(builtin_legend=\"NLCD\")\nm\n</pre> m = leafmap.Map() url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, ) m.add_legend(builtin_legend=\"NLCD\") m <p>Add U.S. National Wetlands Inventory (NWI). More info at https://www.fws.gov/wetlands.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(google_map=\"HYBRID\")\n\nurl1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\"\nm.add_wms_layer(\n    url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\"\n)\n\nurl2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\"\nm.add_wms_layer(\n    url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\"\n)\n\nm.add_legend(builtin_legend=\"NWI\")\nm\n</pre> m = leafmap.Map(google_map=\"HYBRID\")  url1 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands/MapServer/WMSServer?\" m.add_wms_layer(     url1, layers=\"1\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Vector\" )  url2 = \"https://www.fws.gov/wetlands/arcgis/services/Wetlands_Raster/ImageServer/WMSServer?\" m.add_wms_layer(     url2, layers=\"0\", format=\"image/png\", transparent=True, name=\"NWI Wetlands Raster\" )  m.add_legend(builtin_legend=\"NWI\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nlabels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n# color can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]\n\nm.add_legend(title=\"Legend\", labels=labels, colors=colors)\nm\n</pre> m = leafmap.Map()  labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"] # color can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"] # colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68, 123)]  m.add_legend(title=\"Legend\", labels=labels, colors=colors) m <p>Define a legend dictionary.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\n\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nm.add_wms_layer(\n    url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019 CONUS Land Cover\",\n    format=\"image/png\",\n    transparent=True,\n)\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nm.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nm\n</pre> m = leafmap.Map()  url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" m.add_wms_layer(     url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019 CONUS Land Cover\",     format=\"image/png\",     transparent=True, )  legend_dict = {     \"11 Open Water\": \"466b9f\",     \"12 Perennial Ice/Snow\": \"d1def8\",     \"21 Developed, Open Space\": \"dec5c5\",     \"22 Developed, Low Intensity\": \"d99282\",     \"23 Developed, Medium Intensity\": \"eb0000\",     \"24 Developed High Intensity\": \"ab0000\",     \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",     \"41 Deciduous Forest\": \"68ab5f\",     \"42 Evergreen Forest\": \"1c5f2c\",     \"43 Mixed Forest\": \"b5c58f\",     \"51 Dwarf Scrub\": \"af963c\",     \"52 Shrub/Scrub\": \"ccb879\",     \"71 Grassland/Herbaceous\": \"dfdfc2\",     \"72 Sedge/Herbaceous\": \"d1d182\",     \"73 Lichens\": \"a3cc51\",     \"74 Moss\": \"82ba9e\",     \"81 Pasture/Hay\": \"dcd939\",     \"82 Cultivated Crops\": \"ab6c28\",     \"90 Woody Wetlands\": \"b8d9eb\",     \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\", }  m.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\nimport leafmap.colormaps as cm\n</pre> import leafmap import leafmap.colormaps as cm In\u00a0[\u00a0]: Copied! <pre>cm.palettes.dem\n</pre> cm.palettes.dem <p>Show the DEM palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.dem, axis_off=True)\n</pre> cm.plot_colormap(colors=cm.palettes.dem, axis_off=True) <p>Color palette for NDVI data.</p> In\u00a0[\u00a0]: Copied! <pre>cm.palettes.ndvi\n</pre> cm.palettes.ndvi <p>Show the NDVI palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.palettes.ndvi)\n</pre> cm.plot_colormap(colors=cm.palettes.ndvi) In\u00a0[\u00a0]: Copied! <pre>cm.get_palette(\"terrain\", n_class=8)\n</pre> cm.get_palette(\"terrain\", n_class=8) <p>Show the terrain palette with 8 classes.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8))\n</pre> cm.plot_colormap(colors=cm.get_palette(\"terrain\", n_class=8)) <p>Create a palette with custom colors, label, and font size.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12)\n</pre> cm.plot_colormap(colors=[\"red\", \"green\", \"blue\"], label=\"Temperature\", font_size=12) <p>Create a discrete color palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12\n)\n</pre> cm.plot_colormap(     colors=[\"red\", \"green\", \"blue\"], discrete=True, label=\"Temperature\", font_size=12 ) <p>Specify the width and height for the palette.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=1000, ) <p>Change the orentation of the colormap to be vertical.</p> In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=1000,\n)\n</pre> cm.plot_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=1000, ) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=8.0,\n    height=0.4,\n    orientation=\"horizontal\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=8.0,     height=0.4,     orientation=\"horizontal\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"OpenTopoMap\")\nm.add_colormap(\n    \"terrain\",\n    label=\"Elevation\",\n    width=0.4,\n    height=4,\n    orientation=\"vertical\",\n    vmin=0,\n    vmax=4000,\n)\nm\n</pre> m = leafmap.Map() m.add_basemap(\"OpenTopoMap\") m.add_colormap(     \"terrain\",     label=\"Elevation\",     width=0.4,     height=4,     orientation=\"vertical\",     vmin=0,     vmax=4000, ) m In\u00a0[\u00a0]: Copied! <pre>cm.plot_colormaps(width=12, height=0.4)\n</pre> cm.plot_colormaps(width=12, height=0.4) In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\"\ndf = leafmap.csv_to_df(in_csv)\ndf\n</pre> in_csv = \"https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\" df = leafmap.csv_to_df(in_csv) df <p>Create a point layer from a CSV file containing lat/long information.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\")\nm\n</pre> m = leafmap.Map() m.add_xy_data(in_csv, x=\"longitude\", y=\"latitude\", layer_name=\"World Cities\") m <p>Set the output directory.</p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.getcwd()\nout_shp = os.path.join(out_dir, \"world_cities.shp\")\n</pre> out_dir = os.getcwd() out_shp = os.path.join(out_dir, \"world_cities.shp\") <p>Convert a CSV file containing lat/long information to a shapefile.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.csv_to_shp(in_csv, out_shp)\n</pre> leafmap.csv_to_shp(in_csv, out_shp) <p>Convert a CSV file containing lat/long information to a GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>out_geojson = os.path.join(out_dir, \"world_cities.geojson\")\nleafmap.csv_to_geojson(in_csv, out_geojson)\n</pre> out_geojson = os.path.join(out_dir, \"world_cities.geojson\") leafmap.csv_to_geojson(in_csv, out_geojson) <p>Convert a CSV file containing lat/long information to a GeoPandas GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.csv_to_gdf(in_csv)\ngdf\n</pre> gdf = leafmap.csv_to_gdf(in_csv) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\"\nm.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_geojson = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/cable_geo.geojson\" m.add_geojson(in_geojson, layer_name=\"Cable lines\", info_mode=\"on_hover\") m <p>Add a GeoJSON with random filled color to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_geojson(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_geojson(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m <p>Use the <code>style_callback</code> function for assigning a random color to each polygon.</p> In\u00a0[\u00a0]: Copied! <pre>import random\n\nm = leafmap.Map(center=[0, 0], zoom=2)\n\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\n\n\ndef random_color(feature):\n    return {\n        \"color\": \"black\",\n        \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),\n    }\n\n\nm.add_geojson(url, layer_name=\"Countries\", style_callback=random_color)\nm\n</pre> import random  m = leafmap.Map(center=[0, 0], zoom=2)  url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"   def random_color(feature):     return {         \"color\": \"black\",         \"fillColor\": random.choice([\"red\", \"yellow\", \"green\", \"orange\"]),     }   m.add_geojson(url, layer_name=\"Countries\", style_callback=random_color) m <p>Use custom <code>style</code> and <code>hover_style</code> functions.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nstyle = {\n    \"stroke\": True,\n    \"color\": \"#0000ff\",\n    \"weight\": 2,\n    \"opacity\": 1,\n    \"fill\": True,\n    \"fillColor\": \"#0000ff\",\n    \"fillOpacity\": 0.1,\n}\nhover_style = {\"fillOpacity\": 0.7}\nm.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" style = {     \"stroke\": True,     \"color\": \"#0000ff\",     \"weight\": 2,     \"opacity\": 1,     \"fill\": True,     \"fillColor\": \"#0000ff\",     \"fillOpacity\": 0.1, } hover_style = {\"fillOpacity\": 0.7} m.add_geojson(url, layer_name=\"Countries\", style=style, hover_style=hover_style) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, layer_name=\"Countries\") m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nin_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\"\nm.add_kml(in_kml, layer_name=\"US States KML\")\nm\n</pre> m = leafmap.Map() in_kml = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.kml\" m.add_kml(in_kml, layer_name=\"US States KML\") m In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\ngdf = gpd.read_file(\n    \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\"\n)\nm.add_gdf(gdf, layer_name=\"Cable lines\")\nm\n</pre> m = leafmap.Map() gdf = gpd.read_file(     \"https://github.com/opengeos/leafmap/raw/master/examples/data/cable_geo.geojson\" ) m.add_gdf(gdf, layer_name=\"Cable lines\") m <p>Read the GeoPandas sample dataset as a GeoDataFrame.</p> In\u00a0[\u00a0]: Copied! <pre>path_to_data = gpd.datasets.get_path(\"nybb\")\ngdf = gpd.read_file(path_to_data)\ngdf\n</pre> path_to_data = gpd.datasets.get_path(\"nybb\") gdf = gpd.read_file(path_to_data) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"])\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"New York boroughs\", fill_colors=[\"red\", \"green\", \"blue\"]) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Add a point layer programmatically.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\"\nm.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\")\nm\n</pre> m = leafmap.Map() url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.geojson\" m.add_point_layer(url, popup=[\"name\", \"pop_max\"], layer_name=\"US Cities\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[0, 0], zoom=2)\nurl = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\"\nm.add_vector(\n    url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"]\n)\nm\n</pre> m = leafmap.Map(center=[0, 0], zoom=2) url = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/countries.geojson\" m.add_vector(     url, layer_name=\"Countries\", fill_colors=[\"red\", \"yellow\", \"green\", \"orange\"] ) m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"New York City\", layer_name=\"NYC\") m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\")\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_geocode(\"Chicago, Illinois\", layer_name=\"Chicago, IL\") m <p>Show OSM feature tags. https://wiki.openstreetmap.org/wiki/Map_features</p> In\u00a0[\u00a0]: Copied! <pre># leafmap.osm_tags_list()\n</pre> # leafmap.osm_tags_list() In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\", tags={\"amenity\": \"bar\"}, dist=1500, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.add_osm_from_address(\n    address=\"New York City\",\n    tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},\n    dist=1000,\n    layer_name=\"NYC buildings\",\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.add_osm_from_address(     address=\"New York City\",     tags={\"landuse\": [\"retail\", \"commercial\"], \"building\": True},     dist=1000,     layer_name=\"NYC buildings\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nnorth, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965\nm.add_osm_from_bbox(\n    north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\"\n)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) north, south, east, west = 40.7551, 40.7454, -73.9738, -73.9965 m.add_osm_from_bbox(     north, south, east, west, tags={\"amenity\": \"bar\"}, layer_name=\"NYC bars\" ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(46.7808, -96.0156),\n    tags={\"natural\": \"water\"},\n    dist=10000,\n    layer_name=\"Lakes\",\n)\nm\n</pre> m = leafmap.Map(     center=[46.7808, -96.0156], zoom=12, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(46.7808, -96.0156),     tags={\"natural\": \"water\"},     dist=10000,     layer_name=\"Lakes\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(\n    center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True\n)\nm.add_osm_from_point(\n    center_point=(39.9170, 116.3908),\n    tags={\"building\": True, \"natural\": \"water\"},\n    dist=1000,\n    layer_name=\"Beijing\",\n)\nm\n</pre> m = leafmap.Map(     center=[39.9170, 116.3908], zoom=15, toolbar_control=False, layers_control=True ) m.add_osm_from_point(     center_point=(39.9170, 116.3908),     tags={\"building\": True, \"natural\": \"water\"},     dist=1000,     layer_name=\"Beijing\", ) m In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(toolbar_control=False, layers_control=True)\nm.set_center(-73.9854, 40.7500, 16)\nm\n</pre> m = leafmap.Map(toolbar_control=False, layers_control=True) m.set_center(-73.9854, 40.7500, 16) m In\u00a0[\u00a0]: Copied! <pre>m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\")\n</pre> m.add_osm_from_view(tags={\"amenity\": \"bar\", \"building\": True}, layer_name=\"New York\") <p>Create a GeoPandas GeoDataFrame from place.</p> In\u00a0[\u00a0]: Copied! <pre>gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"})\ngdf\n</pre> gdf = leafmap.osm_gdf_from_place(\"New York City\", tags={\"amenity\": \"bar\"}) gdf In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nimport urllib.request\n</pre> import os import leafmap import urllib.request <p>Download a sample DEM dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\"\n</pre> url = \"https://github.com/opengeos/whitebox-python/raw/master/whitebox/testdata/DEM.tif\" In\u00a0[\u00a0]: Copied! <pre>urllib.request.urlretrieve(url, \"dem.tif\")\n</pre> urllib.request.urlretrieve(url, \"dem.tif\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m <p>Display the toolbox using the default mode.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui()\n</pre> leafmap.whiteboxgui() <p>Display the toolbox using the collapsible tree mode. Note that the tree mode does not support Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.whiteboxgui(tree=True)\n</pre> leafmap.whiteboxgui(tree=True) <p>Perform geospatial analysis using the whitebox package.</p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport whitebox\n</pre> import os import whitebox In\u00a0[\u00a0]: Copied! <pre>wbt = whitebox.WhiteboxTools()\nwbt.verbose = False\n</pre> wbt = whitebox.WhiteboxTools() wbt.verbose = False In\u00a0[\u00a0]: Copied! <pre>data_dir = os.getcwd()\nwbt.set_working_dir(data_dir)\n</pre> data_dir = os.getcwd() wbt.set_working_dir(data_dir) In\u00a0[\u00a0]: Copied! <pre>wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9)\nwbt.breach_depressions(\"smoothed.tif\", \"breached.tif\")\nwbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\")\n</pre> wbt.feature_preserving_smoothing(\"dem.tif\", \"smoothed.tif\", filter=9) wbt.breach_depressions(\"smoothed.tif\", \"breached.tif\") wbt.d_inf_flow_accumulation(\"breached.tif\", \"flow_accum.tif\") In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport imageio\n\n%matplotlib inline\n</pre> import matplotlib.pyplot as plt import imageio  %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>original = imageio.imread(os.path.join(data_dir, \"dem.tif\"))\nsmoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\"))\nbreached = imageio.imread(os.path.join(data_dir, \"breached.tif\"))\nflow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\"))\n</pre> original = imageio.imread(os.path.join(data_dir, \"dem.tif\")) smoothed = imageio.imread(os.path.join(data_dir, \"smoothed.tif\")) breached = imageio.imread(os.path.join(data_dir, \"breached.tif\")) flow_accum = imageio.imread(os.path.join(data_dir, \"flow_accum.tif\")) In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(figsize=(16, 11))\n\nax1 = fig.add_subplot(2, 2, 1)\nax1.set_title(\"Original DEM\")\nplt.imshow(original)\n\nax2 = fig.add_subplot(2, 2, 2)\nax2.set_title(\"Smoothed DEM\")\nplt.imshow(smoothed)\n\nax3 = fig.add_subplot(2, 2, 3)\nax3.set_title(\"Breached DEM\")\nplt.imshow(breached)\n\nax4 = fig.add_subplot(2, 2, 4)\nax4.set_title(\"Flow Accumulation\")\nplt.imshow(flow_accum)\n\nplt.show()\n</pre> fig = plt.figure(figsize=(16, 11))  ax1 = fig.add_subplot(2, 2, 1) ax1.set_title(\"Original DEM\") plt.imshow(original)  ax2 = fig.add_subplot(2, 2, 2) ax2.set_title(\"Smoothed DEM\") plt.imshow(smoothed)  ax3 = fig.add_subplot(2, 2, 3) ax3.set_title(\"Breached DEM\") plt.imshow(breached)  ax4 = fig.add_subplot(2, 2, 4) ax4.set_title(\"Flow Accumulation\") plt.imshow(flow_accum)  plt.show() In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>for basemap in leafmap.basemaps:\n    print(basemap)\n</pre> for basemap in leafmap.basemaps:     print(basemap) In\u00a0[\u00a0]: Copied! <pre>layers = list(leafmap.basemaps.keys())[17:117]\n</pre> layers = list(leafmap.basemaps.keys())[17:117] In\u00a0[\u00a0]: Copied! <pre>leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers)\n</pre> leafmap.linked_maps(rows=20, cols=5, height=\"200px\", layers=layers, labels=layers) In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>leafmap.basemaps.keys()\n</pre> leafmap.basemaps.keys() In\u00a0[\u00a0]: Copied! <pre>layers = [\"ROADMAP\", \"HYBRID\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"ROADMAP\", \"HYBRID\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) In\u00a0[\u00a0]: Copied! <pre>layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"]\nleafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers)\n</pre> layers = [\"Esri.WorldTopoMap\", \"OpenTopoMap\"] leafmap.linked_maps(rows=1, cols=2, height=\"400px\", layers=layers) <p>Create a 2 * 2 linked map to visualize land cover change. Specify the <code>center</code> and <code>zoom</code> parameters to change the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]]\nlabels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]]\nleafmap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    layers=layers,\n    labels=labels,\n    center=[36.1, -115.2],\n    zoom=9,\n)\n</pre> layers = [str(f\"NLCD {year} CONUS Land Cover\") for year in [2001, 2006, 2011, 2016]] labels = [str(f\"NLCD {year}\") for year in [2001, 2006, 2011, 2016]] leafmap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     layers=layers,     labels=labels,     center=[36.1, -115.2],     zoom=9, ) In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\")\n</pre> leafmap.split_map(left_layer=\"ROADMAP\", right_layer=\"HYBRID\") <p>Hide the zoom control from the map.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(\n    left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False\n)\n</pre> leafmap.split_map(     left_layer=\"Esri.WorldTopoMap\", right_layer=\"OpenTopoMap\", zoom_control=False ) <p>Add labels to the map and change the default map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.split_map(\n    left_layer=\"NLCD 2001 CONUS Land Cover\",\n    right_layer=\"NLCD 2019 CONUS Land Cover\",\n    left_label=\"2001\",\n    right_label=\"2019\",\n    label_position=\"bottom\",\n    center=[36.1, -114.9],\n    zoom=10,\n)\n</pre> leafmap.split_map(     left_layer=\"NLCD 2001 CONUS Land Cover\",     right_layer=\"NLCD 2019 CONUS Land Cover\",     left_label=\"2001\",     right_label=\"2019\",     label_position=\"bottom\",     center=[36.1, -114.9],     zoom=10, ) In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(layers_control=True)\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> m = leafmap.Map(layers_control=True) in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m <p>Use the folium plotting backend.</p> In\u00a0[\u00a0]: Copied! <pre>from leafmap import foliumap\n</pre> from leafmap import foliumap In\u00a0[\u00a0]: Copied! <pre>m = foliumap.Map()\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\"\nm.add_heatmap(\n    in_csv,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\n</pre> m = foliumap.Map() in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\" m.add_heatmap(     in_csv,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) In\u00a0[\u00a0]: Copied! <pre>colors = [\"blue\", \"lime\", \"red\"]\nm.add_colorbar(colors=colors, vmin=0, vmax=10000)\nm.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\")\nm\n</pre> colors = [\"blue\", \"lime\", \"red\"] m.add_colorbar(colors=colors, vmin=0, vmax=10000) m.add_title(\"World Population Heat Map\", font_size=\"20px\", align=\"center\") m In\u00a0[\u00a0]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_basemap(\"Esri.NatGeoWorldMap\")\nm\n</pre> m = leafmap.Map() m.add_basemap(\"Esri.NatGeoWorldMap\") m <p>Specify the output HTML file name to save the map as a web page.</p> In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mymap.html\")\n</pre> m.to_html(\"mymap.html\") <p>If the output HTML file name is not provided, the function will return a string containing contain the source code of the HTML file.</p> In\u00a0[\u00a0]: Copied! <pre>html = m.to_html()\n</pre> html = m.to_html() In\u00a0[\u00a0]: Copied! <pre># print(html)\n</pre> # print(html) In\u00a0[\u00a0]: Copied! <pre>import leafmap.kepler as leafmap\n</pre> import leafmap.kepler as leafmap In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[40, -100], zoom=2, height=600, widescreen=False)\nm\n</pre> m = leafmap.Map(center=[40, -100], zoom=2, height=600, widescreen=False) m <p>If you encounter an error saying <code>Error displaying widget: model not found</code> when trying to display the map, you can use <code>m.static_map()</code> as a workaround until this kepler.gl bug has been resolved.</p> In\u00a0[\u00a0]: Copied! <pre># m.static_map(width=1280, height=600)\n</pre> # m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[37.7621, -122.4143], zoom=12)\nin_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_data.csv\"\nconfig = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_config.json\"\nm.add_csv(in_csv, layer_name=\"hex_data\", config=config)\nm\n</pre> m = leafmap.Map(center=[37.7621, -122.4143], zoom=12) in_csv = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_data.csv\" config = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/hex_config.json\" m.add_csv(in_csv, layer_name=\"hex_data\", config=config) m In\u00a0[\u00a0]: Copied! <pre>m.static_map(width=1280, height=600)\n</pre> m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>m.save_config(\"cache/config.json\")\n</pre> m.save_config(\"cache/config.json\") In\u00a0[\u00a0]: Copied! <pre>m.to_html(outfile=\"cache/kepler_hex.html\")\n</pre> m.to_html(outfile=\"cache/kepler_hex.html\") In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[50, -110], zoom=2)\npolygons = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\"\nm.add_geojson(polygons, layer_name=\"Countries\")\nm\n</pre> m = leafmap.Map(center=[50, -110], zoom=2) polygons = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_states.json\" m.add_geojson(polygons, layer_name=\"Countries\") m In\u00a0[\u00a0]: Copied! <pre>m.static_map(width=1280, height=600)\n</pre> m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1)\nin_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\"\nm.add_shp(in_shp, \"Countries\")\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1) in_shp = \"https://github.com/opengeos/leafmap/raw/master/examples/data/countries.zip\" m.add_shp(in_shp, \"Countries\") m In\u00a0[\u00a0]: Copied! <pre>m.static_map(width=1280, height=600)\n</pre> m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n</pre> import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>gdf = gpd.read_file(\n    \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.geojson\"\n)\ngdf\n</pre> gdf = gpd.read_file(     \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.geojson\" ) gdf In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[20, 0], zoom=1)\nm.add_gdf(gdf, \"World cities\")\nm\n</pre> m = leafmap.Map(center=[20, 0], zoom=1) m.add_gdf(gdf, \"World cities\") m In\u00a0[\u00a0]: Copied! <pre># m.static_map(width=1280, height=600)\n</pre> # m.static_map(width=1280, height=600) In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>quarterly_tiles = leafmap.planet_quarterly_tiles()\n</pre> quarterly_tiles = leafmap.planet_quarterly_tiles() In\u00a0[\u00a0]: Copied! <pre>for tile in quarterly_tiles:\n    print(tile)\n</pre> for tile in quarterly_tiles:     print(tile) In\u00a0[\u00a0]: Copied! <pre>monthly_tiles = leafmap.planet_monthly_tiles()\n</pre> monthly_tiles = leafmap.planet_monthly_tiles() In\u00a0[\u00a0]: Copied! <pre>for tile in monthly_tiles:\n    print(tile)\n</pre> for tile in monthly_tiles:     print(tile) <p>Add a Planet monthly mosaic by specifying year and month.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_planet_by_month(year=2020, month=8)\nm\n</pre> m = leafmap.Map() m.add_planet_by_month(year=2020, month=8) m <p>Add a Planet quarterly mosaic by specifying year and quarter.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.add_planet_by_quarter(year=2019, quarter=2)\nm\n</pre> m = leafmap.Map() m.add_planet_by_quarter(year=2019, quarter=2) m In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" In\u00a0[\u00a0]: Copied! <pre>tiles = leafmap.planet_tiles()\n</pre> tiles = leafmap.planet_tiles() In\u00a0[\u00a0]: Copied! <pre>leafmap.ts_inspector(tiles, center=[40, -100], zoom=4)\n</pre> leafmap.ts_inspector(tiles, center=[40, -100], zoom=4) <p>Use the time slider to visualize Planet quarterly mosaic.</p> <p></p> In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\n</pre> import os import leafmap In\u00a0[\u00a0]: Copied! <pre>if os.environ.get(\"PLANET_API_KEY\") is None:\n    os.environ[\"PLANET_API_KEY\"] = \"your-api-key\"\n</pre> if os.environ.get(\"PLANET_API_KEY\") is None:     os.environ[\"PLANET_API_KEY\"] = \"your-api-key\" <p>Specify the map center and zoom level.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[38.2659, -103.2447], zoom=13)\nm\n</pre> m = leafmap.Map(center=[38.2659, -103.2447], zoom=13) m <p>Use the time slider to visualize Planet quarterly mosaic.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nlayers_dict = leafmap.planet_quarterly_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map() layers_dict = leafmap.planet_quarterly_tiles() m.add_time_slider(layers_dict, time_interval=1) m <p>Use the time slider to visualize basemaps.</p> In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map()\nm.clear_layers()\nlayers_dict = leafmap.basemap_xyz_tiles()\nm.add_time_slider(layers_dict, time_interval=1)\nm\n</pre> m = leafmap.Map() m.clear_layers() layers_dict = leafmap.basemap_xyz_tiles() m.add_time_slider(layers_dict, time_interval=1) m"},{"location":"workshops/YouthMappers_2021/#introduction","title":"Introduction\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#workshop-description","title":"Workshop description\u00b6","text":"<p>Leafmap is a Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment. It is built upon a number of open-source packages, such as folium and ipyleaflet (for creating interactive maps), WhiteboxTools and whiteboxgui (for analyzing geospatial data), and ipywidgets (for designing interactive graphical user interface). The WhiteboxTools library currently contains 480+ tools for advanced geospatial analysis. Leafmap provides many convenient functions for loading and visualizing geospatial data with only one line of code. Users can also use the interactive user interface to load geospatial data without coding. Anyone with a web browser and Internet connection can use leafmap to perform geospatial analysis and data visualization in the cloud with minimal coding. The topics that will be covered in this workshop include:</p> <ul> <li>A brief introduction to Jupyter and Colab</li> <li>A brief introduction to leafmap and relevant web resources</li> <li>Creating interactive maps using multiple plotting backends</li> <li>Searching and loading basemaps</li> <li>Loading and visualizing vector/raster data</li> <li>Using Cloud Optimized GeoTIFF (COG) and SpatialTemporal Asset Catalog (STAC)</li> <li>Downloading OpenStreetMap data</li> <li>Loading data from a PostGIS database</li> <li>Creating custom legends and colorbars</li> <li>Creating split-panel maps and linked maps</li> <li>Visualizing Planet global monthly/quarterly mosaic</li> <li>Designing and publishing interactive web apps</li> <li>Performing geospatial analysis (e.g., hydrological analysis) using whiteboxgui</li> </ul> <p>This workshop is intended for scientific programmers, data scientists, geospatial analysts, and concerned citizens of Earth. The attendees are expected to have a basic understanding of Python and the Jupyter ecosystem. Familiarity with Earth science and geospatial datasets is useful but not required. More information about leafmap can be found at https://leafmap.org.</p>"},{"location":"workshops/YouthMappers_2021/#jupyter-keyboard-shortcuts","title":"Jupyter keyboard shortcuts\u00b6","text":"<ul> <li>Shift+Enter: run cell, select below</li> <li>Ctrl+Enter: : run selected cells</li> <li>Alt+Enter: run cell and insert below</li> <li>Tab: code completion or indent</li> <li>Shift+Tab: tooltip</li> <li>Ctrl+/: comment out code</li> </ul>"},{"location":"workshops/YouthMappers_2021/#set-up-environment","title":"Set up environment\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#required-python-packages","title":"Required Python packages:\u00b6","text":"<ul> <li>leafmap - A Python package for interactive mapping and geospatial analysis with minimal coding in a Jupyter environment.</li> <li>keplergl - A high-performance web-based application for visual exploration of large-scale geolocation data sets.</li> <li>pydeck - High-scale spatial rendering in Python, powered by deck.gl.</li> <li>geopandas - An open source project to make working with geospatial data in python easier.</li> <li>xarray-leaflet - An xarray extension for tiled map plotting.</li> </ul>"},{"location":"workshops/YouthMappers_2021/#use-google-colab","title":"Use Google Colab\u00b6","text":"<p>Click the button below to open this notebook in Google Colab and execute code interactively.</p> <p> </p>"},{"location":"workshops/YouthMappers_2021/#use-pangeo-binder","title":"Use Pangeo Binder\u00b6","text":"<p>Click the buttons below to open this notebook in JupyterLab (first button) or Jupyter Notebook (second button) and execute code interactively.</p> <p> </p> <ul> <li>JupyterLab: https://gishub.org/ym-binder</li> <li>Jupyter Notebook: https://gishub.org/ym-binder-nb</li> </ul>"},{"location":"workshops/YouthMappers_2021/#use-minicondaanaconda","title":"Use Miniconda/Anaconda\u00b6","text":"<p>If you have Anaconda or Miniconda installed on your computer, you can install leafmap using the following commands. Leafmap has an optional dependency - geopandas, which can be challenging to install on some computers, especially Windows. It is highly recommended that you create a fresh conda environment to install geopandas and leafmap. Follow the commands below to set up a conda env and install geopandas, leafmap, pydeck, keplergl, and xarray_leaflet.</p> <pre><code>conda create -n geo python=3.8\nconda activate geo\nconda install geopandas\nconda install mamba -c conda-forge\nmamba install leafmap keplergl pydeck xarray_leaflet -c conda-forge\nmamba install osmnx pygeos imageio tifffile -c conda-forge\njupyter lab\n</code></pre>"},{"location":"workshops/YouthMappers_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p><code>Leafmap</code> has five plotting backends: folium, ipyleaflet, here-map, kepler.gl, and pydeck. Note that the backends do not offer equal functionality. Some interactive functionality in <code>ipyleaflet</code> might not be available in other plotting backends. To use a specific plotting backend, use one of the following:</p> <ul> <li><code>import leafmap.leafmap as leafmap</code></li> <li><code>import leafmap.foliumap as leafmap</code></li> <li><code>import leafmap.heremap as leafmap</code></li> <li><code>import leafmap.kepler as leafmap</code></li> <li><code>import leafmap.deck as leafmap</code></li> </ul>"},{"location":"workshops/YouthMappers_2021/#use-ipyleaflet","title":"Use ipyleaflet\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#use-folium","title":"Use folium\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#use-keplergl","title":"Use kepler.gl\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#use-pydeck","title":"Use pydeck\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#customize-the-default-map","title":"Customize the default map\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#specify-map-center-and-zoom-level","title":"Specify map center and zoom level\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#change-map-size","title":"Change map size\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#set-control-visibility","title":"Set control visibility\u00b6","text":"<p>When creating a map, set the following controls to either <code>True</code> or <code>False</code> as appropriate.</p> <ul> <li>attribution_control</li> <li>draw_control</li> <li>fullscreen_control</li> <li>layers_control</li> <li>measure_control</li> <li>scale_control</li> <li>toolbar_control</li> </ul>"},{"location":"workshops/YouthMappers_2021/#change-basemaps","title":"Change basemaps\u00b6","text":"<p>Specify a Google basemap to use, can be one of [\"ROADMAP\", \"TERRAIN\", \"SATELLITE\", \"HYBRID\"].</p>"},{"location":"workshops/YouthMappers_2021/#add-tile-layers","title":"Add tile layers\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-xyz-tile-layer","title":"Add XYZ tile layer\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-wms-tile-layer","title":"Add WMS tile layer\u00b6","text":"<p>More WMS basemaps can be found at the following websites:</p> <ul> <li>USGS National Map: https://viewer.nationalmap.gov/services</li> <li>MRLC NLCD Land Cover data: https://www.mrlc.gov/data-services-page</li> <li>FWS NWI Wetlands data: https://www.fws.gov/wetlands/Data/Web-Map-Services.html</li> </ul>"},{"location":"workshops/YouthMappers_2021/#add-xyzservices-provider","title":"Add xyzservices provider\u00b6","text":"<p>Add a layer from xyzservices provider object.</p>"},{"location":"workshops/YouthMappers_2021/#add-cogstac-layers","title":"Add COG/STAC layers\u00b6","text":"<p>A Cloud Optimized GeoTIFF (COG) is a regular GeoTIFF file, aimed at being hosted on a HTTP file server, with an internal organization that enables more efficient workflows on the cloud. It does this by leveraging the ability of clients issuing HTTP GET range requests to ask for just the parts of a file they need.</p> <p>More information about COG can be found at https://www.cogeo.org/in-depth.html</p> <p>Some publicly available Cloud Optimized GeoTIFFs:</p> <ul> <li>https://stacindex.org/</li> <li>https://cloud.google.com/storage/docs/public-datasets/landsat</li> <li>https://www.digitalglobe.com/ecosystem/open-data</li> <li>https://earthexplorer.usgs.gov/</li> </ul> <p>For this demo, we will use data from https://www.maxar.com/open-data/california-colorado-fires for mapping California and Colorado fires. A list of COGs can be found here.</p>"},{"location":"workshops/YouthMappers_2021/#add-cog-layer","title":"Add COG layer\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-stac-layer","title":"Add STAC layer\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc. More information about STAC can be found at https://stacspec.org/</p> <p>Some publicly available SpatioTemporal Asset Catalog (STAC):</p> <ul> <li>https://stacindex.org</li> </ul> <p>For this demo, we will use STAC assets from https://stacindex.org/catalogs/spot-orthoimages-canada-2005#/?t=catalogs</p>"},{"location":"workshops/YouthMappers_2021/#add-local-raster-datasets","title":"Add local raster datasets\u00b6","text":"<p>The <code>add_raster</code> function relies on the <code>xarray_leaflet</code> package and is only available for the ipyleaflet plotting backend. Therefore, Google Colab is not supported. Note that <code>xarray_leaflet</code> does not work properly on Windows (source).</p>"},{"location":"workshops/YouthMappers_2021/#add-legend","title":"Add legend\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-built-in-legend","title":"Add built-in legend\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-custom-legend","title":"Add custom legend\u00b6","text":"<p>There are two ways you can add custom legends:</p> <ol> <li>Define legend labels and colors</li> <li>Define legend dictionary</li> </ol> <p>Define legend keys and colors.</p>"},{"location":"workshops/YouthMappers_2021/#add-colormap","title":"Add colormap\u00b6","text":"<p>The colormap functionality requires the ipyleaflet plotting backend. Folium is not supported.</p>"},{"location":"workshops/YouthMappers_2021/#common-colormaps","title":"Common colormaps\u00b6","text":"<p>Color palette for DEM data.</p>"},{"location":"workshops/YouthMappers_2021/#custom-colormaps","title":"Custom colormaps\u00b6","text":"<p>Specify the number of classes for a palette.</p>"},{"location":"workshops/YouthMappers_2021/#horizontal-colormap","title":"Horizontal colormap\u00b6","text":"<p>Add a horizontal colorbar to an interactive map.</p>"},{"location":"workshops/YouthMappers_2021/#vertical-colormap","title":"Vertical colormap\u00b6","text":"<p>Add a vertical colorbar to an interactive map.</p>"},{"location":"workshops/YouthMappers_2021/#list-of-available-colormaps","title":"List of available colormaps\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-vector-datasets","title":"Add vector datasets\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-csv","title":"Add CSV\u00b6","text":"<p>Read a CSV as a Pandas DataFrame.</p>"},{"location":"workshops/YouthMappers_2021/#add-geojson","title":"Add GeoJSON\u00b6","text":"<p>Add a GeoJSON to the map.</p>"},{"location":"workshops/YouthMappers_2021/#add-shapefile","title":"Add shapefile\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-kml","title":"Add KML\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-geodataframe","title":"Add GeoDataFrame\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#add-point-layer","title":"Add point layer\u00b6","text":"<p>Add a point layer using the interactive GUI.</p> <p></p>"},{"location":"workshops/YouthMappers_2021/#add-vector","title":"Add vector\u00b6","text":"<p>The <code>add_vector</code> function supports any vector data format supported by GeoPandas.</p>"},{"location":"workshops/YouthMappers_2021/#download-osm-data","title":"Download OSM data\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#osm-from-geocode","title":"OSM from geocode\u00b6","text":"<p>Add OSM data of place(s) by name or ID to the map. Note that the leafmap custom layer control does not support GeoJSON, we need to use the ipyleaflet built-in layer control.</p>"},{"location":"workshops/YouthMappers_2021/#osm-from-place","title":"OSM from place\u00b6","text":"<p>Add OSM entities within boundaries of geocodable place(s) to the map.</p>"},{"location":"workshops/YouthMappers_2021/#osm-from-address","title":"OSM from address\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#osm-from-bbox","title":"OSM from bbox\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#osm-from-point","title":"OSM from point\u00b6","text":"<p>Add OSM entities within some distance N, S, E, W of a point to the map.</p>"},{"location":"workshops/YouthMappers_2021/#osm-from-view","title":"OSM from view\u00b6","text":"<p>Add OSM entities within the current map view to the map.</p>"},{"location":"workshops/YouthMappers_2021/#use-whiteboxtools","title":"Use WhiteboxTools\u00b6","text":"<p>Use the built-in toolbox to perform geospatial analysis. For example, you can perform depression filling using the sample DEM dataset downloaded in the above step.</p> <p></p>"},{"location":"workshops/YouthMappers_2021/#create-basemap-gallery","title":"Create basemap gallery\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#create-linked-map","title":"Create linked map\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#create-split-panel-map","title":"Create split-panel map\u00b6","text":"<p>Create a split-panel map by specifying the <code>left_layer</code> and <code>right_layer</code>, which can be chosen from the basemap names, or any custom XYZ tile layer.</p>"},{"location":"workshops/YouthMappers_2021/#create-heat-map","title":"Create heat map\u00b6","text":"<p>Specify the file path to the CSV. It can either be a file locally or on the Internet.</p>"},{"location":"workshops/YouthMappers_2021/#save-map-to-html","title":"Save map to HTML\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#use-kepler-plotting-backend","title":"Use kepler plotting backend\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p>Create an interactive map. You can specify various parameters to initialize the map, such as <code>center</code>, <code>zoom</code>, <code>height</code>, and <code>widescreen</code>.</p>"},{"location":"workshops/YouthMappers_2021/#add-csv","title":"Add CSV\u00b6","text":"<p>Add a CSV to the map. If you have a map config file, you can directly apply config to the map.</p>"},{"location":"workshops/YouthMappers_2021/#save-map-config","title":"Save map config\u00b6","text":"<p>Save the map configuration as a JSON file.</p>"},{"location":"workshops/YouthMappers_2021/#save-map-as-html","title":"Save map as html\u00b6","text":"<p>Save the map to an interactive html.</p>"},{"location":"workshops/YouthMappers_2021/#add-geojons","title":"Add GeoJONS\u00b6","text":"<p>Add a GeoJSON with US state boundaries to the map.</p>"},{"location":"workshops/YouthMappers_2021/#add-shapefile","title":"Add shapefile\u00b6","text":"<p>Add a shapefile to the map.</p>"},{"location":"workshops/YouthMappers_2021/#add-geodataframe","title":"Add GeoDataFrame\u00b6","text":"<p>Add a GeoPandas GeoDataFrame to the map.</p>"},{"location":"workshops/YouthMappers_2021/#use-planet-imagery","title":"Use planet imagery\u00b6","text":"<p>First, you need to sign up a Planet account and get an API key. See  https://developers.planet.com/quickstart/apis. Uncomment the following line to pass in your API key.</p>"},{"location":"workshops/YouthMappers_2021/#use-timeseries-inspector","title":"Use timeseries inspector\u00b6","text":""},{"location":"workshops/YouthMappers_2021/#use-time-slider","title":"Use time slider\u00b6","text":""}]}